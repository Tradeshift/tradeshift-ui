<!DOCTYPE html>
<html>
	<head>
		<title>Panels</title>
	</head>
	<body class="nosticky">
		<header data-ts="TopBar"></header>
    <div data-ts="Panel" data-ts.label="Panel One">
  		<main data-ts="Main">
				<article>
					<h1>Panels</h1>
					<section class="desc">
						<p>Featured prominently in Asides, the Panel is simply a container with a scrollbar. But Panels can also be used to generate entire page layouts &mdash; such as this one.</p>
					</section>				
					<section>
						<p>We can position <att>Panel</att> elements as direct children of the <elm>body</elm> to autogenerate tabs in the TopBar. The tabs at the top of this page are created with the markup shown below.</p>
						<figure data-ts="DoxMarkup">
							<script>
								<body>
									<header data-ts="TopBar"></header>
									<div data-ts="Panel" data-ts.label="Panel One">
										<main data-ts="Main">…</main>
									</div>
									<div data-ts="Panel" data-ts.label="Panel Two">
										<main data-ts="Main">…</main>
									</div>
									<div data-ts="Panel" data-ts.label="Panel Three">
										<main data-ts="Main">…</main>
									</div>
								</body>
							</script>
						</figure>
						<p>Note that the content of the three "pages" are each wrapped inside a nested <att>Main</att> element. It is possible to nest further <att>Panel</att> elements inside these <att>Main</att> elements to generate additional <att>TabBars</att> as seen in <a onclick="ts.ui.TopBar.tabs().selectedIndex = 1">Panel Two</a>.</p>

						<h3>When to use this?</h3>
						<p>Certainly when you are prototyping as a UX designer, but it will otherwise depend on your technology stack (since this may not a good fit for all frameworks) and on your requirements. If you app features highly dynamic navigation, it may be easier to approach this kind of multi-page layout <a data-ts="Button" href="/#components/bars/topbar.html">programatically</a> instead of declaratively.</p>

						<!--
						If you are working in an Angular app that has a single controller and a single view, perhaps it is easier to create layouts programatically as seen in the <a>Bars</a> documentation.</p>
						-->

						<h3>History support</h3>
						<p>To avoid conflicts with your favorite routing library, Tradeshift UI will not attempt to update the history (via the address bar). You can however add history support if you manually intercept tab selection like this.</p>
						<figure data-ts="DoxScript">
							<script>
								ts.ui.TopBar.tabs().onselect = function(newindex, oldindex) {
									// update history here
								};
							</script>
						</figure>

						<!--
						<p>If the developers wants to reflect the selected tab in the URL (for history support), he must add some custom functionality to the <code>onselect</code> method of each (individual) Tab in the TopBar. But this should be made easier, see note below.</p>
						<div data-ts="Note">
							<i class="ts-icon-todo"></i>
							<p>We should implement <code>onselect</code> as a configurable method on the TopBar API so that this becomes easier to setup. The method could pass the selected Tab and/or selected index as an argument.</p>
						</div>
						-->
					</section>
				</article>
  		</main>
    </div>
    <div data-ts="Panel" data-ts.label="Panel Two">
      <main data-ts="Main">
				<div data-ts="Panel" data-ts.label="Panel Two A">
					<article>
						<h1>Panel Two A</h1>
						<section>
							<p>In this <att>Panel</att>, the nested <att>Main</att> contains two additional <att>Panel</att> elements to automatically generate the <a data-ts="Button" href="/#components/bars/tabbar.html">TabBar</a> seen above.</p>
							<figure data-ts="DoxMarkup">
								<script>
									<body>
										<!-- Panel One -->
										<div data-ts="Panel" data-ts.label="Panel Two">
											<main data-ts="Main">
												<div data-ts="Panel" data-ts.label="Panel Two A">…</div>
												<div data-ts="Panel" data-ts.label="Panel Two B">…</div>
											</main>
										<div>
										<!-- Panel Three -->
									</body>
								</script>
							</figure>

							<h3>Dynamic updates</h3>
							<p>You can add or remove tabs in this TabBar above by appending or detaching further <att>Panel</att> elements, but if you need to assign <code>onselect</code> callbacks or change the <code>label</code> of the tabs, you will need a programatic API that resembles the <a data-ts="Button" href="/#components/bars/tabbar.html">Main TabBar</a> except you must involve the ordinal index of the root <att>Panel</att> (the Panel that is a child of <elm>body</elm>).</p>
							<figure data-ts="DoxScript">
								<script type="runnable">
									var index = 1; // the root panel index!!!
									var tabs = ts.ui.TabBar.get(index).tabs();
									tabs[1].label = 'Select Me!';
									tabs[1].onselect = function() {
										ts.ui.Notification.success('Thanks!');
									};
								</script>
							</figure>
						</section>
					<article>
				</div>
				<div data-ts="Panel" data-ts.label="Panel Two B">
					<article>
						<h1>Panel Two B</h1>
						<section>
							<p>Bacon ipsum Tradeshift döner, shoulder loin drumstick Pork Chop Express. Swine biltong pastrami fatback meatball ham rump boudin picanha. Ground round beef ribs doner boudin, brisket biltong t-bone capicola. Corned beef flank pancetta sirloin jowl meatball pork chop alcatra. Landjaeger biltong pork chop alcatra spare ribs, turducken strip steak bresaola shankle chicken pastrami doner salami brisket. Ham hock biltong t-bone, salami sausage pork spare ribs beef flank pig. Kevin meatloaf turducken short loin sausage spare ribs tongue ham hock leberkas ham strip steak pig jerky. Tenderloin alcatra leberkas shoulder sirloin pancetta short ribs pastrami t-bone tri-tip pork belly kevin.</p>
							<p>Tenderloin filet mignon chicken, spare ribs meatball capicola ham jerky swine bresaola pork chop ribeye cupim t-bone bacon. Pork belly tail swine ham hock alcatra pork chop shoulder pastrami spare ribs venison hamburger beef drumstick pancetta. Kevin swine ham spare ribs strip steak andouille rump. Pork chop rump filet mignon, shankle pastrami ground round landjaeger ribeye shoulder strip steak chicken bresaola. Swine turkey bresaola, flank jerky salami bacon filet mignon. Turducken jowl pork chop, meatball pastrami swine ball tip leberkas.</p>
							<p>Doner cow chicken, rump swine flank salami. Pork belly bacon tenderloin tongue cow, tri-tip alcatra short ribs turducken chicken biltong drumstick meatball. Drumstick frankfurter shank sausage andouille shankle. Strip steak flank brisket ham pastrami, shoulder hamburger chicken drumstick meatball tail. Brisket drumstick meatball leberkas beef ribs. Prosciutto bacon pork shoulder salami. Meatloaf salami beef chuck biltong.</p>
						</section>
					<article>
				</div>
			</main>
		</div>
		<div data-ts="Panel" data-ts.label="Panel Three">
			<aside data-ts="SideBar" data-ts.title="SideBar">
				<div data-ts="Panel"></div>
			</aside>
  		<main data-ts="Main">
				<article>
	  			<h1>Panel Three</h1>
	  			<section>
						<p>In this <att>Panel</att>, we have a nested <a data-ts="Button" href="/#components/sidebars/">SideBar</a> just to show that it must be positioned either before or after the <att>Main</att> element.</p>
						<figure data-ts="DoxMarkup">
							<script>
								<body>
									<!-- Panel One -->
									<!-- Panel Two -->
									<div data-ts="Panel" data-ts.label="Panel Three">
										<aside data-ts="SideBar" data-ts.title="SideBar">
											<div data-ts="Panel"></div>
										</aside>
										<main data-ts="Main">…</main>
									</div>
								</body>
							</script>
						</figure>
					</section>
				</article>
  		</main>
    </div>
	</body>
</html>
