/**
 * Bootstrap tradeshift-ui from single script.
 * The "?internal" flag will also load the CSS.
 */
(function boostrap(sources) {
	var scripts = document.querySelectorAll('script'),
		head = document.querySelector('head'),
		script = scripts[scripts.length - 1];

	// assign an ID to this script so that if we break up into "bundles",
	// the scripts ID can be used as an ad hoc bundle detection feature.
	script.id = script.id || 'ts-js';

	// fix relative protocols in blob (not terribly relevant now)
	if (location.protocol === 'blob:') {
		Object.keys(sources).forEach(function(key) {
			sources[key] = 'http:' + sources[key];
		});
	}

	// Always load the CSS (internal flag ignored for now)
	stylesheet(document.querySelector('#ts-css'));

	// load JS
	if (document.readyState === 'loading' || document.all) {
		loadscripts(scriptsources());
	} else {
		console.error('ts.js should really not be loaded async at this point...');
	}

	/**
	 * Make sure that the stylesheet goes into
	 * HEAD as the first stylesheet on the page.
	 * TODO (jmo@): Minimize repaint by letting
	 * this go into document.write if conditions
	 * are right (ts.js loaded in HEAD already).
	 * @param {HTMLLinkElement} existing
	 */
	function stylesheet(existing) {
		if (!existing) { // testing a theory...
			var oldsheet = document.querySelector('link[rel=stylesheet]');
			var newsheet = document.createElement('link');
			newsheet.id = 'ts-css'; // prepare for multiple bundles...
			newsheet.rel = 'stylesheet';
			newsheet.href = sources.runtimecss;
			head.insertBefore(newsheet, oldsheet || head.lastElementChild);
		}
	}

	/**
	 * Compile list of script sources to load asynchronously.
	 * This basically boils down to the localization script.
	 * @returns {Array<string>}
	 */
	function scriptsources() {
		var srcs = [];
		var root = document.documentElement;
		var lang = root.getAttribute('lang');
		if (lang) {
			lang = lang.toLowerCase().replace('_', '-');
			srcs.push(sources.langbundle.replace('<LANG>', lang));
		} else if (!document.all) {
			console.log('No lang given. Will default to en-US');
		}
		return srcs;
	}

	/*
	 * Inject the script(s). Not quite as sync as it used to be
	 * because `document.write` is being phased out (in Chrome).
	 * @param {Array<string>} src
	 */
	function loadscripts(srcs) {
		var next = null;
		var prev = script;
		var left = srcs.length;
		var root = script.parentNode;
		function onload() {
			if (--left === 0) {
				ts.ui.$maybebootstrap(true);
			}
		};
		function onerror(error) {
			var src = error.target.src;
			throw new URIError('The script ' + src + ' is not accessible :/');
		}
		if (srcs.length) {
			/*
			 * In most real world cases, the app will have a `lang` attribute
			 * on the root `html` element and we load the localization script.
			 */
			srcs.forEach(function(src) {
				next = document.createElement('script');
				next.src = src;
				next.defer = true;
				next.onload = onload;
				next.onerror = onerror;
				root.insertBefore(next, prev.nextSibling);
				prev = next;
			});
		} else {
			/*
			 * Otherwise we attempt bootstrap. All the Runtime code will be
			 * parsed after this code, so we have to take a break before we
			 * can address it. TODO: Let's micro-task instead of a timeout!
			 */
			setTimeout(function deferred() {
				ts.ui.$maybebootstrap(true);
			});
		}
	}
}({
	langbundle: 'ts-lang-<LANG>.js',
	runtimecss: 'ts.css'
}));

(function(window) {

"use strict";


/**
 * Polyfilling missing features from ES5 and selected features from ES6.
 * Some of these are implemented weakly and should be used with caution
 * (See Map, Set and WeakMap).
 * TODO: Remove Set, Map and WeakMap!
 * TODO: Object.is and friends
 */
(function polyfilla() {
	/**
	 * Extend one object with another.
	 * @param {object} what Native prototype
	 * @param {object} whit Extension methods
	 */
	function extend(what, whit) {
		Object.keys(whit).forEach(function(key) {
			var def = whit[key];
			if (what[key] === undefined) {
				if (def.get && def.set) {
					// TODO: look at element.dataset polyfill (iOS?)
				} else {
					what[key] = def;
				}
			}
		});
	}

	/**
	 * Patching `String.prototype`
	 */
	function strings() {
		extend(String.prototype, {
			trim: function() {
				return this.trimLeft().trimRight();
			},
			trimRight: function() {
				return this.replace(/\s+$/, '');
			},
			trimLeft: function() {
				return this.replace(/^\s*/, '');
			},
			repeat: function(n) {
				return new Array(n + 1).join(this);
			},
			startsWith: function(sub) {
				return this.indexOf(sub) === 0;
			},
			endsWith: function(sub) {
				sub = String(sub);
				var i = this.lastIndexOf(sub);
				return i >= 0 && i === this.length - sub.length;
			},
			contains: function() { // they changed it :/
				console.warn('String.prototype.contains is deprecated. You can use String.prototype.includes');
				return this.includes.apply(this, arguments);
			},
			includes: function() {
				return String.prototype.indexOf.apply(this, arguments) !== -1;
			},
			toArray: function() {
				return this.split('');
			}
		});
	}

	/**
	 * Patching arrays.
	 */
	function arrays() {
		extend(Array.prototype, {
			find: function(predicate) {
				if (this === null) {
					throw new TypeError('Array.prototype.find called on null or undefined');
				}
				if (typeof predicate !== 'function') {
					throw new TypeError('predicate must be a function');
				}
				var list = Object(this);
				var length = list.length >>> 0;
				var thisArg = arguments[1];
				var value;
				for (var i = 0; i < length; i++) {
					value = list[i];
					if (predicate.call(thisArg, value, i, list)) {
						return value;
					}
				}
				return undefined;
			}
		});
		extend(Array, {
			every: function every(array, fun, thisp) {
				var res = true,
					len = array.length >>> 0;
				for (var i = 0; i < len; i++) {
					if (array[i] !== undefined) {
						if (!fun.call(thisp, array[i], i, array)) {
							res = false;
							break;
						}
					}
				}
				return res;
			},
			forEach: function forEach(array, fun, thisp) {
				var len = array.length >>> 0;
				for (var i = 0; i < len; i++) {
					if (array[i] !== undefined) {
						fun.call(thisp, array[i], i, array);
					}
				}
			},
			map: function map(array, fun, thisp) {
				var m = [],
					len = array.length >>> 0;
				for (var i = 0; i < len; i++) {
					if (array[i] !== undefined) {
						m.push(fun.call(thisp, array[i], i, array));
					}
				}
				return m;
			},
			filter: function map(array, fun, thisp) {
				return Array.prototype.filter.call(array, fun, thisp);
			},
			isArray: function isArray(o) {
				return Object.prototype.toString.call(o) === '[object Array]';
			},
			concat: function(a1, a2) {
				function map(e) {
					return e;
				}
				return this.map(a1, map).concat(this.map(a2, map));
			}
		});
	}

	/**
	 * Patching `Function.prototype` (something about iOS)
	 */
	function functions() {
		extend(Function.prototype, {
			bind: function bind(oThis) {
				if (typeof this !== 'function') {
					throw new TypeError('Function bind not callable');
				}
				var fSlice = Array.prototype.slice,
					aArgs = fSlice.call(arguments, 1),
					fToBind = this,
					Fnop = function() {},
					fBound = function() {
						return fToBind.apply(
							this instanceof Fnop ? this : oThis || window,
							aArgs.concat(fSlice.call(arguments))
						);
					};
				Fnop.prototype = this.prototype;
				fBound.prototype = new Fnop();
				return fBound;
			}
		});
	}

	/**
	 * TODO: investigate support for Object.getPrototypeOf(window)
	 */
	function globals() {
		extend(window, {
			console: {
				log: function() {},
				debug: function() {},
				warn: function() {},
				error: function() {}
			}
		});
	}

	/**
	 * Patching cheap DHTML effects with super-simplistic polyfills.
	 * TODO: use MessageChannel pending moz bug#677638
	 * @see http://www.nonblocking.io/2011/06/windownexttick.html
	 * @param [Window} win
	 */
	function effects() {
		extend(window, {
			requestAnimationFrame: (function() {
				var func =
					window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame ||
					(function() {
						var lastTime = 0;
						return function(callback, element) {
							var currTime = new Date().getTime();
							var timeToCall = Math.max(0, 16 - (currTime - lastTime));
							var id = window.setTimeout(function() {
								callback(currTime + timeToCall);
							},
								timeToCall);
							lastTime = currTime + timeToCall;
							return id;
						};
					}());
				return func;
			})(),
			cancelAnimationFrame: (function() {
				return (
					window.cancelAnimationFrame ||
					window.webkitCancelAnimationFrame ||
					window.mozCancelAnimationFrame ||
					window.oCancelAnimationFrame ||
					window.msCancelAnimationFrame ||
					clearTimeout
				);
			}()),
			/*
			 * TODO: Internalize into gui.Tick
			 * TODO: Move to MessageChannel!!!
			 */
			setImmediate: (function() {
				var list = [],
					handle = 1;
				var name = 'spiritual:emulated:setimmediate';
				window.addEventListener('message', function(e) {
					if (e.data === name && list.length) {
						list.shift().apply(window);
						e.stopPropagation();
					}
				}, false);
				return function emulated(func) {
					list.push(func);
					window.postMessage(name, '*');
					return handle++;
				};
			})()
		});
	}

	/**
	 * Alias methods plus IE and Safari mobile patches.
	 */
	function extras() {
		extend(console, {
			debug: console.log
		});
		extend(XMLHttpRequest.prototype, {
			overrideMimeType: function() {}
		});
		extend(XMLHttpRequest, {
			UNSENT: 0,
			OPENED: 1,
			HEADERS_RECEIVED: 2,
			LOADING: 3,
			DONE: 4
		});
	}

	/**
	 * Skip selected polyfills in worker context.
	 */
	(function fill(isWorker) {
		strings();
		arrays();
		functions();
		globals();
		extras();
		if (!isWorker) {
			effects();
		}
	}(false));
}());



/**
 * Create the primordial namespace.
 * @using {ts.gui.Namespace} Namespace
 * @using {Object} Timer
 */
window.gui = (function using(Namespace, Timer) {
	return new Namespace('gui', {

		/**
		 * Export as `gui.Namespace`.
		 * @type {constructor}
		 */
		Namespace: Namespace,

		/**
		 * TODO: Current version (should be injected during build process).
		 * @see https://www.npmjs.org/package/grunt-spiritual-build
		 * @type {string} (majorversion.minorversion.patchversion)
		 */
		version: '-1.0.0',

		/**
		 * Flag general debug mode.
		 * @type {boolean}
		 */
		debug: false,

		/**
		 * @TODO: This ain't up to date no more...
		 * @TODO: leave the URL alone a see if we can postMessage these things just in time...
		 * The {gui.IframeSpirit} will stamp this querystring parameter into any URL it loads.
		 * The value of the parameter matches the iframespirits '$contextid'. Value becomes the
		 * '$contextid' of the local 'gui' object (a {gui.Spiritual} instance). This establishes
		 * a relation between iframe and hosted document that can be used for xdomain stuff.
		 * @type {string}
		 */
		PARAM_CONTEXTID: 'gui-contextid',
		PARAM_XHOST: 'gui-xhost',

		/*
		 * Local broadcasts
		 */
		BROADCAST_TODOM: 'gui-broadcast-todom',
		BROADCAST_ONDOM: 'gui-broadcast-ondom',
		BROADCAST_TOLOAD: 'gui-broadcast-toload',
		BROADCAST_ONLOAD: 'gui-broadcast-onload',
		BROADCAST_TOUNLOAD: 'gui-broadcast-tounload',
		BROADCAST_ONUNLOAD: 'gui-broadcast-unload',
		BROADCAST_WILL_UNLOAD: 'gui-broadcast-will-unload', // deprecated

		/**
		 * Global broadcasts (TODO: stamp GLOBAL in there)
		 * TODO: harmonize some naming with action types
		 */
		BROADCAST_MOUSECLICK: 'gui-broadcast-mouseevent-click',
		BROADCAST_MOUSEMOVE: 'gui-broadcast-mouseevent-mousemove',
		BROADCAST_MOUSEDOWN: 'gui-broadcast-mouseevent-mousedown',
		BROADCAST_MOUSEUP: 'gui-broadcast-mouseevent-mouseup',
		BROADCAST_SCROLL: 'gui-broadcast-window-scroll',
		BROADCAST_RESIZE: 'gui-broadcast-window-resize', // should at least be local
		BROADCAST_RESIZE_END: 'gui-broadcast-window-resize-end',
		BROADCAST_POPSTATE: 'gui-broadcast-window-popstate',
		BROADCAST_HASHCHANGE: 'gui-broadcast-window-hashchange',
		BROADCAST_ORIENTATIONCHANGE: 'gui-broadcast-orientationchange',
		BROADCAST_TWEEN: 'gui-broadcast-tween',

		/**
		 * Global actions
		 */
		ACTION_DOC_ONDOMCONTENT: 'gui-action-document-domcontent',
		ACTION_DOC_ONLOAD: 'gui-action-document-onload',
		ACTION_DOC_ONHASH: 'gui-action-document-onhash',
		ACTION_DOC_UNLOAD: 'gui-action-document-unload',

		/**
		 * Timeout in milliseconds before we decide that user is finished resizing the window.
		 */
		TIMEOUT_RESIZE_END: 250,

		/**
		 * Device orientation.
		 * TODO: Get this out of here, create gui.Device or something
		 */
		orientation: 0,
		ORIENTATION_PORTRAIT: 0,
		ORIENTATION_LANDSCAPE: 1,

		/**
		 * Uniquely identifies this instance of `gui` knowing
		 * that other instances may exist in iframes.
		 * @type {String}
		 */
		$contextid: null,

		/**
		 * Usually the window object. Occasionally a web worker scope.
		 * TODO: Figure out if it's safe to deprecate this nowadays
		 * @type {GlobalScope}
		 */
		context: window,

		/**
		 * The {gui.Document} knows more about this whole browser environment.
		 * @type {gui.Document}
		 */
		document: null,

		/**
		 * Running inside an iframe?
		 * @type {boolean}
		 */
		hosted: false,

		/**
		 * Cross domain origin of containing iframe if:
		 *
		 * 1. We are loaded inside a {gui.IframeSpirit}
		 * 2. Containing document is on an external host
		 * @type {String} eg. `http://parenthost.com:8888`
		 */
		xhost: '*', // hardcoded for now!

		/**
		 * Flipped by the {gui.Guide}. TODO: Don't rely on that guy here!
		 * @type {boolean}
		 */
		initialized: false,

		/**
		 * Window is unloading?
		 * @type {boolean}
		 */
		unloading: false,

		/**
		 * Do something before the spirits get here.
		 * if that's already too late, just do it now.
		 * @param @optional {function} action
		 * @param @optional {object} thisp
		 * @returns {boolean} True when ready already
		 */
		init: function(action, thisp) {
			var is = this.initialized;
			if (arguments.length) {
				if (is) {
					action.call(thisp);
				} else {
					this._initcallbacks = this._initcallbacks || [];
					this._initcallbacks.push(function() {
						if (gui.debug) {
							try {
								action.call(thisp);
							} catch (exception) {
								console.error(action.toString());
								throw exception;
							}
						} else {
							action.call(thisp);
						}
					});
				}
			}
			return is;
		},

		/**
		 * The `ready` method get's expanded in
		 * core-spirits@wunderbyte.com (it runs
		 * when spirits are all ready) but for
		 * now we'll just alias it to `init`.
		 * @param @optional {function} action
		 * @param @optional {object} thisp
		 * @returns {boolean} True when ready already
		 */
		ready: function(action, thisp) {
			return this.init(action, thisp);
		},

		/**
		 * Register module.
		 * @param {String} name
		 * @param {object} module
		 * @returns {gui.Module}
		 */
		module: function(name, module) {
			var Module;
			if (gui.Type.isString(name) && name.length) {
				Module = gui.Module.extend(name, module || {});
				module = gui.Module.$register(new Module(name));
				return module;
			} else {
				throw new Error('Module needs an identity token');
			}
		},

		/**
		 * Has module registered?
		 * @param {String} name Module name
		 * @returns {boolean}
		 */
		hasModule: function(name) {
			return gui.Module.$hasModule(name);
		},

		/**
		 * List registered namespaces.
		 * TODO: Move to {gui.Namespace}
		 * @returns {Array<string>}
		 */
		namespaces: function() {
			return Namespace.namespaces.map(function(ns) {
				return ns.$ns;
			});
		},

		/**
		 * TODO: Something about this.
		 * TODO: Move to {gui.Namespace}
		 */
		spacenames: function() {
			Namespace.namespaces.forEach(function(ns) {
				ns.spacename();
			});
		},

		/**
		 * Declare namespace. Optionally add members.
		 * @param {String} ns
		 * @param {Map<String,object>} members
		 * @returns {gui.Namespace}
		 */
		namespace: function(ns, members) {
			var no;
			if (gui.Type.isString(ns)) {
				no = gui.Object.lookup(ns);
				no = new gui.Namespace(ns);
				no = gui.Object.assert(ns, no);
			} else {
				throw new TypeError('Expected a namespace string');
			}
			return gui.Object.extend(no, members || {});
		},

		/**
		 * Broadcast something globally. Events will be wrapped in an EventSummary.
		 * @param {String} message gui.BROADCAST_MOUSECLICK or similar
		 * @param @optional {object} arg This could well be a MouseEvent
		 */
		broadcastGlobal: function(msg, arg) {
			if (gui.Type.isEvent(arg)) {
				arg = new gui.EventSummary(arg);
			}
			gui.Broadcast.dispatchGlobal(msg, arg);
		},

		// Private .................................................................

		/**
		 * @type {Array<function>}
		 */
		_initcallbacks: null,

		/**
		 * Invoked at parse time (so right now).
		 */
		_exist: function() {
			this.hosted = window !== parent;
			this.$contextid = 'key' + Math.random().toString().slice(2, 11);
			if (this.hosted) { // TODO: get rid of this stuff!
				this.xhost = '*';
			}
			return this;
		},

		// Privileged ..............................................................

		/**
		 * Initialize all the things that did 'gui.init(callback)' during boot.
		 * Called on 'DOMContentLoaded' by the {gui.Document}.
		 */
		$initialize: function() {
			this.spacenames(); // TODO: get this out of here
			this.initialized = true;
			var list = this._initcallbacks;
			if (list) {
				while (list.length) {
					list.shift()();
				}
				this._initcallbacks = null;
			}
		},

		/**
		 * Instigate shutdown procedure. This usually happens on `window.unload` but
		 * may have to be invoked manually in Chrome packaged apps (pending a fix for
		 * https://code.google.com/p/chromium/issues/detail?id=167824).
		 * Called by the {gui.Document} on 'window.unload'
		 * @see {gui.Document._onunload}
		 */
		$shutdown: function() {
			this.unloading = true;
		},

		/**
		 * Start measurement.
		 * @param {string} string
		 */
		$mark: function(string) {
			Timer.mark(string);
		},

		/**
		 * Stop measurement.
		 * @param {string} string
		 * @returns {PerformanceMeasure}
		 */
		$stop: function(string) {
			return Timer.stop(string);
		},

		/**
		 * Conduct measurement of given action.
		 * @param {string} string
		 * @param {Function} action
		 * @param @optional {Object} thisp
		 * Note: Returns the result of calling that action (not the timing info).
		 */
		$measure: function(string, action, thisp) {
			this.$mark(string);
			var res = action.call(thisp);
			this.$stop(string);
			return res;
		},

		/**
		 * Get all measurements. Note: This always returns an array, maybe empty.
		 * @returns {Array|Array<PerformanceMeasure>}
		 */
		$measurements: function() {
			return Timer.measurements() || [];
		}

	})._exist();
}((function() {
 // ad hoc namespace mechanism ..................................

	/**
	 * When the first namespace `gui` has been instantiated,
	 * this will become exposed publically as `gui.Namespace`.
	 * TODO: Let's remember to check for namespace collions!
	 * @param {string} ns
	 * @param @optional {object} members
	 */
	function Namespace(ns, members) {
		Namespace.namespaces.push(this);
		this.$ns = ns;
		if (members) {
			Object.keys(members).forEach(function(key) {
				Object.defineProperty(this, key,
					Object.getOwnPropertyDescriptor(members, key)
				);
			}, this);
		}
	}

	Namespace.namespaces = [];
	Namespace.prototype = {

		/**
		 * Namespace string.
		 * @type {String}
		 */
		$ns: null,

		/**
		 * Identification.
		 * @returns {String}
		 */
		toString: function() {
			return '[namespace ' + this.$ns + ']';
		},

		/**
		 * Compute classnames for class-type members.
		 * @returns {gui.Namespace}
		 */
		spacename: function() {
			this._spacename(this, this.$ns);
			return this;
		},

		/**
		 * Name members recursively.
		 * @param {object|function} o
		 * @param {String} name
		 */
		_spacename: function(o, name) {
			gui.Object.each(o, function(key, value) {
				if (key !== '$superclass' && gui.Type.isConstructor(value)) {
					if (value.$classname === gui.Class.ANONYMOUS) {
						Object.defineProperty(value, '$classname', {
							value: name + '.' + key,
							enumerable: true,
							writable: false
						});
						this._spacename(value, name + '.' + key);
					}
				}
			}, this);
		}
	};

	return Namespace;
}()),

	/*
	 * Ad hoc timing device to investigate the timing of all the things.
	 * TODO: check out `performance.setResourceTimingBufferSize(10000);`
	 * @param {boolean} native Supporting `window.performance` natively?
	 * @param {boolean} enabled Timing enabled (in dev mode and on Docs)?
	 * @returns {object}
	 */
	(function Timer(native, enabled) {
		var sets = {}; // for polyfilling
		var list = []; // for polyfilling

		/**
		 * Insert item chronologically correct (for polyfilling).
		 * @param {object} item
		 * @returns {object}
		 */
		function push(item) {
			var low = 0;
			var high = list.length;
			var mid;
			while (low < high) {
				mid = (low + high) >>> 1;
				if (list[mid].startTime < item.startTime) {
					low = mid + 1;
				} else {
					high = mid;
				}
			}
			list.splice(low, 0, item);
			return item;
		}

		return {

			/**
			 * Begin measurement.
			 * @param {string} key
			 * @returns {Timer}
			 */
			mark: function(key) {
				if (enabled) {
					if (native) {
						performance.mark('mark ' + key);
					} else {
						sets['$' + key] = Date.now();
					}
				}
				return this;
			},

			/**
			 * End measurement.
			 * @param {string} key
			 * @returns {object}
			 */
			stop: function(key) {
				if (enabled) {
					if (native) {
						performance.mark('stop ' + key);
						performance.measure(key, 'mark ' + key, 'stop ' + key);
						var entries = performance.getEntriesByName(key);
						return entries[entries.length - 1];
					} else {
						var init = sets['$' + key];
						return push({
							startTime: init,
							name: key,
							duration: Date.now() - init,
							itemType: 'measure'
						});
					}
				}
			},

			/**
			 * Get all measurements.
			 * @returns {Array<Object>}
			 */
			measurements: function() {
				if (enabled) {
					if (native) {
						return performance.getEntriesByType('measure');
					} else {
						return list.slice();
					}
				}
			}
		};
	}(!!(window.performance &&
			performance.mark &&
			performance.measure &&
			performance.getEntriesByName &&
			performance.getEntriesByType),
		!!(location.port === '10114' || location.host === 'ui.tradeshift.com')
	))

));

/*
 * Start the measurements.
 * TODO: These kinds of "saga" measurements into seperate script files!
 */
gui.$mark('boostrap everything');
gui.$mark('- parse spiritual');



/**
 * Generating keys for unique key purposes.
 */
gui.KeyMaster = {

	/**
	 * Generate random key. Not simply incrementing a counter in order to celebrate the
	 * rare occasion that subjects might be uniquely identified across different domains.
	 * @returns {String}
	 */
	generateKey: function() {
		var ran = Math.random().toString();
		var key = 'key' + ran.slice(2, 11);
		if (this._keys[key]) {
			key = this.generateKey();
		} else {
			this._keys[key] = true;
		}
		return key;
	},

	/**
	 * Generate GUID. TODO: Verify integrity of this by mounting result in Java or something.
	 * @see http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {String}
	 */
	generateGUID: function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random() * 16 | 0,
				v = c === 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		}).toLowerCase();
	},

	/**
	 * String appears to be a generated key? We don't look it up in the key cache,
	 * so this method can be used to check a key that was generated in old session.
	 * @param {String} string
	 * @returns {boolean}
	 */
	isKey: function(string) {
		var hit = null,
			looks = false;
		if (gui.Type.isString(string)) {
			hit = this.extractKey(string);
			looks = hit && hit[0] === string;
		}
		return looks;
	},

	/**
	 * Extract (potential) key from string.
	 * TODO: Rename 'extractKeys' (multiple)
	 * @param {string} string
	 * @returns {Array<string>}
	 */
	extractKey: function(string) {
		return (/key\d{9}/).exec(string);
	},

	// Private ...................................................................

	/**
	 * Tracking generated keys to prevent doubles.
	 * @type {Map<String,boolean>}
	 */
	_keys: Object.create(null)
};



/**
 * Working with objects.
 */
gui.Object = {

	/**
	 * Object.create with default property descriptors.
	 * @see http://wiki.ecmascript.org/doku.php?id=strawman:define_properties_operator
	 * @param {object} proto
	 * @param {object} props
	 */
	create: function(proto, props) {
		var resolved = {};
		Object.keys(props).forEach(function(prop) {
			resolved[prop] = {
				value: props[prop],
				writable: true,
				enumerable: true,
				configurable: true
			};
		});
		return Object.create(proto, resolved);
	},

	/**
	 * Extend target with source properties *excluding* prototype stuff.
	 * Optional parameter 'loose' to skips properties already declared.
	 * TODO: bypass mixin?
	 * @param {object} target
	 * @param {object} source
	 * @param @optional {boolean} loose Skip properties already declared
	 * @returns {object}
	 */
	extend: function(target, source, loose) {
		var hiding = this._hiding;
		if (gui.Type.isObject(source)) {
			Object.keys(source).forEach(function(key) {
				if (!loose || !gui.Type.isDefined(target[key])) {
					var desc = Object.getOwnPropertyDescriptor(source, key);
					desc = hiding ? gui.Object._hide(desc) : desc;
					Object.defineProperty(target, key, desc);
				}
			}, this);
		} else {
			throw new TypeError('Expected object, got ' + gui.Type.of(source));
		}
		return target;
	},

	/**
	 * Extend target with source properties,
	 * skipping everything already declared.
	 * @param {object} target
	 * @param {object} source
	 * @returns {object}
	 */
	extendmissing: function(target, source) {
		return this.extend(target, source, true);
	},

	/**
	 * Copy object.
	 * @returns {object}
	 */
	copy: function(source) {
		try {
			return this.extend({}, source);
		} catch (exception) {
			throw new TypeError('Could not object-copy ' + gui.Type.of(source));
		}
	},

	/**
	 * Call function for each own key in object (exluding the prototype stuff)
	 * with key and value as arguments. Returns array of function call results.
	 * Function results that are `undefined` get's filtered out of this list.
	 * @param {object} object
	 * @param {function} func
	 * @param @optional {object} thisp
	 */
	each: function(object, func, thisp) {
		return Object.keys(object).map(function(key) {
			return func.call(thisp, key, object[key]);
		}).filter(function(result) {
			return result !== undefined;
		});
	},

	/**
	 * Call function for all properties in object (including prototype stuff)
	 * with key and value as arguments. Returns array of function call results.
	 * @param {object} object
	 * @param {function} func
	 * @param @optional {object} thisp
	 */
	all: function(object, func, thisp) {
		var res = [];
		for (var key in object) {
			res.push(func.call(thisp, key, object[key]));
		}
		return res.filter(function(result) {
			return result !== undefined;
		});
	},

	/**
	 * Create new object by passing all property
	 * names and values through a resolver call.
	 * Eliminate values that map to `undefined`.
	 * @param {object} source
	 * @param {function} domap
	 * @param @optional {object} thisp
	 * @returns {object}
	 */
	map: function(source, domap, thisp) {
		var result = {},
			mapping;
		this.each(source, function(key, value) {
			mapping = domap.call(thisp, key, value);
			if (mapping !== undefined) {
				result[key] = mapping;
			}
		});
		return result;
	},

	/**
	 * Lookup object for string of type "my.ns.Thing" in given context or this window.
	 * @param {String} opath Object path eg. "my.ns.Thing"
	 * @param @optional {Window} context
	 * @returns {object}
	 */
	lookup: function(opath, context) {
		var result, struct = context || self;
		if (gui.Type.isString(opath)) {
			if (!opath.includes('.')) {
				result = struct[opath];
			} else {
				var parts = opath.split('.');
				parts.every(function(part) {
					struct = struct[part];
					return gui.Type.isDefined(struct);
				});
				result = struct;
			}
		} else {
			throw new TypeError('Expected string, got ' + gui.Type.of(opath));
		}
		return result;
	},

	/**
	 * Update property of object in given context based on string input.
	 * TODO: Rename "declare"
	 * @param {String} opath Object path eg. "my.ns.Thing.name"
	 * @param {object} value Property value eg. `"Johnson` or"` `[]`
	 * @param @optional {Window|object} context
	 * @returns {object}
	 */
	assert: function(opath, value, context) {
		var prop, struct = context || self;
		if (opath.includes('.')) {
			var parts = opath.split('.');
			prop = parts.pop();
			parts.forEach(function(part) {
				struct = struct[part] || (struct[part] = {});
			});
		} else {
			prop = opath;
		}
		if (struct) {
			struct[prop] = value;
		}
		return value;
	},

	/**
	 * List names of invocable methods *including* prototype stuff.
	 * @return {Array<String>}
	 */
	methods: function(object) {
		var name, value, desc, obj = object,
			result = [];
		for (name in object) {
			// make sure that we don't poke any getter type properties...
			while (!(desc = Object.getOwnPropertyDescriptor(obj, name))) {
				obj = Object.getPrototypeOf(obj);
			}
			if (typeof desc.value === 'function') {
				value = object[name];
				if (gui.Type.isMethod(value)) {
					result.push(name);
				}
			}
		}
		return result;
	},

	/**
	 * List names of invocable methods *excluding* prototype stuff.
	 * @return {Array<String>}
	 */
	ownmethods: function(object) {
		return Object.keys(object).filter(function(key) {
			return gui.Type.isMethod(object[key]);
		}).map(function(key) {
			return key;
		});
	},

	/**
	 * List names of non-method properties *including* prototype stuff.
	 * @return {Array<String>}
	 */
	nonmethods: function(object) {
		var result = [];
		for (var def in object) {
			if (!gui.Type.isFunction(object[def])) {
				result.push(def);
			}
		}
		return result;
	},

	/**
	 * Bind the "this" keyword for all public instance methods.
	 * Stuff descending from the prototype chain is ignored.
	 * TODO: does this belong here?
	 * @param {object} object
	 * @returns {object}
	 */
	bindall: function(object) {
		var methods = Array.prototype.slice.call(arguments).slice(1);
		if (!methods.length) {
			methods = gui.Object.ownmethods(object).filter(function(name) {
				return name[0] !== '_'; // exclude private methods
			});
		}
		methods.forEach(function(name) {
			object[name] = object[name].bind(object);
		});
		return object;
	},

	/**
	 * Sugar for creating non-enumerable function properties (methods).
	 * To be be used in combination with `gui.Object.extend` for effect.
	 * `mymethod : gui.Object.hidden ( function () {})'
	 * @param {function} method
	 * @return {function}
	 */
	hidden: function(method) {
		gui.Object._hiding = true;
		method.$hidden = true;
		return method;
	},

	// Private ...................................................................

	/**
	 * Hiding any methods from inspection?
	 * Otherwise economize a function call.
	 * @see {edb.Object#extend}
	 * @type {boolean}
	 */
	_hiding: false,

	/**
	 * Modify method descriptor to hide from inspection.
	 * Do note that the method may still be called upon.
	 * @param {object} desc
	 * @returns {object}
	 */
	_hide: function(desc) {
		if (desc.value && gui.Type.isFunction(desc.value)) {
			if (desc.value.$hidden && desc.configurable) {
				desc.enumerable = false;
			}
		}
		return desc;
	}
};



/**
 * Type checking studio. All checks are string based.
 */
gui.Type = {

	/**
	 * Get type of argument. Note that response may differ between user agents.
	 * @see	http://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator
	 * @param {object} o
	 * @returns {String}
	 */
	of: function(o) {
		var type = ({}).toString.call(o).match(this._typeexp)[1].toLowerCase();
		if (type === 'domwindow' && String(typeof o) === 'undefined') {
			type = 'undefined'; // some kind of degenerate bug in Safari on iPad
		}
		return type;
	},

	/**
	 * Is object defined?
	 * TODO: unlimited arguments support
	 * @param {object} o
	 * @returns {boolean}
	 */
	isDefined: function(o) {
		return this.of(o) !== 'undefined';
	},

	/**
	 * Is complex type?
	 * @param {object} o
	 * @returns {boolean}
	 */
	isComplex: function(o) {
		switch (this.of(o)) {
			case 'undefined':
			case 'boolean':
			case 'number':
			case 'string':
			case 'null':
				return false;
		}
		return true;
	},

	/**
	 * Is Window object?
	 * @param {object} o
	 * @returns {boolean}
	 */
	isWindow: function(o) {
		return o && o.document && o.location && o.alert && o.setInterval;
	},

	/**
	 * Is Event object?
	 * @pram {object} o
	 * @returns {boolean}
	 */
	isEvent: function(o) {
		return this.of(o).endsWith('event') && this.isDefined(o.type);
	},

	/**
	 * Is DOM element?
	 * @param {object} o
	 * @returns {boolean}
	 */
	isElement: function(o) {
		return this.of(o).endsWith('element') && o.nodeType === Node.ELEMENT_NODE;
	},

	/**
	 * Is Document Fragment?
	 * @param {object} o
	 * @returns {boolean}
	 */
	isDocumentFragment: function(o) {
		return o && o.nodeName && o.nodeName === '#document-fragment';
	},

	/**
	 * Is Document?
	 * @param {object} o
	 * @returns {boolean}
	 */
	isDocument: function(o) {
		return o && o.nodeType === Node.DOCUMENT_NODE;
	},

	/**
	 * Is most likely a method?
	 * @param {object} o
	 * @return {boolean}
	 */
	isMethod: function(o) {
		return o && this.isFunction(o) && !this.isConstructor(o) &&
			!String(o).includes('[native code]'); // hotfix 'Array' and 'Object' ...
	},

	/**
	 * Is spirit instance?
	 * @returns {boolean}
	 */
	isSpirit: function(o) {
		return o && (o instanceof gui.Spirit);
	},

	/**
	 * Is function fit to be invoked via the "new" operator?
	 * We assume so if the prototype reveals any properties.
	 * @param {function} what
	 * @returns {boolean}
	 */
	isConstructor: function(what) {
		return this.isFunction(what) &&
			this.isObject(what.prototype) &&
			Object.keys(what.prototype).length;
	},

	/**
	 * Is {gui.Class} constructor?
	 */
	isGuiClass: function(what) {
		return this.isConstructor(what) && what.$classname;
	},

	/**
	 * Is constructor for a Spirit?
	 * TODO: Why can't isConstructor be used here?
	 * TODO: something more reliable than "summon".
	 * @param {function} what
	 * @returns {boolean}
	 */
	isSpiritConstructor: function(what) {
		return this.isFunction(what) && this.isFunction(what.summon); // lousy
	},

	/**
	 * Something appears to be something array-like?
	 * @param {object} what
	 * @returns {boolean}
	 */
	isArrayLike: function(what) {
		return '0' in what && !this.isArray(what);
	},

	/**
	 * Autocast string to an inferred type. "123" will
	 * return a number, "false" will return a boolean.
	 * @param {String} string
	 * @returns {object}
	 */
	cast: function(string) {
		var result = String(string);
		switch (result) {
			case 'null':
				result = null;
				break;
			case 'true':
			case 'false':
				result = (result === 'true');
				break;
			default:
				if (String(parseInt(result, 10)) === result) {
					result = parseInt(result, 10);
				} else if (String(parseFloat(result)) === result) {
					result = parseFloat(result);
				}
				break;
		}
		return result;
	},

	// Private ...................................................................

	/**
	 * Match "Array" in "[object Array]" and so on.
	 * @type {RegExp}
	 */
	_typeexp: /\s([a-zA-Z]+)/

};

/**
 * Generate methods for isArray, isFunction, isBoolean etc.
 * TODO: can we do an "isError" here?
 */
(function generatecode() {
	['array',
		'function',
		'object',
		'string',
		'number',
		'boolean',
		'null',
		'arguments',
		'file'
	].forEach(function(type) {
		this['is' + type[0].toUpperCase() + type.slice(1)] = function is(o) {
			return this.of(o) === type;
		};
	}, this);
}).call(gui.Type);

/**
 * Bind the "this" keyword for all methods.
 */
gui.Object.bindall(gui.Type);



/**
 * Working with arrays.
 */
gui.Array = {

	/**
	 * Takes a variable number of arguments and produces
	 * an instance of Array containing those elements.
	 * http://wiki.ecmascript.org/doku.php?id=strawman:array_extras
	 * @returns {Array}
	 */
	of: (function() {
		var slice = Array.prototype.slice;
		return (Array.of) || function() {
			return slice.call(arguments);
		};
	}()),

	/**
	 * Converts a single argument that is an array-like
	 * object or list into a fresh array.
	 * https://gist.github.com/rwaldron/1074126
	 * @param {object} arg
	 * @returns {Array}
	 */
	from: (function() {
		return (Array.from) || function(arg) {
			var array = [];
			var object = Object(arg);
			var len = object.length >>> 0;
			var i = 0;
			while (i < len) {
				if (i in object) {
					array[i] = object[i];
				}
				i++;
			}
			return array;
		};
	})(),

	/**
	 * Resolve single argument into an array with one or more
	 * entries with special handling of single string argument:
	 *
	 * 1. Strings to be split at spaces into an array
	 * 3. Arrays are converted to a similar but fresh array
	 * 2. Array-like objects transformed into real arrays.
	 * 3. Other objects are pushed into a one entry array.
	 *
	 * @param {object} arg
	 * @returns {Array} Always return an array
	 */
	make: function(arg) {
		switch (gui.Type.of(arg)) {
			case 'string':
				return arg.split(' ');
			case 'array':
				return this.from(arg);
			default:
				if (gui.Type.isArrayLike(arg)) {
					return this.from(arg);
				} else {
					return [arg];
				}
		}
	},

	/**
	 * Remove array member(s) by index (given numbers) or reference (given other).
	 * @see http://ejohn.org/blog/javascript-array-remove/#comment-296114
	 * TODO: Special setup for handling strings????
	 * TODO: More corner case handling of types...
	 * @param {Array} array
	 * @param {number|object} from
	 * @param @optional {number|object} to
	 * @returns {number} new length
	 */
	remove: function(array, from, to) {
		var markers = gui.Array.from(arguments).slice(1);
		if (markers.some(isNaN)) {
			return this.remove.apply(this, [array].concat(
				markers.map(function toindex(m) {
					return isNaN(m) ? array.indexOf(m) : m;
				})
			));
		} else {
			array.splice(from, !to || 1 + to - from + (!(to < 0 ^ from >= 0) &&
				(to < 0 || -1) * array.length));
			return array.length;
		}
	}
};



/**
 * Function argument type checking studio.
 */
gui.Arguments = {

	/**
	 * Forgiving arguments matcher.
	 * Ignores action if no match.
	 */
	provided: function(/* ...types */) {
		var types = gui.Array.from(arguments);
		return function(action) {
			return function() {
				if (gui.Arguments._match(arguments, types)) {
					return action.apply(this, arguments);
				}
			};
		};
	},

	/**
	 * Revengeful arguments validator.
	 * Throws an exception if no match.
	 */
	confirmed: function(/* ...types */) {
		var types = gui.Array.from(arguments);
		return function(action) {
			return function() {
				if (gui.Arguments._validate(arguments, types)) {
					return action.apply(this, arguments);
				} else {
					gui.Arguments._abort(this);
				}
			};
		};
	},

	// Private ...................................................................

	/**
	 * Validating mode?
	 * @type {boolean}
	 */
	_validating: false,

	/**
	 * Error repporting.
	 * @type {Array<String>}
	 */
	_bugsummary: null,

	/**
	 * Use this to check the runtime signature of a function call:
	 * gui.Arguments.match ( arguments, "string", "number" );
	 * Note that some args may be omitted and still pass the test,
	 * eg. the example would pass if only a single string was given.
	 * Note that `gui.Type.of` may return different xbrowser results
	 * for certain exotic objects. Use the pipe char to compensate:
	 * gui.Arguments.match ( arguments, "window|domwindow" );
	 * @returns {boolean}
	 */
	_match: function(args, types) {
		return types.every(function(type, index) {
			return this._matches(type, args[index], index);
		}, this);
	},

	/**
	 * Strict type-checking facility to throw exceptions on failure.
	 * TODO: at some point, return true unless in developement mode.
	 * @returns {boolean}
	 */
	_validate: function(args, types) {
		this._validating = true;
		var is = this._match(args, types);
		this._validating = false;
		return is;
	},

	/**
	 * Extract expected type of (optional) argument.
	 * @param {string} xpect
	 * @param {boolean} optional
	 */
	_xtract: function(xpect, optional) {
		return optional ? xpect.slice(1, -1) : xpect;
	},

	/**
	 * Check if argument matches expected type.
	 * @param {string} xpect
	 * @param {object} arg
	 * @param {number} index
	 * @returns {boolean}
	 */
	_matches: function(xpect, arg, index) {
		var needs = !xpect.startsWith('(');
		var split = this._xtract(xpect, !needs).split('|');
		var input = gui.Type.of(arg);
		var match = (xpect === '*' ||
			(xpect === 'node' && arg && arg.nodeType) ||
			(xpect === 'constructor' && arg && gui.Type.isConstructor(arg)) ||
			(xpect === 'element' && arg && arg.nodeType === Node.ELEMENT_NODE) ||
			(xpect === 'spirit' && arg && arg.$instanceid && arg.element) ||
			(!needs && input === 'undefined') ||
			(!needs && split.indexOf('*') > -1) ||
			split.indexOf(input) > -1);
		if (!match && this._validating) {
			if (input === 'string') {
				arg = '"' + arg + '"';
			}
			this._bugsummary = [index, xpect, input, arg];
		}
		return match;
	},

	/**
	 * Throw exception.
	 * @TODO: Rig up to report offended methods name.
	 * @param {object} that
	 * @param {Array<String>} report
	 */
	_abort: function(that) {
		var summ = this._bugsummary;
		var name = that.constructor.$classname || String(that);
		console.error([
			'Spiritual GUI: Bad argument ' + summ.shift(),
			'for ' + name + ':', 'Expected ' + summ.shift() + ',',
			'got ' + summ.shift() + ':', summ.shift()
		].join(' '));
	}
};



/**
 * Working with functions.
 */
gui.Function = {

	/**
	 * Create named function. This may not be the most optimized thing to compile.
	 * @see https://mail.mozilla.org/pipermail/es-discuss/2009-March/008954.html
	 * @see http://wiki.ecmascript.org/doku.php?id=strawman:name_property_of_functions
	 * @param @optional {String} name
	 * @param @optional {Array<String>} params
	 * @param @optional {String} body
	 * @param @optional {Window} context
	 * @returns {function}
	 */
	create: function(name, params, body, context) {
		var F = context ? context.Function : Function;
		name = this.safename(name);
		params = params ? params.join(',') : '';
		body = body || '';
		return new F(
			'return function ' + name + ' ( ' + params + ' ) {' + body + '}'
		)();
	},

	/**
	 * Decorate object method before.
	 * @param {object} target
	 * @param {String} name
	 * @param {function} decorator
	 * @returns {object}
	 */
	decorateBefore: gui.Arguments.confirmed('object|function', 'string', 'function')(
		function(target, name, decorator) {
			return this._decorate('before', target, name, decorator);
		}
	),

	/**
	 * Decorate object method after.
	 * @param {object} target
	 * @param {String} name
	 * @param {function} decorator
	 * @returns {object}
	 */
	decorateAfter: gui.Arguments.confirmed('object|function', 'string', 'function')(
		function(target, name, decorator) {
			return this._decorate('after', target, name, decorator);
		}
	),

	/**
	 * TODO: Decorate object method around.
	 * @param {object} target
	 * @param {String} name
	 * @param {function} decorator
	 * @returns {object}
	 */
	decorateAround: function() {
		throw new Error('TODO');
	},

	/**
	 * Strip namespaces from name to create valid function name.
	 * TODO: Return a safe name no matter what has been input.
	 * @param {String} name
	 * @return {String}
	 */
	safename: function(name) {
		if (name && name.includes('.')) {
			name = name.split('.').pop();
		}
		return name || '';
	},

	// Private ...................................................................

	/**
	 * Decorate object method
	 * @param {String} position
	 * @param {object|function} target
	 * @param {String} name
	 * @param {function} decorator
	 * @returns {object}
	 */
	_decorate: function(position, target, name, decorator) {
		target[name] = gui.Combo[position](decorator)(target[name]);
		return target;
	}

};



/**
 * This fellow allow us to create a newable constructor that can be "subclassed" via an extend method.
 * Instances of the "class" may use a special `_super` method to override members of the "superclass".
 * TODO: Evaluate static stuff first so that proto can declare vals as static props
 * TODO: Check if static stuff shadows recurring static (vice versa) and warn about it.
 * TODO: It's possible for a prototype to be a prototype, investigate this inception
 * TODO: Assign uppercase properties as constants
 */
gui.Class = {

	/**
	 * Create constructor. Use method `extend` on
	 * the constructor to subclass further.
	 * @param @optional {String} name
	 * @param {object} proto Base prototype
	 * @param {object} protos Prototype extensions
	 * @param {object} recurring Constructor and subconstructor extensions
	 * @param {object} statics Constructor extensions
	 * @returns {function}
	 */
	create: function() {
		var b = this._breakdown_base(arguments);
		var C = this._createclass(null, b.proto, b.name);
		gui.Object.extend(C.prototype, b.protos);
		gui.Object.extend(C, b.statics);
		gui.Property.extendall(b.protos, C.prototype);
		if (b.recurring) {
			gui.Object.each(b.recurring, function(key, val) {
				var desc = Object.getOwnPropertyDescriptor(C, key);
				if (!desc || desc.writable) {
					C[key] = C.$recurring[key] = val;
				}
			});
		}
		return C;
	},

	/**
	 * Get constructor by $classid.
	 * @param {string} classid
	 * @returns {constructor}
	 */
	get: function(classid) {
		return this._classes[classid] || null;
	},

	// Privileged ................................................................

	/**
	 * The `this` keyword around here points to the instance via `apply`.
	 * @param {object} instance
	 * @param {Arguments} arg
	 */
	$constructor: function() {
		var constructor = this.$onconstruct || this.onconstruct;
		var nonenumprop = gui.Property.nonenumerable;
		var returnvalue = this;
		Object.defineProperties(this, {
			$instanceid: nonenumprop({
				value: gui.KeyMaster.generateKey()
			}),
			displayName: nonenumprop({
				value: this.constructor.displayName,
				writable: true
			})
		});
		if (gui.Type.isFunction(constructor)) {
			returnvalue = constructor.apply(this, arguments);
		}
		// if (false) { // if stil an instance of gui.Class (but disabled for now)
		// 	if (gui.Client && gui.Super) {
		// 		gui.Super.$proxy(returnvalue || this);
		// 	}
		// }
		return returnvalue || this;
	},

	// Private ...................................................................

	/**
	 * Mapping $classid to constructors.
	 * @type {Map<string,constructor>}
	 */
	_classes: Object.create(null),

	/**
	 * Nameless name.
	 * @type {String}
	 */
	ANONYMOUS: 'Anonymous',

	/**
	 * TODO: Memoize this!
	 * Self-executing function creates a string property _BODY
	 * which we can as constructor body for classes. The `$name`
	 * will be substituted for the class name. Note that if
	 * called without the `new` keyword, the function acts
	 * as a shortcut the the MyClass.extend method (against
	 * convention, which is to silently imply the `new` keyword).
	 * @type {String}
	 */
	_BODY: (function($name) {
		var body = $name.toString().trim();
		return body.slice(body.indexOf('{') + 1, -1);
	}(
		function $name() {
			if (this instanceof $name) {
				return gui.Class.$constructor.apply(this, arguments);
			} else {
				return $name.extend.apply($name, arguments);
			}
		}
	)),

	/**
	 * Breakdown arguments for base exemplar only (has one extra argument).
	 * TODO: Something in gui.Arguments instead.
	 * @see {gui.Class#breakdown}
	 * @param {Arguments} args
	 * @returns {object}
	 */
	_breakdown_base: function(args) {
		var named = gui.Type.isString(args[0]);
		return {
			name: named ? args[0] : null,
			proto: args[named ? 1 : 0] || Object.create(null),
			protos: args[named ? 2 : 1] || Object.create(null),
			recurring: args[named ? 3 : 2] || Object.create(null),
			statics: args[named ? 4 : 3] || Object.create(null)
		};
	},

	/**
	 * Break down class constructor arguments. We want to make the string (naming)
	 * argument optional, but we still want to keep is as first argument, so the
	 * other arguments must be identified by whether or not it's present.
	 * TODO: Something in gui.Arguments instead.
	 * @param {Arguments} args
	 * @returns {object}
	 */
	_breakdown_subs: function(args) {
		var named = gui.Type.isString(args[0]);
		return {
			name: named ? args[0] : null,
			protos: args[named ? 1 : 0] || Object.create(null),
			recurring: args[named ? 2 : 1] || Object.create(null),
			statics: args[named ? 3 : 2] || Object.create(null)
		};
	},

	/**
	 * TODO: comments here!
	 * @param {object} proto Prototype of superconstructor
	 * @param {String} name Constructor name (for debug).
	 * @returns {function}
	 */
	_createclass: function(SuperC, proto, name) {
		name = name || gui.Class.ANONYMOUS;
		// TODO: this in devmode if and when we might know the name beforehand
		// C = gui.Function.create ( name, null, this._namedbody ( name ));
		var C = function $Class() {
			if (this instanceof $Class) {
				return gui.Class.$constructor.apply(this, arguments);
			} else {
				return $Class.extend.apply($Class, arguments);
			}
		};
		C.$classid = gui.KeyMaster.generateKey();
		C.prototype = Object.create(proto || null);
		C.prototype.constructor = C;
		C = this._internals(C, SuperC);
		C = this._interface(C);
		C = this._classname(C, name);
		this._classes[C.$classid] = C;
		return C;
	},

	/**
	 * Create subclass for given class.
	 * @param {funciton} SuperC
	 * @param {Object} args
	 * @return {function}
	 */
	_createsubclass: function(SuperC, args) {
		args = this._breakdown_subs(args);
		return this._extendclass(
			SuperC,
			args.protos,
			args.recurring,
			args.statics,
			args.name
		);
	},

	/**
	 * Create subclass constructor.
	 * @param {object} SuperC super constructor
	 * @param {object} protos Prototype extensions
	 * @param {object} recurring Constructor and subconstructor extensions
	 * @param {object} statics Constructor extensions
	 * @param {String} generated display name (for development)
	 * @returns {function} Constructor
	 */
	_extendclass: function(SuperC, protos, recurring, statics, name) {
		var C = this._createclass(SuperC, SuperC.prototype, name);
		gui.Object.extend(C, statics);
		gui.Object.extend(C.$recurring, recurring);
		gui.Object.each(C.$recurring, function(key, val) {
			var desc = Object.getOwnPropertyDescriptor(C, key);
			if (!desc || desc.writable) {
				C[key] = val;
			}
		});
		gui.Property.extendall(protos, C.prototype);
		C = this._classname(C, name);
		return C;
	},

	/**
	 * Setup framework internal propeties.
	 * @param {function} C
	 * @param @optional {function} superclass
	 * @param @optional {Map<String,object>} recurring
	 * @returns {function}
	 */
	_internals: function(C, SuperC) {
		C.$super = null; // what's this?
		C.$subclasses = [];
		C.$superclass = SuperC || null;
		C.$recurring = SuperC ?
			gui.Object.copy(SuperC.$recurring) : Object.create(null);
		if (SuperC) {
			SuperC.$subclasses.push(C);
		}
		return C;
	},

	/**
	 * Setup standard static methods for extension, mixin and instance checking.
	 * @param {function} C
	 * @returns {function}
	 */
	_interface: function(C) {
		['extend', 'mixin', 'is'].forEach(function(method) {
			C[method] = this[method];
		}, this);
		return C;
	},

	/**
	 * Assign toString() return value to function constructor and instance object.
	 * TODO: validate unique name
	 * @param {constructor} C
	 * @param {String} name
	 * @returns {function}
	 */
	_classname: function(C, name) {
		/*
		 * At this point the $classname is a writable property, it will
		 * become non-writable after we call {gui.Namespace#spacenames}.
		 */
		C.$classname = name || gui.Class.ANONYMOUS;
		Object.defineProperty(C.prototype, '$classname', {
			enumerable: false,
			configurable: true,
			get: function() {
				return this.constructor.$classname;
			}
		});
		C.toString = function() {
			return '[function ' + this.$classname + ']';
		};
		C.prototype.toString = function() {
			return '[object ' + this.constructor.$classname + ']';
		};
		return C;
	},

	/**
	 * Compute constructor body for class of given name.
	 * @param	{[type]} name [description]
	 * @return {[type]}			[description]
	 */
	_namedbody: function(name) {
		return this._BODY.replace(
			new RegExp('\\$name', 'gm'),
			gui.Function.safename(name)
		);
	}

	/**
	 * This might do something in the profiler. Not much luck with stack traces.
	 * @see http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/
	 * @see https://code.google.com/p/chromium/issues/detail?id=17356
	 * @param {function} C
	 * @returns {function}
	 *
	_profiling : function ( C ) {
		var name = C.name || gui.Class.ANONYMOUS;
		[ C, C.prototype ].forEach ( function ( thing ) {
			gui.Object.each ( thing, function ( key, value ) {
				if ( gui.Type.isMethod ( value )) {
					this._displayname ( value, name + "." + key );
				}
			}, this );
		}, this );
		return C;
	},
	*/
};

// Class members ...............................................................

gui.Object.extend(gui.Class, {

	/**
	 * Create subclass. To be called on the class constructor: MyClass.extend()
	 * @param @optional {String} name
	 * @param {object} proto Base prototype
	 * @param {object} protos Prototype methods and properties
	 * @param {object} recurring Constructor and subconstructor extensions
	 * @param {object} statics Constructor extensions
	 * @returns {function} Constructor
	 */
	extend: function() { // protos, recurring, statics
		return gui.Class._createsubclass(this, arguments);
	},

	/**
	 * Mixin something.
	 * @param {object} proto
	 * @param {object} recurring
	 * @param {object} statics
	 * @returns {function}
	 */
	mixin: function(proto, recurring, statics) {
		Array.forEach(arguments, function(mixins, i) {
			if (mixins) {
				gui.Object.each(mixins, function(name, value) {
					if (i === 0) {
						// TODO: something more elaborate (like defineProperty)
						this.prototype[name] = value;
					} else { // TODO: only at index 1 right?
						gui.Class.descendantsAndSelf(this, function(C) {
							C.$recurring[name] = value;
							C[name] = value;
						});
					}
				}, this);
			}
		}, this);
		return this;
	},

	/**
	 * Is instance of this?
	 * @param {object} object
	 * @returns {boolean}
	 */
	is: function(object) {
		return gui.Type.isObject(object) && (object instanceof this);
	},

	/**
	 * Deprecated API.
	 */
	isInstance: function() {
		console.error('Deprecated API is derecated');
	}

});

// Class navigation ............................................................

gui.Object.extend(gui.Class, {

	/**
	 * Return superclass. If action is provided, return an array of the results
	 * of executing the action for each subclass with the subclass as argument.
	 * @param {function} C constructor
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 * @returns {Array<gui.Class|object>}
	 */
	children: function(C, action, thisp) {
		var results = [];
		action = action || gui.Combo.identity;
		C.$subclasses.forEach(function(sub) {
			results.push(action.call(thisp, sub));
		}, thisp);
		return results;
	},

	/**
	 * Apply action recursively to all derived subclasses of given class.
	 * Returns an array of accumulated results. If no action is provided,
	 * returns array of descendant sublasses.
	 * @param {function} C constructor
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 * @param @internal {Array<gui.Class|object>} results
	 * @returns {Array<gui.Class|object>}
	 */
	descendants: function(C, action, thisp, results) {
		results = results || [];
		action = action || gui.Combo.identity;
		C.$subclasses.forEach(function(sub) {
			results.push(action.call(thisp, sub));
			gui.Class.descendants(sub, action, thisp, results);
		}, thisp);
		return results;
	},

	/**
	 * Return descendant classes and class itself. If action is provided, return
	 * array of the results of executing the action for each descendant class
	 * and class itself with the class as argument.
	 * @param {function} C constructor
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 * @returns {Array<gui.Class|object>}
	 */
	descendantsAndSelf: function(C, action, thisp) {
		var results = [];
		action = action || gui.Combo.identity;
		results.push(action.call(thisp, C));
		return this.descendants(C, action, thisp, results);
	},

	/**
	 * Return superclass. If action is provided, return the result
	 * of executing the action with the superclass as argument.
	 * @param {function} C constructor
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 * @returns {gui.Class|object}
	 */
	parent: function(C, action, thisp) {
		if (C && C.$superclass) {
			action = action || gui.Combo.identity;
			return action.call(thisp, C.$superclass);
		}
		return null;
	},

	/**
	 * Return ancestor classes. If action is provided, return array of the results
	 * of executing the action for each ancestor class with the class as argument.
	 * @param {function} C constructor
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 * @param @internal {<gui.Class|object>} results
	 * @returns {Array<gui.Class|object>}
	 */
	ancestors: function(C, action, thisp, results) {
		results = results || [];
		action = action || gui.Combo.identity;
		if (C.$superclass) {
			results.push(action.call(thisp, C.$superclass));
			gui.Class.ancestors(C.$superclass, action, thisp, results);
		}
		return results;
	},

	/**
	 * Return ancestor classes and class itself. If action is provided, return
	 * array of the results of executing the action for each ancestor class and
	 * class itself with the class as argument.
	 * @param {function} C constructor
	 * @param @optional {function} action Takes the class as argument
	 * @param @optional {object} thisp
	 * @returns {Array<gui.Class|object>}
	 */
	ancestorsAndSelf: function(C, action, thisp) {
		var results = [];
		action = action || gui.Combo.identity;
		results.push(action.call(thisp, C));
		return this.ancestors(C, action, thisp, results);
	},

	/**
	 * Return ancestor classes, descendant classes and class itself. If action is
	 * provided, return array of the results of executing the action for each
	 * related class and class itself with the class as argument.
	 * @param {constructor} C
	 * @param @optional {function} action Takes the class as argument
	 * @param @optional {object} thisp
	 * @returns {Array<<gui.Class|object>>}
	 */
	family: function(C, action, thisp) {
		var results = this.ancestorsAndSelf(C).concat(this.descendants(C));
		if (action) {
			results = results.map(function(Con) {
				return action.call(thisp, Con);
			});
		}
		return results;
	}

});



/**
 * Working with properties.
 */
gui.Property = {

	/**
	 * Clone properties from source to target.
	 * @param {object} source
	 * @param {object} target
	 * @returns {object}
	 */
	extendall: function(source, target) {
		Object.keys(source).forEach(function(key) {
			this.extend(source, target, key);
		}, this);
		return target;
	},

	/**
	 * Copy property from source to target. Main feature is that it
	 * will be setup to a property accessor (getter/setter) provided:
	 *
	 * 1) The property value is an object
	 * 2) It has (only) one or both properties "getter" and "setter"
	 * 3) These are both functions
	 */
	extend: function(source, target, key) {
		var desc = Object.getOwnPropertyDescriptor(source, key);
		desc = this._accessor(target, key, desc);
		Object.defineProperty(target, key, desc);
		return target;
	},

	/**
	 * Provide sugar for non-enumerable propety descriptors.
	 * Omit "writable" since accessors must not define that.
	 * @param {object} desc
	 * @returns {object}
	 */
	nonenumerable: function(desc) {
		return gui.Object.extendmissing({
			configurable: true,
			enumerable: false
		}, desc);
	},

	/**
	 * Create getter/setter for object assuming enumerable and configurable.
	 * @param {object} object The property owner
	 * @param {string} key The property name
	 * @param {object} def An object with methods "get" and/or "set"
	 * @returns {object}
	 */
	accessor: function(object, key, def) {
		if (this._isaccessor(def)) {
			return Object.defineProperty(object, key, {
				enumerable: true,
				configurable: true,
				get: def.getter || this._NOGETTER,
				set: def.setter || this._NOSETTER
			});
		} else {
			throw new TypeError('Expected getter and/or setter method');
		}
	},

	// Private ...................................................................

	/**
	 * Object is getter-setter definition?
	 * @param {object} obj
	 * @returns {boolean}
	 */
	_isaccessor: function(obj) {
		return Object.keys(obj).every(function(key) {
			var is = false;
			switch (key) {
				case 'getter':
				case 'setter':
					is = gui.Type.isFunction(obj[key]);
					break;
			}
			return is;
		});
	},

	/**
	 * Copy single property to function prototype.
	 * @param {object} proto
	 * @param {String} key
	 * @param {object} desc
	 * @returns {object}
	 */
	_accessor: function(proto, key, desc) {
		var val = desc.value;
		if (gui.Type.isObject(val)) {
			if (val.getter || val.setter) {
				if (this._isactive(val)) {
					desc = this._activeaccessor(proto, key, val);
				}
			}
		}
		return desc;
	},

	/**
	 * Object is getter-setter definition?
	 * @param {object} obj
	 * @returns {boolean}
	 */
	_isactive: function(obj) {
		return Object.keys(obj).every(function(key) {
			var is = false;
			switch (key) {
				case 'getter':
				case 'setter':
					is = gui.Type.isFunction(obj[key]);
					break;
			}
			return is;
		});
	},

	/**
	 * Compute property descriptor for getter-setter
	 * type definition and assign it to the prototype.
	 * @param {object} proto
	 * @param {String} key
	 * @param {object} def
	 * @returns {defect}
	 */
	_activeaccessor: function(proto, key, def) {
		var desc;
		['getter', 'setter'].forEach(function(name, set) {
			while (proto && proto[key] && !gui.Type.isDefined(def[name])) {
				proto = Object.getPrototypeOf(proto);
				desc = Object.getOwnPropertyDescriptor(proto, key);
				if (desc) {
					def[name] = desc[set ? 'set' : 'get'];
				}
			}
		});
		return {
			enumerable: true,
			configurable: true,
			get: def.getter || this._NOGETTER,
			set: def.setter || this._NOSETTER
		};
	},

	/**
	 * Bad getter.
	 */
	_NOGETTER: function() {
		throw new Error('Getting a property that has only a setter');
	},

	/**
	 * Bad setter.
	 */
	_NOSETTER: function() {
		throw new Error('Setting a property that has only a getter');
	}
};

/**
 * Bind the "this" keyword for all public methods.
 */
gui.Object.bindall(gui.Property);



/**
 * Checks an object for required methods and properties.
 */
gui.Interface = {

	/**
	 * Check object interface. Throw exception on fail.
	 * @param {object} interfais
	 * @param {object} osbject
	 * @returns {boolean}
	 */
	validate: function(interfais, object) {
		var is = true;
		var expected = interfais.toString();
		var type = gui.Type.of(object);
		switch (type) {
			case 'null':
			case 'string':
			case 'number':
			case 'boolean':
			case 'undefined':
				throw new Error('Expected ' + expected + ', got ' + type + ': ' + object);
			default:
				try {
					var missing = null,
						t = null;
					is = Object.keys(interfais).every(function(name) {
						missing = name;
						t = gui.Type.of(interfais[name]);
						return gui.Type.of(object[name]) === t;
					});
					if (!is) {
						throw new Error('Expected ' + expected + '. A required ' + type + ' "' + missing + '" is missing');
					}
				} catch (exception) {
					throw new Error('Expected ' + expected);
				}
				break;
		}
		return is;
	}
};



/**
 * From Raganwalds "Method Combinators".
 * @see https://github.com/raganwald/method-combinators/blob/master/README-JS.md
 * @see https://github.com/raganwald/homoiconic/blob/master/2012/09/precondition-and-postcondition.md
 */
gui.Combo = {

	/**
	 * Decorate function before.
	 * @param {function} decoration
	 * @returns {function}
	 */
	before: function(decoration) {
		return function(base) {
			return function() {
				decoration.apply(this, arguments);
				return base.apply(this, arguments);
			};
		};
	},

	/**
	 * Decorate function after.
	 * @param {function} decoration
	 * @returns {function}
	 */
	after: function(decoration) {
		return function(base) {
			return function() {
				var result = base.apply(this, arguments);
				decoration.apply(this, arguments);
				return result;
			};
		};
	},

	/**
	 * Decorate function around.
	 * @param {function} decoration
	 * @returns {function}
	 */
	around: function(decoration) {
		var slice = [].slice;
		return function(base) {
			return function() {
				var argv, callback, result, that = this;
				argv = arguments.length >= 1 ? slice.call(arguments, 0) : [];
				result = void 0;
				callback = function() {
					result = base.apply(that, argv);
					return result;
				};
				decoration.apply(this, [callback].concat(argv));
				return result;
			};
		};
	},

	/**
	 * Decorate function provided with support for an otherwise operation.
	 * @param {function} condition
	 */
	provided: function(condition) {
		return function(base, otherwise) {
			return function() {
				if (condition.apply(this, arguments)) {
					return base.apply(this, arguments);
				} else if (otherwise) {
					return otherwise.apply(this, arguments);
				}
			};
		};
	},

	/**
	 * Make function return `this` if otherwise it would return `undefined`.
	 * Variant of the `fluent` combinator which would always returns `this`.
	 * We use this extensively to ensure API consistancy, but we might remove
	 * it for a theoretical performance gain once we have a huge test suite.
	 * @param {function} base
	 * @returns {function}
	 */
	chained: function(base) {
		return function() {
			var result = base.apply(this, arguments);
			return result === undefined ? this : result;
		};
	},

	/**
	 * Memoize return value for function that take zero or more
	 * args, each of which must be amenable to JSON.stringify.
	 * @param {function} base
	 * @returns {function}
	 */
	memoized: function(base) {
		var memos;
		memos = {};
		return function() {
			var key;
			key = JSON.stringify(arguments);
			if (memos.hasOwnProperty(key)) {
				return memos[key];
			} else {
				memos[key] = base.apply(this, arguments);
				return memos[key];
			}
		};
	},

	/**
	 * Simply output the input. Wonder what it could be.
	 * @param {object} subject
	 * @return {object}
	 */
	identity: function(subject) {
		return subject;
	}

};



/**
 * Base constructor for all plugins.
 * TODO: "context" should be required in constructor (sandbox scenario)
 */
gui.Plugin = gui.Class.create(Object.prototype, {

	/**
	 * The {gui.Class} for whom the plugin is plugged into.
	 * @type {gui.Spirit|gui.Plugin|edb.Object|edb.Array}
	 */
	client: null,

	/**
	 * If client is a spirit, this property is it.
	 * TODO: Move to gui-spirits@wunderbyte.com
	 * @type {gui.Spirit}
	 */
	spirit: null,

	/**
	 * Plugins may be designed to work without an associated spirit.
	 * In that case, an external entity might need to define this.
	 * @type {Global} Typically identical to `window`
	 */
	context: null,

	/**
	 * Construct
	 */
	onconstruct: function() {},

	/**
	 * Destruct.
	 */
	ondestruct: function() {},

	/**
	 * Implements DOM2 EventListener (native event handling).
	 * We forwards the event to method 'onevent' IF that has
	 * been specified on the plugin.
	 * TODO: move to $protected area
	 * @param {Event} e
	 */
	handleEvent: function(e) {
		if (gui.Type.isFunction(this.onevent)) {
			this.onevent(e);
		}
	},

	// Privileged ................................................................

	/**
	 * Flag destructed status.
	 * TODO: Move this to {gui.Class}
	 */
	$destructed: false,

	/**
	 * Secret constructor. Called before `onconstruct`.
	 * @type {gui.Spirit|gui.Plugin|edb.Object|edb.Array}
	 */
	$onconstruct: function(client) {
		this.client = client;
		if (gui.hasModule('gui-spirits@wunderbyte.com')) {
			if (client instanceof gui.Spirit) {
				this.spirit = client || null;
				this.context = window; // otherwise web worker scenario, maybe deprecate
			}
		}
		this.onconstruct();
	},

	/**
	 * Secret destructor. Called after `ondestruct`.
	 */
	$ondestruct: function() {}

}, { // Xstatic ................................................................

	/**
	 * Construct only when requested?
	 * @type {boolean}
	 */
	lazy: true

}, { // Static .................................................................

	/**
	 * Lazy plugins are newed up only when needed. We'll create an
	 * accessor for the prefix that will instantiate the plugin and
	 * create a new accesor to return it. To detect if a plugin
	 * has been instantiated, check with {gui.LifePlugin#plugins}.
	 * That's a hashmap that maps plugin prefixes to a boolean status.
	 * @param {gui.Spirit} spirit
	 * @param {String} prefix
	 * @param {function} Plugin
	 */
	$prepare: function(spirit, prefix, Plugin) {
		Object.defineProperty(spirit, prefix, {
			enumerable: true,
			configurable: true,
			get: function() {
				var plugin = new Plugin(this);
				this.life.plugins[prefix] = true;
				gui.Plugin.$assign(spirit, prefix, plugin);
				return plugin;
			}
		});
	},

	/**
	 * Assign plugin to prefix in such a clever way
	 * that it cannot accidentally be overwritten.
	 * TODO: Importantly handle 'force' parameter when overriding a plugin!
	 * @param {gui.Spirit} spirit
	 * @param {String} prefix
	 * @param {gui.Plugin} plugin
	 */
	$assign: function(spirit, prefix, plugin) {
		Object.defineProperty(spirit, prefix, {
			enumerable: true,
			configurable: true,
			get: function() {
				return plugin;
			},
			set: function() {
				throw new Error(
					'The property name "' + prefix + '" is reserved for the ' +
					plugin.$classname + ' and cannot be redefined.' // note about 'force'!
				);
			}
		});
	}

});



/**
 * We used to keep a clientside `super` implementation around, but it
 * was obscuring the stacktraces. The long term plan was to implement
 * super methods using Proxys, but that also turned out to be complex
 * if not impossible. So now we just use the respected `call` pattern.
 * We have however rigged it up so that the Grunt build task will
 * replace the old `this.super` syntax with the new pattern during
 * some compile step. If you're not using the build tool, you would go
 * about this super-businnes like outlined in this implementation...
 * @extends {gui.Plugin}
 * @using {gui.Plugin.prototype} suber
 */
gui.SuperPlugin = (function using(suber) {
	return gui.Plugin.extend({
		onconstruct: function() {
			suber.onconstruct.call(this);
			console.error([
				"Note that 'this.super' doesn't really exist. You can either:",
				"1) compile the script serverside using 'grunt-spiritual-build' or",
				"2) use the pattern 'SuperClass.prototype.methodname.apply(this)'",
				'(the Grunt task basically just applies this pattern to the code)'
			].join('\n'));
		}
	});
}(gui.Plugin.prototype));



/**
 * Comment goes here.
 * @extends {gui.Plugin}
 */
gui.TrackerPlugin = gui.Plugin.extend({

	/**
	 * Construction time.
	 * @param {Spirit} spirit
	 */
	onconstruct: function() {
		gui.Plugin.prototype.onconstruct.call(this);
		this._trackedtypes = Object.create(null);
		if (this.spirit) {
			this._sig = gui.$contextid; // TODO: get rid of this
		}
	},

	/**
	 * Cleanup on destruction.
	 */
	ondestruct: function() {
		gui.Plugin.prototype.ondestruct.call(this);
		gui.Object.each(this._trackedtypes, function(type, list) {
			list.slice().forEach(function(checks) {
				this._cleanup(type, checks);
			}, this);
		}, this);
	},

	/**
	 * TODO: Toggle type(s).
	 * @param {object} arg
	 * @returns {gui.Tracker}
	 */
	toggle: function(arg, checks) {
		console.error('TODO: SpiritTracker#toggle');
	},

	/**
	 * Invokes `add` or `remove` according to first argument given.
	 * The remaining arguments are applied to the method we invoke.
	 * @param {boolean} on
	 * @returns {gui.Tracker}
	 */
	shift: function(on /* ...rest */) {
		var rest = gui.Array.from(arguments).slice(1);
		if (on) {
			return this.add.apply(this, rest);
		} else {
			return this.remove.apply(this, rest);
		}
	},

	/**
	 * Shift globally. This may not be applicable to the plugin.
	 * @param {boolean} on
	 * @returns {gui.Tracker}
	 */
	shiftGlobal: function(on /* ...rest */) {
		return this._globalize(function() {
			return this.shift.apply(arguments);
		});
	},

	/**
	 * Contains handlers for type(s)? Note that handlers might
	 * assert criterias other than type in order to be invoked.
	 * @param {object} arg
	 * @returns {boolean}
	 */
	contains: function(arg) {
		return gui.Array.make(arg).every(function(type) {
			return this._trackedtypes[type];
		}, this);
	},

	// Private .....................................................

	/**
	 * Global mode? This doesn't nescessarily makes
	 * sense for all {gui.Tracker} implementations.
	 * @type {boolean}
	 */
	_global: false,

	/**
	 * Bookkeeping types and handlers.
	 * @type {Map<String,Array<object>}
	 */
	_trackedtypes: null,

	/**
	 * @TODO: Get rid of it
	 * @type {String}
	 */
	_sig: null,

	/**
	 * Execute operation in global mode. Note that sometimes it's still
	 * needed to manually flip the '_global' flag back to 'false' in
	 * order to avoid the mode leaking the into repeated (nested) calls.
	 * @param {function} operation
	 * @returns {object}
	 */
	_globalize: function(operation) {
		this._global = true;
		var res = operation.call(this);
		this._global = false;
		return res;
	},

	/**
	 * Can add type of given checks?
	 * @param {String} type
	 * @param {Array<object>} checks
	 * @returns {boolean}
	 */
	_addchecks: function(type, checks) {
		var result = false;
		var list = this._trackedtypes[type];
		if (!list) {
			list = this._trackedtypes[type] = [];
			result = true;
		} else {
			result = !this._haschecks(list, checks);
		}
		if (result && checks) {
			list.push(checks);
		}
		return result;
	},

	/**
	 * Can remove type of given checks? If so, do it now.
	 * @param {String} type
	 * @param {Array<object>} checks
	 * @returns {boolean}
	 */
	_removechecks: function(type, checks) {
		var result = false;
		var list = this._trackedtypes[type];
		if (list) {
			var index = this._checksindex(list, checks);
			if (index > -1) {
				result = true;
				// TODO: this seems to not run when checks is none (undefined)!
				if (gui.Array.remove(list, index) === 0) {
					delete this._trackedtypes[type];
				}
			}
		}
		return result;
	},

	/**
	 * Has list for type AND given checks?
	 * @param {String} type
	 * @param {Array<object>} checks
	 */
	_containschecks: function(type, checks) {
		var result = false;
		var list = this._trackedtypes[type];
		if (list) {
			result = !checks || this._haschecks(list, checks);
		}
		return result;
	},

	/**
	 * Has checks indexed?
	 * @param {Array<Array<object>>} list
	 * @param {Array<object>} checks
	 * @returns {boolean}
	 */
	_haschecks: function(list, checks) {
		var result = !checks || false;
		if (!result) {
			list.every(function(a) {
				if (a.every(function(b, i) {
					return b === checks[i];
				})) {
					result = true;
				}
				return !result;
			});
		}
		return result;
	},

	/**
	 * All checks removed?
	 * @returns {boolean}
	 */
	_hashandlers: function() {
		return Object.keys(this._trackedtypes).length > 0;
	},

	/**
	 * Get index of checks.
	 * @param {Array<Array<object>>} list
	 * @param {Array<object>} checks
	 * @returns {number}
	 */
	_checksindex: function(list, checks) {
		var result = -1;
		list.every(function(a, index) {
			if (a.every(function(b, i) {
				return b === checks[i];
			})) {
				result = index;
			}
			return result === -1;
		});
		return result;
	},

	/**
	 * Isolated for subclass to overwrite.
	 * @param {String} type
	 * @param {Array<object>} checks
	 */
	_cleanup: function(type, checks) {
		if (this._removechecks(type, checks)) {
			// do cleanup here (perhaps overwrite all
			// this to perform _removechecks elsewhere)
		}
	}

});



/**
 * Spirit action.
 * @using {gui.Arguments#confirmed} confirmed
 * @using {gui.Combo#chained} chained
 */
gui.Action = (function using(confirmed, chained) {
	if (gui.hosted) {
 // relay actions from parent frame.

		/*
		 * Under mysterious circumstances, Internet Explorer may evaluate this
		 * callback in a phantom lexical scope where `gui` is undefined, so
		 * we'll check that that `gui` exsists ang ignore the message otherwise.
		 * TODO: If this fails, surely it will fix with a `try-catch` statement.
		 */
		addEventListener('message', function(e) {
			if (window.gui && gui.Type && gui.Type.isString(e.data)) {
				if (e.source === parent) {
					gui.Action.$maybeDescendGlobal(e.data);
				}
			}
		});
	}

	return gui.Class.create(Object.prototype, {

		/**
		 * From who or where the action was dispatched.
		 * @type {Node|gui.Spirit}
		 */
		target: null,

		/**
		 * Action type eg. "save-button-clicked".
		 * @type {String}
		 */
		type: null,

		/**
		 * Optional data of any type.
		 * This might be undefined.
		 * @type {object}
		 */
		data: null,

		/**
		 * Is travelling up or down? Matches "ascend" or "descend".
		 * @type {String}
		 */
		direction: null,

		/**
		 * Traverse iframe boundaries?
		 * @type {boolean}
		 */
		global: false,

		/**
		 * Is action consumed?
		 * TODO: rename 'consumed'
		 * @type {boolean}
		 */
		isConsumed: false,

		/**
		 * Is action cancelled?
		 * TODO: rename 'cancelled'
		 * @type {boolean}
		 */
		isCancelled: false,

		/**
		 * Spirit who (potentially) consumed the action.
		 * @type {gui.Spirit}
		 */
		consumer: null,

		/**
		 * Used when posting actions xdomain. Matches an iframespirit key.
		 * TODO: rename this to something else (now that action has $instanceid).
		 * @type {String}
		 */
		instanceid: null,

		/**
		 * Connstruct from JSON.
		 * @param {object} json
		 */
		onconstruct: function(json) {
			gui.Object.extend(this, json);
		},

		/**
		 * Block further ascend.
		 * @param @optional {gui.Spirit} consumer
		 */
		consume: function(consumer) {
			this.isConsumed = true;
			this.consumer = consumer;
		},

		/**
		 * Consume and cancel the event. Note that it is
		 * up to the dispatcher to honour cancellation.
		 * @param @optional {gui.Spirit} consumer
		 */
		cancel: function(consumer) {
			this.isCancelled = true;
			this.consume(consumer);
		}

	}, {}, { // Static ...........................................................

		DESCEND: 'descend',
		ASCEND: 'ascend',

		/**
		 * Action handler interface.
		 */
		IActionHandler: {
			onaction: function(a) {},
			toString: function() {
				return '[interface ActionHandler]';
			}
		},

		/**
		 * Don't use just yet! (pending WeakMaps)
		 * @param {string|Array<string>} type
		 * @param {object} handler Implements `onaction`
		 * @param @optional {String} sig
		 * @returns {constructor}
		 */
		add: confirmed('node', 'array|string', 'object|function')(
			chained(function(elm, type, handler) {
				this._listen(true, elm, type, handler, false);
			})),

		/**
		 * Don't use just yet! (pending WeakMaps)
		 * @param {string|Array<string>} type
		 * @param {object} handler
		 * @param @optional {String} sig
		 * @returns {constructor}
		 */
		remove: confirmed('node', 'array|string', 'object|function')(
			chained(function(node, type, handler) {
				this._listen(false, node, type, handler, false);
			})),

		/**
		 * Don't use just yet! (pending WeakMaps)
		 * @param {string|Array<string>} type
		 * @param {object} handler Implements `onaction`
		 * @returns {constructor}
		 */
		addGlobal: confirmed('node', 'array|string', 'object|function')(
			chained(function(node, type, handler) {
				this._listen(true, node, type, handler, true);
			})),

		/**
		 * Don't use just yet! (pending WeakMaps)
		 * @param {string|Array<string>} type
		 * @param {object} handler
		 * @returns {constructor}
		 */
		removeGlobal: confirmed('node', 'array|string', 'object|function')(
			chained(function(node, type, handler) {
				this._listen(false, node, type, handler, true);
			})),

		/**
		 *
		 */
		dispatch: function(target, type, data) {
			return this.ascend(target, type, data);
		},

		/**
		 *
		 */
		ascend: function(target, type, data) {
			return this._dispatch(target, type, data, gui.Action.ASCEND, false);
		},

		/**
		 *
		 */
		descend: function(target, type, data) {
			return this._dispatch(target, type, data, gui.Action.DESCEND, false);
		},

		/**
		 *
		 */
		dispatchGlobal: function(target, type, data) {
			return this.ascendGlobal(target, type, data);
		},

		/**
		 *
		 */
		ascendGlobal: function(target, type, data) {
			return this._dispatch(target, type, data, gui.Action.ASCEND, true);
		},

		/**
		 *
		 */
		descendGlobal: function(target, type, data) {
			return this._dispatch(target, type, data, gui.Action.DESCEND, true);
		},

		/**
		 * Encode action to be posted xdomain.
		 * @param {gui.Action} a
		 * @param @optional {String} key Associates dispatching document
		 *				to the hosting iframespirit (ascending action scenario)
		 * @returns {String}
		 */
		stringify: function(a, key) {
			var prefix = 'spiritual-action:';
			return prefix + (function() {
				a.target = null;
				a.data = (function(d) {
					if (gui.Type.isComplex(d)) {
						if (gui.Type.isFunction(d.stringify)) {
							d = d.stringify();
						} else {
							try {
								JSON.stringify(d);
							} catch (jsonexception) {
								d = null;
							}
						}
					}
					return d;
				}(a.data));
				a.instanceid = key || null;
				return JSON.stringify(a);
			}());
		},

		/**
		 * Parse string to {gui.Action}.
		 * @param {string} msg
		 * @returns {gui.Action}
		 */
		parse: function(msg) {
			var prefix = 'spiritual-action:';
			if (msg.startsWith(prefix)) {
				return new gui.Action(
					JSON.parse(msg.split(prefix)[1])
				);
			}
			return null;
		},

		// Privileged static .......................................................

		/**
		 * Parse postmessage from parent into descending action in this window?
		 * @param {string} postmessage
		 */
		$maybeDescendGlobal: function(postmessage) {
			var data = postmessage, action, root, handlers;
			if (gui.Type.isString(data) && data.startsWith('spiritual-action:')) {
				action = gui.Action.parse(data);
				if (action.direction === gui.Action.DESCEND) {
					// Hotfix for actions in nospirit scenario
					// TODO: rething this pending WeakMaps...
					if ((handlers = this._globals[action.type])) {
						handlers.slice().forEach(function(handler) {
							handler.onaction(action);
						});
					}
					if (gui.hasModule('gui-spirits@wunderbyte.com')) {
						gui.ready(function onspiritualized() {
							if ((root = gui.get('html'))) {
								root.action.$handleownaction = true;
								root.action.descendGlobal(
									action.type,
									action.data
								);
							}
						});
					}
				}
			}
		},

		// Private static ..........................................................

		/**
		 *
		 */
		_globals: {},

		/**
		 *
		 */
		_locals: {},

		/**
		 *
		 */
		_listen: function(add, node, type, handler, global) {
			if (node.nodeType === Node.DOCUMENT_NODE) {
				var map = global ? this._globals : this._locals;
				var handlers = map[type];
				var ok = gui.Action.IActionHandler;
				if (gui.Interface.validate(ok, handler)) {
					gui.Array.make(type).forEach(function(t) {
						if (add) {
							if (!handlers) {
								handlers = map[type] = [];
							}
							if (handlers.indexOf(handler) === -1) {
								handlers.push(handler);
							}
						} else if (handlers) {
							if (gui.Array.remove(handlers, handler) === 0) {
								delete map[type];
							}
						}
					});
				}
			} else { // elements support pending WeakMap
				throw new TypeError('Document node expected');
			}
		},

		/**
		 * Dispatch action. The dispatching spirit will not `onaction()` its own action.
		 * TODO: Measure performance against https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
		 * TODO: Class-like thing to carry all these scoped methods...
		 * TODO: support custom `gui.Action` as an argument
		 * TODO: common ancestor class for action, broadcast etc?
		 * @param {gui.Spirit|Element} target
		 * @param {String} type
		 * @param @optional {object} data
		 * @param @optional {String} direction
		 * @param @optional {boolean} global
		 * @returns {gui.Action}
		 */
		_dispatch: function dispatch(target, type, data, direction, global) {
			// TODO: encapsulate this
			var action = new gui.Action({
				target: target,
				type: type,
				data: data,
				direction: direction || gui.Action.ASCEND,
				global: global || false
			});

			var crawler = new gui.Crawler(gui.CRAWLER_ACTION);
			crawler.global = action.global || false;
			crawler[action.direction](target, {
				/*
				 * Evaluate action for spirit.
				 * @param {gui.Spirit} spirit
				 */
				handleSpirit: function(spirit) {
					var directive = gui.Crawler.CONTINUE;
					if (spirit.action.contains(type)) {
						spirit.action.$onaction(action);
						if (action.isConsumed) {
							directive = gui.Crawler.STOP;
							action.consumer = spirit;
						}
					}
					return directive;
				},

				/*
				 * Teleport action across domains.
				 * @see {gui.IframeSpirit}
				 * @param {Window} win Remote window
				 * @param {String} uri target origin
				 * @param {String} key Spiritkey of xdomain IframeSpirit (who will relay the action)
				 */
				transcend: function(win, uri, key) {
					var msg = gui.Action.stringify(action, key);
					win.postMessage(msg, '*'); // uri
				}
			});
			return action;
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));



/**
 * Broadcast.
 * @using {gui.Arguments#confirmed}
 * @using {gui.Combo#chained}
 */
gui.Broadcast = (function using(confirmed, chained) {
	/**
	 * Under mysterious circumstances, Internet Explorer may evaluate this
	 * callback in a phantom lexical scope where `gui` is undefined, so
	 * we'll check that that `gui` exsists ang ignore the message otherwise.
	 * TODO: If this fails, surely it will fix with a `try-catch` statement.
	 */
	window.addEventListener('message', function onmessage(e) {
		if (window.gui && gui.Type && gui.Type.isString(e.data)) {
			if (e.data.startsWith('spiritual-broadcast:')) {
				gui.Broadcast.$maybeBroadcastGlobal(e.data);
			}
		}
	});

	return gui.Class.create(Object.prototype, {

		/**
		 * Broadcast target.
		 * @type {gui.Spirit}
		 */
		target: null,

		/**
		 * Broadcast type.
		 * @type {String}
		 */
		type: null,

		/**
		 * Broadcast data.
		 * @type {object}
		 */
		data: null,

		/**
		 * Global broadcast?
		 * @type {boolean}
		 */
		global: false,

		/**
		 * Signature of dispatching context.
		 * Unimportant for global broadcasts.
		 * @type {String}
		 */
		$contextid: null,

		/**
		 * Experimental...
		 * TODO: Still used?
		 * @type {Array<String>}
		 */
		$contextids: null,

		/**
		 * Constructor.
		 * @param {Map<String,object>} defs
		 */
		$onconstruct: function(defs) {
			gui.Object.extend(this, defs);
			this.$contextids = this.$contextids || [];
		}

	}, {}, { // Static ...........................................................

		/**
		 * Broadcast handler interface.
		 */
		IBroadcastHandler: {
			onbroadcast: function(b) {},
			toString: function() {
				return '[interface BroadcastHandler]';
			}
		},

		/**
		 * @type {gui.Spirit}
		 */
		$target: null,

		/**
		 * TODO: Ths can be deprecated now(?)
		 * Tracking global handlers (mapping broadcast types to list of handlers).
		 * @type {Map<String,<Array<object>>}
		 */
		_globals: Object.create(null),

		/**
		 * TODO: Ths can be deprecated now!
		 * Tracking local handlers (mapping gui.$contextids
		 * to broadcast types to list of handlers).
		 * @type {Map<String,Map<String,Array<object>>>}
		 */
		_locals: Object.create(null),

		/**
		 * mapcribe handler to message.
		 * @param {object} message String or array of strings
		 * @param {object} handler Implements `onbroadcast`
		 * @param @optional {String} sig
		 * @returns {function}
		 */
		add: chained(function(message, handler, sig) {
			this._add(message, handler, sig || gui.$contextid);
		}),

		/**
		 * Unmapcribe handler from broadcast.
		 * @param {object} message String or array of strings
		 * @param {object} handler
		 * @param @optional {String} sig
		 * @returns {function}
		 */
		remove: chained(function(message, handler, sig) {
			this._remove(message, handler, sig || gui.$contextid);
		}),

		/**
		 * mapcribe handler to message globally.
		 * @param {object} message String or array of strings
		 * @param {object} handler Implements `onbroadcast`
		 * @returns {function}
		 */
		addGlobal: chained(function(message, handler) {
			this._add(message, handler);
		}),

		/**
		 * Unmapcribe handler from global broadcast.
		 * @param {object} message String or array of strings
		 * @param {object} handler
		 * @returns {function}
		 */
		removeGlobal: chained(function(message, handler) {
			this._remove(message, handler);
		}),

		/**
		 * Publish broadcast in specific window scope (defaults to this window)
		 * TODO: queue for incoming dispatch (finish current message first).
		 * @param {Spirit} target
		 * @param {String} type
		 * @param {object} data
		 * @param {String} contextid
		 * @returns {gui.Broadcast}
		 */
		dispatch: function(type, data) {
			if (gui.Type.isString(type)) {
				return this._dispatch({
					type: type,
					data: data,
					global: false
				});
			} else {
				console.error('The "target" argument (the first argument) of gui.Broadcast.dispatch is deprecated');
				this.dispatch(arguments[1], arguments[2]);
			}
		},

		/**
		 * Dispatch broadcast in global scope (all windows).
		 * TODO: queue for incoming dispatch (finish current first).
		 * TODO: Handle remote domain iframes ;)
		 * @param {Spirit} target
		 * @param {String} type
		 * @param {object} data
		 * @returns {gui.Broadcast}
		 */
		dispatchGlobal: function(type, data) {
			if (gui.Type.isString(type)) {
				return this._dispatch({
					type: type,
					data: data,
					global: true,
					$contextid: gui.$contextid
				});
			} else {
				console.error('The "target" argument (the first argument) of gui.Broadcast.dispatchGlobal is deprecated');
				return this.dispatchGlobal(arguments[1], arguments[2]);
			}
		},

		/**
		 * Encode broadcast to be posted xdomain.
		 * @param {gui.Broacast} b
		 * @returns {String}
		 */
		stringify: function(b) {
			var prefix = 'spiritual-broadcast:';
			return prefix + (function() {
				b.target = null;
				b.data = (function(d) {
					if (gui.Type.isComplex(d)) {
						if (gui.Type.isFunction(d.stringify)) {
							d = d.stringify();
						} else {
							try {
								JSON.stringify(d); // @TODO: think mcfly - how come not d = JSON.stringify????
							} catch (jsonexception) {
								d = null;
							}
						}
					}
					return d;
				}(b.data));
				return JSON.stringify(b);
			}());
		},

		/**
		 * Decode broadcast posted from xdomain and return a broadcast-like object.
		 * @param {String} msg
		 * @returns {object}
		 */
		parse: function(msg) {
			var prefix = 'spiritual-broadcast:';
			if (msg.startsWith(prefix)) {
				return JSON.parse(msg.split(prefix)[1]);
			}
		},

		// Privileged static .......................................................

		/**
		 * Parse postmessage into broadcast in this window?
		 * Broadcasts propagate over-agressively, so perhaps
		 * the broadcast has already bypassed this context.
		 * @param {string} postmessage
		 */
		$maybeBroadcastGlobal: function(postmessage) {
			var b = gui.Broadcast.parse(postmessage);
			if (b.$contextids.indexOf(gui.$contextid) === -1) {
				gui.Broadcast._dispatch(b);
			}
		},

		// Private .................................................................

		/**
		 * Subscribe handler to message(s).
		 * @param {Array<string>|string} type
		 * @param {object|function} handler Implements `onbroadcast`
		 * @param @optional {String} sig
		 */
		_add: confirmed('array|string', 'object|function', '(string)')(
			function(type, handler, sig) {
				// var interfais = gui.Broadcast.IBroadcastHandler;
				// if (true || gui.Interface.validate(interfais, handler)) {
				if (gui.Type.isArray(type)) {
					type.forEach(function(t) {
						this._add(t, handler, sig);
					}, this);
				} else {
					var map;
					if (sig) {
						map = this._locals[sig];
						if (!map) {
							map = this._locals[sig] = Object.create(null);
						}
					} else {
						map = this._globals;
					}
					if (!map[type]) {
						map[type] = [];
					}
					var array = map[type];
					if (array.indexOf(handler) === -1) {
						array.push(handler);
					}
				}
				// }
			}
		),

		/**
		 * Hello.
		 * @param {object} message String or array of strings
		 * @param {object} handler
		 * @param @optional {String} sig
		 */
		_remove: function(message, handler, sig) {
			// var interfais = gui.Broadcast.IBroadcastHandler;
			// if (true || gui.Interface.validate(interfais, handler)) {
			if (gui.Type.isArray(message)) {
				message.forEach(function(msg) {
					this._remove(msg, handler, sig);
				}, this);
			} else {
				var index, array = (function(locals, globals) {
						if (sig) {
							if (locals[sig]) {
								return locals[sig][message];
							}
						} else {
							return globals[message];
						}
					}(this._locals, this._globals));
				if (array) {
					index = array.indexOf(handler);
					if (index > -1) {
						gui.Array.remove(array, index);
					}
				}
			}
			// }
		},

		/**
		 * Dispatch broadcast.
		 * @param {gui.Broadcast|Map<String,object>} b
		 */
		_dispatch: function(b) {
			var map = b.global ? this._globals : this._locals[gui.$contextid];
			if (gui.hasModule('gui-spirits@wunderbyte.com')) {
				if (!gui.spiritualized) {
					if (b.type !== gui.BROADCAST_WILL_SPIRITUALIZE) {
						// TODO: cache broadcast until spiritualized?
					}
				}
			}
			if (this.$target) {
				if (!b.global) {
					b.target = this.$target;
				}
				this.$target = null;
			}
			if (b instanceof gui.Broadcast === false) {
				b = new gui.Broadcast(b);
			}
			if (map) {
				var handlers = map[b.type];
				if (handlers) {
					handlers.slice().forEach(function(handler) {
						handler.onbroadcast(b);
					});
				}
			}
			if (b.global) {
				this._propagate(b);
			}
			return b;
		},

		/**
		 * Propagate broadcast xframe.
		 *
		 * 1. Propagate descending
		 * 2. Propagate ascending
		 * TODO: Don't post to universal domain "*"
		 * @param {gui.Broadcast} b
		 */
		_propagate: function(b) {
			var postmessage = (function stamp() {
				b.$contextids.push(gui.$contextid);
				return gui.Broadcast.stringify(b);
			}());
			this._propagateDown(postmessage);
			this._propagateUp(postmessage, b.type);
		},

		/**
		 * Propagate broadcast to sub documents.
		 * TODO: implement something similar to {gui.IframeSpirit._postbox}
		 * but without expecting the bundle gui-spirits@wunderbyte.com
		 * (it would in that case involve onload instead of onspiritualized)
		 * @param {string} postmessage
		 */
		_propagateDown: function(postmessage) {
			var iframes = document.querySelectorAll('iframe');
			Array.forEach(iframes, function(iframe) {
				iframe.contentWindow.postMessage(postmessage, '*');
			});
		},

		/**
		 * Propagate broadcast to parent document.
		 * @param {string} postmessage
		 */
		_propagateUp: function(postmessage) {
			if (window !== top) {
				parent.postMessage(postmessage, '*');
			}
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));



/**
 * Ticks are used for timed events.
 * TODO: Tick.push
 * @using {gui.Arguments#confirmed}
 */
(function using(confirmed) {
	/**
	 * @param {String} type
	 */
	gui.Tick = function(type) {
		this.type = type;
	};

	gui.Tick.prototype = {

		/**
		 * Tick type.
		 * @type {String}
		 */
		type: null,

		/**
		 * Identification.
		 * @returns {String}
		 */
		toString: function() {
			return '[object gui.Tick]';
		}
	};

	// Static ....................................................................

	gui.Object.extend(gui.Tick, {

		/**
		 * Identification.
		 * @returns {String}
		 */
		toString: function() {
			return '[function gui.Tick]';
		},

		/**
		 * Add handler for tick.
		 * The `confirmed` stuff would cause a *random* error that might be
		 * related to minification, so we've simply disabled it for now :/
		 * UPDATE: We now believe that said random error is caused somehow
		 * by use of the `postMessage` trick to emulate `setImmediate`,
		 * because Angular uses this trick for rendering and the error only
		 * occurs while Angular is rendering (`setTimeout` will fix it)...
		 * TODO: Sig argument is deprecated...
		 * @param {object} type String or array of strings
		 * @param {object} handler
		 * @param @optional {boolean} one Remove handler after on tick of this type?
		 * @returns {function}
		 */
		add: function(type, handler, sig) { // confirmed("string|array", "object|function", "(string)")(
			return this._add(type, handler, false, sig || gui.$contextid);
		},

		/**
		 * Remove handler for tick.
		 * @param {object} type String or array of strings
		 * @param {object} handler
		 * @returns {function}
		 */
		remove: function(type, handler, sig) { // confirmed("string|array", "object|function", "(string)")(
			return this._remove(type, handler, sig || gui.$contextid);
		},

		/**
		 * Add auto-removing handler for tick.
		 * @param {object} type String or array of strings
		 * @param {object} handler
		 * @returns {function}
		 */
		one: function(type, handler, sig) { // confirmed("string|array", "object|function", "(string)")(
			return this._add(type, handler, true, sig || gui.$contextid);
		},

		/**
		 * Schedule action for next available execution stack.
		 * @TODO: deprecate setImmedate polyfix and do the fix here
		 * @param {function} action
		 * @param @optional {object} thisp
		 */
		next: function(action, thisp) {
			setImmediate(function() {
				action.call(thisp);
			});
		},

		/**
		 * Schedule action for next animation frame.
		 * @TODO: deprecate requestAnimationFrame polyfix and do the fix here
		 * @param {function} action
		 * @param @optional {object} thisp
		 * returns {number}
		 */
		nextFrame: function(action, thisp) {
			return requestAnimationFrame(function(timestamp) {
				action.call(thisp, timestamp);
			});
		},

		/**
		 * Cancel animation frame by index.
		 * @param {number} n
		 */
		cancelFrame: function(n) {
			cancelAnimationFrame(n);
		},

		/**
		 * Set a timeout.
		 * @param {function} action
		 * @param @optional {number} time Default to something like 4ms
		 * @param @optional {object} thisp
		 * returns {number}
		 */
		time: confirmed('function', '(number)', '(function|object)')(
			function(action, time, thisp) {
				return setTimeout(function() {
					action.call(thisp);
				}, time || 0);
			}
		),

		/**
		 * Cancel timeout by index.
		 * @param {number} n
		 */
		cancelTime: function(n) {
			clearTimeout(n);
		},

		/**
		 * Start repeated tick of given type.
		 * @param {string} type Tick type
		 * @param {ITickHandler} handler
		 * @param {number} time Time in milliseconds
		 * @returns {function}
		 */
		start: confirmed('string', 'number')(
			function(type, time) {
				var map = this._intervals;
				if (!map[type]) {
					var tick = new gui.Tick(type);
					map[type] = setInterval(function() {
						this._doit(tick);
					}.bind(this), time);
				}
			}
		),

		/**
		 * Stop repeated tick of given type.
		 * @param {String} type Tick type
		 * @returns {function}
		 */
		stop: confirmed('string')(
			function(type) {
				var map = this._intervals;
				var id = map[type];
				if (id) {
					clearInterval(id);
					delete map[type];
				}
			}
		),

		/**
		 * Dispatch tick now or in specified time. Omit time to
		 * dispatch now. Zero resolves to next available thread.
		 * @param {String} type
		 * @param @optional {number} time
		 * @returns {gui.Tick}
		 */
		dispatch: function(type, time, sig) {
			return this._dispatch(type, time, sig || gui.$contextid);
		},

		// Private static ..........................................................

		/**
		 * Comment goes here.
		 */
		_intervals: Object.create(null),

		/**
		 * Return of the comment.
		 */
		_tempname: {
			types: Object.create(null),
			handlers: Object.create(null)
		},

		/**
		 * Hello. There seems to be a *random* error where the handler get's passed
		 * along to this method wrapped in an array. It would happen *sometimes*
		 * in the test, but changing a `console.error` to `throw new Error` would
		 * make it go away (see "gui.Arguments.js"). This would however only fix
		 * the *tests*: We know of at least one production scenario where the
		 * bug persists, so we'll just unwrap the hander from the array manually.
		 * The bug could be related to minification, but we will probably never know.
		 */
		_add: function(type, handler, one, sig) {
			if (Array.isArray(handler)) {
				handler = handler[0]; // hacky workaround :/
			}
			if (gui.Type.isArray(type)) {
				type.forEach(function(t) {
					this._add(t, handler, one, sig);
				}, this);
			} else {
				var list, index;
				var map = this._tempname;
				list = map.handlers[type];
				if (!list) {
					list = map.handlers[type] = [];
				}
				index = list.indexOf(handler);
				if (index === -1) {
					index = list.push(handler) - 1;
				}
				/*
				 * @TODO
				 * Adding a property to an array will
				 * make it slower in Firefox. Fit it!
				 */
				if (one) {
					list._one = list._one || Object.create(null);
					list._one[index] = true;
				}
			}
			return this;
		},

		/**
		 * Hello.
		 */
		_remove: function(type, handler, sig) {
			if (gui.Type.isArray(type)) {
				type.forEach(function(t) {
					this._remove(t, handler, sig);
				}, this);
			} else {
				if (Array.isArray(handler)) { // The weird bug just happened!
					handler = handler[0]; // hacky workaround :/
				}
				var map = this._tempname;
				var list = map.handlers[type];
				if (list) {
					var index = list.indexOf(handler);
					if (index > -1) {
						gui.Array.remove(list, index);
						if (list.length === 0) {
							delete map.handlers[type];
						}
					}
				}
			}
			return this;
		},

		/**
		 * Dispatch tick sooner or later.
		 * @param {String} type
		 * @param @optional {number} time
		 * @param @optional {String} sig
		 */
		_dispatch: function(type, time, sig) {
			var map = this._tempname;
			var types = map.types;
			var tick = new gui.Tick(type);
			time = time || 0;
			if (!types[type]) {
				types[type] = true;
				var that = this;
				var id = null; // eslint-disable-line no-unused-vars
				var doit = function() {
					delete types[type];
					that._doit(tick);
				};
				if (!time) {
					id = setImmediate(doit);
				} else if (time > 0) {
					id = setTimeout(doit, time);
				} else {
					doit();
				}
			}
			return tick; // TODO: shouldn't it return the `id` so that it can cancel?
		},

		/**
		 * Tick now.
		 * @param {gui.Tick} tick
		 */
		_doit: function(tick) {
			var list = this._tempname.handlers[tick.type];
			if (list) {
				var mishandlers = [];
				list.filter(function(handler) {
					if (handler.$destructed) {
						mishandlers.push(handler);
						return false;
					}
					return true;
				}).forEach(function(handler) {
					handler.ontick(tick);
				});
				mishandlers.forEach(function(handler) { // symptom treatment!
					gui.Array.remove(list, list.indexOf(handler));
				});
			}
		}

	});
}(gui.Arguments.confirmed));



/**
 * Document lifecycle manager.
 * TODO: Support custom implementation?
 */
gui.Document = (function() {
	/**
	 * Dispatch global action to hosting document (if any).
	 * This will most likely get picked up by the containing
	 * {gui.IframeSpirit} so that it knows what's going on.
	 * @param {string} type
	 * @param @optional {object} data
	 */
	function doaction(type, data) {
		if (gui.hosted) {
			gui.Action.ascendGlobal(document, type, data);
		}
	}

	/**
	 * Dispatch one or more (local) broadcasts.
	 */
	function dobrodcast(/* ...types */) {
		gui.Array.make(arguments).forEach(function(type) {
			gui.Broadcast.dispatch(type);
		});
	}

	/**
	 * If the window width is zero, we assume that this iframe was
	 * either just created (and there is this bug in WebKit) or that
	 * the iframe is `display:none`. This would need to be accounted
	 * for in *all* spirits that measure width, height, display state
	 * and so on, so we will simply not run until iframe gets shown.
	 * Note that this may delay spiritualization to happen *async*
	 * sometimes after the `DOMContentLoaded` event has fired.
	 */
	function islayoutready() {
		return window.innerWidth > 0;
	}

	/*
	 * Create the class already.
	 */
	return gui.Class.create(Object.prototype, {

		/**
		 * Setup loads of event listeners.
		 */
		onconstruct: function() {
			var that = this, add = function(target, events, capture) {
					events.split(' ').forEach(function(type) {
						target.addEventListener(type, that, capture);
					});
				};
			add(document, 'DOMContentLoaded visibilitychange');
			add(document, 'click mousedown mouseup', true);
			add(window, 'load hashchange resize');
			if (!gui.hosted) {
				add(window, 'orientationchange');
			}
			if (!(window.chrome && chrome.app && chrome.runtime)) {
				add(window, 'unload');
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		handleEvent: function(e) {
			switch (e.type) {
				case 'click':
				case 'mousedown':
				case 'mouseup':
					this._onmouseevent(e);
					break;
				case 'orientationchange':
					this._onrotate();
					break;
				case 'resize':
					this._onresize();
					break;
				case 'DOMContentLoaded':
					this._ondom();
					break;
				case 'load':
					this._onload();
					break;
				case 'unload':
					this._onunload();
					break;
				case 'hashchange':
					this._onhashchange();
					break;
				case 'visibilitychange':
					this._onvisibilitychange(!document.hidden);
					break;
			}
		},

		// Private .................................................................

		/**
		 * Window loaded?
		 * @type {boolean}
		 */
		_loaded: false,

		/**
		 * DOMContentLoaded?
		 * @type {boolean}
		 */
		_domloaded: true,

		/**
		 * Resize-end timeout id.
		 * @type {number}
		 */
		_timeout: -1,

		/**
		 * TODO: broadcast from here to trigger the {gui.Guide}
		 *
		 * 1. Name all namespace members (toString methods and such)
		 * 2. Resolve META tags that may configure namespaces properties
		 * 3. Dispatch `DOMContentLoaded` action to hosting document
		 * 4. Broadcast 'DOMContentLoaded' status in two discrete steps
		 */
		_ondom: function() {
			this._domloaded = true;
			gui.$initialize();
			this._configure(gui.namespaces());
			(function onlayoutready() {
				if (islayoutready()) {
					doaction(gui.ACTION_DOC_ONDOMCONTENT, location.href);
					dobrodcast(
						gui.BROADCAST_TODOM, // intercepted in gui.extensions.js (if bundled)
						gui.BROADCAST_ONDOM // at this point we are finally ready
					);
				} else {
					setTimeout(onlayoutready); // wait for this iframe to be displayed...
				}
			}());
		},

		/**
		 * Dispatch `load` event to hosting document.
		 */
		_onload: function() {
			this._loaded = true;
			dobrodcast(gui.BROADCAST_TOLOAD, gui.BROADCAST_ONLOAD);
			doaction(gui.ACTION_DOC_ONLOAD, location.href);
		},

		/**
		 * Dispatch `unload` event to hosting document.
		 * TODO: https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching
		 */
		_onunload: function() {
			this._unloaded = true;
			gui.$shutdown();
			dobrodcast(gui.BROADCAST_TOUNLOAD, gui.BROADCAST_ONUNLOAD);
			doaction(gui.ACTION_DOC_UNLOAD, location.href);
		},

		/**
		 * Dispatch `hashchange` status to hosting document.
		 */
		_onhashchange: function() {
			doaction(gui.ACTION_DOC_ONHASH, location.hash);
		},

		/**
		 * Dispatch global broadcasts on selected mouse events
		 * (close that menu when the user clicks that iframe).
		 * @param {Event} e
		 */
		_onmouseevent: function(e) {
			gui.broadcastGlobal(({
				click: gui.BROADCAST_MOUSECLICK,
				mousedown: gui.BROADCAST_MOUSEDOWN,
				mouseup: gui.BROADCAST_MOUSEUP
			})[e.type], gui.$contextid);
		},

		/**
		 * Intensive resize procedures should subscribe
		 * to the resize-end message as broadcasted here.
		 */
		_onresize: function() {
			clearTimeout(this._timeout);
			this._timeout = setTimeout(function() {
				gui.Broadcast.dispatch(gui.BROADCAST_RESIZE_END);
			}, gui.TIMEOUT_RESIZE_END);
		},

		/**
		 * Device orientation changed.
		 * TODO: Make this local to all iframes (not just topframe)
		 * TODO: gui.Device of some sorts?
		 */
		_onrotate: function() {
			if (!gui.hosted) {
				gui.orientation = window.innerWidth > window.innerHeight ? 1 : 0;
				gui.broadcastGlobal(gui.BROADCAST_ORIENTATIONCHANGE, gui.orientation);
			}
		},

		/**
		 * Reflex all whenever the user comes back from other tab excursions.
		 * TODO: Figure out if nested iframes can even see this stuff and
		 * create something like `reflexGlobal` in case they really can't.
		 * @param {boolean} hidden
		 */
		_onvisibilitychange: function(visible) {
			var root = gui.get(document.documentElement);
			if (visible && root) {
				root.reflex();
			}
		},

		/**
		 * Resolve metatags that appear to
		 * configure stuff in namespaces.
		 * @param {Array<string>} spaces
		 */
		_configure: function(spaces) {
			var prop, def, metas = document.querySelectorAll('meta[name]');
			Array.forEach(metas, function(meta) {
				prop = meta.getAttribute('name');
				spaces.forEach(function(ns) {
					if (prop.startsWith(ns + '.')) {
						def = gui.Object.lookup(prop);
						if (gui.Type.isDefined(def)) {
							gui.Object.assert(prop,
								gui.Type.cast(meta.getAttribute('content'))
							);
						} else {
							console.error('No definition for "' + prop + '"');
						}
					}
				});
			});
		}

	});
}());

/**
 * Here we go.
 */
gui.document = new gui.Document();



/**
 * Module base. Unknown to many, new
 * modules will be a subclass of this.
 */
gui.Module = gui.Class.create(Object.prototype, {

	/**
	 * Called immediately. Other modules may not be parsed yet.
	 * TODO: Migrate to 'onrun' in the long run.
	 * @return {Window} context
	 */
	oncontextinitialize: function() {},

	/**
	 * Called immediately. Other modules may not be parsed yet.
	 * @type {function}
	 */
	onrun: function() {},

	/**
	 * Called on DOMContentLoaded.
	 * @type {function}
	 */
	ondom: function() {},

	/**
	 * Called on load.
	 * @type {function}
	 */
	onload: function() {},

	/**
	 * Called on unload.
	 * @type {function}
	 */
	onunload: function() {},

	// Privileged ................................................................

	/**
	 * Module identity token.
	 * @type {string}
	 */
	$modname: null,

	/**
	 * Secret constructor.
	 * @param {string} name
	 */
	$onconstruct: function(name) {
		this.$modname = name;
		this.toString = function() {
			return '[module ' + name + ']';
		};
	}

}, {}, { // Static .............................................................

	/**
	 * Register module, although please use 'gui.module()' to do so.
	 * TODO: deprecate oncontextinitialize!
	 * @param {gui.Module} module
	 * @returns {gui.Module}
	 */
	$register: function(module) {
		var name = module.$modname;
		if (!this.$hasModule(name)) {
			this._modules.push(module);
			if (gui.Type.isFunction(module.oncontextinitialize)) {
				module.oncontextinitialize(window);
			}
			if (gui.Type.isFunction(module.onrun)) {
				module.onrun();
			}
		} else {
			throw new Error(name + ' loaded twice?');
		}
		return module;
	},

	/**
	 * Module registered by name?
	 * @param {string} name
	 * @returns {boolean}
	 */
	$hasModule: function(name) {
		return this._modules.some(function(module) {
			return module.$modname === name;
		});
	},

	/**
	 * Collecting modules.
	 * @type {Array<gui.Module>}
	 */
	_modules: []

});

/**
 * Hookup modules to document lifecycle.
 * @param {Array<gui.Module>} modules
 */
(function hookup(modules) {
	gui.Object.each({
		ondom: gui.BROADCAST_TODOM,
		onload: gui.BROADCAST_TOLOAD,
		onunload: gui.BROADCAST_TOUNLOAD
	}, function associate(action, broadcast) {
		gui.Broadcast.add(broadcast, {
			onbroadcast: function() {
				modules.forEach(function(module) {
					module[action]();
				});
			}
		});
	});
}(gui.Module._modules));



/**
 * Where spirits go to be garbage collected. Not for public
 * consumption: Please dispose of spirits via the {gui.Guide}.
 * TODO: Don't assume that we are collecting spirits primarily
 * @see {gui.Guide#materialize}
 * @see {gui.Guide#materializeOne}
 * @see {gui.Guide#materializeSub}
 */
gui.Garbage = {

	/**
	 * To identify our exception in a try-catch scenario, look for
	 * this string in the *beginning* of the exception message
	 * since sometimes we might append additional information.
	 * @type {string}
	 */
	DENIAL: 'Attempt to handle destructed object',

	/**
	 * Identification.
	 * @returns {string}
	 */
	toString: function() {
		return '[object gui.Garbage]';
	},

	/**
	 * Nukefication moved to next tick. This will minimize chaos,
	 * but does imply that for the duration of this tick, methods
	 * might be called on spirits that don't exist in the DOM and
	 * this should technically not be possible :/
	 */
	ontick: function(t) {
		if (t.type === 'gui-tick-garbage-empty') {
			if (window.gui) { // hotfix IE window unloaded scenario (TODO: still?)
				this._nukemnow();
			}
		}
	},

	// Privileged ................................................................

	/**
	 * Schedule to nuke the spirit.
	 * TODO: Make this work for stuff that ain't exactly spirits
	 * @param {gui.Spirit} spirit
	 */
	$collect: function(spirit) {
		if (gui.unloading) {
			this.$nuke(spirit);
		} else {
			this._spirits.push(spirit);
			gui.Tick.dispatch('gui-tick-garbage-empty');
		}
	},

	/**
	 * Nuke that spirit.
	 *
	 * - Nuke lazy plugins so that we don't accidentally instantiate them
	 * - Destruct remaining plugins, saving the {gui.Life} plugin for last
	 * - Replace all properties with an accessor to throw an exception
	 *
	 * @param {gui.Spirit} spirit
	 */
	$nuke: function(spirit) {
		var prefixes = [],
			plugins = spirit.life.plugins;
		gui.Object.each(plugins, function(prefix, instantiated) {
			if (instantiated) {
				if (prefix !== 'life') {
					prefixes.push(prefix);
				}
			} else {
				Object.defineProperty(spirit, prefix, {
					enumerable: true,
					configurable: true,
					get: function() {},
					set: function() {}
				});
			}
		});
		plugins = prefixes.map(function(key) {
			return spirit[key];
		}, this);
		if (!gui.unloading) {
			this.$nukeplugins(plugins, false);
			gui.Tick.next(function() { // TODO: organize this at some point...
				this.$nukeplugins(plugins, true);
				this.$nukeelement(spirit);
				this.$nukeallofit(spirit);
			}, this);
		}
	},

	/**
	 * Nuke plugins in three steps to minimize access violations.
	 * @param {gui.Spirit} spirit
	 * @param {Array<String>} prefixes
	 * @param {boolean} nuke
	 */
	$nukeplugins: function(plugins, nuke) {
		if (nuke) {
			plugins.forEach(function(plugin) {
				this.$nukeallofit(plugin);
			}, this);
		} else {
			plugins.map(function(plugin) {
				plugin.ondestruct();
				return plugin;
			}).forEach(function(plugin) {
				plugin.$ondestruct();
			});
		}
	},

	/**
	 * Unreference spirit associated element.
	 * Explorer may deny permission in frames.
	 * @TODO: Is IE exception still relevant?
	 */
	$nukeelement: function(spirit) {
		try {
			spirit.element.spirit = null;
		} catch (denied) {}
	},

	/**
	 * Replace own properties with an accessor to throw an exception.
	 * In 'gui.debug' mode we replace all props, not just own props,
	 * so that we may fail fast on attempt to handle destructed spirit.
	 * @TODO: keep track of non-enumerables and nuke those as well :/
	 * @param {object} thing
	 */
	$nukeallofit: function(thing) {
		var nativeprops = Object.prototype;
		if (!gui.unloading && !thing.$destructed) {
			thing.$destructed = true;
			for (var prop in thing) {
				if (thing.hasOwnProperty(prop) || gui.debug) {
					if (nativeprops[prop] === undefined) {
						if (prop !== '$destructed') {
							var desc = Object.getOwnPropertyDescriptor(thing, prop);
							if (!desc || desc.configurable) {
								if (gui.debug) {
									this._definePropertyItentified(thing, prop);
								} else {
									Object.defineProperty(thing, prop, this.DENIED);
								}
							}
						}
					}
				}
			}
		}
	},

	/**
	 * User to access property post destruction,
	 * report that the spirit was terminated.
	 */
	DENIED: {
		enumerable: true,
		configurable: true,
		get: function() {
			gui.Garbage.DENY();
		},
		set: function() {
			gui.Garbage.DENY();
		}
	},

	/**
	 * Obscure mechanism to include the whole stacktrace in the error message
	 * because some kind of Selenium WebDriver can't print stack traces...
	 * @see https://gist.github.com/jay3sh/1158940
	 * @param @optional {string} message
	 */
	DENY: function(message) {
		var stack, e = new Error(
			gui.Garbage.DENIAL + (message ? ': ' + message : '')
		);
		if (!gui.Client.isExplorer && (stack = e.stack)) {
			if (gui.Client.isWebKit) {
				stack = stack.replace(/^[^\(]+?[\n$]/gm, '')
				.replace(/^\s+at\s+/gm, '')
				.replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
				.split('\n');
			} else {
				stack = stack.split('\n');
			}
			stack.shift();
			stack.shift(); // @TODO: shift one more now?
			console.warn(e.message + '\n' + stack);
		} else {
			console.warn(e.message);
		}
	},

	// Private ...................................................................

	/**
	 * Spirits scheduled for destruction.
	 * @type {Array<gui.Spirit>}
	 */
	_spirits: [],

	/**
	 * In debug mode, throw a more qualified "attempt to handle destructed spirit"
	 * @param {object} thing
	 * @param {string} prop
	 */
	_definePropertyItentified: function(thing, prop) {
		Object.defineProperty(thing, prop, {
			enumerable: true,
			configurable: true,
			get: function() {
				gui.Garbage.DENY(thing);
			},
			set: function() {
				gui.Garbage.DENY(thing);
			}
		});
	},

	/**
	 * Nuke spirits now.
	 */
	_nukemnow: function() {
		var spirit, spirits = this._spirits.slice();
		if (window.gui) { // hotfix IE window unloaded scenario...
			while ((spirit = spirits.shift())) {
				this.$nuke(spirit);
			}
			this._spirits = [];
		}
	}

};

gui.Tick.add('gui-tick-garbage-empty', gui.Garbage);



/**
 * Resolve an URL string relative to a document.
 * TODO: Read https://gist.github.com/jlong/2428561
 * @param {Document} doc TODO: Move to second arg!
 * @param {String} href
 */
gui.URL = function(doc, href) {
	if (doc && doc.nodeType === Node.DOCUMENT_NODE) {
		var val, link = gui.URL._createLink(doc, href);
		Object.keys(gui.URL.prototype).forEach(function(key) { // TODO: exclude toString somehow...
			if (gui.Type.isString((val = link[key]))) {
				if (key === 'pathname' && !val.startsWith('/')) {
					val = '/' + val; // http://stackoverflow.com/questions/956233/javascript-pathname-ie-quirk
				}
				this[key] = val;
			}
		}, this);
		this.id = this.hash ? this.hash.substring(1) : null;
		this.external = this.href.split('#')[0] !== doc.URL.split('#')[0];
	} else {
		throw new TypeError('Document expected');
	}
};

gui.URL.prototype = {
	hash: null, // #test
	host: null, // www.example.com:80
	hostname: null, // www.example.com
	href: null, // http://www.example.com:80/search?q=devmo#test
	pathname: null, // search
	port: null, // 80
	protocol: null, // http:
	search: null, // ?q=devmo
	id: null, // test,
	external: false, // external relative to the *document*, not the server host!!! (rename "outbound" to clear this up?)
	toString: function() { // behave somewhat like window.location ....
		return this.href;
	}
};

// Statics ..............................................................................................

/**
 * Convert relative path to absolute path in context of base where base is a document or an absolute path.
 * @see http://stackoverflow.com/questions/14780350/convert-relative-path-to-absolute-using-javascript
 * @param {String|Document} base
 * @param {String} href
 * @returns {String}
 */
gui.URL.absolute = function(base, href) { // return /(^data:)|(^http[s]?:)|(^\/)/.test(inUrl);
	href = href || '';
	if (base.nodeType === Node.DOCUMENT_NODE) {
		return new gui.URL(base, href).href;
	} else if (typeof base === 'string') {
		var stack = base.split('/');
		var parts = href.split('/');
		stack.pop(); // remove current filename (or empty string) (omit if "base" is the current folder without trailing slash)
		parts.forEach(function(part) {
			if (part !== '.') {
				if (part === '..') {
					stack.pop();
				} else {
					stack.push(part);
				}
			}
		});
		return stack.join('/');
	}
};

/**
 * Is URL external to document (as in external host)?
 * @param {String} url
 * @param {Document} doc
 * @returns {boolean}
 */
gui.URL.external = function(src, doc) {
	doc = doc || document;
	var url = new gui.URL(doc, src);
	return url.host !== doc.location.host || url.port !== doc.location.port;
};

/**
 * Extract querystring parameter value from URL.
 * @param {String} url
 * @param {String} name
 * @returns {String} String or null
 */
gui.URL.getParam = function(url, name) {
	name = name.replace(/(\[|\])/g, '\\$1');
	var results = new RegExp('[\\?&]' + name + '=([^&#]*)').exec(url);
	return results === null ? null : results[1];
};

/**
 * Add or remove (unencoded) querystring parameter from URL. If it
 * already exists, we'll replace it's (first ancountered) value.
 * TODO: Something simpler
 * @param {String} url
 * @param {String} name
 * @param {String} value Use null to remove
 * @returns {String} String
 */
gui.URL.setParam = function(url, name, value) {
	var params = [],
		cut, index = -1;
	var path = url.split('#')[0];
	var hash = url.split('#')[1];
	if (path.indexOf('?') > -1) {
		cut = path.split('?');
		path = cut[0];
		params = cut[1].split('&');
		params.every(function(param, i) {
			var x = param.split('=');
			if (x[0] === name) {
				index = i;
				if (value !== null) {
					x[1] = value;
					params[i] = x.join('=');
				}
			}
			return index < 0;
		});
	}
	if (value === null) {
		if (index > -1) {
			params.remove(index, index);
		}
	} else if (index < 0) {
		params[params.length] = [name, value].join('=');
	}
	params = params.length > 0 ? '?' + params.join('&') : '';
	return path + params + (hash ? '#' + hash : '');
};

/**
 * Format URL with hashmap key-values as querystring parameters.
 * @param {String} baseurl
 * param @optional {Map<String,String|number|boolean|Array>} params
 * @returns {String}
 */
gui.URL.parametrize = function(baseurl, params) {
	if (gui.Type.isObject(params)) {
		gui.Object.each(params, function(key, value) {
			baseurl += baseurl.includes('?') ? '&' : '?';
			switch (gui.Type.of(value)) {
				case 'array':
					baseurl += value.map(function(member) {
						return key + '=' + String(member);
					}).join('&');
					break;
				default:
					baseurl += key + '=' + String(value);
					break;
			}
		});
	}
	return baseurl;
};

/**
 * @TODO: fix this
 * @param {Window} win
 * @returns {String}
 */
gui.URL.origin = function(win) {
	var loc = win.location;
	return loc.origin || loc.protocol + '//' + loc.host;
};

/**
 * @param {Document} doc
 * @param @optional {String} href
 */
gui.URL._createLink = function(doc, href) {
	var link = doc.createElement('a');
	link.href = href || '';
	if (gui.Client.isExplorer) { // IE9???
		var uri = gui.URL.parseUri(link.href);
		Object.keys(uri).forEach(function(key) {
			if (!link[key]) {
				link[key] = uri[key]; // this is wrong...
			}
		});
	}
	return link;
};

/**
 * Temp IE hotfix...
 * @see http://blog.stevenlevithan.com/archives/parseuri
 * TODO: https://github.com/websanova/js-url
 * TODO: https://github.com/allmarkedup/purl
 */
gui.URL.parseUri = function(str) {
	var o = gui.URL.parseOptions,
		m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
		uri = {},
		i = 14;
	while (i--) {
		uri[o.key[i]] = m[i] || '';
	}
	uri[o.q.name] = {};
	uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
		if ($1) {
			uri[o.q.name][$1] = $2;
		}
	});
	return uri;
};

/**
 * Temp IE hotfix...
 * TODO: Now that it's not so temp anymore, at least figure out where it came from...
 */
gui.URL.parseOptions = {
	strictMode: true,
	key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
	q: {
		name: 'queryKey',
		parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	},
	parser: {
		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
		loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	}
};



/**
 * Encapsulates a callback for future use.
 * TODO: mimic DOM Futures to some degree.
 * TODO: The future is here, deprecate this
 * @param @optional {function} callback
 * @param @optional {object} thisp
 */
gui.Then = function Then(callback, thisp) {
	if (callback) {
		this.then(callback, thisp);
	}
};

gui.Then.prototype = {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.Then]';
	},

	/**
	 * Setup callback with optional this-pointer.
	 * @param {function} callback
	 * @param @optional {object} pointer
	 */
	then: function(callback, thisp) {
		this._callback = callback || null;
		this._pointer = thisp || null;
		if (this._now) {
			this.now.apply(this, this._arg);
		}
	},

	/**
	 * Callback with optional this-pointer.
	 * @returns {object}
	 * @returns {gui.Then}
	 */
	now: gui.Combo.chained(function() {
		var c = this._callback;
		var p = this._pointer;
		if (c) {
			this.then(null, null);
			c.apply(p, arguments);
		} else {
			this._arg = arguments;
			this._now = true;
		}
	}),

	// Private ...................................................................

	/**
	 * Callback to execute.
	 * @type {function}
	 */
	_callback: null,

	/**
	 * "this" keyword in callback.
	 * @type {object}
	 */
	_pointer: null,

	/**
	 * Execute as soon as callback gets delivered?
	 * @type {boolean}
	 */
	_now: false

};



/**
 * Parsing markup strings to DOM nodes. You might think that this was called a
 * DOMParser, but that's just plain wrong because it doesn't parse DOM elements.
 */
gui.HTMLParser = {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.HTMLParser]';
	},

	/**
	 * Parse to element.
	 * @param {String} markup
	 * @param @optional {Document} targetdoc
	 * @returns {Node}
	 */
	parse: function(markup, targetdoc) {
		return this.parseAll(markup, targetdoc)[0] || null;
	},

	/**
	 * Parse to array of one or more elements.
	 * @param {String} markup
	 * @param @optional {Document} targetdoc
	 * @returns {Array<Element>}
	 */
	parseAll: function(markup, targetdoc) {
		return this.parseToNodes(markup, targetdoc).filter(function(node) {
			return node.nodeType === Node.ELEMENT_NODE;
		});
	},

	/**
	 * Parse to node.
	 * @param {String} markup
	 * @param @optional {Document} targetdoc
	 * @returns {Node}
	 */
	parseToNode: function(markup, targetdoc) {
		return this.parseToNodes(markup, targetdoc)[0] || null;
	},

	/**
	 * Parse to array of one or more nodes.
	 * @param {String} markup
	 * @param @optional {Document} targetdoc
	 * @returns {Array<Node>}
	 */
	parseToNodes: function(markup, targetdoc) {
		var elm, doc = this._document ||
			(this._document = document.implementation.createHTMLDocument(''));
		return gui.Guide.suspend(function() {
			doc.body.innerHTML = this._unsanitize(markup);
			elm = doc.querySelector('.' + this._classname) || doc.body;
			return Array.map(elm.childNodes, function(node) {
				return (targetdoc || document).importNode(node, true);
			});
		}, this);
	},

	/**
	 * Parse to document. Bear in mind that the
	 * document.defaultView of this thing is null.
	 * @TODO: Use DOMParser for text/html supporters
	 * @param {String} markup
	 * @returns {HTMLDocument}
	 */
	parseToDocument: function(markup) {
		markup = markup || '';
		return gui.Guide.suspend(function() {
			var doc = document.implementation.createHTMLDocument('');
			if (markup.toLowerCase().includes('<!doctype')) {
				try {
					doc.documentElement.innerHTML = markup;
				} catch (ie9exception) {
					doc = new ActiveXObject('htmlfile');
					doc.open();
					doc.write(markup);
					doc.close();
				}
			} else {
				doc.body.innerHTML = markup;
			}
			return doc;
		});
	},

	// Private ...................................................................

	/**
	 * Classname for obscure wrapping containers.
	 * @type {String}
	 */
	_classname: '_gui-htmlparser',

	/**
	 * Match comments.
	 * @type {RegExp}
	 */
	_comments: /<!--[\s\S]*?-->/g,

	/**
	 * Match first tag.
	 * @type {RegExp}
	 */
	_firsttag: /^<([a-z]+)/i,

	/**
	 * Recycled for parseToNodes operations.
	 * TODO: Create on first demand
	 * @type {HTMLDocument}
	 */
	_document: null,

	/**
	 * Some elements must be created in obscure markup
	 * structures in order to be rendered correctly.
	 * @param {String} markup
	 * @returns {String}
	 */
	_unsanitize: function(markup) {
		var match, fix;
		markup = markup.trim().replace(this._comments, '');
		if ((match = markup.match(this._firsttag))) {
			if ((fix = this._unsanestructures[match[1]])) {
				markup = fix
				.replace('${class}', this._classname)
				.replace('${markup}', markup);
			}
		}
		return markup;
	},

	/**
	 * Mapping tag names to miminum viable tag structure.
	 * @see https://github.com/petermichaux/arbutus
	 * TODO: "without the option in the next line, the
	 * parsed option will always be selected."
	 * @type {Map<String,String>}
	 */
	_unsanestructures: (function() {
		var map = {
			td: '<table><tbody><tr class="${class}">${markup}</tr></tbody></table>',
			tr: '<table><tbody class="${class}">${markup}</tbody></table>',
			tbody: '<table class="${class}">${markup}</table>',
			col: '<table><colgroup class="${class}">${markup}</colgroup></table>',
			option: '<select class="${class}"><option>a</option>${markup}</select>'
		};
		map.th = map.td; // duplicate fixes.
		['thead', 'tfoot', 'caption', 'colgroup'].forEach(function(tag) {
			map[tag] = map.tbody;
		});
		return map;
	}())
};



/**
 * Provides convenient access to an events originating
 * window, document and spirit of the document element.
 * TODO: Fire this onmousemove only if has listeners!
 * @param {Event} e
 */
gui.EventSummary = function(e) {
	this._construct(e);
};

gui.EventSummary.prototype = {

	/**
	 * The event itself.
	 * @type {Event}
	 */
	event: null,

	/**
	 * Originating window.
	 * @type {Window}
	 */
	window: null,

	/**
	 * Originating document.
	 * @type {Document}
	 */
	document: null,

	/**
	 * Spirit of the root element (the HTML element) in originating document.
	 * @type {gui.DocumentSpirit}
	 */
	documentspirit: null,

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.EventSummary]';
	},

	// Private ...................................................................

	/**
	 * Breakdown event argument into more manegable properties
	 * (this method illustrates the need for en event summary).
	 * @param {Event} e
	 * @returns {object}
	 */
	_construct: function(e) {
		var win = null,
			doc = null,
			target = e.target,
			type = target.nodeType;
		if (gui.Type.isDefined(type)) {
			doc = (type === Node.DOCUMENT_NODE ? target : target.ownerDocument);
			win = doc.defaultView;
		} else {
			win = target;
			doc = win.document;
		}
		this.event = e;
		this.window = win;
		this.document = doc;
		this.documentspirit = doc.documentElement.spirit;
	}
};



/**
 * Crawling the DOM ascending or descending.
 * TODO: method `descendBelow` and 'ascendAbove' to skip start element
 * @using {gui.Type} type
 */
gui.Crawler = (function using(Type) {
	return gui.Class.create(Object.prototype, {

		/**
		 * Identifies the crawler.
		 * @type {String}
		 */
		type: null,

		/**
		 * Direction "ascending" or "descending".
		 * @type {String}
		 */
		direction: null,

		/**
		 * @type {Boolean}
		 */
		global: false,

		/**
		 * Identification.
		 * @returns {String}
		 */
		toString: function() {
			return '[object gui.Crawler]';
		},

		/**
		 * Constructor.
		 * @param {String} type
		 */
		onconstruct: function(type) {
			this.type = type || null;
		},

		/**
		 * Crawl DOM ascending.
		 * @param {Element|gui.Spirit} start
		 * @param {object} handler
		 */
		ascend: function(start, handler) {
			this._stopped = false;
			this.direction = gui.Crawler.ASCENDING;
			var supports = gui.hasModule('gui-spirits@wunderbyte.com');
			var isspirit = supports && start instanceof gui.Spirit;
			var win, elm = isspirit ? start.element : start;
			do {
				if (elm.nodeType === Node.DOCUMENT_NODE) {
					if (this.global) {
						win = elm.defaultView;
						if (win.gui.hosted) { // win.parent !== win
							/*
							 * @TODO: iframed document might have navigated elsewhere, stamp this in localstorage
							 * @TODO: sit down and wonder if localstorage is even available in sandboxed iframes...
							 */
							if (win.gui.xhost) {
								elm = null;
								if (Type.isFunction(handler.transcend)) {
									handler.transcend(win.parent, win.gui.xhost, win.gui.$contextid);
								}
							} else {
								elm = win.frameElement;
							}
						} else {
							elm = null;
						}
					} else {
						elm = null;
					}
				}
				if (elm) {
					var directive = this._handleElement(elm, handler);
					switch (directive) {
						case gui.Crawler.STOP:
							elm = null;
							break;
						default:
							elm = elm.parentNode;
							break;
					}
				}
			} while (elm);
		},

		/**
		 * Crawl DOM ascending, transcend into ancestor frames.
		 * @param {Element|gui.Spirit} start
		 * @param {object} handler
		 */
		ascendGlobal: function(start, handler) {
			this.global = true;
			this.ascend(start, handler);
			this.global = false;
		},

		/**
		 * Crawl DOM descending.
		 * @param {object} start Spirit or Element
		 * @param {object} handler
		 * @param @optional {object} arg @TODO: is this even supported?
		 */
		descend: function(start, handler, arg) {
			this._stopped = false;
			this.direction = gui.Crawler.DESCENDING;
			var elm = (start instanceof gui.Spirit) ? start.element : start;
			if (elm.nodeType === Node.DOCUMENT_NODE) {
				elm = elm.documentElement;
			}
			this._descend(elm, handler, arg, true);
		},

		/**
		 * Crawl DOM descending, transcend into iframes.
		 * @param {object} start Spirit or Element
		 * @param {object} handler
		 * @param @optional {object} arg @TODO: is this even supported?
		 */
		descendGlobal: function(start, handler, arg) {
			this.global = true;
			this.descend(start, handler, arg);
			this.global = false;
		},

		// Private ...................................................................

		/**
		 * Crawler was stopped?
		 * @type {boolean}
		 */
		_stopped: false,

		/**
		 * Iterate descending.
		 * @param {Element} elm
		 * @param {object} handler
		 * @param {boolean} start
		 */
		_descend: function(elm, handler, arg, start) {
			var next, spirit, directive = this._handleElement(elm, handler, arg);
			switch (directive) {
				case gui.Crawler.STOP:
					this._stopped = true;
					break;
				case gui.Crawler.CONTINUE:
				case gui.Crawler.SKIP_CHILDREN:
					if (directive !== gui.Crawler.SKIP_CHILDREN) {
						if (elm.childElementCount) {
							this._descend(elm.firstElementChild, handler, arg, false);
						} else if (this.global && elm.localName === 'iframe') {
							/*
							 * TODO: Make iframe transcend work even without spirit support.
							 */
							if ((spirit = elm.spirit) && (spirit instanceof gui.IframeSpirit)) {
								if (Type.isFunction(handler.transcend)) {
									handler.transcend(
										spirit.contentWindow,
										spirit.xguest,
										spirit.$instanceid
									);
								}
							}
						}
					}
					if (!this._stopped) {
						if (!start && (next = elm.nextElementSibling)) {
							this._descend(next, handler, arg, false);
						}
					}
					break;
			}
		},

		/**
		 * Handle element. Invoked by both ascending and descending crawler.
		 * @param {Element} element
		 * @param {object} handler
		 * @returns {number} directive
		 */
		_handleElement: function(element, handler, arg) {
			var hasspirit = gui.hasModule('gui-spirits@wunderbyte.com');
			var directive = gui.Crawler.CONTINUE;
			var spirit;
			if (handler) {
				if (Type.isFunction(handler.handleElement)) {
					directive = handler.handleElement(element, arg);
				}
				if (!directive && hasspirit) {
					if ((spirit = gui.get(element))) {
						directive = spirit.oncrawler(this);
						if (!directive) {
							if (Type.isFunction(handler.handleSpirit)) {
								directive = this._handleSpirit(spirit, handler);
							}
						}
					}
				}
			}
			if (!directive) {
				directive = gui.Crawler.CONTINUE;
			}
			return directive;
		},

		/**
		 * Handle Spirit.
		 * @param {Spirit} spirit
		 * @param {object} handler
		 * @returns {number}
		 */
		_handleSpirit: function(spirit, handler) {
			return handler.handleSpirit(spirit);
		}

	}, {}, { // Static .............................................................

		ASCENDING: 'ascending',
		DESCENDING: 'descending',
		CONTINUE: 0,
		STOP: 1,
		SKIP: 2, // @TODO: support this
		SKIP_CHILDREN: 4

	});
}(gui.Type));



/**
 * Simplistic XMLHttpRequest wrapper.
 * @param @optional {String} url
 * @param @optional {Document} doc Resolve URL relative to given document location.
 */
gui.Request = function Request(url, doc) {
	doc = doc || document;
	this._headers = {
		Accept: 'application/json'
	};
	if (url) {
		this.url(url, doc);
	}
};

/**
 * @using {gui.Combo#chained}
 */
gui.Request.prototype = (function using(chained) {
	return {

		/**
		 * Set request address.
		 * @param {String} url
		 * @param @optional {Document} doc Resolve URL relative to this document
		 */
		url: chained(function(url, doc) {
			this._url = doc ? new gui.URL(doc, url).href : url;
		}),

		/**
		 * Convert to synchronous request.
		 */
		sync: chained(function() {
			this._async = false;
		}),

		/**
		 * Convert to asynchronous request.
		 */
		async: chained(function() {
			this._async = true;
		}),

		/**
		 * Expected response type. Sets the accept header and formats
		 * callback result accordingly (eg. as JSON object, XML document)
		 * @param {String} mimetype
		 * @returns {gui.Request}
		 */
		accept: chained(function(mimetype) {
			this._headers.Accept = mimetype;
		}),

		/**
		 * Expect JSON response.
		 * @returns {gui.Request}
		 */
		acceptJSON: chained(function() {
			this.accept('application/json');
		}),

		/**
		 * Expect XML response.
		 * @returns {gui.Request}
		 */
		acceptXML: chained(function() {
			this.accept('text/xml');
		}),

		/**
		 * Expect text response.
		 * @returns {gui.Request}
		 */
		acceptText: chained(function() {
			this.accept('text/plain');
		}),

		/**
		 * Format response to this type.
		 * @param {String} mimetype
		 * @returns {gui.Request}
		 */
		format: chained(function(mimetype) {
			this._format = mimetype;
		}),

		/**
		 * Override mimetype to fit accept.
		 * @returns {gui.Request}
		 */
		override: chained(function(doit) {
			this._override = doit || true;
		}),

		/**
		 * Append request headers.
		 * @param {Map<String,String>} headers
		 * @returns {gui.Request}
		 */
		headers: chained(function(headers) {
			if (gui.Type.isObject(headers)) {
				gui.Object.each(headers, function(name, value) {
					this._headers[name] = String(value);
				}, this);
			} else {
				throw new TypeError('Object expected');
			}
		}),

		// Private ...................................................................................

		/**
		 * @type {boolean}
		 */
		_async: true,

		/**
		 * @type {String}
		 */
		_url: null,

		/**
		 * Default request type. Defaults to JSON.
		 * @type {String}
		 */
		_format: 'application/json',

		/**
		 * Override response mimetype?
		 * @type {String}
		 */
		_override: false,

		/**
		 * Request headers.
		 * @type {Map<String,String}
		 */
		_headers: null,

		/**
		 * Do the XMLHttpRequest.
		 * TODO: http://mathiasbynens.be/notes/xhr-responsetype-json
		 * @param {String} method
		 * @param {object} payload
		 * @param {function} callback
		 */
		_request: function(method, payload, callback) {
			var that = this,
				request = new XMLHttpRequest();
			var xtarget = gui.URL.external(this._url, document);
			request.onreadystatechange = function() {
				if (this.readyState === XMLHttpRequest.DONE) {
					var data = that._response(this.responseText);
					callback(this.status, data, this.responseText);
				}
			};
			if (this._override) {
				request.overrideMimeType(this._headers.Accept);
			}
			request.open(method.toUpperCase(), this._url, true);
			if (!xtarget) { // headers not used xdomain per spec
				gui.Object.each(this._headers, function(name, value) {
					request.setRequestHeader(name, value, false);
				});
			}
			request.send(payload);
		},

		/**
		 * Parse response to expected type.
		 * @param {String} text
		 * @returns {object}
		 */
		_response: function(text) {
			var result = text;
			try {
				switch (this._headers.Accept) {
					case 'application/json':
						result = JSON.parse(text);
						break;
					case 'text/xml':
						result = new DOMParser().parseFromString(text, 'text/xml');
						break;
				}
			} catch (exception) {
				if (gui.debug) {
					console.error(
						this._headers.Accept + ' dysfunction at ' + this._url
					);
				}
			}
			return result;
		}
	};
}(gui.Combo.chained));

/**
 * Generating methods for GET PUT POST DELETE.
 * @param @optional {object} payload
 */
['get', 'post', 'put', 'delete'].forEach(function(method) {
	gui.Request.prototype[method] = function(payload) {
		if (gui.Type.isFunction(payload)) {
			throw new Error('Deprecated: gui.Request returns a gui.Then');
		}
		var then = new gui.Then();
		payload = method === 'get' ? null : payload;
		this._request(method, payload, function(status, data, text) {
			then.now(status, data, text);
		});
		return then;
	};
});



/**
 * Questionable browser identity and feature detection.
 * @TODO Load earlier by not using gui.Broadcast
 * @TODO Lazycompute properties when requested (not least scrollBarSize)
 */
gui.Client = (function() {
	var agent = navigator.userAgent.toLowerCase();

	/**
	 * Supports CSS feature?
	 * @param {String} feature
	 * @returns {boolean}
	 */
	function supports(feature) {
		var root = document.documentElement;
		var fixt = feature[0].toUpperCase() + feature.substring(1);
		return !['', 'Webkit', 'Moz', 'O', 'ms'].every(function(prefix) {
			return root.style[prefix ? prefix + fixt : feature] === undefined;
		});
	}

	function Client() {
		// user agent death match - this obviously needs some work
		this.isExplorer = agent.includes('msie') || agent.includes('trident') || agent.includes('edge');
		this.isExplorer9 = this.isExplorer && agent.includes('msie 9');
		this.isExplorer10 = this.isExplorer && agent.includes('msie 10');
		this.isExplorer11 = this.isExplorer && agent.includes('rv:11');
		this.isExplorer12 = this.isExplorer && agent.includes('rv:12'); // NOT TESTED!
		this.isEdge = this.isExplorer && agent.includes('edge');
		this.isWebKit = !this.isExplorer && (agent.includes('webkit') || agent.includes('opera'));
		this.isChrome = !this.isExplorer && this.isWebKit && agent.includes('chrome');
		this.isSafari = !this.isExplorer && this.isWebKit && !this.isChrome && agent.includes('safari');
		this.isGecko = !this.isExplorer && !this.isWebKit && !this.isOpera && agent.includes('gecko');
		this.isBlink = agent.includes('blink');
		this.isChromeApp = !!((window.chrome && window.chrome.app && window.chrome.app.runtime));

		/**
		 * Agent is one of "webkit" "firefox" "opera" or "explorer"
		 * @type {String}
		 */
		this.agent = (function() {
			if (this.isWebKit) {
				return 'webkit';
			} else if (this.isGecko) {
				return 'gecko';
			} else if (this.isOpera) {
				return 'opera';
			}
			return 'explorer';
		}.call(this));

		/**
		 * System is "linux" "osx" "ios" "windows" "windowsmobile" "haiku" or "amiga".
		 */
		this.system = (function(shortlist) {
			var os = null;
			shortlist.every(function(test) {
				if (agent.includes(test)) {
					if (test.match(/ipad|iphone/)) {
						os = 'ios';
					} else {
						os = test.replace(/ /g, ''); // no spaces
					}
				}
				return os === null;
			});
			return os;
		}([
			'window mobile',
			'windows',
			'ipad',
			'iphone',
			'os x',
			'linux',
			'haiku',
			'amiga'
		]));

		/**
		 * Has touch support? Note that desktop Chrome has this.
		 * @TODO Investigate this in desktop IE10.
		 * @type {boolean}
		 */
		this.hasTouch = (window.ontouchstart !== undefined || this.isChrome);

		/**
		 * Has native pointer events? Seems to work best if we hardcode `false`.
		 * @TODO: feature detect somewhing
		 * @type {boolean}
		 */
		this.hasPointers = false; // ( this.isExplorer && !this.isExplorer9 );

		/**
		 * Supports file blob?
		 * @type {boolean}
		 */
		this.hasBlob = (window.Blob && (window.URL || window.webkitURL));

		/**
		 * Supports the History API?
		 * @type {boolean}
		 */
		this.hasHistory = !!((window.history && window.history.pushState));

		/**
		 * Is touch device? Not to be confused with {gui.Client#hasTouch}
		 * @type {boolean}
		 */
		this.isTouchDevice = (function(shortlist) {
			return shortlist.some(function(system) {
				return agent.includes(system);
			});
		}([
			'android',
			'webos',
			'iphone',
			'ipad',
			'ipod',
			'blackberry',
			'windows phone'
		]));

		/**
		 * Supports CSS transitions?
		 * @type {boolean}
		 */
		this.hasTransitions = supports('transition');

		/**
		 * Supports CSS transforms?
		 * @type {boolean}
		 */
		this.hasTransforms = supports('transform');

		/**
		 * Supports CSS animations?
		 * @type {boolean}
		 */
		this.hasAnimations = supports('animationName');

		/**
		 * Supports CSS 3D transform? (note https://bugzilla.mozilla.org/show_bug.cgi?id=677173)
		 * @type {boolean}
		 */
		this.has3D = supports('perspective');

		/**
		 * Supports flexible box module?
		 * @type {boolean}
		 */
		this.hasFlex = supports('flex');

		/**
		 * Has support for Proxy objects?
		 * http://wiki.ecmascript.org/doku.php?id=harmony:proxies
		 * @type {boolean}
		 */
		this.hasProxies = (window.Proxy && window.Proxy.create);

		/**
		 * Has Performance API?
		 * @type {boolean}
		 */
		this.hasPerformance = (window.performance && window.performance.now);

		/**
		 * Temp...
		 */
		Object.defineProperty(this, 'hasFlexBox', {
			get: function() {
				console.error('Depracated API is deprecated: hasFlexBox >> hasFlex');
			}
		});

		/**
		 * Supports requestAnimationFrame somewhat natively?
		 * @type {boolean}
		 */
		this.hasAnimationFrame = (function() {
			var win = window;
			return !!((
				win.requestAnimationFrame ||
				win.webkitRequestAnimationFrame ||
				win.mozRequestAnimationFrame ||
				win.msRequestAnimationFrame ||
				win.oRequestAnimationFrame
			));
		}());

		/**
		 * Supports HTMLTemplateElement?
		 * @type {boolean}
		 */
		this.hasTemplates = (function(template) {
			return 'content' in template;
		}(document.createElement('template')));

		/**
		 * Supports HTML imports?
		 * @type {boolean}
		 */
		this.hasImports = (function(link) {
			return 'import' in link;
		}(document.createElement('link')));

		/**
		 * Supports MutationObserver feature?
		 * @type {boolean}
		 */
		this.hasMutations = (function() {
			return !['', 'WebKit', 'Moz', 'O', 'Ms'].every(function(vendor) {
				return !gui.Type.isDefined(window[vendor + 'MutationObserver']);
			});
		}());

		/**
		 * DOM attributes have been moved to prototype chains
		 * and they do also expose JavaScript getters/setters?
		 * @see http://code.google.com/p/chromium/issues/detail?id=13175
		 * @see https://bugs.webkit.org/show_bug.cgi?id=49739
		 * @type {boolean}
		 */
		this.hasAttributesOnPrototype = (function(Client_) {
			if (Client_.isSafari) {
				return false;
			} else if (Client_.isWebKit) {
				var rex = /chrom(e|ium)\/([0-9]+)\./;
				var raw = agent.match(rex);
				var ver = raw ? parseInt(raw[2], 10) : 0;
				return !ver || ver >= 44; // 43 should be ok, but still...
			}
			return true;
		}(this));

		/**
		 * Browsers disagree on the primary scrolling element.
		 * Is it document.body or document.documentElement?
		 * TODO: This has probably been fixed (in Chrome) by now...
		 * @see https://code.google.com/p/chromium/issues/detail?id=2891
		 * @type {HTMLElement}
		 */
		this.scrollRoot = null;

		/**
		 * Scrollbar default span in pixels.
		 * Note that this is zero on mobiles.
		 * @type {number}
		 */
		this.scrollBarSize = 0;

		/**
		 * Supports position fixed?
		 * @type {boolean}
		 */
		this.hasPositionFixed = false;

		/**
		 * Compute some stuff that couldn't be determined parse time.
		 */
		this.$init = function() {
			if (!gui.CSSPlugin) {
				return;
			}
			var win = window,
				doc = document,
				html = doc.documentElement,
				body = doc.body,
				root = null;

			// make sure window is scrollable
			var temp = body.appendChild(
				gui.CSSPlugin.style(doc.createElement('div'), {
					position: 'absolute',
					height: '10px',
					width: '10px',
					top: '100%'
				})
			);

			// what element will get scrolled?
			win.scrollBy(0, 10);
			root = html.scrollTop ? html : body;
			this.scrollRoot = root;

			// supports position fixed?
			gui.CSSPlugin.style(temp, {
				position: 'fixed',
				top: '10px'
			});

			// restore scroll when finished
			var has = temp.getBoundingClientRect().top === 10;
			this.hasPositionFixed = has;
			body.removeChild(temp);
			win.scrollBy(0, -10);

			// compute scrollbar size
			var inner = gui.CSSPlugin.style(document.createElement('p'), {
				width: '100%',
				height: '200px'
			});
			var outer = gui.CSSPlugin.style(document.createElement('div'), {
				position: 'absolute',
				top: '0',
				left: '0',
				visibility: 'hidden',
				width: '200px',
				height: '150px',
				overflow: 'hidden'
			});
			outer.appendChild(inner);
			html.appendChild(outer);
			var w1 = inner.offsetWidth;
			outer.style.overflow = 'scroll';
			var w2 = inner.offsetWidth;
			if (w1 === w2) {
				w2 = outer.clientWidth;
			}
			html.removeChild(outer);
			this.scrollBarSize = w1 - w2;
			if (this.isExplorer) {
				// sad hotfix for IE, but TODO: isn't the scrollbar really big in Windows 10?
				this.scrollBarSize = 17;
			}
		};
	}

	return new Client();
}());



/**
 * Some kind of special map with strings keys and arrays values.
 * TODO: Refactor the various {gui.TrackerPlugin} implementations to use this.
 * @using {gui.Arguments#confirmed}
 * @using {gui.Array} GuiArray
 */
gui.MapList = (function using(confirmed, GuiArray) {
	function MapList(Fit) {
		this._map = Object.create(null);
		this._fit = Fit || null;
	}

	MapList.prototype = {

		/**
		 * Get list indexed by key.
		 * @param {string} key
		 * @returns {Array}
		 */
		get: function(key) {
			return this._map[key];
		},

		/**
		 * Set list by key (you would normally `add` entries instead, see below).
		 * @param {string} key
		 * @param {Array} val
		 */
		set: confirmed('string', 'array')(function(key, val) {
			this._map[key] = val;
			return this._map[key];
		}),

		/**
		 * Has list indexed by key?
		 * @param {string} key
		 * @returns {boolean}
		 */
		has: function(key) {
			return this._map[key] !== undefined;
		},

		/**
		 * Delete list indexed by key.
		 * TODO: Support function arg for destructing members of the list?
		 * @param {string} key
		 */
		'delete': function(key) {
			this._map[key] = null;
			delete this._map[key];
		},

		/**
		 * Push entry to list indexed by key.
		 * Don't push no double entries here.
		 * Creates the list on first push.
		 * Return true if not already added.
		 * @param {string} key
		 * @param {object} val
		 * @returns {boolean} True if *not* already added
		 */
		add: confirmed('string')(function(key, val) {
			var list = this.get(key) || this.set(key, []);
			var puts = list.indexOf(val) === -1;
			if (puts) {
				if (this._fit && !(val instanceof this._fit)) {
					throw new TypeError(val + ' is not a ' + this._fit);
				}
				list.push(val);
			}
			return puts;
		}),

		/**
		 * Remove entry from list index by key. Deletes the list when empty.
		 * @param {string} key
		 * @param {object} val
		 */
		remove: confirmed('string')(function(key, val) {
			var length, list = this.get(key);
			if (list) {
				length = GuiArray.remove(list, val);
				if (length === 0) {
					this.delete(key);
				}
			}
		}),

		/**
		 * @param {function} callback
		 * @param @optional {object} thisp
		 */
		each: function(callback, thisp) {
			gui.Object.each(this._map, function(key, list) {
				callback.call(thisp, key, list);
			});
		},

		// Private .................................................................

		/**
		 * @type {Map<string,Array>}
		 */
		_map: null,

		/**
		 * @type {constructor}
		 */
		_fit: null

	};

	return MapList;
}(gui.Arguments.confirmed, gui.Array));



/**
 * Core module.
 */
gui.module('gui@wunderbyte.com');



}(self));
(function(window) {

"use strict";


/* global gui:true */

/**
 * Extend `gui` to support spirits.
 */
gui = gui.Object.extend(gui, {

	/**
	 * Robot mode: Automatically spiritualize and
	 * materialize by overriding native DOM methods.
	 * @type {string}
	 */
	MODE_ROBOT: 'robot',

	/**
	 * Human mode: Spiritualize and materialize at own risk.
	 * @type {string}
	 */
	MODE_HUMAN: 'human',

	/**
	 * Funny mode: Spiritualize manually, materialize automatically.
	 * TODO: Remove all traces of this. It is not funny.
	 * @type {string}
	 */
	MODE_FUNNY: 'funny',

	// broadcasts
	BROADCAST_WILL_SPIRITUALIZE: 'gui-broadcast-will-spiritualize',
	BROADCAST_DID_SPIRITUALIZE: 'gui-broadcast-did-spiritualize',

	// actions
	ACTION_DOC_ONSPIRITUALIZED: 'gui-action-document-spiritualized',

	// framework-internal stuff (most should eventually dollarprefix!)
	$ACTION_XFRAME_VISIBILITY: 'gui-action-xframe-visibility',

	// lifecycle events (all spirits)
	LIFE_CONSTRUCT: 'gui-life-construct',
	LIFE_CONFIGURE: 'gui-life-configure',
	LIFE_ENTER: 'gui-life-enter',
	LIFE_ATTACH: 'gui-life-attach',
	LIFE_READY: 'gui-life-ready',
	LIFE_DETACH: 'gui-life-detach',
	LIFE_EXIT: 'gui-life-exit',
	LIFE_ASYNC: 'gui-life-async',
	LIFE_DESTRUCT: 'gui-life-destruct',
	LIFE_VISIBLE: 'gui-life-visible',
	LIFE_INVISIBLE: 'gui-life-invisible',
	LIFE_RENDER: 'gui-life-render', // belongs to edb.module really...

	// ifecycle events (some spirits)
	LIFE_IFRAME_CONSTRUCT: 'gui-life-iframe-construct',
	LIFE_IFRAME_DOMCONTENT: 'gui-life-iframe-domcontent',
	LIFE_IFRAME_SPIRITUALIZED: 'gui-life-iframe-spiritualized',
	LIFE_IFRAME_ONLOAD: 'gui-life-iframe-onload',
	LIFE_IFRAME_ONHASH: 'gui-life-iframe-onhash',
	LIFE_IFRAME_UNLOAD: 'gui-life-iframe-unload',

	// tick types (timed events)
	$TICK_INSIDE: 'gui-tick-spirits-inside',
	$TICK_OUTSIDE: 'gui-tick-spirits-outside',

	// crawler identification strings
	CRAWLER_SPIRITUALIZE: 'gui-crawler-spiritualize',
	CRAWLER_MATERIALIZE: 'gui-crawler-materialize',
	CRAWLER_DETACH: 'gui-crawler-detach',
	CRAWLER_DISPOSE: 'gui-crawler-dispose', // TODO: what is this?
	CRAWLER_ACTION: 'gui-crawler-action',
	CRAWLER_VISIBLE: 'gui-crawler-visible', // TODO: move to plugin
	CRAWLER_INVISIBLE: 'gui-crawler-invisible', // TODO: move to plugin
	CRAWLER_REFLEX: 'gui-crawler-reflex',

	/**
	 * CSS classnames
	 */
	CLASS_NOSPIRITS: 'gui-nospirits', // declare spirit-free zone (performance)
	CLASS_INVISIBLE: '_gui-invisible',
	CLASS_HIDDEN: '_gui-hidden',

	/**
	 * Spirit management mode. Matches 'robot' or 'human' (or 'funny' perhaps).
	 * @type {String}
	 */
	mode: 'robot',

	/**
	 * Automatically run on DOMContentLoaded?
	 * @TODO: rename this to something
	 * @type {boolean}
	 */
	autostrap: true,

	/**
	 * Delay boostrap by some milliseconds as a "catch all" for
	 * frameworks that do something to the DOM without exposing
	 * lifecycle events that tell us *when* it's done (Angular).
	 * @type {number}
	 */
	bootstrapdelay: -1,

	/**
	 * True (only) while initial spiritualization is in progress.
	 * @type {boolean}
	 */
	spiritualizing: false,

	/**
	 * Flipped by the {gui.Guide} after initial spiritualization
	 * @type {boolean}
	 */
	spiritualized: false,

	/**
	 * Magic attributes to trigger spirit association and configuration.
	 * By default we support 'gui' but you may prefer to use 'data-gui'.
	 * @type {Array<string>}
	 */
	attributes: null,

	/**
	 * Boostrap Spiritual. Unless `autostrap` is set to `false`, this
	 * happens automatically at `DOMContentLoaded`. You can nudge the
	 * `boostrapdelay` to accomodate for cornercase framework behavior,
	 * ie. allow Angular to parse the DOM for template elements first
	 * (this to avoid HTML from initialized spirits in the tempaltes!).
	 */
	bootstrap: function() {
		gui.bootstrap = function notagain() {};
		var delay = gui.bootstrapdelay;
		gui.Client.$init();
		function start() {
			gui.spiritualizing = true;
			gui.Guide.$startGuiding();
			gui.spiritualizing = false;
			gui._nowready();
		}
		if (delay > -1) {
			setTimeout(start, delay);
		} else {
			start();
		}
	},

	/**
	 * Possess element and descendants.
	 * TODO: Jump detached spirit if matching id (!)
	 * @param {Element} target
	 */
	spiritualize: function(target) {
		gui.Guide.$spiritualize(target || document);
	},

	/**
	 * Possess descendants.
	 * @param {Element|gui.Spirit} target
	 */
	spiritualizeSub: function(target) {
		gui.Guide.$spiritualizeSub(target || document);
	},

	/**
	 * Possess one element non-crawling.
	 * @param {Element|gui.Spirit} target
	 */
	spiritualizeOne: function(target) {
		gui.Guide.$spiritualizeOne(target || document);
	},

	/**
	 * Dispell spirits from element and descendants.
	 * @param {Element|gui.Spirit} target
	 * @param @optional {boolean} webkithack (not an official thing!)
	 */
	materialize: function(target, webkithack) {
		gui.Guide.$materialize(target || document, webkithack);
	},

	/**
	 * Dispell spirits for descendants.
	 * @param {Element|gui.Spirit} target
	 */
	materializeSub: function(target) {
		gui.Guide.$materializeSub(target || document);
	},

	/**
	 * Dispell one spirit non-crawling.
	 * @param {Element|gui.Spirit} target
	 */
	materializeOne: function(target) {
		gui.Guide.$materializeOne(target || document);
	},

	/**
	 * Don't materialize and spiritualize during given operation.
	 * @param {funtion} operation
	 */
	suspend: function(operation) {
		return gui.DOMObserver.suspend(function() {
			return gui.Guide.suspend(operation);
		});
	},

	/**
	 * Get spirit for fuzzy argument.
	 * TODO: Perhaps delegate this to {gui.DOMPlugin}?
	 * @param {String|Element} arg
	 * @param @optional {function} callback
	 * @param @optional {object} thisp
	 * @returns {gui.Spirit}
	 */
	get: function(arg, callback, thisp) {
		var spirit;
		switch (arguments.length) {
			case 1:
				if (this.spiritualizing || this.spiritualized) {
					spirit = this._getspirit(arg);
				} else if (window.console && console.warn && console.error) {
					var message = this._guigetmessage();
					if (location.hostname === 'localhost') {
						console.error(message); // stacktrace version
					} else {
						console.warn(message);
					}
				}
				break;
			case 2:
				this.ready(function onready() {
					spirit = gui._getspirit(arg);
					callback.call(thisp, spirit);
				});
				break;
		}
		return spirit || null;
	},

	/**
	 * @TODO
	 */
	getAll: function(arg) {
		console.error('TODO: gui.getAll');
	},

	/**
	 * Channel spirits to CSS selectors.
	 * TODO: explain args
	 */
	channel: function() {
		gui.Guide.$channel.apply(gui.Guide, arguments);
	},

	/**
	 * Has channels?
	 * TODO: rebrand as 'channelings'
	 * @returns {boolean}
	 */
	hasChannels: function() {
		return gui.Guide.$hasChannels();
	},

	/**
	 * Get channels (read only).
	 * TODO: rebrand as 'channelings'
	 * @type {Array<Array<String,function>>}
	 */
	getChannels: function() {
		return gui.Guide.$getChannels();
	},

	/**
	 * Do something when everything is spiritualized (synchronously after
	 * DOMContentLoaded). Or if that's already too late, just do it now.
	 * TODO: support `onready` object handler
	 * @overwrites {gui#ready} A stub implementation
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 * @returns {boolean} True when ready already
	 */
	ready: function(action, thisp) {
		var is = this.spiritualized;
		if (arguments.length) {
			if (is) {
				action.call(thisp);
			} else {
				this._readycallbacks = this._readycallbacks || [];
				this._readycallbacks.push(function() {
					action.call(thisp);
				});
			}
		}
		return is;
	},

	// Private ...................................................................

	/**
	 * @type {Array<function>}
	 */
	_readycallbacks: null,

	/**
	 * Setup a broadcast listener to bootstrap Spiritual
	 * after any other potential framework initialization.
	 * @returns {gui.Namespace} myself
	 */
	_initialize: function() {
		this.attributes = ['gui'];
		gui.Broadcast.add(gui.BROADCAST_TODOM, {
			onbroadcast: function() {
				if (gui.autostrap) {
					gui.bootstrap();
				}
			}
		});
		return this;
	},

	/**
	 * Initial spirits are ready.
	 * Run accumulated callbacks.
	 */
	_nowready: function() {
		this.spiritualized = true;
		var list = this._readycallbacks;
		if (list) {
			while (list.length) {
				list.shift()();
			}
			this._readycallbacks = null;
		}
	},

	/**
	 * Get spirit for fuzzy argument.
	 * @param {String|Element} arg
	 * @returns {gui.Spirit}
	 */
	_getspirit: function(arg) {
		var spirit = null, element, doc = document;
		switch (gui.Type.of(arg)) {
			case 'string':
				arg = arg.trim();
				if (gui.KeyMaster.isKey(arg)) {
					spirit = gui.Guide.$getSpiritById(arg); // TODO!!!!!!!!!!!!!!!!!!!!!!
				}
				if (!spirit) {
					try {
						element = arg.match(/[^a-zA-Z\d]/) ?
							doc.querySelector(arg) :	// lookup selector in document
							(
								doc.getElementById(arg) || // lookup by ID in document
								doc.querySelector(arg) // lookup by tagname in document
							);
					} catch (badselector) {
						console.warn(badselector.message, arg);
					} finally {
						spirit = element ? element.spirit : null;
					}
				}
				break;
			case 'function':
				var sp, spirits = this._spirits.inside;
				if (gui.Type.isSpiritConstructor(arg)) {
					Object.keys(this._spirits.inside).some(function(key) {
						if (((sp = spirits[key]).constructor === arg)) {
							spirit = sp;
							return true;
						}
					});
				}
				break;
			default:
				if (gui.Type.isElement(arg)) {
					spirit = arg.spirit || null;
				}
				break;
		}
		return spirit;
	},

	/**
	 * TODO: Support custom namespace to replace `gui` here.
	 * @returns {string}
	 */
	_guigetmessage: function() {
		return [
			'gui.get() failed because we\'re not initialized just yet.',
			'You can supply a callback function as the second argument',
			'or you can wrap your existing code in gui.ready(mycallback).'
		].join(' ');
	}

}._initialize());



/**
 * ActionPlugin.
 * @extends {gui.TrackerPlugin}
 * TODO: 'one' and 'oneGlobal' methods
 * @using {gui.Arguments#confirmed}
 * @using {gui.Combo#chained}
 */
gui.ActionPlugin = (function using(confirmed, chained) {
	return gui.TrackerPlugin.extend({

		/**
		 * Free slot for spirit to define any single type of action to dispatch.
		 * @type {String}
		 */
		type: null,

		/**
		 * Free slot for spirit to define any single type of data to dispatch.
		 * @type {Object}
		 */
		data: null,

		/**
		 * Add one or more action handlers.
		 * @param {array|string} arg
		 * @param @optional {object|function} handler
		 * @returns {gui.ActionPlugin}
		 */
		add: confirmed('array|string', '(object|function)')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.Action.IActionHandler, handler)) {
					gui.Array.make(arg).forEach(function(type) {
						this._addchecks(type, [handler, this._global]);
					}, this);
				}
			})
		),

		/**
		 * Remove one or more action handlers.
		 * @param {object} arg
		 * @param @optional {object} handler
		 * @returns {gui.ActionPlugin}
		 */
		remove: confirmed('array|string', '(object|function)')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.Action.IActionHandler, handler)) {
					gui.Array.make(arg).forEach(function(type) {
						this._removechecks(type, [handler, this._global]);
					}, this);
				}
			})
		),

		/**
		 * Add global action handler(s).
		 * @param {object} arg
		 * @param @optional {object} handler
		 * @returns {gui.ActionPlugin}
		 */
		addGlobal: function(arg, handler) {
			return this._globalize(function() {
				return this.add(arg, handler);
			});
		},

		/**
		 * Remove global action handler(s).
		 * @param {object} arg
		 * @param @optional {object} handler
		 * @returns {gui.ActionPlugin}
		 */
		removeGlobal: function(arg, handler) {
			return this._globalize(function() {
				return this.remove(arg, handler);
			});
		},

		/**
		 * Dispatch type(s) ascending.
		 * @alias {gui.ActionPlugin#ascend}
		 * @param {string} type
		 * @param @optional {object} data
		 * @returns {gui.Action}
		 */
		dispatch: confirmed('string', '(*)')(function(type, data) {
			return gui.Action.dispatch(this.spirit, type, data);
		}),

		/**
		 * Dispatch type(s) ascending.
		 * @param {string} type
		 * @param @optional {object} data
		 * @returns {gui.Action}
		 */
		ascend: confirmed('string', '(*)')(function(type, data) {
			return gui.Action.ascend(this.spirit, type, data);
		}),

		/**
		 * Dispatch type(s) descending.
		 * @param {string} type
		 * @param @optional {object} data
		 * @returns {gui.Action}
		 */
		descend: confirmed('string', '(*)')(function(type, data) {
			return gui.Action.descend(this.spirit, type, data);
		}),

		/**
		 * Dispatch type(s) globally (ascending).
		 * @alias {gui.ActionPlugin#ascendGlobal}
		 * @param {string} type
		 * @param @optional {object} data
		 * @returns {gui.Action}
		 */
		dispatchGlobal: confirmed('string', '(*)')(function(type, data) {
			return gui.Action.dispatchGlobal(this.spirit, type, data);
		}),

		/**
		 * Dispatch type(s) globally ascending.
		 * @param {string} type
		 * @param @optional {object} data
		 * @returns {gui.Action}
		 */
		ascendGlobal: confirmed('string', '(*)')(function(type, data) {
			return gui.Action.ascendGlobal(this.spirit, type, data);
		}),

		/**
		 * Dispatch type(s) globally descending.
		 * @param {string} type
		 * @param @optional {object} data
		 * @returns {gui.Action}
		 */
		descendGlobal: confirmed('string', '(*)')(function(type, data) {
			return gui.Action.descendGlobal(this.spirit, type, data);
		}),

		// Private .................................................................

		/**
		 * Remove delegated handlers.
		 * @overwrites {gui.Tracker#_cleanup}
		 * @param {String} type
		 * @param {Array<object>} checks
		 */
		_cleanup: function(type, checks) {
			var handler = checks[0],
				global = checks[1];
			if (global) {
				this.removeGlobal(type, handler);
			} else {
				this.remove(type, handler);
			}
		},

		// Privileged ..............................................................

		/**
		 * Flip to a mode where the spirit will handle it's own action. Corner case
		 * scenario: IframeSpirit watches an action while relaying the same action
		 * from another document context.
		 * @type {boolean}
		 */
		$handleownaction: false,

		/**
		 * Handle action. If it matches listeners, the action will be
		 * delegated to the spirit. Called by crawler in `gui.Action`.
		 * @see {gui.Action#dispatch}
		 * @param {gui.Action} action
		 */
		$onaction: function(action) {
			var list = this._trackedtypes[action.type];
			if (list) {
				list.forEach(function(checks) {
					var handler = checks[0];
					var matches = checks[1] === action.global;
					var hacking = handler === this.spirit && this.$handleownaction;
					if (matches && (handler !== action.target || hacking)) {
						handler.onaction(action);
					}
				}, this);
			}
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));



/**
 * Tracking broadcasts.
 * @extends {gui.TrackerPlugin}
 * @using {gui.Combo#chained}
 */
gui.BroadcastPlugin = (function using(chained, confirmed) {
	return gui.TrackerPlugin.extend({

		/**
		 * Add one or more broadcast handlers.
		 * @param {object} arg
		 * @param @optional {object} handler implements BroadcastListener (defaults to spirit)
		 * @returns {gui.BroadcastPlugin}
		 */
		add: confirmed('string|array')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				var sig = this._global ? null : this._sig;
				gui.Array.make(arg).forEach(function(type) {
					if (this._addchecks(type, [handler, this._global])) {
						if (this._global) {
							gui.Broadcast.addGlobal(type, handler);
						} else {
							gui.Broadcast.add(type, handler, sig);
						}
					}
				}, this);
			})
		),

		/**
		 * Remove one or more broadcast handlers.
		 * @param {object} arg
		 * @param @optional {object} handler implements BroadcastListener (defaults to spirit)
		 * @returns {gui.BroadcastPlugin}
		 */
		remove: confirmed('string|array')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				var sig = this._global ? null : this._sig;
				gui.Array.make(arg).forEach(function(type) {
					if (this._removechecks(type, [handler, this._global])) {
						if (this._global) {
							gui.Broadcast.removeGlobal(type, handler);
						} else {
							gui.Broadcast.remove(type, handler, sig);
						}
					}
				}, this);
			})
		),

		/**
		 * Dispatch type(s).
		 * @param {object} arg
		 * @param @optional {object} data
		 * @returns {gui.Broadcast}
		 */
		dispatch: confirmed('string|array')(
			function(arg, data) {
				var result = null;
				var global = this._global;
				var sig = global ? null : this._sig;
				this._global = false;
				gui.Array.make(arg).forEach(function(type) {
					gui.Broadcast.$target = this.spirit;
					if (global) {
						result = gui.Broadcast.dispatchGlobal(type, data);
					} else {
						result = gui.Broadcast.dispatch(type, data, sig);
					}
				}, this);
				return result;
			}
		),

		/**
		 * Add handlers for global broadcast(s).
		 * @param {object} arg
		 * @param @optional {object} handler implements BroadcastListener (defaults to spirit)
		 * @returns {gui.BroadcastPlugin}
		 */
		addGlobal: function(arg, handler) {
			return this._globalize(function() {
				return this.add(arg, handler);
			});
		},

		/**
		 * Add handlers for global broadcast(s).
		 * @param {object} arg
		 * @param @optional {object} handler implements BroadcastListener (defaults to spirit)
		 * @returns {gui.BroadcastPlugin}
		 */
		removeGlobal: function(arg, handler) {
			return this._globalize(function() {
				return this.remove(arg, handler);
			});
		},

		/**
		 * @param {boolean} on
		 * @param {object} arg
		 * @param @optional {object} handler implements BroadcastListener (defaults to spirit)
		 */
		shiftGlobal: function(on, arg, handler) {
			return this._globalize(function() {
				return this.shift(on, arg, handler);
			});
		},

		/**
		 * Dispatch type(s) globally.
		 * @param {object} arg
		 * @param @optional {object} data
		 * @returns {gui.Broadcast}
		 */
		dispatchGlobal: function(arg, data) {
			return this._globalize(function() {
				return this.dispatch(arg, data);
			});
		},

		// Private .................................................................

		/**
		 * Remove delegated handlers.
		 * @overwrites {gui.Tracker#_cleanup}
		 * @param {String} type
		 * @param {Array<object>} checks
		 */
		_cleanup: function(type, checks) {
			var handler = checks[0],
				global = checks[1];
			if (global) {
				gui.Broadcast.removeGlobal(type, handler);
			} else {
				gui.Broadcast.remove(type, handler, this._sig);
			}
		}

	});
}(gui.Combo.chained, gui.Arguments.confirmed));



/**
 * Tracking timed events.
 * TODO: Global timed events.
 * @extends {gui.TrackerPlugin}
 * @using {gui.Combo#chained}
 * @using {gui.Array} guiArray
 */
gui.TickPlugin = (function using(chained, guiArray) {
	return gui.TrackerPlugin.extend({

		/**
		 * Setup to clear timeouts when destructed.
		 */
		onconstruct: function() {
			gui.TrackerPlugin.prototype.onconstruct.call(this);
			this._timeouts = [];
		},

		/**
		 * Clear timeouts when destructed.
		 */
		ondestruct: function() {
			gui.TrackerPlugin.prototype.ondestruct.call(this);
			this._timeouts.forEach(function(id) {
				gui.Tick.cancelTime(id);
			});
		},

		/**
		 * Add one or more tick handlers.
		 * @param {string|Array<string>} types
		 * @param @optional {object} handler
		 * @param @optional {boolean} one Remove handler after on tick of this type?
		 * @returns {gui.TickPlugin}
		 */
		add: chained(function(types, handler, one) {
			if (!this.spirit.$destructed) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.ITickHandler, handler)) {
					guiArray.make(types).forEach(function(type) {
						if (this._addchecks(type, [handler, this._global])) {
							this._add(type, handler, false);
						}
					}, this);
				}
			}
		}),

		/**
		 * Remove one or more tick handlers.
		 * @param {string|Array<string>} types
		 * @param @optional {object} handler implements
		 *				ActionListener interface, defaults to spirit
		 * @returns {gui.TickPlugin}
		 */
		remove: chained(function(types, handler) {
			handler = handler || this.spirit;
			if (gui.Interface.validate(gui.ITickHandler, handler)) {
				guiArray.make(types).forEach(function(type) {
					if (this._removechecks(type, [handler, this._global])) {
						this._remove(type, handler);
					}
				}, this);
			}
		}),

		/**
		 * Add handler for single tick of given type(s).
		 * TODO: This on ALL trackers :)
		 * @param {string|Array<string>} types
		 * @param @optional {object} handler
		 * @returns {gui.TickPlugin}
		 */
		one: chained(function(types, handler) {
			this.add(types, handler, true);
		}),

		/**
		 * Execute action in next available tick.
		 * TODO: Support cancellation
		 * @param {function} action
		 * @param @optional {object|function} thisp
		 * @returns {gui.TickPlugin}
		 */
		next: chained(function(action, thisp) {
			gui.Tick.next(action, thisp || this.spirit);
		}),

		/**
		 * Execute action in next animation frame.
		 * @param {function} action
		 * @param @optional {object|function} thisp
		 * @returns {gui.TickPlugin}
		 * @returns {number}
		 */
		nextFrame: function(action, thisp) {
			return gui.Tick.nextFrame(action, thisp || this.spirit);
		},

		/**
		 * Cancel scheduled animation frame.
		 * @param {number} n
		 * @returns {gui.TickPlugin}
		 */
		cancelFrame: chained(function(n) {
			gui.Tick.cancelFrame(n);
		}),

		/**
		 * Schedule timeout.
		 * @param {function} action
		 * @param {number} time
		 * @param @optional {object|function} thisp
		 * @returns {number}
		 */
		time: function(action, time, thisp) {
			var id = gui.Tick.time(action, time, thisp || this.spirit);
			this._timeouts.push(id);
			return id;
		},

		/**
		 * Cancel scheduled timeout.
		 * @param {number} n
		 */
		cancelTime: chained(function(n) {
			gui.Tick.cancelTime(n);
		}),

		/**
		 * Shortcut to add and start timer
		 * @param {string} type
		 * @param {number} time
		 * @param @optional {object} handler
		 * @param @optional {boolean} one Remove handler after on tick of this type?
		 * @returns {gui.TickPlugin}
		 */
		addStart: chained(function(type, time, handler, one) {
			gui.Tick.add(type, handler, one).start(type, time);
		}),

		/**
		 * Start tick of type.
		 * @param {string} type
		 * @param {number} time
		 */
		start: chained(function(type, time) {
			gui.Tick.start(type, time);
		}),

		/**
		 * Stop tick of type. This will stop the tick for all
		 * listeners, so perhaps you're looking for `remove`?
		 * @param {string} type
		 */
		stop: chained(function(type) {
			gui.Tick.stop(type);
		}),

		/**
		 * Dispatch tick after given time.
		 * @param {String} type
		 * @param {number} time Milliseconds (zero is setImmediate)
		 * @returns {gui.Tick}
		 */
		dispatch: function(type, time) {
			return this._dispatch(type, time || 0);
		},

		// Private .................................................................

		/**
		 * Global mode?
		 * @type {boolean}
		 */
		_global: false,

		/**
		 * Tracking timeouts so we can cancel them.
		 * @type {Array<number>}
		 */
		_timeouts: null,

		/**
		 * Add handler.
		 * @param {string} type
		 * @param {object|function} handler
		 * @param {boolean} one
		 */
		_add: function(type, handler, one) {
			var sig = this.spirit.$contextid;
			if (one) {
				if (this._global) {
					gui.Tick.oneGlobal(type, handler);
				} else {
					gui.Tick.one(type, handler, sig);
				}
			} else {
				if (this._global) {
					gui.Tick.addGlobal(type, handler);
				} else {
					gui.Tick.add(type, handler, sig);
				}
			}
		},

		/**
		 * Remove handler.
		 * @param {String} type
		 * @param {object|function} handler
		 */
		_remove: function(type, handler) {
			var sig = this.spirit.$contextid;
			if (this._global) {
				gui.Tick.removeGlobal(type, handler);
			} else {
				gui.Tick.remove(type, handler, sig);
			}
		},

		/**
		 * Dispatch.
		 * @param {String} type
		 * @param @optional {number} time
		 */
		_dispatch: function(type, time) {
			var tick, sig = this.spirit.$contextid;
			if (this._global) {
				tick = gui.Tick.dispatchGlobal(type, time);
			} else {
				tick = gui.Tick.dispatch(type, time, sig);
			}
			return tick;
		},

		/**
		 * Remove delegated handlers.
		 * @overwrites {gui.Tracker#_cleanup}
		 * @param {String} type
		 * @param {Array<object>} checks
		 */
		_cleanup: function(type, checks) {
			var handler = checks[0];
			var bglobal = checks[1];
			if (this._remove(type, [handler])) {
				if (bglobal) {
					gui.Tick.removeGlobal(type, handler);
				} else {
					gui.Tick.remove(type, handler, this.$contextid);
				}
			}
		}
	});
}(gui.Combo.chained, gui.Array));



/**
 * Interface TickHandler.
 */
gui.ITickHandler = {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object ITickHandler]';
	},

	/**
	 * Handle tick.
	 * @param {gui.Tick} tick
	 */
	ontick: function(tick) {}
};



/**
 * SpiritLife is a non-bubbling event type that covers the life cycle of a spirit.
 * @see {gui.LifePlugin}
 * @param {gui.Spirit} target
 * @param {String} type
 */
gui.Life = function Life(target, type) {
	this.target = target;
	this.type = type;
};

gui.Life.prototype = {

	/**
	 * @type {gui.Spirit}
	 */
	target: null,

	/**
	 * @type {String}
	 */
	type: null,

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.Life]';
	}
};



/**
 * Tracking spirit life cycle events.
 * TODO: Support optional data argument
 * @extends {gui.TrackerPlugin}
 */
gui.LifePlugin = gui.TrackerPlugin.extend({

	/**
	 * Spirit is constructed? This is almost certainly true by
	 * the time you address the spirit.
	 * @type {boolean}
	 */
	constructed: false,

	/**
	 * Spirit is configured?
	 * @type {boolean}
	 */
	configured: false,

	/**
	 * Is now or has ever been in page DOM?
	 * @type {boolean}
	 */
	entered: false,

	/**
	 * Is currently located in page DOM?
	 * False whenever detached is true.
	 * @TODO: make udefined on startup
	 * @type {boolean}
	 */
	attached: false,

	/**
	 * Is currently not located in page DOM? Note that this is initially
	 * true until the spirit has been discovered and registered as attached.
	 * @TODO: make udefined on startup
	 * @type {boolean}
	 */
	detached: true,

	/**
	 * Is ready? If so, it implies that all descendant spirits are also ready.
	 * @type {boolean}
	 */
	ready: false,

	/**
	 * Is after whatever happens roughly 4 milliseconds after 'ready'?
	 * @type {boolean}
	 */
	async: false,

	/**
	 * Spirit was in page DOM, but has now been removed (ie. it was
	 * detached and not re-attached in the same execution stack).
	 * This schedules the spirit for destruction.
	 * @type {boolean}
	 */
	exited: false,

	/**
	 * Is destructed? If true, don't try anything funny.
	 * @type {boolean}
	 */
	destructed: false,

	/**
	 * Is visible?
	 * @type {boolean}
	 */
	visible: undefined,

	/**
	 * Is rendered? Belongs to edb.module really...
	 * TODO: Move this to the edb module, really.
	 */
	rendered: false,

	/**
	 * Mapping plugin prefix to initialized status, 'false'
	 * is a lazy plugin that has not yet been constructed.
	 * @type {[type]}
	 */
	plugins: null,

	/**
	 * Construction time.
	 * @overrides {gui.Tracker#construct}
	 */
	onconstruct: function() {
		gui.TrackerPlugin.prototype.onconstruct.call(this);
		this._handlers = Object.create(null);
		this.plugins = Object.create(null);
	},

	/**
	 * Add one or more action handlers.
	 * @param {object} arg
	 * @param @optional {object} handler implements LifeListener
	 * interface, defaults to this.spirit
	 * @returns {gui.Spirit}
	 */
	add: function(arg, handler) {
		handler = handler || this.spirit;
		gui.Array.make(arg).forEach(function(type) {
			if (this._addchecks(type, [handler])) {
				if (!this._handlers[type]) {
					this._handlers[type] = [];
				}
				this._handlers[type].push(handler);
			}
		}, this);
		return this.spirit;
	},

	/**
	 * Remove one or more action handlers.
	 * @param {object} arg
	 * @param @optional {object} handler implements LifeListener
	 * interface, defaults to spirit
	 * @returns {gui.Spirit}
	 */
	remove: function(arg, handler) {
		handler = handler || this.spirit;
		gui.Array.make(arg).forEach(function(type) {
			if (this._removechecks(type, [handler])) {
				if (this._handlers[type]) { // weirdo Gecko condition...
					var index = this._handlers[type].indexOf(type);
					gui.Array.remove(this._handlers[type], index);
					if (this._handlers[type].length === 0) {
						delete this._handlers[type];
					}
				}
			}
		}, this);
		return this.spirit;
	},

	/**
	 * Dispatch type and cleanup handlers for
	 * life cycle events that only occurs once.
	 * TODO: support optional data argument
	 * @param {String} type
	 */
	dispatch: function(type) {
		var list = this._handlers[type];
		if (list) {
			var life = new gui.Life(this.spirit, type);
			list.forEach(function(handler) {
				handler.onlife(life);
			});
			switch (type) {
				case gui.LIFE_CONSTRUCT:
				case gui.LIFE_CONFIGURE:
				case gui.LIFE_ENTER:
				case gui.LIFE_READY:
				case gui.LIFE_DETACH:
				case gui.LIFE_EXIT:
				case gui.LIFE_DESTRUCT:
					delete this._handlers[type];
					break;
			}
		}
	},

	/**
	 * TODO: move declaration to super or something (?)
	 * @type {Map<String,Array<object>}
	 */
	_handlers: null,

	/**
	 * Cleanup.
	 */
	_cleanup: function(type, checks) {
		var handler = checks[0];
		this.remove(type, handler);
	}

});



/**
 * Configures a spirit by attribute parsing.
 * TODO: Evaluate properties onconfigure; evaluate methods later.
 * @extends {gui.Plugin}
 */
gui.ConfigPlugin = gui.Plugin.extend({

	/**
	 * Invoked by the {gui.Spirit} once all plugins have been plugged in.
	 *
	 * - Simple properties (booleans etc) will run at {gui.Spirit#onconfigure}
	 * - Methods calls of any kind will be invoked at {gui.Spirit#onready}
	 *
	 * TODO: Simple props with no setter does nothing when updated now.
	 * Perhaps it would be possible to somehow configure those *first*?
	 * TODO: Figure out what the TODO above is supposed to mean
	 */
	configureall: function() {
		var atts = this.spirit.element.attributes;
		Array.forEach(atts, function(att) {
			this.configureone(att.name, att.value);
		}, this);
	},

	/**
	 * Evaluate method updates at {gui.Spirit#onready}.
	 * @param {gui.Life} l
	 */
	onlife: function(l) {
		var update;
		if (l.type === gui.LIFE_READY) {
			while ((update = this._onready.shift())) {
				update.action();
			}
		}
	},

	/**
	 * Setup configuration (if applicable) after an attribute update.
	 * This should probably only ever be invoked by the {gui.AttPlugin}.
	 * @param {string} name
	 * @param {string} value
	 */
	configureone: function(name, value) {
		var hit, gux = this.spirit.window.gui;
		var dot = gui.ConfigPlugin.SEPARATOR;
		gux.attributes.every(function(fix) {
			if ((hit = name.startsWith(fix + dot))) {
				this._evaluate(name, value, fix, dot);
			}
			return !hit;
		}, this);
	},

	// Private ...................................................................

	/**
	 * Collecting method-type updates during spirit initialization.
	 * @type {Array<function>}
	 */
	_onready: null,

	/**
	 * Evaluate single attribute in search for "gui." prefix.
	 * The string value will be autocast to an inferred type.
	 * "false" becomes a boolean while "23" becomes a number.
	 * @param {string} name
	 * @param {string} value
	 * @param {string} fix
	 * @param {string} dot
	 */
	_evaluate: function(name, value, fix, dot) {
		var struct = this.spirit,
			success = true,
			prop = null,
			cuts = null;
		name = prop = name.split(fix + dot)[1];
		if (name.indexOf(dot) > -1) {
			cuts = name.split(dot);
			cuts.forEach(function(cut, i) {
				if (gui.Type.isDefined(struct)) {
					if (i < cuts.length - 1) {
						struct = struct[cut];
					} else {
						prop = cut;
					}
				} else {
					success = false;
				}
			});
		}
		// Note that a "getter" must not returned `undefined` here!
		if (success && gui.Type.isDefined(struct[prop])) {
			this._schedule(struct, prop, this._revaluate(value));
		} else {
			console.error(
				'No definition for "' + name +
				'" in ' + this.spirit.toString()
			);
		}
	},

	/**
	 * Schedule update. Simple properties (strings, booleans, numbers) will be
	 * updated during `onconfigure` while methods will be invoked at `onready`.
	 * @param {object} struct What to update
	 * @param {string} prop Property or method name
	 * @param {object} value Property value or method argument
	 */
	_schedule: function(struct, prop, value) {
		if (gui.Type.isFunction(struct[prop])) {
			if (this.spirit.life.ready) {
				struct[prop](value);
			} else {
				this.spirit.life.add(gui.LIFE_READY, this);
				if (this._onready) {
					this._onready.reduce(function(x, o, i) {
						return o.struct === struct && o.prop === prop ? i : x;
					}, -1);
				} else {
					this._onready = [];
				}
				this._onready.push({
					struct: struct,
					prop: prop,
					action: function() {
						struct[prop](value);
					}
				});
			}
		} else {
			struct[prop] = value;
		}
	},

	/**
	 * Typecast the value.
	 * TODO: Move the EDB hack into EDBML module somehow.
	 * @param {object} value
	 * @returns {object}
	 */
	_revaluate: function(value) {
		if (gui.Type.isString(value)) {
			if (gui.hasModule('edbml@wunderbyte.com') && value.startsWith('edbml.$get')) {
				value = window.edbml.$get(gui.KeyMaster.extractKey(value)[0]);
			} else {
				value = gui.Type.cast(value);
				if (gui.Type.isString(value)) {
					value = gui.ConfigPlugin.jsonvaluate(value);
				}
			}
		}
		return value;
	}

}, { // Static .................................................................

	/**
	 * Run on spirit startup (don't wait for implementation to require it).
	 * @type {boolean}
	 */
	lazy: false,

	/**
	 * Use dots to separate object-path style attributes.
	 * Isolated so that you can overwrite it if you like.
	 * @type {string}
	 */
	SEPARATOR: '.',

	/**
	 * Hack to parse invalid JSON (with no quotes on keys)
	 * as valid JSON, so basically a relaxed `JSON.parse`.
	 * TODO: Now validate that we actually get an object!
	 * @param {string} json
	 * @returns {object}
	 */
	jsonify: (function(div) {
		return function(json) {
			div.setAttribute('onclick', 'this.json = ' + json);
			div.click();
			return div.json;
		};
	})(document.createElement('div')),

	/**
	 * JSONArray or JSONObject scrambled with encodeURIComponent?
	 * If so, let's decode and parse this into an array or object.
	 * @param {string} value
	 * @returns {Array|Object>}
	 */
	jsonvaluate: function(value) {
		if ([
			['%5B', '%5D'],
			['%7B', '%7D']
		].some(function isencoded(tokens) {
			return value.startsWith(tokens[0]) && value.endsWith(tokens[1]);
		})) {
			value = decodeURIComponent(value);
			value = gui.ConfigPlugin.jsonify(value);
		}
		return value;
	}

});



/**
 * Attribute wrapper.
 * @param {String} name
 * @param {String} value
 */
gui.Att = function Att(name, value) {
	this.value = gui.Type.cast(value);
	this.name = this.type = name;
};

gui.Att.prototype = {

	/**
	 * Attribute name.
	 * @type {String}
	 */
	name: null,

	/**
	 * Alias 'name' to conform the API with events, broadcasts, actions etc.
	 * @type {String}
	 */
	type: null,

	/**
	 * Attribute value will be cast to an inferred type, eg. "false" becomes
	 * boolean and "23" becomes number. When handling an attribute, 'null'
	 * implies that the attribute WILL be deleted (it happens after 'onatt').
	 * TODO: look into deleting the attribute first
	 * @type {String|number|boolean|null}
	 */
	value: null
};



/**
 * Manipulate DOM attributes and observe attribute changes.
 * @extends {gui.TrackerPlugin}
 * @using {gui.Arguments#confirmed}
 * @using {gui.Combo#chained}
 * @using {gui.Client} Client
 */
gui.AttPlugin = (function using(confirmed, chained, Client) {
	return gui.TrackerPlugin.extend({

		/**
		 * Get single element attribute cast to an inferred type.
		 * @param {String} att
		 * @returns {String|number|boolean} Autoconverted
		 */
		get: function(name) {
			return gui.AttPlugin.get(this.spirit.element, name);
		},

		/**
		 * Set single element attribute (use null to remove).
		 * @param {String} name
		 * @param {String|number|boolean} value
		 * @returns {gui.AttPlugin}
		 */
		set: chained(function(name, value) {
			if (!this.$suspended) {
				gui.AttPlugin.set(this.spirit.element, name, value);
			}
		}),

		/**
		 * Element has attribute?
		 * @param {String|number|boolean} att
		 * @returns {boolean}
		 */
		has: function(name) {
			return gui.AttPlugin.has(this.spirit.element, name);
		},

		/**
		 * Remove element attribute.
		 * @TODO: Rename "remove" ???
		 * @param {String} att
		 * @returns {gui.AttPlugin}
		 */
		del: chained(function(name) {
			if (!this.$suspended) {
				gui.AttPlugin.del(this.spirit.element, name);
			}
		}),

		/**
		 * Collect attributes as an array (of DOMAttributes).
		 * @returns {Array<Attr>}
		 */
		all: function() {
			return gui.AttPlugin.all(this.spirit.element);
		},

		/**
		 * Set attribute or remove the attribute alltogether.
		 * @param {boolean} on
		 * @param {string} name
		 * @param {string|number|boolean} value
		 * @returns {gui.AttPlugin}
		 */
		shift: confirmed('boolean', 'string')(
			chained(function(on, name, value) {
				if (on) {
					if (value !== undefined) {
						this.set(name, value);
					} else {
						throw new TypeError('Missing value for "' + name + '"');
					}
				} else {
					this.del(name);
				}
			})
		),

		/**
		 * Get all attributes as hashmap type object.
		 * Values are converted to an inferred type.
		 * @returns {Map<String,String>}
		 */
		getmap: function() {
			return gui.AttPlugin.getmap(this.spirit.element);
		},

		/**
		 * Invoke multiple attributes update via hashmap
		 * argument. Use null value to remove an attribute.
		 * @param {Map<String,String>}
		 */
		setmap: function(map) {
			gui.AttPlugin.setmap(this.spirit.element, map);
		},

		/**
		 * Add one or more attribute listeners.
		 * @param {array|string} arg
		 * @param @optional {object|function} handler
		 * @returns {gui.AttPlugin}
		 */
		add: confirmed('array|string', '(object|function)')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.IAttHandler, handler)) {
					gui.Array.make(arg).forEach(function(type) {
						if (this._addchecks(type, [handler])) {
							this._onadd(type);
							if (type === 'class' && Client.isExplorer9) {
								this.spirit.element.addEventListener('DOMAttrModified', this);
							}
						}
					}, this);
				}
			})
		),

		/**
		 * Remove one or more attribute listeners.
		 * @param {object} arg
		 * @param @optional {object} handler
		 * @returns {gui.AttPlugin}
		 */
		remove: confirmed('array|string', '(object|function)')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.IAttHandler, handler)) {
					gui.Array.make(arg).forEach(function(type) {
						if (this._removechecks(type, [handler])) {
							// NOTE: we'll need to enable something in {gui.DOMCombos} to watch `class`!
							if (type === 'class' && Client.isExplorer9) {
								this.spirit.element.removeEventListener('DOMAttrModified', this);
							}
						}
					}, this);
				}
			})
		),

		/**
		 * Handle that mutation event for IE9. Other browsers will be
		 * covered with an override of `className` in {gui.DOMCombos}.
		 * @param {MutationEvent} e
		 */
		handleEvent: function(e) {
			if (e.type === 'DOMAttrModified' && e.attrName === 'class') {
				this.$onatt('class', e.newValue);
			}
		},

		/**
		 * Cleanup weird event listener. The DOMAttrModified event
		 * is by the way not exactly great for overall performance.
		 * @param {String} type
		 * @param {Array<object>} checks
		 */
		_cleanup: function(type, checks) {
			gui.TrackerPlugin.prototype._cleanup.call(this, type,checks);
			if (type === 'class' && Client.isExplorer9) {
				this.spirit.element.removeEventListener('DOMAttrModified', this);
			}
		},

		// Privileged ..............................................................

		/**
		 * Attribute updates disabled?
		 * @type {boolean}
		 */
		$suspended: false,

		/**
		 * Suspend attribute updates for the duration of the
		 * action. This to prevent endless attribute updates.
		 * @param {function} action
		 * @retruns {object}
		 */
		$suspend: function(action) {
			this.$suspended = true;
			var res = action();
			this.$suspended = false;
			return res;
		},

		/**
		 * Trigger potential handlers for attribute update.
		 * @param {String} name
		 * @param {String} value
		 */
		$onatt: function(name, value) {
			var list, att, handler, trigger;
			var triggers = !gui.attributes.every(function(prefix) {
				if ((trigger = name.startsWith(prefix))) {
					this.spirit.config.configureone(name, value);
				}
				return !trigger;
			}, this);
			if (!triggers && (list = this._trackedtypes[name])) {
				att = new gui.Att(name, value);
				list.forEach(function(checks) {
					handler = checks[0];
					handler.onatt(att);
				}, this);
			}
		},

		// Private .................................................................

		/**
		 * Resolve attribute listeners immediately when added.
		 * @param {String} name
		 */
		_onadd: function(name) {
			if (this.has(name)) {
				var value = this.get(name);
				if (name.startsWith(gui.ConfigPlugin.PREFIX)) {
					this.spirit.config.configureone(name, value);
				} else {
					this.$onatt(name, value);
				}
			}
		}

	}, {}, { // Static ...........................................................

		/**
		 * Get single element attribute cast to an inferred type.
		 * @param {Element} elm
		 * @param {String} name
		 * @returns {object} String, boolean or number
		 */
		get: function(elm, name) {
			switch (name) {
				case 'disabled':
				case 'readonly':
				case 'required':
				case 'autofocus':
					return elm.spirit.att.has(elm, name);
			}
			return gui.Type.cast(elm.getAttribute(name));
		},

		/**
		 * Set single element attribute (use null to remove).
		 * @param {Element} elm
		 * @param {String} name
		 * @param {String} value
		 * @param @optional @internal {boolean} $hotfix
		 * @returns {function}
		 */
		set: chained(function(elm, name, value, $hotfix) {
			var spirit = elm.spirit;
			var change = false;

			if (this._ischecked(elm, name)) { // checkbox or radio?
				change = elm.checked !== value;
				elm.checked = String(value) === 'false' ? false : value !== null;
				if (change) {
					spirit.att.$onatt(name, value);
				}
			} else if (this._isvalue(elm, name)) { // input value?
				change = elm.value !== String(value);
				if (change) {
					elm.value = String(value);
					spirit.att.$onatt(name, value);
				}
			} else if (name === 'required') { // required?
				elm.required = !!value;
			} else if (name === 'readonly') { // readonly?
				elm.readOnly = !!value;
			} else if (name === 'disabled') { // disabled?
				elm.disabled = !!value;
			} else if (name === 'autofocus') { // autofocus?
				elm.autofocus = !!value;
			} else if (value === null) { // deleted?
				this.del(elm, name);
			} else { // added or changed
				value = String(value);
				if (elm.getAttribute(name) !== value) {
					if (spirit) {
						spirit.att.$suspend(function() {
							elm.setAttribute(name, value);
						});
						spirit.att.$onatt(name, value);
					} else {
						elm.setAttribute(name, value);
					}
				}
			}
		}),

		/**
		 * @returns {boolean}
		 */
		_ischecked: function(elm, name) {
			return elm.type && elm.checked !== undefined && name === 'checked';
		},

		/**
		 * @returns {boolean}
		 */
		_isvalue: function(elm, name) {
			return elm.value !== undefined && name === 'value';
		},

		/**
		 * Element has attribute?
		 * @param {Element} elm
		 * @param {String} name
		 * @returns {boolean}
		 */
		has: function(elm, name) {
			return elm.hasAttribute(name);
		},

		/**
		 * Remove element attribute.
		 * @param {Element} elm
		 * @param {String} att
		 * @returns {function}
		 */
		del: chained(function(elm, name) {
			var spirit = elm.spirit;
			if (this._ischecked(elm, name)) {
				elm.checked = false;
			} else if (this._isvalue(elm, name)) {
				elm.value = ''; // or what?
			} else {
				if (spirit) {
					spirit.att.$suspend(function() {
						elm.removeAttribute(name);
					});
					if (!spirit.config.configureone(name, null)) {
						spirit.att.$onatt(name, null);
					}
				} else {
					elm.removeAttribute(name);
				}
			}
		}),

		/**
		 * Collect attributes as an array (of DOMAttributes).
		 * @param {Element} elm
		 * @returns {Array<Attr>}
		 */
		all: function(elm) {
			return gui.Array.from(elm.attributes);
		},

		/**
		 * Get all attributes as hashmap type object.
		 * Values are converted to an inferred type.
		 * @param {Element} elm
		 * @returns {Map<String,String>}
		 */
		getmap: function(elm) {
			var map = Object.create(null);
			this.all(elm).forEach(function(att) {
				map[att.name] = gui.Type.cast(att.value);
			});
			return map;
		},

		/**
		 * Invoke multiple attributes update via hashmap
		 * argument. Use null value to remove an attribute.
		 * @param {Element} elm
		 * @param {Map<String,String>}
		 * @returns {function}
		 */
		setmap: chained(function(elm, map) {
			gui.Object.each(map, function(name, value) {
				this.set(elm, name, value);
			}, this);
		})

	});
}(gui.Arguments.confirmed, gui.Combo.chained, gui.Client));



/**
 * Interface AttHandler.
 */
gui.IAttHandler = {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object IAttHandler]';
	},

	/**
	 * Handle attribute update.
	 * @param {gui.Action} action
	 */
	onatt: function(att) {}
};



/**
 * Spirit box object. Note that these are all properties, not methods.
 * @extends {gui.Plugin}
 * TODO: Support globalX, globalY, screenX, screenY
 */
gui.BoxPlugin = gui.Plugin.extend({

	width: 0, // width
	height: 0, // height
	localX: 0, // X relative to positioned ancestor
	localY: 0, // Y relative to positioned ancestor
	pageX: 0, // X relative to the full page (includes scrolling)
	pageY: 0, // Y telative to the full page (includes scrolling)
	clientX: 0, // X relative to the viewport (excludes scrolling)
	clientY: 0, // Y relative to the viewport (excludes scrolling)

	/**
	 * Returns local scrolling element (hotfixed)
	 * TODO: Fix this in gui.Client...
	 * @returns {Element}
	 */
	_scrollroot: function() {
		return (function(doc) {
			if (gui.Client.scrollRoot.localName === 'html') {
				return doc.documentElement;
			} else {
				return doc.body;
			}
		}(this.spirit.document));
	}
});

Object.defineProperties(gui.BoxPlugin.prototype, {

	/**
	 * Width.
	 * @type {number}
	 */
	width: {
		get: function() {
			return this.spirit.element.offsetWidth;
		}
	},

	/**
	 * Height.
	 * @type {number}
	 */
	height: {
		get: function() {
			return this.spirit.element.offsetHeight;
		}
	},

	/**
	 * X relative to positioned ancestor.
	 * @type {number}
	 */
	localX: {
		get: function() {
			return this.spirit.element.offsetLeft;
		}
	},

	/**
	 * Y relative to positioned ancestor.
	 * @type {number}
	 */
	localY: {
		get: function() {
			return this.spirit.element.offsetTop;
		}
	},

	/**
	 * X relative to the full page (includes scrolling).
	 * TODO: IMPORTANT scrollroot must be local to context
	 * @type {number}
	 */
	pageX: {
		get: function() {
			return this.clientX + this._scrollroot().scrollLeft;
		}
	},

	/**
	 * Y relative to the full page (includes scrolling).
	 * TODO: IMPORTANT scrollroot must be local to context
	 * @type {number}
	 */
	pageY: {
		get: function() {
			return this.clientY + this._scrollroot().scrollTop;
		}
	},

	/**
	 * X relative to the viewport (excludes scrolling).
	 * @type {number}
	 */
	clientX: {
		get: function() {
			return this.spirit.element.getBoundingClientRect().left;
		}
	},

	/**
	 * Y relative to the viewport (excludes scrolling).
	 * @type {number}
	 */
	clientY: {
		get: function() {
			return this.spirit.element.getBoundingClientRect().top;
		}
	}
});



/**
 * Spirit styling studio.
 * @extends {gui.Plugin}
 * @using {gui.Combo#chained}
 * @using {gui.Arguments#confirmed}
 */
gui.CSSPlugin = (function using(chained, confirmed) {
	return gui.Plugin.extend({

		/**
		 * Add classname(s).
		 * @param {string|Array<string>} name
		 * @returns {gui.CSSPlugin}
		 */
		add: confirmed('string|array')(chained(function(name) {
			var elm = this.spirit.element;
			gui.Array.make(name).forEach(function(n) {
				gui.CSSPlugin.add(elm, n);
			});
		})),

		/**
		 * Remove classname(s).
		 * @param {String} name
		 * @returns {gui.CSSPlugin}
		 */
		remove: confirmed('string|array')(chained(function(name) {
			var elm = this.spirit.element;
			gui.Array.make(name).forEach(function(n) {
				gui.CSSPlugin.remove(elm, n);
			});
		})),

		/**
		 * Toggle classname(s).
		 * @param {String} name
		 * @returns {gui.CSSPlugin}
		 */
		toggle: confirmed('string|array')(chained(function(name) {
			var elm = this.spirit.element;
			gui.Array.make(name).forEach(function(n) {
				gui.CSSPlugin.toggle(elm, n);
			});
		})),

		/**
		 * Add or remove classname(s) according to first argument.
		 * @param {boolean|object} on
		 * @param {String} name
		 * @returns {gui.CSSPlugin}
		 */
		shift: confirmed('*', 'string|array')(chained(function(on, name) {
			var elm = this.spirit.element;
			gui.Array.make(name).forEach(function(n) {
				gui.CSSPlugin.shift(elm, on, n);
			});
		})),

		/**
		 * Contains classname?
		 * @param {String} name
		 * @returns {boolean}
		 */
		contains: confirmed('string')(function(name) {
			return gui.CSSPlugin.contains(this.spirit.element, name);
		}),

		/**
		 * Set single element.style.
		 * @param {String} prop
		 * @param {String} val
		 * @returns {gui.CSSPlugin}
		 */
		set: chained(function(prop, val) {
			gui.CSSPlugin.set(this.spirit.element, prop, val);
		}),

		/**
		 * Set multiple styles via key value map.
		 * @param {Map<String,String>} map
		 * @returns {gui.CSSPlugin}
		 */
		style: chained(function(map) {
			gui.CSSPlugin.style(this.spirit.element, map);
		}),

		/**
		 * Get single element.style; see also compute method.
		 * @param {String} prop
		 * @returns {String}
		 */
		get: function(prop) {
			return gui.CSSPlugin.get(this.spirit.element, prop);
		},

		/**
		 * Compute runtime style.
		 * @param {String} prop
		 * @returns {String}
		 */
		compute: function(prop) {
			return gui.CSSPlugin.compute(this.spirit.element, prop);
		},

		/**
		 * Get or set (full) className.
		 * @param @optional {String} name
		 * @returns {String|gui.CSSPlugin}
		 */
		name: chained(function(name) {
			var result = this.spirit.element.className;
			if (name !== undefined) {
				this.spirit.element.className = name;
				result = this.spirit;
			}
			return result;
		}),

		/**
		 * Spirit element mathes selector?
		 * @TODO: move to gui.DOMPlugin!
		 * @param {String} selector
		 * @returns {boolean}
		 */
		matches: function(selector) {
			return gui.CSSPlugin.matches(this.spirit.element, selector);
		}

	}, {}, { // Static ...........................................................

		/**
		 * classList.add
		 * @param {Element} element
		 * @param {String} names
		 * @returns {function}
		 */
		add: chained(function(element, name) {
			if (gui.Type.isString(name)) {
				if (name.indexOf(' ') > -1) {
					name = name.split(' ');
				}
				if (gui.Type.isArray(name)) {
					name.forEach(function(n) {
						this.add(element, n);
					}, this);
				} else {
					if (this._supports) {
						if (!element.classList.contains(name)) {
							element.classList.add(name);
						}
					} else {
						var now = element.className.split(' ');
						if (now.indexOf(name) === -1) {
							now.push(name);
							element.className = now.join(' ');
						}
					}
				}
			}
		}),

		/**
		 * classList.remove
		 * @param {Element} element
		 * @param {String} name
		 * @returns {function}
		 */
		remove: chained(function(element, name) {
			if (gui.Type.isString(name)) {
				name = name || '';
				if (name.indexOf(' ') > -1) {
					name = name.split(' ');
				}
				if (gui.Type.isArray(name)) {
					name.forEach(function(n) {
						this.remove(element, n);
					}, this);
				} else {
					if (this._supports) {
						element.classList.remove(name);
					} else {
						var now = element.className.split(' ');
						var idx = now.indexOf(name);
						if (idx > -1) {
							gui.Array.remove(now, idx);
						}
						element.className = now.join(' ');
					}
				}
			}
		}),

		/**
		 * classList.toggle
		 * @param {Element} element
		 * @param {String} name
		 * @returns {function}
		 */
		toggle: chained(function(element, name) {
			if (gui.Type.isString(name)) {
				if (this._supports) {
					element.classList.toggle(name);
				} else {
					if (this.contains(element, name)) {
						this.remove(element, name);
					} else {
						this.add(element, name);
					}
				}
			}
		}),

		/**
		 * Add or remove classname according to second argument.
		 * TODO: for consistancy, the boolean arg must go first!
		 * @param {Element} element
		 * @param {truthy} on
		 * @param {String} name
		 * @returns {function}
		 */
		shift: chained(function(element, on, name) {
			if (on) { // coerce to boolean
				this.add(element, name);
			} else {
				this.remove(element, name);
			}
		}),

		/**
		 * classList.contains
		 * @param {Element} element
		 * @param {String} name
		 * @returns {boolean}
		 */
		contains: function(element, name) {
			if (this._supports) {
				return element.classList.contains(name);
			} else {
				var classnames = element.className.split(' ');
				return classnames.indexOf(name) > -1;
			}
		},

		/**
		 * Set single CSS property. Use style() for multiple properties.
		 * TODO: also automate shorthands such as "10px 20px 10px 20px"
		 * @param {Element}
		 * @param {String} prop
		 * @returns {function}
		 */
		set: chained(function(element, prop, value) {
			value = this._shorthand(prop, value);
			if (prop === 'float') {
				prop = 'cssFloat';
			} else {
				value = this._jsvalue(value);
				prop = this._jsproperty(prop);
			}
			element.style[prop] = value;
		}),

		/**
		 * TODO: Get element.style property; if this has been set.
		 * Not to be confused with compute() for computedStyle!!!
		 * @param {Element}
		 * @param {String} prop
		 * @returns {String}
		 */
		get: function(element, prop) {
			prop = this._jsproperty(prop);
			return this._jsvalue(element.style[prop]);
		},

		/**
		 * Set multiple element.style properties via hashmap. Note that
		 * this method returns the element (ie. it is not chainable).
		 * @param {Element|gui.Spirit} thing Spirit or element.
		 * @param {Map<String,String>} styles
		 * @returns {Element|gui.Spirit}
		 */
		style: function(thing, styles) {
			var element = thing instanceof gui.Spirit ? thing.element : thing;
			gui.Object.each(styles, function(prop, value) {
				this.set(element, prop, value);
			}, this);
			return thing;
		},

		/**
		 * Compute runtime style.
		 * @param {Element|gui.Spirit} thing
		 * @param {String} prop
		 * @returns {String}
		 */
		compute: function(thing, prop) {
			var element = thing instanceof gui.Spirit ? thing.element : thing;
			prop = this._standardcase(this._jsproperty(prop));
			return window.getComputedStyle(element, null).getPropertyValue(prop);
		},

		/**
		 * Node matches CSS selector?
		 * @param {Node} node
		 * @param {String} selector
		 * @returns {boolean}
		 */
		matches: function(node, selector) {
			var matches = false;
			try { // TODO: Something about trycatch not being JIT compatible?
				matches = node[this._matchmethod](selector);
			} catch (dysfunction) {
				console.error('Invalid selector: "' + selector + '"');
				throw dysfunction;
			}
			return matches;
		},

		// Private static ..........................................................

		/**
		 * Non-matching vendors removed after first run. First entry
		 * gets to stay since it represents the unprefixed property.
		 * @type {Array<String>}
		 */
		_vendors: ['', '-webkit-', '-moz-', '-ms-', '-o-'],

		/**
		 * _supports Element.classList?
		 * @type {boolean}
		 */
		_supports: document.documentElement.classList !== undefined,

		/**
		 * Resolve shorthands for value.
		 * @param {string} prop
		 * @param {number|string} value
		 * @returns {string}
		 */
		_shorthand: function(prop, value) {
			var short;
			switch (gui.Type.of(value)) { // not much of a difference (just yet)
				case 'number':
					if ((short = this._numbershorthands[prop])) {
						value = short.replace('@', value);
					}
					break;
				case 'string':
					if ((short = this._stringshorthands[prop])) {
						value = short.replace('@', value);
					}
					break;
			}
			return String(value);
		},

		/**
		 * CamelCase string.
		 * @param {String} string
		 * @returns {String}
		 */
		_camelcase: function(string) {
			return string.replace(/-([a-z])/ig, function(all, letter) {
				return letter.toUpperCase();
			});
		},

		/**
		 * standard-css-notate CamelCased string.
		 * @param {String} string
		 * @returns {String}
		 */
		_standardcase: function(string) {
			return string.replace(/[A-Z]/g, function(all, letter) {
				return '-' + string.charAt(letter).toLowerCase();
			});
		},

		/**
		 * Normalize declaration property for use in element.style scenario.
		 * @param {String} prop
		 * @returns {String}
		 */
		_jsproperty: function(prop) {
			var vendors = this._vendors,
				fixt = prop;
			var element = document.documentElement;
			prop = String(prop);
			if (prop.startsWith('-beta-')) {
				vendors.every(function(vendor) {
					var test = this._camelcase(prop.replace('-beta-', vendor));
					if (element.style[test] !== undefined) {
						fixt = test;
						return false;
					}
					return true;
				}, this);
			} else {
				fixt = this._camelcase(fixt);
			}
			return fixt;
		},

		/**
		 * Normalize declaration value for use in element.style scenario.
		 * @param {String} value
		 * @returns {String}
		 */
		_jsvalue: function(value) {
			var vendors = this._vendors;
			var element = document.documentElement;
			value = String(value);
			if (value && value.includes('-beta-')) {
				var parts = [];
				value.split(', ').forEach(function(part) {
					if ((part = part.trim()).startsWith('-beta-')) {
						vendors.every(function(vendor) {
							var test = this._camelcase(part.replace('-beta-', vendor));
							if (element.style[test] !== undefined) {
								parts.push(part.replace('-beta-', vendor));
								return false;
							}
							return true;
						}, this);
					} else {
						parts.push(part);
					}
				}, this);
				value = parts.join(',');
			}
			return value;
		},

		/**
		 * Normalize declaration property for use in CSS text.
		 * @param {String} prop
		 * @returns {String}
		 */
		_cssproperty: function(prop) {
			return this._standardcase(this._jsproperty(prop));
		},

		/**
		 * Normalize declaration value for use in CSS text.
		 * @param {String} prop
		 * @returns {String}
		 */
		_cssvalue: function(value) {
			return this._standardcase(this._jsvalue(value));
		},

		/**
		 * Number shorthands will autosuffix properties that require units
		 * in support of the syntax: this.css.width = 300 (no method call)
		 * TODO: add more properties
		 * TODO: getters as well as setters
		 * @type {Map<String,String>
		 */
		_numbershorthands: {
			top: '@px',
			right: '@px',
			bottom: '@px',
			left: '@px',
			width: '@px',
			height: '@px',
			maxWidth: '@px',
			maxHeight: '@px',
			minWidth: '@px',
			minHeight: '@px',
			textIndent: '@px',
			margin: '@px',
			marginTop: '@px',
			marginRight: '@px',
			marginBottom: '@px',
			marginLeft: '@px',
			padding: '@px',
			paddingTop: '@px',
			paddingRight: '@px',
			paddingBottom: '@px',
			paddingLeft: '@px',
			fontWeight: '@',
			opacity: '@',
			zIndex: '@'
		},

		/**
		 *
		 */
		_stringshorthands: {
			backgroundImage: 'url("@")',
			position: '@',
			display: '@',
			visibility: '@'
		},

		/**
		 * Lookup vendors "matchesSelector" method.
		 * @type {String}
		 */
		_matchmethod: (function() {
			var match = null,
				root = document.documentElement;
			[
				'mozMatchesSelector',
				'webkitMatchesSelector',
				'msMatchesSelector',
				'oMatchesSelector',
				'matchesSelector'
			].every(function(method) {
				if (gui.Type.isDefined(root[method])) {
					match = method;
				}
				return match === null;
			});
			return match;
		})()

	});
}(
	gui.Combo.chained,
	gui.Arguments.confirmed
));

/**
 * Generate shorthand getters/setters for top|left|width|height etc.
 * @using {constructor} plugin
 */
(function using(Plugin) {
	function getset(prop) {
		Object.defineProperty(Plugin.prototype, prop, {
			enumerable: true,
			configurable: true,
			get: function get() {
				if (this.spirit) {
					return parseInt(this.get(prop), 10);
				}
			},
			set: function set(val) {
				this.set(prop, val);
			}
		});
	}
	[
		Plugin._numbershorthands,
		Plugin._stringshorthands
	].forEach(function(shorts) {
		for (var prop in shorts) {
			if (shorts.hasOwnProperty(prop)) {
				getset(prop);
			}
		}
	});
}(gui.CSSPlugin));



/**
 * DOM query and manipulation.
 * @extends {gui.Plugin}
 * TODO: add `prependTo` method
 * TODO: https://github.com/whatwg/dom/commit/8fa7ac749d1b612504184aad2c20808a1785b370
 * @using {gui.Combo#chained}
 * @using {gui.Guide}
 * @using {gui.DOMObserver}
 */
gui.DOMPlugin = (function using(chained, guide, observer) {
	return gui.Plugin.extend({

		/**
		 * Set or get element id.
		 * @param @optional {String} id
		 * @returns {String|gui.DOMPlugin}
		 */
		id: chained(function(id) {
			if (id) {
				this.spirit.element.id = id;
			} else {
				return this.spirit.element.id || null;
			}
		}),

		/**
		 * Get or set element title (tooltip).
		 * @param @optional {String} title
		 * @returns {String|gui.DOMPlugin}
		 */
		title: chained(function(title) {
			var element = this.spirit.element;
			if (gui.Type.isDefined(title)) {
				element.title = title || '';
			} else {
				return element.title;
			}
		}),

		/**
		 * Get or set element markup.
		 * @param @optional {String} html
		 * @param @optional {String} position
		 * @returns {String|gui.DOMPlugin}
		 */
		html: chained(function(html, position) {
			return gui.DOMPlugin.html(this.spirit.element, html, position);
		}),

		/**
		 * Get or set element outer markup.
		 * @param @optional {String} html
		 * @returns {String|gui.DOMPlugin}
		 */
		outerHtml: chained(function(html) {
			return gui.DOMPlugin.outerHtml(this.spirit.element, html);
		}),

		/**
		 * Get or set element textContent.
		 * @param @optional {String} text
		 * @returns {String|gui.DOMPlugin}
		 */
		text: chained(function(text) {
			return gui.DOMPlugin.text(this.spirit.element, text);
		}),

		/**
		 * Empty spirit subtree.
		 * @returns {gui.DOMPlugin}
		 */
		empty: chained(function() {
			this.html('');
		}),

		/**
		 * Hide spirit element and mark as invisible.
		 * Adds the `._gui-hidden` classname.
		 * @returns {gui.DOMPlugin}
		 */
		hide: chained(function() {
			if (!this.spirit.css.contains(gui.CLASS_HIDDEN)) {
				this.spirit.css.add(gui.CLASS_HIDDEN);
				if (gui.hasModule('gui-layout@wunderbyte.com')) { // TODO: - fix
					if (this.spirit.visibility) { // some kind of Selenium corner case
						this.spirit.visibility.off();
					}
				}
			}
		}),

		/**
		 * Show spirit element and mark as visible.
		 * Removes the `._gui-hidden` classname.
		 * @returns {gui.DOMPlugin}
		 */
		show: chained(function() {
			if (this.spirit.css.contains(gui.CLASS_HIDDEN)) {
				this.spirit.css.remove(gui.CLASS_HIDDEN);
				if (gui.hasModule('gui-layout@wunderbyte.com')) {
					if (this.spirit.visibility) { // some kind of Selenium corner case
						this.spirit.visibility.on();
					}
				}
			}
		}),

		/**
		 * Get spirit element tagname (identicased with HTML).
		 * @returns {String}
		 */
		tag: function() {
			return this.spirit.element.localName;
		},

		/**
		 * Is positioned in page DOM? Otherwise plausible
		 * createElement or documentFragment scenario.
		 * @returns {boolean}
		 */
		embedded: function() {
			return gui.DOMPlugin.embedded(this.spirit.element);
		},

		/**
		 * Removing this spirit from it's parent container. Note that this will
		 * schedule destruction of the spirit unless it gets reinserted somewhere.
		 * Also note that this method is called on the spirit, not on the parent.
		 * @returns {object} Returns the argument
		 */
		remove: function() {
			var parent = this.spirit.element.parentNode;
			if (parent) {
				parent.removeChild(this.spirit.element);
			}
		},

		/**
		 * Clone spirit element.
		 * @return {Element}
		 */
		clone: function() {
			return this.spirit.element.cloneNode(true);
		},

		/**
		 * Get ordinal index of element.
		 * TODO: Support 'of-same-type' or something
		 * @returns {number}
		 */
		ordinal: function() {
			return gui.DOMPlugin.ordinal(this.spirit.element);
		},

		/**
		 * Compare the DOM position of this spirit against something else.
		 * @see http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-compareDocumentPosition
		 * @param {Element|gui.Spirit} other
		 * @returns {number}
		 */
		compare: function(other) {
			return gui.DOMPlugin.compare(this.spirit.element, other);
		},

		/**
		 * Contains other node or spirit?
		 * @param {Node|gui.Spirit} other
		 * @returns {boolean}
		 */
		contains: function(other) {
			return gui.DOMPlugin.contains(this.spirit.element, other);
		},

		/**
		 * Contained by other node or spirit?
		 * @param {Node|gui.Spirit} other
		 * @returns {boolean}
		 */
		containedBy: function(other) {
			return gui.DOMPlugin.contains(other, this.spirit.element);
		},

		/**
		 * Parse HTML to DOM node.
		 * @param {string} html
		 * @returns {Node}
		 */
		parseToNode: function(html) {
			return gui.DOMPlugin.parseToNode(html);
		},

		/**
		 * Parse HTML to array of DOM node(s).
		 * @param {string} html
		 * @returns {Node}
		 */
		parseToNodes: function(html) {
			return gui.DOMPlugin.parseToNodes(html);
		}

	}, {}, { // Static ...........................................................

		/**
		 * Spiritual-aware innerHTML (WebKit first aid).
		 * @param {Element} elm
		 * @param @optional {String} html
		 * @param @optional {String} pos
		 */
		html: function(elm, html, pos) {
			if (gui.Type.isString(html)) {
				if (pos) {
					return elm.insertAdjacentHTML(pos, html);
				} else {
					if (gui.mode === gui.MODE_ROBOT) {
						gui.materializeSub(elm);
						gui.suspend(function() {
							elm.innerHTML = html;
						});
						gui.spiritualizeSub(elm);
					} else {
						elm.innerHTML = html;
					}
				}
			} else {
				return elm.innerHTML;
			}
		},

		/**
		 * Spiritual-aware outerHTML (WebKit first aid).
		 * TODO: deprecate and support "replace" value for position?
		 * TODO: can outerHTML carry multiple root-nodes?
		 * @param {Element} elm
		 * @param @optional {String} html
		 */
		outerHtml: function(elm, html) {
			if (gui.Type.isString(html)) {
				if (gui.mode === gui.MODE_ROBOT) {
					gui.materialize(elm);
					gui.suspend(function() {
						elm.outerHTML = html;
					});
					gui.spiritualize(elm);
				} else {
					elm.outerHTML = html;
				}
			} else {
				return elm.outerHTML;
			}
		},

		/**
		 * Spiritual-aware textContent (WebKit first aid).
		 * @param {Element} elm
		 * @param @optional {String} html
		 * @param @optional {String} position
		 */
		text: function(elm, text) {
			var guide_ = gui.Guide;
			if (gui.Type.isString(text)) {
				if (gui.mode === gui.MODE_ROBOT) {
					guide_.materializeSub(elm);
					gui.suspend(function() {
						elm.textContent = text;
					});
				} else {
					elm.textContent = text;
				}
			} else {
				return elm.textContent;
			}
		},

		/**
		 * Get ordinal position of element within container.
		 * @param {Element} element
		 * @returns {number}
		 */
		ordinal: function(element) {
			var result = 0;
			var parent = element.parentNode;
			if (parent) {
				var node = parent.firstElementChild;
				while (node) {
					if (node === element) {
						break;
					} else {
						node = node.nextElementSibling;
						result++;
					}
				}
			}
			return result;
		},

		/**
		 * Compare document position of two nodes.
		 * @see http://mdn.io/compareDocumentPosition
		 * @param {Node|gui.Spirit} node1
		 * @param {Node|gui.Spirit} node2
		 * @returns {number}
		 */
		compare: function(node1, node2) {
			node1 = node1 instanceof gui.Spirit ? node1.element : node1;
			node2 = node2 instanceof gui.Spirit ? node2.element : node2;
			return node1.compareDocumentPosition(node2);
		},

		/**
		 * Node contains other node?
		 * @param {Node|gui.Spirit} node
		 * @param {Node|gui.Spirit} othernode
		 * @returns {boolean}
		 */
		contains: function(node, othernode) {
			var check = Node.DOCUMENT_POSITION_CONTAINS + Node.DOCUMENT_POSITION_PRECEDING;
			return this.compare(othernode, node) === check;
		},

		/**
		 * Other node is a following sibling to node?
		 * @param {Node|gui.Spirit} node
		 * @param {Node|gui.Spirit} othernode
		 * @returns {boolean}
		 */
		follows: function(node, othernode) {
			return this.compare(othernode, node) === Node.DOCUMENT_POSITION_FOLLOWING;
		},

		/**
		 * Other node is a preceding sibling to node?
		 * @param {Node|gui.Spirit} node
		 * @param {Node|gui.Spirit} othernode
		 * @returns {boolean}
		 */
		precedes: function(node, othernode) {
			return this.compare(othernode, node) === Node.DOCUMENT_POSITION_PRECEDING;
		},

		/**
		 * Is node positioned in page DOM?
		 * TODO: can a check for `this.element.ownerDocument.defaultView` do this?
		 * @param {Element|gui.Spirit} node
		 * @returns {boolean}
		 */
		embedded: function(node) {
			node = node instanceof gui.Spirit ? node.element : node;
			return this.contains(node.ownerDocument, node);
		},

		/**
		 * Remove from list all nodes that are contained by others.
		 * @param {Array<Element|gui.Spirit>} nodes
		 * @returns {Array<Element|gui.Spirit>}
		 */
		group: function(nodes) {
			var node, groups = [];
			function containedby(target, others) {
				return others.some(function(other) {
					return gui.DOMPlugin.contains(other, target);
				});
			}
			while ((node = nodes.pop())) {
				if (!containedby(node, nodes)) {
					groups.push(node);
				}
			}
			return groups;
		},

		/**
		 * Get first element that matches a selector.
		 * Optional type argument filters to spirit of type.
		 * @param {Node} node
		 * @param {String} selector
		 * @param @optional {function} type
		 * @returns {Element|gui.Spirit}
		 */
		q: function(node, selector, type) {
			var result = null;
			return this._qualify(node, selector)(function(node_, selector_) {
				if (type) {
					result = this.qall(node_, selector_, type)[0] || null;
				} else {
					try {
						result = node_.querySelector(selector_);
					} catch (exception) {
						console.error('Dysfunctional selector: ' + selector_);
						throw exception;
					}
				}
				return result;
			});
		},

		/**
		 * Get list of all elements that matches a selector.
		 * Optional type argument filters to spirits of type.
		 * Method always returns a (potentially empty) array.
		 * @param {Node} node
		 * @param {String} selector
		 * @param @optional {function} type
		 * @returns {Array<Element|gui.Spirit>}
		 */
		qall: function(node, selector, type) {
			var result = [];
			return this._qualify(node, selector)(function(node_, selector_) {
				result = gui.Array.from(node_.querySelectorAll(selector_));
				if (type) {
					result = result.filter(function(el) {
						return el.spirit && (el.spirit instanceof type);
					}).map(function(el) {
						return el.spirit;
					});
				}
				return result;
			});
		},

		/**
		 * Get first element in document that matches a selector.
		 * Optional type argument filters to spirit of type.
		 * @param {String} selector
		 * @param @optional {function} type
		 * @returns {Element|gui.Spirit}
		 */
		qdoc: function(selector, type) {
			return this.q(document, selector, type);
		},

		/**
		 * Get list of all elements in document that matches a selector.
		 * Optional type argument filters to spirits of type.
		 * Method always returns a (potentially empty) array.
		 * @param {String} selector
		 * @param @optional {function} type
		 * @returns {Array<Element|gui.Spirit>}
		 */
		qdocall: function(selector, type) {
			return this.qall(document, selector, type);
		},

		// Private static .........................................................

		/**
		 * Support direct children selection using proprietary 'this' keyword
		 * by temporarily assigning the element an ID and modifying the query.
		 * @param {Node} node
		 * @param {String} selector
		 * @param {function} action
		 * @returns {object}
		 */
		_qualify: function(node, selector, action) {
			var hadid = true, orig = node, id, regexp = this._thiskeyword;
			if (node.nodeType === Node.ELEMENT_NODE) {
				if (regexp.test(selector)) {
					hadid = node.id;
					id = node.id = (node.id || gui.KeyMaster.generateKey());
					selector = selector.replace(regexp, '#' + id);
					node = node.ownerDocument;
				}
			}
			return function(action_) {
				var res = action_.call(gui.DOMPlugin, node, selector);
				if (orig && !hadid) {
					orig.id = '';
				}
				return res;
			};
		},

		/**
		 * Match custom 'this' keyword in CSS selector. You can start
		 * selector expressions with "this>*" to find immediate child
		 * TODO: skip 'this' and support simply ">*" and "+*" instead.
		 * UPDATE: This should now be called `:scope` according to the spec!
		 * @see http://dev.w3.org/2006/webapi/selectors-api2/
		 * @type {RegExp}
		 */
		_thiskeyword: /^this|,this/g // TODO: ((^|,)\s*):scope/g

	});
}(
	gui.Combo.chained,
	gui.Guide,
	gui.DOMObserver
));

/**
 * Bind the "this" keyword for all static methods.
 */
gui.Object.bindall(gui.DOMPlugin);

/**
 * DOM query methods accept a CSS selector and an optional spirit constructor
 * as arguments. They return a spirit, an element or an array of either.
 */
gui.DOMPlugin.mixin(
	gui.Object.map({

		/**
		 * Get first descendant element matching selector. Optional type argument returns
		 * spirit for first element to be associated to spirit of this type. Note that
		 * this may not be the first element to match the selector. Also note that type
		 * performs slower than betting on <code>this.dom.q ( "tagname" ).spirit</code>
		 * @param {String} selector
		 * @param @optional {function} type Spirit constructor (eg. gui.Spirit)
		 * @returns {Element|gui.Spirit}
		 */
		q: function(selector, type) {
			return gui.DOMPlugin.q(this.spirit.element, selector, type);
		},

		/**
		 * Get list of all descendant elements that matches a selector. Optional type
		 * arguments returns instead all associated spirits to match the given type.
		 * @param {String} selector
		 * @param @optional {function} type Spirit constructor
		 * @returns {Array<Element|gui.Spirit>}
		 */
		qall: function(selector, type) {
			return gui.DOMPlugin.qall(this.spirit.element, selector, type);
		},

		/**
		 * Same as q, but scoped from the document root. Use wisely.
		 * @param {String} selector
		 * @param @optional {function} type Spirit constructor
		 * returns {Element|gui.Spirit}
		 */
		qdoc: function(selector, type) {
			return gui.DOMPlugin.qdoc(selector, type);
		},

		/**
		 * Same as qall, but scoped from the document root. Use wisely.
		 * @param {String} selector
		 * @param @optional {function} type Spirit constructor
		 * @returns {Array<Element|gui.Spirit>}
		 */
		qdocall: function(selector, type) {
			return gui.DOMPlugin.qdocall(selector, type);
		}

	}, function(name, base) {
		return function() {
			var selector = arguments[0],
				type = arguments[1];
			if (gui.Type.isString(selector)) {
				if (arguments.length === 1 || gui.Type.isFunction(type)) {
					return base.apply(this, arguments);
				} else {
					type = gui.Type.of(type);
					throw new TypeError('Unknown spirit for query: ' + name + '(' + selector + ',' + type + ')');
				}
			} else {
				throw new TypeError('Bad selector for query: ' + name + '(' + selector + ')');
			}
		};
	})
);

/**
 * DOM navigation methods accept an optional spirit constructor as
 * argument. They return a spirit, an element or an array of either.
 */
gui.DOMPlugin.mixin(
	gui.Object.map({

		/**
		 * Next element or next spirit of given type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		next: function(type) {
			var result = null,
				spirit = null,
				el = this.spirit.element;
			if (type) {
				while ((el = el.nextElementSibling) !== null) {
					spirit = el.spirit;
					if (spirit !== null && spirit instanceof type) {
						result = spirit;
						break;
					}
				}
			} else {
				result = el.nextElementSibling;
			}
			return result;
		},

		/**
		 * Previous element or previous spirit of given type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		previous: function(type) {
			var result = null,
				spirit = null,
				el = this.spirit.element;
			if (type) {
				while ((el = el.previousElementSibling) !== null) {
					spirit = el.spirit;
					if (spirit !== null && spirit instanceof type) {
						result = spirit;
						break;
					}
				}
			} else {
				result = el.previousElementSibling;
			}
			return result;
		},

		/**
		 * First element or first spirit of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		first: function(type) {
			var result = null,
				spirit = null,
				el = this.spirit.element.firstElementChild;
			if (type) {
				while (result === null && el !== null) {
					spirit = el.spirit;
					if (spirit !== null && spirit instanceof type) {
						result = spirit;
					}
					el = el.nextElementSibling;
				}
			} else {
				result = el;
			}
			return result;
		},

		/**
		 * Last element or last spirit of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		last: function(type) {
			var result = null,
				spirit = null,
				el = this.spirit.element.lastElementChild;
			if (type) {
				while (result === null && el !== null) {
					spirit = el.spirit;
					if (spirit !== null && spirit instanceof type) {
						result = spirit;
					}
					el = el.previoustElementSibling;
				}
			} else {
				result = el;
			}
			return result;
		},

		/**
		 * Parent parent or parent spirit of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		parent: function(type) {
			var result = this.spirit.element.parentNode;
			if (result && type) {
				var spirit = result.spirit;
				if (spirit && spirit instanceof type) {
					result = spirit;
				} else {
					result = null;
				}
			}
			return result;
		},

		/**
		 * Child element or child spirit of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		child: function(type) {
			var result = this.spirit.element.firstElementChild;
			if (result && type) {
				result = this.children(type)[0] || null;
			}
			return result;
		},

		/**
		 * Children elements or children spirits of type.
		 * TODO: just use this.element.children :)
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Array<Element|gui.Spirit>}
		 */
		children: function(type) {
			var result = gui.Array.from(this.spirit.element.children);
			if (type) {
				result = result.filter(function(elm) {
					return elm.spirit && elm.spirit instanceof type;
				}).map(function(elm) {
					return elm.spirit;
				});
			}
			return result;
		},

		/**
		 * First ancestor element (parent!) or first ancestor spirit of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		ancestor: function(type) {
			var result = this.parent();
			if (type) {
				result = null;
				new gui.Crawler().ascend(this.parent(), {
					handleSpirit: function(spirit) {
						if (spirit instanceof type) {
							result = spirit;
							return gui.Crawler.STOP;
						}
					}
				});
			}
			return result;
		},

		/**
		 * First ancestor elements or ancestor spirits of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Array<Element|gui.Spirit>}
		 */
		ancestors: function(type) {
			var result = [];
			var crawler = new gui.Crawler();
			if (type) {
				crawler.ascend(this.parent(), {
					handleSpirit: function(spirit) {
						if (spirit instanceof type) {
							result.push(spirit);
						}
					}
				});
			} else {
				crawler.ascend(this.parent(), {
					handleElement: function(el) {
						result.push(el);
					}
				});
			}
			return result;
		},

		/**
		 * First descendant element (first child!) first descendant spirit of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Element|gui.Spirit}
		 */
		descendant: function(type) {
			var result = this.child();
			var me = this.spirit.element;
			if (type) {
				new gui.Crawler().descend(me, {
					handleSpirit: function(spirit) {
						if (spirit instanceof type) {
							if (spirit.element !== me) {
								result = spirit;
								return gui.Crawler.STOP;
							}
						}
					}
				});
			}
			return result;
		},

		/**
		 * All descendant elements or all descendant spirits of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Array<Element|gui.Spirit>}
		 */
		descendants: function(type) {
			var result = [];
			var me = this.spirit.element;
			new gui.Crawler().descend(me, {
				handleElement: function(element) {
					if (!type && element !== me) {
						result.push(element);
					}
				},
				handleSpirit: function(spirit) {
					if (type && spirit instanceof type) {
						if (spirit.element !== me) {
							result.push(spirit);
						}
					}
				}
			});
			return result;
		},

		/**
		 * Get following sibling elements or spirits of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Array<element|gui.Spirit>}
		 */
		following: function(type) {
			var result = [],
				spirit, el = this.spirit.element;
			while ((el = el.nextElementSibling)) {
				if (type) {
					if ((spirit = el.spirit) && spirit instanceof type) {
						result.push(spirit);
					}
				} else {
					result.push(el);
				}
			}
			return result;
		},

		/**
		 * Get preceding sibling elements or spirits of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Array<element|gui.Spirit>}
		 */
		preceding: function(type) {
			var result = [],
				spirit, el = this.spirit.element;
			while ((el = el.previousElementSibling)) {
				if (type) {
					if ((spirit = el.spirit) && spirit instanceof type) {
						result.push(spirit);
					}
				} else {
					result.push(el);
				}
			}
			return result;
		},

		/**
		 * Get sibling elements or spirits of type.
		 * @param @optional {constructor} type Spirit constructor
		 * @returns {Array<element|gui.Spirit>}
		 */
		siblings: function(type) {
			return this.preceding(type).concat(this.following(type));
		}

	}, function map(name, base) {
		return function(Type) {
			if (!gui.Type.isDefined(Type) || gui.Type.isFunction(Type)) {
				return base.apply(this, arguments);
			} else {
				throw new TypeError(
					'Unknown spirit for query: ' + name +
					'(' + gui.Type.of(Type) + ')'
				);
			}
		};
	})
);

(function scoped() {
	/**
	 * @TODO fancy insertions
	 */
	gui.DOMPlugin.mixin({

		/**
		 * Append spirit (element) to another spirit or element.
		 * @param {object} thing
		 * @returns {gui.DOMPlugin} or what?
		 */
		appendTo: function(thing) {
			var elm = this.spirit.element;
			if (gui.Type.isSpirit(thing)) {
				thing.dom.append(elm);
			} else if (gui.Type.isElement(thing)) {
				thing.appendChild(elm);
			}
			return this; // or what?
		},

		// @todo implement prependChild()
		// /**
		// * Prepend spirit (element) to another spirit or element.
		// * @param {object} thing
		// * @returns {gui.DOMPlugin} or what?
		// */
		// prependTo: function(thing) {
		//	var elm = this.spirit.element;
		//	if (gui.Type.isSpirit(thing)) {
		//		thing.dom.prepend(elm);
		//	} else if (gui.Type.isElement(thing)) {
		//		thing.prependChild(elm);
		//	}
		//	return this; // or what?
		// },

		/**
		 * Insert spirit (element) before another spirit or element
		 * @param {object} thing
		 * @returns {gui.DOMPlugin} or what?
		 */
		insertBefore: function(thing) {
			var elm = this.spirit.element;
			if (gui.Type.isSpirit(thing)) {
				thing.dom.before(elm);
			} else if (gui.Type.isElement(thing)) {
				thing.parentNode.insertBefore(elm, thing);
			}
			return this; // or what?
		},

		/**
		 * Parse HTML to DOM node.
		 * @param {string} html
		 * @param @optional {Document} targetdoc
		 * @returns {Node}
		 */
		parseToNode: function(html, targetdoc) {
			return gui.HTMLParser.parseToNode(html, targetdoc);
		},

		/**
		 * Parse HTML to array of DOM node(s).
		 * @param {string} html
		 * @param @optional {Document} targetdoc
		 * @returns {Array<Node>}
		 */
		parseToNodes: function(html, targetdoc) {
			return gui.HTMLParser.parseToNodes(html, targetdoc);
		}
	});
}());

/**
 * DOM insertion methods accept one argument: one spirit OR one element OR an array of either or both.
 * The input argument is returned as given. This allows for the following one-liner to be constructed:
 * this.something = this.dom.append ( gui.SomeThingSpirit.summon ( this.document )); // imagine 15 more
 * TODO: Go for compliance with DOM4 method matches (something about textnoding string arguments)
 */

(function scoped() {
	gui.DOMPlugin.mixin(
		gui.Object.map({

			/**
			 * Append spirit OR element OR array of either.
			 * @param {object} things Complicated argument
			 * @returns {object} Returns the argument
			 */
			append: function(things) {
				var els = things,
					element = this.spirit.element;
				els.forEach(function(el) {
					element.appendChild(el);
				});
			},

			/**
			 * Prepend spirit OR element OR array of either.
			 * @param {object} things Complicated argument
			 * @returns {object} Returns the argument
			 */
			prepend: function(things) {
				var els = things,
					element = this.spirit.element,
					first = element.firstChild;
				els.reverse().forEach(function(el) {
					element.insertBefore(el, first);
				});
			},

			/**
			 * Insert spirit OR element OR array of either before this spirit.
			 * @param {object} things Complicated argument
			 * @returns {object} Returns the argument
			 */
			before: function(things) {
				var els = things,
					target = this.spirit.element,
					parent = target.parentNode;
				els.reverse().forEach(function(el) {
					parent.insertBefore(el, target);
				});
			},

			/**
			 * Insert spirit OR element OR array of either after this spirit.
			 * @param {object} things Complicated argument
			 * @returns {object} Returns the argument
			 */
			after: function(things) {
				var els = things,
					target = this.spirit.element,
					parent = target.parentNode;
				els.forEach(function(el) {
					parent.insertBefore(el, target.nextSibling);
				});
			},

			/**
			 * Replace the spirit with something else. This may nuke the spirit.
			 * Note that this method is called on the spirit, not on the parent.
			 * @param {object} things Complicated argument.
			 * @returns {object} Returns the argument
			 */
			replace: function(things) {
				this.after(things);
				this.remove();
			}

		}, function map(name, base) {
			/*
			 * 1. Convert arguments to array of one or more elements
			 * 2. Confirm array of elements (exception supressed pending IE9 issue)
			 * 3. Invoke the base
			 * 4. Return the input
			 * TODO: DocumentFragment and friends
			 * @param {String} name
			 * @param {function} base
			 */
			return function(things) {
				var elms = Array.map(gui.Array.make(things), function(thing) {
					return thing && thing instanceof gui.Spirit ? thing.element : thing;
				}).filter(function(thing) { // TODO: IE9 may sometimes for some reason throw an array in here :/ must investigate!!!
					return thing && gui.Type.isNumber(thing.nodeType); // first check added for FF which now may fail as well :/
				});
				if (elms.length) {
					base.call(this, elms);
				}
				return things;
			};
		})
	);
}());



/**
 * Tracking DOM events.
 * TODO Static interface for general consumption.
 * @extends {gui.TrackerPlugin}
 * @using {gui.Combo#chained} chained
 * @using {gui.Array} guiArray
 * @using {gui.DOMPlugin} DOMplugin
 * @using {gui.Interface} Interface
 * @uisng {gui.Type} Type
 */
gui.EventPlugin = (function using(chained, guiArray, DOMPlugin, Interface, Type) {
	return gui.TrackerPlugin.extend({

		/**
		 * Add one or more DOM event handlers.
		 * TODO: Don't assume spirit handler
		 * @param {object} arg String, array or whitespace-separated-string
		 * @param @optional {object} target Node, Window or XmlHttpRequest. Defaults to spirit element
		 * @param @optional {object} handler implements {gui.IEventHandler}, defaults to spirit
		 * @param @optional {boolean} capture Defaults to false
		 * @returns {gui.EventPlugin}
		 */
		add: chained(function(arg, target, handler, capture) {
			target = this._getelementtarget(target);
			if (target.nodeType || Type.isWindow(target)) {
				handler = handler || this.spirit;
				capture = capture || false;
				if (Interface.validate(gui.IEventHandler, handler)) {
					var checks = [target, handler, capture];
					this._breakdown(arg).forEach(function(type) {
						if (this._addchecks(type, checks)) {
							this._shiftEventListener(true, target, type, handler, capture);
						}
					}, this);
				}
			} else {
				throw new TypeError(
					'Invalid target: ' + target + ' (' + this.spirit.$classname + ')'
				);
			}
		}),

		/**
		 * Add one or more DOM event handlers.
		 * @param {object} arg String, array or whitespace-separated-string
		 * @param @optional {object} target Node, Window or XmlHttpRequest. Defaults to spirit element
		 * @param @optional {object} handler implements {gui.IEventHandler}, defaults to spirit
		 * @param @optional {boolean} capture Defaults to false
		 * @returns {gui.EventPlugin}
		 */
		remove: chained(function(arg, target, handler, capture) {
			target = this._getelementtarget(target);
			if (target.nodeType || Type.isWindow(target)) {
				handler = handler || this.spirit;
				capture = capture || false;
				if (Interface.validate(gui.IEventHandler, handler)) {
					var checks = [target, handler, capture];
					this._breakdown(arg).forEach(function(type) {
						if (this._removechecks(type, checks)) {
							this._shiftEventListener(false, target, type, handler, capture);
						}
					}, this);
				}
			} else {
				throw new TypeError(
					'Invalid target: ' + target + ' (' + this.spirit.$classname + ')'
				);
			}
		}),

		/**
		 * Toggle one or more DOM event handlers.
		 * @param {object} arg String, array or whitespace-separated-string
		 * @param @optional {object} target Node, Window or XmlHttpRequest. Defaults to spirit element
		 * @param @optional {object} handler implements EventListener interface, defaults to spirit
		 * @param @optional {boolean} capture Defaults to false
		 * @returns {gui.EventPlugin}
		 */
		toggle: chained(function(arg, target, handler, capture) {
			target = this._getelementtarget(target);
			handler = handler || this.spirit;
			capture = capture || false;
			if (target instanceof gui.Spirit) {
				target = target.element;
			}
			var checks = [target, handler, capture];
			guiArray.make(arg).forEach(function(type) {
				if (this._contains(type, checks)) {
					this.add(type, target, handler, capture);
				} else {
					this.remove(type, target, handler, capture);
				}
			}, this);
		}),

		/**
		 * Dispatch event.
		 * https://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#customeventinit
		 * http://stackoverflow.com/questions/5342917/custom-events-in-ie-without-using-libraries
		 * @param {string} type
		 * @param @optional {Map} params TODO: If not supported in IE(?), deprecate???
		 * @returns {boolean} True if the event was cancelled (prevetDefaulted)
		 */
		dispatch: function(type, params) {
			var elm = this.spirit.element,
				evt = null;
			if (window.CustomEvent && !gui.Client.isExplorer) { // TODO: IE version???
				evt = new CustomEvent(type, params);
			} else {
				params = params || {
					bubbles: false,
					cancelable: false,
					detail: undefined
				};
				evt = document.createEvent('HTMLEvents');
				evt.initEvent(type, params.bubbles, params.cancelable);
			}
			evt.eventName = type;
			if (elm.dispatchEvent) {
				return elm.dispatchEvent(evt);
			} else if (elm[type]) {
				return elm[type]();
			} else if (elm['on' + type]) {
				return elm['on' + type]();
			}
		},

		/**
		 * TODO: Delete this if Safari supports natively (and otherwise not used)
		 * Handle special event.
		 * @param {Event} e
		 */
		handleEvent: function(e) {
			var related = e.relatedTarget;
			var element = this.spirit.element;
			var inorout = related && related !== element &&
				!DOMPlugin.contains(element, related);
			switch (e.type) {
				case 'mouseover':
					if (inorout && this._mouseenter) {
						this.spirit.onevent(
							this._getfakeevent(e, 'mouseenter')
						);
					}
					break;
				case 'mouseout':
					if (inorout && this._mouseleave) {
						this.spirit.onevent(
							this._getfakeevent(e, 'mouseleave')
						);
					}
					break;
			}
		},

		// Private .................................................................

		/**
		 * Tracking `mouseenter`?
		 * @type {boolean}
		 */
		_mouseenter: false,

		/**
		 * Tracking `mouseout`?
		 * @type {boolean}
		 */
		_mouseleave: false,

		/**
		 * Actual event registration has been isolated so that
		 * one may overwrite or overload this particular part.
		 * @param {boolean} add
		 * @param {Node} target
		 * @param {string} type
		 * @param {object} handler
		 * @param {boolean} capture
		 */
		_shiftEventListener: function(add, target, type, handler, capture) {
			var action = add ? 'addEventListener' : 'removeEventListener';
			target[action](type, handler, capture);
		},

		/**
		 * TODO: Delete this if Safari supports natively!
		 * Reform vendor specific event types to standard event types.
		 * TODO: Elaborate setup to support vendor events universally
		 * @param {boolean} add
		 * @param {string} type
		 * @param {IEventHandler} handler
		 */
		_enterleavetype: function(add, type, handler) {
			var spirit = this.spirit;
			if (handler === spirit) {
				switch (type) {
					case 'mouseenter':
						this._mouseenter = add;
						return 'mouseover';
					case 'mouseleave':
						this._mouseleave = add;
						return 'mouseout';
				}
			} else {
				throw new TypeError(type + ' not (yet) supported on ' + handler);
			}
		},

		/**
		 * Get element for target argument.
		 * @param {Element|gui.Spirit} target
		 * @returns {Element}
		 */
		_getelementtarget: function(target) {
			target = target || this.spirit.element;
			return (target instanceof gui.Spirit ? target.element : target);
		},

		/**
		 * TODO: Delete this if Safari supports natively (and otherwise not used)
		 * Clone the DOM event into a JS
		 * object, then change the type.
		 * @param {Event} realevent
		 * @param {string} newtype
		 * @returns {object}
		 */
		_getfakeevent: function(realevent, newtype) {
			var prop, fakeevent = Object.create(null);
			for (prop in realevent) {
				switch (prop) {
					case 'webkitMovementX':
					case 'webkitMovementY':
						// avoid console "deprecated" warning
						break;
					default:
						fakeevent[prop] = realevent[prop];
						break;
				}
				fakeevent.type = newtype;
			}
			return fakeevent;
		},

		/**
		 * Remove event listeners.
		 * @overwrites {gui.Tracker#_cleanup}
		 * @param {String} type
		 * @param {Array<object>} checks
		 */
		_cleanup: function(type, checks) {
			var target = checks[0];
			var handler = checks[1];
			var capture = checks[2];
			this.remove(type, target, handler, capture);
		},

		/**
		 * Manhandle 'transitionend' event.
		 * @param {Array<String>|String} arg
		 * @returns {Array<String>}
		 */
		_breakdown: function(arg) {
			return guiArray.make(arg).map(function(type) {
				return type === 'transitionend' ? this._transitionend() : type;
			}, this);
		},

		/**
		 * Compute vendor prefixed 'transitionend' event name.
		 * NOTE: Chrome is unprefixed now, Safarai is still left.
		 * NOTE: Some functionality regarding the transitionend
		 *			 event still resides in the "module.js" file!
		 * @TODO: Cache the result somehow...
		 * @returns {String}
		 */
		_transitionend: function() {
			if ('transition' in document.documentElement.style) {
				return 'transitionend';
			} else {
				return 'webkitTransitionEnd';
			}
		}

	});
}(
	gui.Combo.chained,
	gui.Array,
	gui.DOMPlugin,
	gui.Interface,
	gui.Type
));



/**
 * Interface EventHandler.
 *
 */
gui.IEventHandler = {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object IEventHandler]';
	},

	/**
	 * Native DOM interface. We'll forward the event to the method `onevent`.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-EventListener
	 * @param {Event} e
	 */
	handleEvent: function(e) {},

	/**
	 * Conforms to other Spiritual event handlers.
	 * @param {Event} e
	 */
	onevent: function(e) {}
};



/**
 * Transformation time!
 * @TODO: transform more
 * @TODO: support non-px units
 */
gui.SpritePlugin = (function() {
	function total(a, b) { // eslint-disable-line no-unused-vars
		return (a || 0) + b;
	}

	return gui.Plugin.extend({

		/**
		 * X position.
		 * @type {number}
		 */
		x: {
			getter: function() {
				return this._pos.x;
			},
			setter: function(x) {
				this._pos.x = x;
				this._apply();
			}
		},

		/**
		 * Y position.
		 * @type {number}
		 */
		y: {
			getter: function() {
				return this._pos.y;
			},
			setter: function(y) {
				this._pos.y = y;
				this._apply();
			}
		},

		/**
		 * Z position.
		 * @type {number}
		 */
		z: {
			getter: function() {
				return this._pos.z;
			},
			setter: function(z) {
				this._pos.z = z;
				this._apply();
			}
		},

		/**
		 * Construction time.
		 */
		onconstruct: function() {
			gui.Plugin.prototype.onconstruct.call(this);
			this._pos = new gui.Position();
		},

		/**
		 * Reset transformations.
		 */
		reset: function() {
			if (gui.Client.has3D) {
				this.spirit.css.set('-beta-transform', '');
			} else {
				this.spirit.css.left = '';
				this.spirit.css.top = '';
			}
		},

		// Private ...............................................

		/**
		 * Position tracking.
		 * @type {gui.Position}
		 */
		_pos: null,

		/**
		 * Default position as assigned by stylesheet (for IE9).
		 * @type {gui.Position}
		 */
		_def: null,

		/**
		 * Compute default position (in IE9).
		 * @param {gui.CSSPlugin} css
		 * @returns {gui.Position}
		 */
		_defpos: function(css) {
			return this._def || (this._def = new gui.Position(
				parseInt(css.compute('left'), 10),
				parseInt(css.compute('top'), 10)
			));
		},

		/**
		 * Go ahead.
		 */
		_apply: function() {
			var pos = this._pos;
			var set = [pos.x, pos.y, pos.z].map(Math.round);
			var css = this.spirit.css;
			// if (false && set.reduce(total) === 0) {
			// 	this.reset(); // DISABLED FOR NOW!
			// } else {
			if (gui.Client.has3D) {
				css.set('-beta-transform',
					'translate3d(' + set.join('px,') + 'px)'
				);
			} else {
				var def = this._defpos(css);
				css.left = def.x + set[0];
				css.top = def.y + set[1];
			}
			// }
		}
	});
}());



/**
 * Base constructor for all spirits.
 * TODO: Implement `dispose` method.
 */
gui.Spirit = gui.Class.create(Object.prototype, {

	/**
	 * Spirit element.
	 * @type {Element}
	 */
	element: null,

	/**
	 * Containing document (don't use).
	 * @deprecated
	 * @type {Document}
	 */
	document: document,

	/**
	 * Containing window (don't use).
	 * @deprecated
	 * @type {Window}
	 */
	window: window,

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.Spirit]';
	},

	/**
	 * Exorcise spirit from element.
	 * TODO: This whole thing with 'dispose' for all {gui.Class} things
	 */
	exorcise: function() {
		if (!this.life.destructed) {
			gui.Spirit.$destruct(this); // API user should cleanup here
			gui.Spirit.$dispose(this); // everything is destroyed here
		}
	},

	// Sync lifecycle ............................................................

	/**
	 * You can safely overload or overwrite methods in the lifecycle section,
	 * but you should always leave it to the {gui.Guide} to invoke them.
	 * Make sure to always call `this.super.method()` unless you really mean it.
	 */

	/**
	 * `onconstruct` gets called when the spirit is newed up. Spirit
	 * element may not be positioned in the document DOM at this point.
	 */
	onconstruct: function() {},

	/**
	 * `onconfigure` gets callend immediately after construction. This
	 * instructs the spirit to parse configuration attributes in markup.
	 * TODO: Rename to `onconfig`
	 * @see {gui.ConfigPlugin}
	 */
	onconfigure: function() {},

	/**
	 * `onenter` gets called when the spirit element is first
	 * encounted in the page DOM. This is only called once in
	 * the lifecycle of a spirit (unlike `attach`, see below).
	 */
	onenter: function() {},

	/**
	 * `onattach` gets called whenever
	 *
	 * 1. The spirit element is attached to the document DOM by some guy
	 * 2. The element is already in DOM when the page loads and the spirit
	 *		gets injected by the framework
	 */
	onattach: function() {},

	/**
	 * `onready` gets called (only once) when all descendant spirits
	 * are attached and ready. From a DOM tree perspective, this fires
	 * in reverse order, innermost first.
	 */
	onready: function() {},

	/**
	 * Experimental and not even supported.
	 */
	oninit: function() {},

	/**
	 * `ondetach` gets callend whenever the spirit element is about to
	 * be detached from the DOM tree. Unless the element is appended
	 * somewhere else, this will schedule the spirit for destruction.
	 */
	ondetach: function() {},

	/**
	 * `onexit` gets called if the spirit element has been *manually* detached
	 * and not re-attached in the same execution stack. Spirit is not positioned
	 * in the document DOM at this point.
	 */
	onexit: function() {},

	/**
	 * Invoked when spirit is about to be destroyed. Code your last wishes here.
	 * Spirit element may not be positioned in the document DOM at this point.
	 * @TODO: This method currently is NOT CALLED during window.unload, in
	 * that case we skip directly to {gui.GreatSpirit}. Would be nice if the
	 * spirit could eg. save stuff to localstorage at this point...
	 */
	ondestruct: function() {},

	// Async lifecycle ...........................................................

	/**
	 * Invoked some milliseconds after `onattach` to give the browser a repaint
	 * break. TODO: Should be evaluated after 'appendChild' to another position.
	 */
	onasync: function() {},

	// Handlers ..................................................................

	/**
	 * Handle crawler (tell me more)
	 * @param {gui.Crawler} crawler
	 * @returns {number}
	 */
	oncrawler: function(crawler) {},

	// Layout ....................................................................

	/**
	 * Add-hoc reflex mechanism.
	 * @param @optional {function} action
	 * @param @optional {object} thisp
	 */
	reflex: function(action, thisp) {
		if (action) {
			action.apply(thisp);
		}
		new gui.Crawler(gui.CRAWLER_REFLEX).descend(this, {
			handleSpirit: function(spirit) {
				spirit.onflex();
			}
		});
	},

	/**
	 *
	 */
	onflex: function() {},

	// Privileged ................................................................

	/**
	 * Unique key for this spirit instance.
	 * @TODO: Uppercase to imply read-only.
	 * @type {String}
	 */
	$instanceid: null,

	/**
	 * Matches the property `$contextid` of the local `gui` object.
	 * TODO: rename this property
	 * TODO: perhapse deprecate?
	 * TODO: really just deprecate!
	 * @type {String}
	 */
	$contextid: null,

	/**
	 * Don't try anything funny.
	 * @type {boolean}
	 */
	$destructed: false,

	/**
	 * Secret constructor invoked before `onconstruct`.
	 * @param {Element} elm
	 */
	$onconstruct: function(elm) {
		this.$contextid = gui.$contextid;
		this.element = elm;
		this.document = document; // TODO: deprecate
		this.window = window; // TODO: deprecate
		gui.Spirit.$construct(this);
	},

	/**
	 * Secret destructor invvoked after `ondestruct`.
	 */
	$ondestruct: function() {},

	/**
	 * Plug in the plugins. Lazy plugins will be newed up when needed.
	 *
	 * - {gui.LifePlugin} first
	 * - {gui.ConfigPlugin} second
	 * - bonus plugins galore
	 *
	 * @TODO: To preserve order, refactor plugins stack from object to array
	 */
	$pluginplugins: function() {
		var Plugin, plugins = this.constructor.$plugins;
		this.life = new gui.LifePlugin(this);
		this.config = new gui.ConfigPlugin(this);
		Object.keys(plugins).filter(function(prefix) {
			return prefix !== 'life' && prefix !== 'config';
		}).sort().forEach(function(prefix) {
			Plugin = plugins[prefix];
			if ((this.life.plugins[prefix] = !Plugin.lazy)) {
				gui.Plugin.$assign(this, prefix, new Plugin(this));
			} else {
				gui.Plugin.$prepare(this, prefix, Plugin);
			}
		}, this);
	},

	/**
	 * In debug mode, stamp the spirit constructor name onto the spirit element.
	 * Square brackets indicate that the `gui` attribute was added by this method.
	 * @param {boolean} constructing
	 */
	$debug: function(constructing) {
		if (gui.debug) {
			var val, elm = this.element;
			var fix = gui.attributes[0]; // by default using `gui`
			if (constructing) {
				if (gui.attributes.every(function(f) {
					return !elm.hasAttribute(f);
				})) {
					val = '[' + this.constructor.$classname + ']';
					elm.setAttribute(fix, val);
				}
			} else {
				val = elm.getAttribute(fix);
				if (val && val.startsWith('[')) {
					elm.removeAttribute(fix);
				}
			}
		}
	}

}, { // Xstatic (copied onto subclass constructors) ............................

	/**
	 * Portal spirit into iframes via the `gui.portal` method?
	 * @see {ui#portal}
	 * @type {boolean}
	 */
	portals: true,

	/**
	 * Create DOM element and associate gui.Spirit instance.
	 * @param @optional {Document} doc
	 * @returns {gui.Spirit}
	 */
	summon: function(doc) {
		return this.possess((doc || document).createElement('div'));
	},

	/**
	 * Associate gui.Spirit instance to DOM element.
	 * @param {Element} element
	 * @returns {gui.Spirit}
	 */
	possess: function(element) {
		return gui.Guide.$possess(element, this);
	},

	/**
	 * Extend with plugins.
	 * @TODO: move all this to {gui.Class}
	 * @TODO: validate that user isn't declaring non-primitives on the prototype
	 * @param {object} extension
	 * @param {object} recurring
	 * @param {object} statics
	 * @returns {gui.Spirit}
	 */
	extend: function() {
		var C = gui.Class.extend.apply(this, arguments);
		C.$plugins = gui.Object.copy(this.$plugins);
		return C;
	},

	/**
	 * Assign plugin to prefix, checking for naming collision. Prepared for
	 * a scenario where spirits may have been declared before plugins load.
	 * TODO: Stamp the plugin on the prototype instead, if at all possible.
	 * @param {String} prefix "att", "dom", "action", "event" etc
	 * @param {function} plugin Constructor for plugin
	 * @param @optional {boolean} override Disable collision detection
	 * @returns {ts.gui.Spirit}
	 */
	plugin: function(prefix, plugin, override) {
		var plugins = this.$plugins;
		var proto = this.prototype;
		if (!proto.hasOwnProperty(prefix) || proto.prefix === null || override) {
			if (!plugins[prefix] || override) {
				plugins[prefix] = plugin;
				proto.prefix = null;
				gui.Class.children(this, function(child) {
					child.plugin(prefix, plugin, override); // recursing to descendants
				});
			}
		} else {
			console.error('Plugin naming crash in ' + this + ': ' + prefix);
		}
		return this;
	},

	// Privileged ................................................................

	/**
	 * Mapping plugin prefix to plugin constructor.
	 * @type {Map<String,function>}
	 */
	$plugins: Object.create(null)

}, { // Static privileged ......................................................

	/**
	 * Spirit construct gets called by the secret constructor `$onconstruct`.
	 * @param {gui.Spirit} spirit
	 */
	$construct: function(spirit) {
		spirit.$pluginplugins();
		spirit.$debug(true);
		spirit.life.constructed = true;
		spirit.onconstruct();
		spirit.life.dispatch(gui.LIFE_CONSTRUCT);
	},

	/**
	 * Spirit configure.
	 * @param {gui.Spirit} spirit
	 */
	$configure: function(spirit) {
		spirit.config.configureall();
		spirit.life.configured = true;
		spirit.onconfigure();
		spirit.life.dispatch(gui.LIFE_CONFIGURE);
	},

	/**
	 * Spirit enter.
	 * @param {gui.Spirit} spirit
	 */
	$enter: function(spirit) {
		gui.Guide.$inside(spirit);
		spirit.life.entered = true;
		spirit.onenter();
		spirit.life.dispatch(gui.LIFE_ENTER);
	},

	/**
	 * Spirit attach.
	 * @param {gui.Spirit} spirit
	 */
	$attach: function(spirit) {
		gui.Guide.$inside(spirit);
		spirit.life.attached = true;
		spirit.life.detached = false;
		spirit.onattach();
		spirit.life.dispatch(gui.LIFE_ATTACH);
	},

	/**
	 * Spirit ready.
	 * @param {gui.Spirit} spirit
	 */
	$ready: function(spirit) {
		spirit.life.ready = true;
		spirit.onready();
		spirit.life.dispatch(gui.LIFE_READY);
	},

	/**
	 * Spirit detach.
	 * @param {gui.Spirit} spirit
	 */
	$detach: function(spirit) {
		gui.Guide.$outside(spirit);
		spirit.life.attached = false;
		spirit.life.detached = true;
		spirit.life.visible = false; // TODO: remove this!
		spirit.life.dispatch(gui.LIFE_DETACH);
		spirit.life.dispatch(gui.LIFE_INVISIBLE); // ... and this!
		spirit.ondetach();
	},

	/**
	 * Spirit exit.
	 * @param {gui.Spirit} spirit
	 */
	$exit: function(spirit) {
		spirit.life.exited = true;
		spirit.life.dispatch(gui.LIFE_EXIT);
		spirit.onexit();
	},

	/**
	 * Spirit async.
	 * @TODO: This should be evaluated after `appendChild` to another position.
	 * @param {gui.Spirit} spirit
	 */
	$async: function(spirit) {
		spirit.life.async = true;
		spirit.onasync(); // TODO: life cycle stuff goes here
		spirit.life.dispatch(gui.LIFE_ASYNC);
	},

	/**
	 * Spirit destruct.
	 * @param {gui.Spirit} spirit
	 */
	$destruct: function(spirit) {
		spirit.$debug(false);
		spirit.life.destructed = true;
		spirit.life.dispatch(gui.LIFE_DESTRUCT);
		spirit.ondestruct();
	},

	/**
	 * Spirit dispose. This calls the secret destructor `$ondestruct`.
	 * @see {gui.Spirit#$ondestruct}
	 * @param {gui.Spirit} spirit
	 */
	$dispose: function(spirit) {
		spirit.$ondestruct();
		spirit.$destructed = true;
		gui.Guide.$forget(spirit);
		gui.Garbage.$collect(spirit);
	},

	/**
	 * TODO: Init that spirit (work in progress)
	 * TODO: wait and done methods to support this
	 * @param {gui.Spirit} spirit
	 */
	$oninit: function(spirit) {
		spirit.life.initialized = true;
		spirit.life.dispatch('life-initialized');
		spirit.oninit();
	}

});



/**
 * Spirit of the HTML element.
 * @extends {gui.Spirit}
 */
gui.DocumentSpirit = gui.Spirit.extend({

	/**
	 * Get ready.
	 * TODO: think more about late loading (module loading) scenario
	 * TODO: let's go _waiting only if parent is a Spiritual document
	 */
	onready: function() {
		gui.Spirit.prototype.onready.call(this);
		if ((this.waiting = gui.hosted)) { // TODO: get rid of this :(
			this.action.addGlobal(gui.$ACTION_XFRAME_VISIBILITY);
		}
		this.action.dispatchGlobal(gui.ACTION_DOC_ONSPIRITUALIZED);
		this.broadcast.add(gui.BROADCAST_RESIZE_END);
	},

	/**
	 * Handle action.
	 * TODO: Completely remove this xframe visibility stuff!
	 * @param {gui.Action} a
	 */
	onaction: function(a) {
		gui.Spirit.prototype.onaction.call(this, a);
		this.action.$handleownaction = false;
		switch (a.type) {
			case gui.$ACTION_XFRAME_VISIBILITY:
				this._waiting = false;
				if (gui.hasModule('gui-layout@wunderbyte.com')) { // TODO: - fix
					if (a.data === true) {
						this.visibility.on();
					} else {
						this.visibility.off();
					}
				}
				a.consume();
				break;
		}
	},

	/**
	 * Handle broadcast.
	 * @param {gui.Broadcast} b
	 */
	onbroadcast: function(b) {
		gui.Spirit.prototype.onbroadcast.call(this, b);
		if (b.type === gui.BROADCAST_RESIZE_END) {
			this.reflex();
		}
	},

	/**
	 * Don't crawl for visibility inside iframed documents until
	 * hosting {gui.IframeSpirit} has reported visibility status.
	 * @param {gui.Crawler} crawler
	 */
	oncrawler: function(crawler) {
		var dir = gui.Spirit.prototype.oncrawler.call(this, crawler);
		if (dir === gui.Crawler.CONTINUE) {
			switch (crawler.type) {
				case gui.CRAWLER_VISIBLE:
				case gui.CRAWLER_INVISIBLE:
					if (this._waiting) {
						dir = gui.Crawler.STOP;
					}
					break;
			}
		}
		return dir;
	},

	/**
	 * Relay visibility from ancestor frame (match iframe visibility).
	 */
	onvisible: function() {
		this.css.remove(gui.CLASS_INVISIBLE);
		gui.Spirit.prototype.onvisible.call(this);
	},

	/**
	 * Relay visibility from ancestor frame (match iframe visibility).
	 */
	oninvisible: function() {
		this.css.add(gui.CLASS_INVISIBLE);
		gui.Spirit.prototype.oninvisible.call(this);
	},

	// Private ...................................................................

	/**
	 * Flipped on window.onload
	 * @type {boolean}
	 */
	_loaded: false,

	/**
	 * Waiting for hosting {gui.IframeSpirit} to relay visibility status?
	 * @type {boolean}
	 */
	_waiting: false,

	/**
	 * Timeout before we broadcast window resize ended.
	 * This timeout cancels itself on each resize event.
	 * @type {number}
	 */
	_timeout: null

});



/**
 * Spirit of the iframe.
 * @extends {gui.Spirit}
 */
gui.IframeSpirit = gui.Spirit.extend({

	/**
	 * Flipped when the *hosted* document is loaded and spiritualized.
	 * @type {boolean}
	 */
	spiritualized: false,

	/**
	 * Fit height to contained document height (seamless style)?
	 * @type {boolean}
	 */
	fit: false,

	/**
	 * Cross domain origin of hosted document (if that's the case).
	 * @type {String} `http://iframehost.com:8888`
	 */
	xguest: null,

	/**
	 * Hosted window.
	 * @type {Window}
	 */
	contentWindow: {
		getter: function() {
			return this.element.contentWindow;
		}
	},

	/**
	 * Hosted document.
	 * @type {Document}
	 */
	contentDocument: {
		getter: function() {
			return this.element.contentDocument;
		}
	},

	/**
	 * URL details for hosted document.
	 * @type {gui.URL}
	 */
	contentLocation: null,

	/**
	 * Construction time.
	 */
	onconstruct: function() {
		gui.Spirit.prototype.onconstruct.call(this);
		this.event.add('message', window);
		this._postbox = [];
	},

	/**
	 * Stamp SRC on startup.
	 * Configure content document events in order of
	 * appearance and resolve current contentLocation.
	 */
	onenter: function() {
		gui.Spirit.prototype.onenter.call(this);
		this.event.add('load');
		this.action.addGlobal([ // in order of appearance
			gui.ACTION_DOC_ONDOMCONTENT,
			gui.ACTION_DOC_ONLOAD,
			gui.ACTION_DOC_ONHASH,
			gui.ACTION_DOC_ONSPIRITUALIZED,
			gui.ACTION_DOC_UNLOAD
		]);
		if (this.fit) {
			this.css.height = 0;
		}
		var src = this.element.src;
		if (src && src !== gui.IframeSpirit.SRC_DEFAULT) {
			if (!src.startsWith('blob:')) { // wrong...
				this._setupsrc(src);
			}
		}
	},

	/**
	 * Handle action.
	 * @param {gui.Action} a
	 */
	onaction: function(a) {
		gui.Spirit.prototype.onaction.call(this, a);
		this.action.$handleownaction = false;
		var base;
		switch (a.type) {
			case gui.ACTION_DOC_ONDOMCONTENT:
				this.contentLocation = new gui.URL(document, a.data);
				this.life.dispatch(gui.LIFE_IFRAME_DOMCONTENT);
				this.action.remove(a.type);
				a.consume();
				break;
			case gui.ACTION_DOC_ONLOAD:
				this.contentLocation = new gui.URL(document, a.data);
				this.life.dispatch(gui.LIFE_IFRAME_ONLOAD);
				this.action.remove(a.type);
				a.consume();
				break;
			case gui.ACTION_DOC_ONHASH:
				base = this.contentLocation.href.split('#')[0];
				this.contentLocation = new gui.URL(document, base + a.data);
				this.life.dispatch(gui.LIFE_IFRAME_ONHASH);
				a.consume();
				break;
			case gui.ACTION_DOC_ONSPIRITUALIZED:
				this._onspiritualized();
				this.life.dispatch(gui.LIFE_IFRAME_SPIRITUALIZED);
				this.action.remove(a.type);
				a.consume();
				break;
			case gui.ACTION_DOC_UNLOAD:
				this._onunload();
				this.life.dispatch(gui.LIFE_IFRAME_UNLOAD);
				this.action.add([
					gui.ACTION_DOC_ONCONSTRUCT,
					gui.ACTION_DOC_ONDOMCONTENT,
					gui.ACTION_DOC_ONLOAD,
					gui.ACTION_DOC_ONSPIRITUALIZED
				]);
				a.consume();
				break;
		}
	},

	/**
	 * Handle event.
	 * @param {Event} e
	 */
	onevent: function(e) {
		gui.Spirit.prototype.onevent.call(this, e);
		switch (e.type) {
			case 'message':
				this._onmessage(e.data, e.origin, e.source);
				break;
			case 'load':
				// now what?
				break;
		}
	},

	/**
	 * Status visible.
	 */
	onvisible: function() {
		gui.Spirit.prototype.onvisible.call(this);
		if (this.spiritualized) {
			this._visibility();
		}
	},

	/*
	 * Status invisible.
	 */
	oninvisible: function() {
		gui.Spirit.prototype.oninvisible.call(this);
		if (this.spiritualized) {
			this._visibility();
		}
	},

	/**
	 * Get and set the iframe source. Set in markup using <iframe gui.src="x"/>
	 * if you need to postpone iframe loading until the spirit gets initialized.
	 * @param @optional {String} src
	 * @returns @optional {String} src
	 */
	src: function(src) {
		if (src) {
			this._setupsrc(src);
			this.element.src = src;
		}
		return this.element.src;
	},

	/**
	 * Experimentally load some kind of blob.
	 * @param @optional {URL} url
	 * @param @optional {String} src
	 */
	url: function(url, src) {
		if (src) {
			this._setupsrc(src);
		}
		if (url) {
			this.element.src = url;
		}
		return this.contentLocation.href;
	},

	/**
	 * Post message to content window. This method assumes
	 * that we are messaging Spiritual components and will
	 * buffer the messages for bulk dispatch once Spiritual
	 * is known to run inside the iframe.
	 * @param {String} msg
	 */
	postMessage: function(msg) {
		if (this.spiritualized) {
			this.contentWindow.postMessage(msg, '*');
		} else {
			this._postbox.push(msg);
		}
	},

	// Private ...................................................................

	/**
	 * @param {String} src
	 */
	_setupsrc: function(src) {
		var doc = document;
		this.contentLocation = new gui.URL(doc, src);
		this.xguest = (function(secured) {
			if (secured) {
				return '*';
			} else if (gui.URL.external(src, doc)) {
				var url = new gui.URL(doc, src);
				return url.protocol + '//' + url.host;
			}
			return null;
		}(this._sandboxed()));
	},

	/**
	 * Hosted document spiritualized.
	 * Dispatching buffered messages.
	 */
	_onspiritualized: function() {
		this.spiritualized = true;
		while (this._postbox.length) {
			this.postMessage(this._postbox.shift());
		}
		this._visibility();
	},

	/**
	 * Hosted document changed size. Resize to fit?
	 * Dispatching an action to {gui.DocumentSpirit}
	 * @param {number} height
	 */
	_onfit: function(height) {
		if (this.fit) {
			this.css.height = height;
			this.action.dispatchGlobal(gui.ACTION_DOC_FIT);
		}
	},

	/**
	 * Hosted document unloading.
	 */
	_onunload: function() {
		this.spiritualized = false;
		if (this.fit) {
			this.css.height = 0;
		}
	},

	/**
	 * Handle posted message, scanning for ascending actions.
	 * Descending actions are handled by the documentspirit.
	 * TODO: Don't claim this as action target!
	 * @see {gui.DocumentSpirit._onmessage}
	 * @param {String} msg
	 */
	_onmessage: function(msg, origin, source) {
		if (source === this.contentWindow) {
			if (msg.startsWith('spiritual-action:')) {
				var a = gui.Action.parse(msg);
				if (a.direction === gui.Action.ASCEND) {
					this.action.$handleownaction = true;
					this.action.ascendGlobal(a.type, a.data);
				}
			}
		}
	},

	/**
	 * Iframe is sandboxed? Returns `true` even for "allow-same-origin" setting.
	 * @returns {boolean}
	 */
	_sandboxed: function() {
		var sandbox = this.element.sandbox;
		return sandbox && sandbox.length; // && !sandbox.includes ( "allow-same-origin" );
	},

	/**
	 * Teleport visibility crawler to hosted document.
	 * Action intercepted by the {gui.DocumentSpirit}.
	 */
	_visibility: function() {
		if (gui.hasModule('gui-layout@wunderbyte.com')) { // TODO: - fix
			if (gui.Type.isDefined(this.life.visible)) {
				this.action.descendGlobal(
					gui.$ACTION_XFRAME_VISIBILITY,
					this.life.visible
				);
			}
		}
	}

}, { // Recurring static .......................................................

	/**
	 * Summon spirit.
	 * TODO: why does spirit.src method fail strangely
	 *			 just now? using iframe.src instead...
	 * @param {Document} doc
	 * @param @optional {String} src
	 * @returns {gui.IframeSpirit}
	 */
	summon: function(doc, src) {
		var iframe = doc.createElement('iframe');
		var spirit = this.possess(iframe);
		spirit.css.add('gui-iframe');
		/*
		 * TODO: should be moved to src() method (but fails)!!!!!
		 */
		if (src) {
			if (gui.URL.external(src, doc)) {
				var url = new gui.URL(doc, src);
				spirit.xguest = url.protocol + '//' + url.host;
				// src = this.sign ( src, doc, spirit.$instanceid );
			}
		} else {
			src = this.SRC_DEFAULT;
		}
		iframe.src = src;
		return spirit;
	}

}, { // Static .................................................................

	/**
	 * Presumably harmless iframe source. The issue here is that "about:blank"
	 * may raise security concerns for some browsers when running HTTPS setup.
	 * @type {String}
	 */
	SRC_DEFAULT: 'javascript:void(false);'

});



/**
 * Something that has position.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 */
gui.Position = function(x, y, z) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
};

gui.Position.prototype = {

	/**
	 * X position.
	 * @type {number}
	 */
	x: 0,

	/**
	 * Y position.
	 * @type {number}
	 */
	y: 0,

	/**
	 * Z position.
	 * @type {number}
	 */
	z: 0,

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.Position]';
	},

	/**
	 * Clone position.
	 * @returns {gui.Position}
	 */
	clone: function() {
		return new gui.Position(this.x, this.y, this.z);
	}
};

// Static ......................................................................

/**
 * Compare two positions.
 * @param {gui.Position} p1
 * @param {gui.Position} p2
 * @return {boolean}
 */
gui.Position.isEqual = function(p1, p2) {
	return (p1.x === p2.x) && (p1.y === p2.y);
};



/**
 * Something that has 2D width and height.
 * @param {number} w
 * @param {number} h
 */
gui.Dimension = function(w, h) {
	this.w = w || 0;
	this.h = h || 0;
};

gui.Dimension.prototype = {

	/**
	 * Width.
	 * @type {number}
	 */
	w: 0,

	/**
	 * Height.
	 * @type {number}
	 */
	h: 0,

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.Dimension]';
	}
};

// Static ......................................................................

/**
 * Compare two dimensions.
 * @param {gui.Dimension} dim1
 * @param {gui.Dimension} dim2
 * @return {boolean}
 */
gui.Dimension.isEqual = function(dim1, dim2) {
	return (dim1.w === dim2.w) && (dim1.h === dim2.h);
};



/**
 * Something that has 2D position and width and height.
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 */
gui.Geometry = function(x, y, w, h) {
	this.x = x || 0;
	this.y = y || 0;
	this.w = w || 0;
	this.h = h || 0;
};

gui.Geometry.prototype = {

	/**
	 * X position.
	 * @type {number}
	 */
	x: 0,

	/**
	 * Y position.
	 * @type {number}
	 */
	y: 0,

	/**
	 * Width.
	 * @type {number}
	 */
	w: 0,

	/**
	 * Height.
	 * @type {number}
	 */
	h: 0,

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object gui.Geometry]';
	},

	/**
	 * Intersects another (2D) geometry?
	 * @param {gui.Geometry} geo
	 */
	hitTest: function(geo) {
		return gui.Geometry.hitTest(this, geo);
	}
};

// Static ......................................................................

/**
 * Compare two geometries.
 * @param {gui.Geometry} geo1
 * @param {gui.Geometry} geo2
 * @returns {boolean}
 */
gui.Geometry.isEqual = function(geo1, geo2) {
	return (
		(geo1.x === geo2.x) &&
		(geo1.y === geo2.y) &&
		(geo1.w === geo2.w) &&
		(geo1.h === geo2.h)
	);
};

/**
 * Hittest two geometries.
 * @param {gui.Geometry} geo1
 * @param {gui.Geometry} geo2
 * @returns {boolean}
 */
gui.Geometry.hitTest = function(geo1, geo2) {
	function x(g1, g2) {
		return g1.x >= g2.x && g1.x <= g2.x + g2.w;
	}

	function y(g1, g2) {
		return g1.y >= g2.y && g1.y <= g2.y + g2.h;
	}
	var hitx = x(geo1, geo2) || x(geo2, geo1);
	var hity = y(geo1, geo2) || y(geo2, geo1);
	return hitx && hity;
};



/**
 * Spiritualizing documents by overloading DOM methods.
 */
gui.DOMChanger = {

	/**
	 * Declare `spirit` as a fundamental property of things.
	 * @param {Window} win
	 */
	init: function() {
		var proto = Element.prototype;
		if (gui.Type.isDefined(proto.spirit)) {
			throw new Error('Spiritual loaded twice?');
		} else {
			proto.spirit = null; // defineProperty fails in iOS5
		}
	},

	/**
	 * Extend native DOM methods in given window scope.
	 * Wonder what happens now with SVG in Explorer?
	 */
	change: function() {
		var combos = gui.DOMCombos;
		this._changeelement(gui.Client.isExplorer ? HTMLElement : Element, combos);
		this._changefragment(DocumentFragment, this._fragmethods(combos));
	},

	// Private ...................................................................

	/**
	 * Fundamentally change all elements.
	 * @param {constructor} Elm
	 * @param {Map} combos
	 */
	_changeelement: function(Elm, combos) {
		if (this._isoldgecko()) {
			this._changeoldgecko(combos);
		} else {
			this._change(Elm.prototype, combos);
		}
	},

	/**
	 * Fundamentally change all document fragments. When jQuery moves elements
	 * around, it places them in an intermediary document fragment (by default).
	 * @param {constructor} Frag
	 * @param {Map} combosubset
	 */
	_changefragment: function(Frag, combosubset) {
		this._change(Frag.prototype, combosubset);
	},

	/**
	 * Isolate methods that are relevant for document fragments.
	 * @param {Map} combos
	 * @returns {Map}
	 */
	_fragmethods: function(combos) {
		var frag = document.createDocumentFragment();
		return gui.Object.map(combos,
			function fragmentmethod(key, value) {
				if (frag[key]) {
					return value;
				}
			}
		);
	},

	/**
	 * Overloading prototype methods (and properties in OK browsers).
	 * @param {object} proto
	 * @param {Window} win
	 * @param {Map<String,function} combos
	 */
	_change: function(proto, combos) {
		var root = document.documentElement;
		var isok = gui.Client.hasAttributesOnPrototype;
		gui.Object.each(combos, function(name, combo) {
			this._docombo(proto, name, combo, root, isok);
		}, this);
	},

	/**
	 * Old versions of Firefox ignore extending of Element.prototype,
	 * we must step down the prototype chain and extend individually.
	 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=618379
	 */
	_changeoldgecko: function(combos) {
		var did = [];
		this._tags().forEach(function(tag) {
			var e = document.createElement(tag);
			var p = e.constructor.prototype;
			if (p !== Object.prototype) { // excluding object and embed tags
				if (did.indexOf(p) === -1) {
					this._change(p, combos);
					did.push(p); // some elements share the same prototype
				}
			}
		}, this);
	},

	/**
	 * Overload methods and setters.
	 * @param {object} proto
	 * @param {String} name
	 * @param {function} combo
	 * @param {Element} root
	 * @param {boolean} ok
	 */
	_docombo: function(proto, name, combo, root, ok) {
		if (this._ismethod(name)) {
			this._domethod(proto, name, combo);
		} else {
			if (gui.Client.isGecko) {
				this._dogeckoaccesor(proto, name, combo, root);
			} else if (ok) {
				this._doaccessor(proto, name, combo);
			} else {
				// Safari and old Chrome relies on the {gui.DOMObserver}
			}
		}
	},

	/**
	 * Is method? (non-crashing Firefox version)
	 * @returns {boolean}
	 */
	_ismethod: function(name) {
		var is = false;
		switch (name) {
			case 'appendChild':
			case 'removeChild':
			case 'insertBefore':
			case 'replaceChild':
			case 'setAttribute':
			case 'removeAttribute':
			case 'insertAdjecantHTML':
			case 'remove':
				is = true;
				break;
		}
		return is;
	},

	/**
	 * Overload DOM method (same for all browsers).
	 * @param {object} proto
	 * @param {String} name
	 * @param {function} combo
	 */
	_domethod: function(proto, name, combo) {
		var base = proto[name];
		proto[name] = combo(function() {
			return base.apply(this, arguments);
		});
	},

	/**
	 * Overload property setter for modern browsers except Safari.
	 * @param {object} proto
	 * @param {String} name
	 * @param {function} combo
	 * @param {Element} root
	 * @param @optional @internal {boolean} once
	 */
	_doaccessor: function(proto, name, combo, once) {
		var base = Object.getOwnPropertyDescriptor(proto, name);
		if (gui.Client.isExplorer9 && name === 'className') {
			return; // TODO: This condition goes into {gui.DOMCombos} somehow
		}
		if (base) {
			Object.defineProperty(proto, name, {
				configurable: true,
				get: function() {
					return base.get.call(this);
				},
				set: combo(function(value) {
					base.set.call(this, value);
				})
			});
		} else if (!once) { // textContent hotfix (is on different prototype)
			this._doaccessor(Node.prototype, name, combo, true);
		}
	},

	/**
	 * New Firefox can do it the standard way and they will
	 * probably remove the non-standard way at some point.
	 * @param {object} proto
	 * @param {String} name
	 * @param {function} combo
	 * @param {Element} root
	 */
	_dogeckoaccesor: function(proto, name, combo, root) {
		if (this._isoldgecko()) {
			this._dolegacyaccessor(proto, name, combo, root);
		} else {
			this._doaccessor(proto, name, combo);
		}
	},

	/**
	 * Symbol was enabled in Firefox 36 and we'll
	 * just declare anything before this as old.
	 * @returns {boolean}
	 */
	_isoldgecko: function() {
		return gui.Client.isGecko && !(window.Symbol && Symbol.for);
	},

	/**
	 * Overload property setter for old Firefox (as in TS integration tests!).
	 * @param {object} proto
	 * @param {String} name
	 * @param {function} combo
	 * @param {Element} root
	 */
	_dolegacyaccessor: function(proto, name, combo, root) {
		var getter = root.__lookupGetter__(name);
		var setter = root.__lookupSetter__(name);
		if (getter) { // firefox 20 needs a getter for this to work
			proto.__defineGetter__(name, function() {
				return getter.apply(this, arguments);
			});
			proto.__defineSetter__(name, combo(function() {
				setter.apply(this, arguments);
			}));
		} else { // textContent hotfix
			this._doaccessor(Node.prototype, name, combo, root);
		}
	},

	/**
	 * Old Firefox has to traverse the constructor of all elements.
	 * Object and embed tags excluded because the constructor of
	 * these elements appear to be identical to `Object.prototype`.
	 * @returns {Array<string>}
	 */
	_tags: function tags() {
		return ('a abbr address area article aside audio b base bdi bdo blockquote ' +
			'body br button canvas caption cite code col colgroup command datalist dd del ' +
			'details device dfn div dl dt em fieldset figcaption figure footer form ' +
			'h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen ' +
			'label legend li link main map menu meta meter nav noscript ol optgroup option ' +
			'output p param pre progress q rp rt ruby s samp script section select small ' +
			'source span strong style submark summary sup table tbody td textarea tfoot ' +
			'th thead time title tr track ul unknown var video wbr').split(' ');
	}

};



/**
 * DOM decoration time.
 * TODO: Standard DOM exceptions (at our level) for missing arguments and so on.
 * TODO: insertAdjecantHTML
 * TODO: DOM4 methods
 * TODO: Maintain some kind of gui.Guide.detachSub !!!!!!
 * @using {gui.Combo.before} before
 * @using {gui.Combo.after} after
 * @using {gui.Combo.around} around
 * @using {gui.Combo.provided} provided
 */
gui.DOMCombos = (function using(
	before,
	after,
	around,
	provided,
	Type,
	guiArray,
	DOMPlugin
) {
	/**
	 * Is `this` embedded in document? If `this` is a document
	 * fragment, we'll look at those other arguments instead.
	 * @returns {boolean}
	 */
	var ifEmbedded = provided(function(newnode, oldnode) {
		if (Type.isDocumentFragment(this)) {
			return DOMPlugin.embedded(this) ||
				(newnode && DOMPlugin.embedded(newnode)) ||
				(oldnode && DOMPlugin.embedded(oldnode));
		} else {
			return DOMPlugin.embedded(this);
		}
	});

	/**
	 * Element has spirit?
	 * @returns {boolean}
	 */
	var ifSpirit = provided(function() {
		var spirit = gui.get(this);
		return spirit && !spirit.$destructed;
	});

	/**
	 * Spiritualize node plus subtree.
	 * @param {Node} node
	 */
	var spiritualizeAfter = around(function(action, node) {
		var contents = [node];
		if (Type.isDocumentFragment(node)) {
			contents = guiArray.from(node.childNodes);
		}
		action();
		contents.forEach(function(n) {
			gui.spiritualize(n); // TODO: Simply support NodeList and DocFrag here!
		});
	});

	/**
	 * There should never *really* be any document fragments here,
	 * but we will support that just in case it's possible somehow.
	 * @param {Node} node
	 */
	function detach(node) {
		var contents = [node];
		if (Type.isDocumentFragment(node)) {
			contents = guiArray.from(node.childNodes);
		}
		contents.forEach(function(n) {
			gui.Guide.$detach(n); // TODO: Simply support NodeList and DocFrag here!
		});
	}

	/**
	 * Detach node plus subtree.
	 * @param {Node} node
	 */
	var detachBefore = before(function(node) {
		detach(node || this);
	});

	/**
	 * Detach old node plus subtree.
	 * @param {Node} newnode
	 * @param {Node} oldnode
	 */
	var detachOldBefore = before(function(newnode, oldnode) {
		detach(oldnode);
	});

	/**
	 * Spirit-aware setAttribute.
	 * @param {string} name
	 * @param {string} value
	 */
	var setAttBefore = before(function(name, value) {
		gui.get(this).att.set(name, value);
	});

	/**
	 * Spirit-aware removeAttribute.
	 * TODO: use the post combo?
	 * @param {string} name
	 */
	var delAttBefore = before(function(name) {
		gui.get(this).att.del(name);
	});

	/*
	 * Spirit-aware className. Convert js-property change to DOM attribute change
	 * so that attribute listeners can pick it up. Note that this voids the
	 * base `className` call, so let's hope other frameworks don't attempt to
	 * override the native accessor. Note that this doesn't work in IE9,
	 * so other workarounds are needed (Mutation Events in {gui.AttPlugin}).
	 * @param {string} name
	 */
	var setClassBefore = before(function(name) { // eslint-disable-line no-unused-vars
		gui.get(this).att.set('class', name);
	});

	/**
	 * Disable DOM mutation observers while doing action.
	 * @param {function} action
	 */
	var suspending = around(function(action) {
		if (gui.DOMObserver.observes) {
			return gui.DOMObserver.suspend(function() {
				return action();
			});
		} else {
			return action();
		}
	});

	/**
	 * Materialize subtree of `this`.
	 */
	var materializeSubBefore = before(function() {
		// TODO: detach goes here!
		gui.materializeSub(this);
	});

	/**
	 * Spiritualize subtree of `this`
	 */
	var spiritualizeSubAfter = after(function() {
		gui.spiritualizeSub(this);
	});

	/**
	 * Detach `this`.
	 */
	var parent = null; // TODO: unref this at some point
	var materializeThisBefore = before(function() {
		// TODO: detach goes here!
		parent = this.parentNode;
		gui.materialize(this);
	});

	/**
	 * Attach parent.
	 */
	var spiritualizeParentAfter = after(function() {
		gui.spiritualize(parent);
	});

	/**
	 * Spiritualize adjecant.
	 * @param {string} position
	 *		 beforebegin: Before the element itself
	 *		 afterbegin: Just inside the element, before its first child
	 *		 beforeend: Just inside the element, after its last child
	 *		 afterend: After the element itself
	 * @param {string} html
	 */
	var spiritualizeAdjecantAfter = after(function(position, html) {
		switch (position) {
			case 'beforebegin':
				console.warn('TODO: Spiritualize previous siblings');
				break;
			case 'afterbegin':
				console.warn('TODO: Spiritualize first children');
				break;
			case 'beforeend':
				console.warn('TODO: Spiritualize last children');
				break;
			case 'afterend':
				console.warn('TODO: Spiritualize following children');
				break;
		}
	});

	/**
	 * Pretend nothing happened when running in managed mode.
	 * TODO: Simply mirror this prop with an internal boolean
	 */
	var ifEnabled = provided(function() {
		var win = this.ownerDocument.defaultView;
		if (win) {
			return win.gui.mode !== gui.MODE_HUMAN;
		} else {
			return false; // abstract HTMLDocument might adopt DOM combos
		}
	});

	/**
	 * Used to *not* invokle the base function (method or accessor).
	 * Note that this doesn't return anything, so bear that in mind.
	 */
	var voidbase = function() {}; // eslint-disable-line no-unused-vars

	/**
	 * Sugar for combo readability.
	 * @param {function} action
	 * @returns {function}
	 */
	var otherwise = function(action) {
		return action;
	};

	return { // Public ...........................................................

		appendChild: function(base) {
			return (
				ifEnabled(
					ifEmbedded(detachBefore(spiritualizeAfter(suspending(base))),
					otherwise(base)),
				otherwise(base))
			);
		},
		insertBefore: function(base) {
			return (
				ifEnabled(
					ifEmbedded(detachBefore(spiritualizeAfter(suspending(base))),
					otherwise(base)),
				otherwise(base))
			);
		},
		replaceChild: function(base) { // TODO: detach instead
			return (
				ifEnabled(
					ifEmbedded(detachOldBefore(spiritualizeAfter(suspending(base))),
					otherwise(base)),
				otherwise(base))
			);
		},
		insertAdjecantHTML: function(base) {
			return (
				ifEnabled(
					ifEmbedded(spiritualizeAdjecantAfter(suspending(base))),
					otherwise(base)),
				otherwise(base)
			);
		},
		removeChild: function(base) {
			return (
				ifEnabled(
					ifEmbedded(detachBefore(suspending(base)),
					otherwise(base)),
				otherwise(base))
			);
		},
		remove: function(base) {
			return (
				ifEnabled(
					ifEmbedded(detachBefore(suspending(base)),
					otherwise(base)),
				otherwise(base))
			);
		},
		setAttribute: function(base) {
			return (
				ifEnabled(
					ifEmbedded(
						ifSpirit(setAttBefore(base),
						otherwise(base)),
					otherwise(base)),
				otherwise(base))
			);
		},
		removeAttribute: function(base) {
			return (
				ifEnabled(
					ifEmbedded(
						ifSpirit(delAttBefore(base),
						otherwise(base)),
					otherwise(base)),
				otherwise(base))
			);
		},
		innerHTML: function(base) {
			return (
				ifEnabled( // subtree instantly disposed without calling detach - should probably detach first!
					ifEmbedded(materializeSubBefore(spiritualizeSubAfter(suspending(base))),
					otherwise(base)),
				otherwise(base))
			);
		},
		outerHTML: function(base) {
			return (
				ifEnabled( // subtree instantly disposed without calling detach - should probably detach first!
					ifEmbedded(materializeThisBefore(spiritualizeParentAfter(suspending(base))),
					otherwise(base)),
				otherwise(base))
			);
		},
		textContent: function(base) {
			return (
				ifEnabled( // subtree instantly disposed without calling detach - should probably detach first!
					ifEmbedded(materializeSubBefore(suspending(base)),
					otherwise(base)),
				otherwise(base))
			);
		}
		/*
		 * If we should need to create observers for the class attribute that
		 * would also work when updated via the JavaScript `className` property,
		 * we'll need to enable this, but we don't need that for the moment.
		 * Note also the IE9 can't do this and will need an `onpropertychange`
		 * handler be setup somewhere in the {gui.AttPlugin}. Something like
		 * this should also be setup to intercept `disabled` and `id` and such.
		 * @see {gui.AttPlugin}
		 *
		className: function(base) {
			return (
				ifEmbedded(ifSpirit(setClassBefore(voidbase)),
					otherwise(base)
				)
			);
		}
		*/
	};
}(
	gui.Combo.before,
	gui.Combo.after,
	gui.Combo.around,
	gui.Combo.provided,
	gui.Type,
	gui.Array,
	gui.DOMPlugin
));



/**
 * Monitor document for unsolicitated DOM changes and spiritualize
 * elements accordingly. This patches a missing feature in Safari
 * that blocks us from overriding native DOM getters and setters
 * (eg. `innerHTML`). Importantly note that spirits will be attached
 * and detached *asynchronously* with this.
 * @using {gui.Type} Type
 * @using {gui.Array} GuiArray
 */
gui.DOMObserver = (function using(Type, GuiArray) {
	/*
	 * Handle mutations?
	 */
	var connected = true;

	/*
	 * Counting stuff that suspends mutation handling.
	 */
	var suspend = 0;

	/**
	 * Node is element?
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function iselement(node) {
		return node && node.nodeType === Node.ELEMENT_NODE;
	}

	/**
	 * Materialize (whole subtree).
	 * @param {Element} node
	 */
	function materialize(node) {
		var webkithack = true;
		gui.materialize(node, webkithack);
	}

	/**
	 * Spiritualize (whole subtree).
	 * @param {Element} node
	 */
	function spiritualize(node) {
		gui.spiritualize(node);
	}

	/**
	 * Building arrays from nodelists so that they are easier to work with.
	 * @param {Array} array
	 * @param {NodeList} nodelist
	 */
	function concatenate(array, nodelist) {
		return array.concat(GuiArray.from(nodelist));
	}

	/**
	 * Collect added or removed nodes from list of mutations.
	 * @param {Array<MutationRecord>} mutations
	 * @param {boolean} added
	 */
	function collect(mutations, added) {
		return mutations.reduce(function toarray(result, mutation) {
			return concatenate(result, added ? mutation.addedNodes : mutation.removedNodes);
		}, []);
	}

	/**
	 * Collect added nodes (while removing duplicates: Nodes that moved around).
	 * @param {Array<MutationRecord>} mutations
	 */
	function addednodes(mutations) {
		var added = collect(mutations, true);
		return added.filter(function duplicate(node, i) {
			return added.indexOf(node) === i;
		});
	}

	/**
	 * Collect removed nodes (while removing nodes reinserted elsewhere).
	 * @param {Array<MutationRecord>} mutations
	 * @param {Array<Element>} added
	 */
	function removednodes(mutations, added) {
		var removed = collect(mutations, false);
		return removed.filter(function reinserted(node) {
			return added.indexOf(node) === -1;
		});
	}

	/**
	 * Main MutationObserver callback.
	 * @param {Array<MutationRecord>} mutations
	 */
	function handlemutations(mutations) {
		if (connected) {
			var added = addednodes(mutations);
			var removed = removednodes(mutations, added);
			removed.filter(iselement).forEach(materialize);
			added.filter(iselement).forEach(spiritualize);
		}
	}

	return {

		/**
		 * Enabled?
		 * @type {boolean}
		 */
		observes: false,

		/**
		 * Start observing. Note that this runs in WebKit only.
		 * @see {gui.Guide#_spiritualizeinitially}
		 */
		observe: function() {
			if (gui.Client.hasMutations) {
				this.observes = true;
				var Observer = this._mutationobserver();
				new Observer(handlemutations).observe(document, {
					childList: true,
					subtree: true
				});
			} else {
				throw new Error(
					'MutationObserver no such thing: ' +
					'Browser (version) not supported'
				);
			}
		},

		/**
		 * Suspend mutation monitoring of document; enable
		 * monitoring again after executing provided function.
		 * @param {Node} node
		 * @param @optional {function} action
		 * @param @optional {object} thisp
		 * @returns {object} if action was defined, we might return something
		 */
		suspend: function(action, thisp) {
			var res;
			if (this.observes) {
				if (++suspend === 1) {
					connected = false;
				}
			}
			if (Type.isFunction(action)) {
				res = action.call(thisp);
			}
			if (this.observes) {
				this.resume();
			}
			return res;
		},

		/**
		 * Resume monitoring of mutations in document.
		 * @param {Node} node
		 */
		resume: function() {
			if (this.observes) {
				if (--suspend === 0) {
					connected = true;
				}
			}
		},

		// Private .................................................................

		/**
		 * Get MutationObserver.
		 * (IE11 has this now!)
		 * @returns {constructor}
		 */
		_mutationobserver: function() {
			return (
				window.MutationObserver ||
				window.WebKitMutationObserver ||
				window.MozMutationObserver
			);
		}

	};
}(gui.Type, gui.Array));



/**
 * Assist the spirit guide (at least until refactored).
 * @using {gui.Crawler} Crawler
 */
gui.Assistant = (function using(Crawler) {
	return {

		/**
		 * Associate element to new instance of Spirit.
		 * @param {Element} elm
		 * @param {constructor} Spirit
		 * @returns {Spirit}
		 */
		$possess: function(elm, Spirit) {
			if (elm.spirit) {
				throw new Error(
					'Cannot repossess element with spirit ' +
					elm.spirit + ' (exorcise first)'
				);
			} else if (!gui.debug || gui.Type.isSpiritConstructor(Spirit)) {
				elm.spirit = new Spirit(elm);
			} else {
				throw new Error(
					'Not a spirit constructor (' + gui.Type.of(Spirit) + ')'
				);
			}
			return elm.spirit;
		},

		/**
		 * If possible, construct and return spirit for element.
		 * TODO: what's this? http://code.google.com/p/chromium/issues/detail?id=20773
		 * TODO: what's this? http://forum.jquery.com/topic/elem-ownerdocument-defaultview-breaks-when-elem-iframe-document
		 * @param {Element} element
		 * @param {Array} channels
		 * @returns {Spirit} or null
		 */
		$maybepossess: function(elm, channels) {
			var hit;
			if (!elm.spirit) {
				if ((hit = this._maybepossess(elm, channels))) {
					this.$possess(elm, hit);
				}
			}
			return elm.spirit;
		},

		/**
		 * Compare elements to channels and instantiate new spirits.
		 * @param {Element} element
		 * @param {boolean} skip Skip the element?
		 * @param {boolean} one Skip the subtree?
		 * @param {Array} channels
		 * @returns {Array<gui.Spirit>} new spirits
		 */
		$detectspirits: function(element, skip, one, channels) {
			var spirit, spirits = []; // classname = gui.CLASS_NOSPIRITS
			var Assistant = this;
			new Crawler(gui.CRAWLER_SPIRITUALIZE).descend(element, {
				handleElement: function(elm) {
					if (!skip || elm !== element) {
						spirit = elm.spirit;
						if (!spirit) {
							spirit = Assistant.$maybepossess(elm, channels);
						}
						if (spirit) {
							if (!spirit.life.attached) {
								spirits.push(spirit);
							}
						}
					}
					if (one) {
						// TODO: investigate why Crawler.STOP didn't quite work out alright
						return Crawler.SKIP_CHILDREN;
					} else if (!elm.childElementCount) {
						return Crawler.SKIP_CHILDREN;
					} else if (elm.hasAttribute('tempname')) {
						return Crawler.SKIP_CHILDREN;
					} else {
						// TODO: interface for this kind of stuff!
						switch (elm.localName) {
							case 'pre':
							case 'code':
								return Crawler.SKIP_CHILDREN;
						}
					}
					return Crawler.CONTINUE;
				}
			});
			return spirits;
		},

		// Private ...................................................................

		/**
		 * Get Spirit constructor for element.
		 *
		 * 1. Test for element `gui` attribute(s)
		 * 2. Test if element matches selectors
		 * @param {Element} element
		 * @returns {function} Spirit constructor
		 */
		_maybepossess: function(elm, channels) {
			var res = null;
			var experimentalattribute = 'data-ts';	// TRADESHIFT HOTFIX
			if (elm.nodeType === Node.ELEMENT_NODE) {
				if (gui.attributes.every(function(fix) {
					if (fix === experimentalattribute) {
						return true;
					} else {
						res = this._maybepossessinline(elm, fix);
						return res === null;
					}
				}, this)) {
					if (channels) {
						channels.every(function(def) { // TODO!!!!!!!!!!!!!!!!!!
							var select = def[0];
							var spirit = def[1];
							if (gui.CSSPlugin.matches(elm, select)) {
								res = spirit;
							}
							return res === null;
						}, this);
					}
				}
			}
			return res;
		},

		/**
		 * Test for spirit assigned using HTML inline attribute.
		 * Special test for "[" accounts for {gui.Spirit#$debug}
		 * @param {Element} elm
		 * @param {Window} win
		 * @param {String} fix
		 * @returns {function} Spirit constructor
		 */
		_maybepossessinline: function(elm, fix) {
			var res = null;
			var att = elm.getAttribute(fix);
			if (gui.Type.isString(att) && !att.startsWith('[')) {
				if (att !== '') {
					res = gui.Object.lookup(att);
					if (!res) {
						console.error(att + ' is not defined.');
					}
				} else {
					res = false; // strange return value implies no spirit for empty string
				}
			}
			return res;
		}
	};
}(gui.Crawler));



/**
 * The spirit guide crawls the document while channeling
 * spirits into DOM elements that matches CSS selectors.
 * @using {gui.Assistant} Assistant
 * @using {gui.Type} Type
 * @using {gui.Array} Array
 * @using {gui.Broadcast} Broadcast
 * @using {gui.DOMPlugin} DOMPlugin
 * @using {gui.Tick} Tick
 * @using gui.Crawler} Crawler
 */
gui.Guide = (function using(
	Assistant,
	Type,
	guiArray,
	Broadcast,
	DOMPlugin,
	Spirit,
	Tick,
	Crawler) {
	/**
	 * Tracking spirits inside and outside the DOM.
	 * Spirits not in the DOM are scheduled to die.
	 */
	var documentspirits = {
		incoming: [], // spirits just entered the DOM (some milliseconds ago)
		inside: Object.create(null), // spirits positioned in page DOM ("entered" and "attached")
		outside: Object.create(null) // spirits removed from page DOM (currently "detached")
	};

	return {

		/**
		 * Identification.
		 * @returns {String}
		 */
		toString: function() {
			return '[object gui.Guide]';
		},

		/**
		 * Suspend spiritualization and materialization during operation.
		 * @param {function} operation
		 * @param @optional {object} thisp
		 * @returns {object}
		 */
		suspend: function(operation, thisp) {
			this._suspended = true;
			var res = operation.call(thisp);
			this._suspended = false;
			return res;
		},

		// Privileged ..............................................................

		/**
		 * Release the spirits and proclaim the document spiritualized.
		 */
		$startGuiding: function() {
			gui.$stop('- idle time ...');
			this._startGuiding();
			Broadcast.dispatch(gui.BROADCAST_WILL_SPIRITUALIZE);
			gui.$measure('- spiritualize initially', function() {
				this._spiritualizeinitially();
				gui.$stop('boostrap everything');
			}, this);
			Broadcast.dispatch(gui.BROADCAST_DID_SPIRITUALIZE);
		},

		/**
		 * Associate element to new spirit instance.
		 * Offloading this to assistant while we
		 * figure out who should handle this stuff.
		 * @param {Element} elm
		 * @param {constructor} Spirit
		 * @returns {Spirit}
		 */
		$possess: function(elm, newSpirit) {
			return Assistant.$possess(elm, newSpirit);
		},

		/**
		 * Possess element and descendants.
		 * TODO: Jump any detached spirit if matching id (and `jump` is set to true)
		 * @param {Element} target
		 */
		$spiritualize: function(target) {
			target = Type.isSpirit(target) ? target.element : target;
			this._maybespiritualize(target, false, false);
		},

		/**
		 * Possess descendants.
		 * @param {Element|gui.Spirit} target
		 */
		$spiritualizeSub: function(target) {
			this._maybespiritualize(target, true, false);
		},

		/**
		 * Possess one element non-crawling.
		 * @param {Element|gui.Spirit} target
		 */
		$spiritualizeOne: function(target) {
			this._maybespiritualize(target, false, true);
		},

		/**
		 * Dispell spirits from element and descendants.
		 * @param {Element|gui.Spirit} target
		 * @param @optional {boolean} webkithack (not an official thing!)
		 */
		$materialize: function(target, webkithack) {
			this._maybematerialize(target, false, false, webkithack);
		},

		/**
		 * Dispell spirits for descendants.
		 * @param {Element|gui.Spirit} target
		 */
		$materializeSub: function(target) {
			this._maybematerialize(target, true, false);
		},

		/**
		 * Dispell one spirit non-crawling.
		 * @param {Element|gui.Spirit} target
		 */
		$materializeOne: function(target) {
			this._maybematerialize(target, false, true);
		},

		/**
		 * Invoke ondetach for element spirit and descendants spirits.
		 * TODO: This sequence should probably be revisited at some point.
		 * @param {Element|gui.Spirit} target
		 */
		$detach: function(target) {
			this._maybedetach(target);
		},

		/*
		 * Stop tracking the spirit.
		 * TODO: Figure out if `null` is recommended for dereferencing nowadays.
		 * @param {gui.Spirit} spirit
		 */
		$forget: function(spirit) {
			var spirits = documentspirits;
			var key = spirit.$instanceid;
			delete spirits.inside[key];
			delete spirits.outside[key];
			this._stoptracking(spirit);
		},

		/**
		 * Channel spirits to CSS selectors.
		 */
		$channel: function() {
			switch (Type.of(arguments[0])) {
				case 'string':
					this._channelOne.apply(this, arguments);
					break;
				case 'array':
					this._channelAll.apply(this, arguments);
					break;
			}
		},

		/**
		 * Has channels?
		 * @returns {boolean}
		 */
		$hasChannels: function() {
			return this._channels && this._channels.length;
		},

		/**
		 * Get channels (read only).
		 * @type {Array<Array<String,function>>}
		 */
		$getChannels: function() {
			return this._channels.slice();
		},

		/**
		 * Log channels to console.
		 * TODO: create {gui.Developer}
		 */
		$debug: function() {
			console.log(this._channels.reduce(function(log, channel) {
				return log + '\n\n' + channel[0] + ' : ' + channel[1];
			}, location.href));
		},

		/**
		 * Register spirit inside the document.
		 * Evaluate new arrivals after 4 millisec.
		 * @param {gui.Spirit} spirit
		 */
		$inside: function(spirit) {
			var spirits = documentspirits;
			var key = spirit.$instanceid;
			if (!spirits.inside[key]) {
				if (spirits.outside[key]) {
					delete spirits.outside[key];
				}
				spirits.inside[key] = spirit;
				spirits.incoming.push(spirit);
				Tick.dispatch(gui.$TICK_INSIDE, 4);
			}
		},

		/**
		 * Register spirit outside document. This schedules the spirit
		 * for destruction unless reinserted somewhere else (and soon).
		 * @param {Spirit} spirit
		 */
		$outside: function(spirit) {
			var spirits = documentspirits;
			var key = spirit.$instanceid;
			if (!spirits.outside[key]) {
				if (spirits.inside[key]) {
					delete spirits.inside[key];
					this._stoptracking(spirit);
				}
				spirits.outside[key] = spirit;
				Tick.dispatch(gui.$TICK_OUTSIDE, 0);
			}
		},

		/**
		 * Invoked by {gui.Spiritual} some milliseconds after
		 * all spirits have been attached to the page DOM.
		 * @param {Array<gui.Spirit>} spirits
		 */
		$goasync: function(spirits) {
			spirits.forEach(function(spirit) {
				Spirit.$async(spirit);
			});

			/*
			 * Temp hack: DocumentSpirit inside *iframe* must
			 * wait for visibility status to relay elsehow...
			 * (this stuff must all move to the plugin)
			 * @see {gui.IframeSpirit}
			 */
			if (gui.hosted) {
				var docspirit = gui.get(document.documentElement);
				if (!docspirit || docspirit.life.visible === undefined) {
					return;
				}
			}
			this._visibility(spirits);
		},

		/**
		 * Get spirit by `$instanceid`.
		 * Please go via `gui.get(id)`.
		 * @param {string} key
		 * @returns {gui.Spirit}
		 */
		$getSpiritById: function(key) {
			return documentspirits.inside[key] || null;
		},

		// Private .................................................................

		/**
		 *
		 */
		_arrivals: Object.create(null),

		/**
		 * Lisitng CSS selectors associated to Spirit constructors.
		 * Order is important: First spirit to match selector is it.
		 * @type {Array<Array<String,function>>}
		 */
		_channels: [],

		/**
		 * Some kind of temp fix.
		 * @type {Array<object>}
		 */
		_todochannels: null,

		/**
		 * Ignore DOM mutations?
		 * @type {boolean}
		 */
		_suspended: false,

		/**
		 * Setup to handle spirits entering and leaving the DOM.
		 * Flush channelings that were bufffered during bootup.
		 */
		_startGuiding: function() {
			var ticks = [gui.$TICK_INSIDE, gui.$TICK_OUTSIDE];
			gui.Tick.add(ticks, {
				ontick: function(tick) {
					if (tick.type === ticks[0]) {
						gui.Guide._updateincoming();
					} else {
						gui.Guide._updateoutside();
					}
				}
			});
			if (this._todochannels) {
				this._channelAll(this._todochannels);
				this._todochannels = null;
			}
		},

		/**
		 * 1. Always spiritualize the HTML element {gui.DocumentSpirit}.
		 * 2. Robot mode: Overload native DOM methods
		 * 3. Robot mode: Monitor DOM for unhandled mutations (WebKit)
		 * 4. Robot mode: Spiritualize everything
		 * 5. (make sure that `onready` is called on the root spirit last)
		 * @param {Window} win
		 * @param {Document} doc
		 */
		_spiritualizeinitially: function() {
			var root = document.documentElement;
			gui.DOMChanger.init();
			this.$spiritualizeOne(root);
			if (gui.mode === gui.MODE_ROBOT) {
				gui.DOMChanger.change();
				if (!gui.Client.hasAttributesOnPrototype) {
					gui.DOMObserver.observe();
				}
				this.$spiritualizeSub(root);
			}
			Spirit.$ready(gui.get(root));
		},

		/**
		 * Continue with spiritualize/materialize of given node? The 'webkithack'
		 * relates to the problem with Safari (and old Chrome) where removed nodes
		 * get detected asynchronously and is therefore NOT embedded when we run.
		 * @param {Node} node
		 * @param @optional {boolean} webkithack (sometimes true on nodes removed)
		 * @returns {boolean}
		 */
		_handles: function(node, webkithack) {
			return node && !this._suspended &&
				(webkithack || DOMPlugin.embedded(node)) &&
				Type.isElement(node);
		},

		/**
		 * Collect non-destructed spirits from element and descendants.
		 * @param {Node} node
		 * @param @optional {boolean} skip Skip start element
		 * @returns {Array<gui.Spirit>}
		 */
		_collect: function(node, skip, id) {
			var list = [];
			new Crawler(id).descend(node, {
				handleSpirit: function(spirit) {
					if (skip && spirit.element === node) {
						// nothing
					} else if (!spirit.life.destructed) {
						list.push(spirit);
					}
				}
			});
			return list;
		},

		/**
		 * Spiritualize node perhaps.
		 * @param {Node|gui.Spirit} node
		 * @param {boolean} skip Skip the element?
		 * @param {boolean} one Skip the subtree?
		 */
		_maybespiritualize: function(node, skip, one) {
			node = Type.isSpirit(node) ? node.element : node;
			node = Type.isDocument(node) ? node.documentElement : node;
			if (this._handles(node)) {
				this._spiritualize(node, skip, one);
			}
		},

		/**
		 * Evaluate spirits for element and subtree.
		 *
		 * - Construct spirits in document order
		 * - Fire life cycle events except `ready` in document order
		 * - Fire `ready` in reverse document order (innermost first)
		 *
		 * @param {Element} element
		 * @param {boolean} skip Skip the element?
		 * @param {boolean} one Skip the subtree?
		 */
		_spiritualize: function(elm, skip, one) {
			var spirits, channels = this._channels;
			skip = false; // until DOM setters can finally replace Mutation Observers
			spirits = Assistant.$detectspirits(elm, skip, one, channels);
			this._sequence(spirits);
		},

		/**
		 * Call `onconfigure`, `onenter`, `onattach` and 'onreflex' in document
		 * order. Finally call `onready` in reverse document order (bottoms up).
		 * @param {Array<gui.Spirit>} spirits
		 */
		_sequence: (function generatefuntion() {
			var root = gui.DocumentSpirit;
			function configure(spirit) {
				if (!spirit.life.configured) {
					Spirit.$configure(spirit);
				}
				return spirit;
			}
			function enter(spirit) {
				if (!spirit.life.entered) {
					Spirit.$enter(spirit);
				}
				return spirit;
			}
			function attach(spirit) {
				// TODO: This check should not be needed, probably a bug in the detach sequence or something :/
				if (!spirit.life.attached) {
					Spirit.$attach(spirit);
				}
				return spirit;
			}
			function ready(spirit) {
				if (!spirit.life.ready && !root.is(spirit)) {
					Spirit.$ready(spirit);
				}
			}
			return function(spirits) {
				spirits.map(
					configure
				).map(
					enter
				).map(
					attach
				).reverse().forEach(
					ready
				);
			};
		}()),

		/**
		 * Destruct spirits from element and subtree. Using a two-phased destruction sequence
		 * to minimize the risk of plugins invoking already destructed plugins during destruct.
		 * @param {Node|gui.Spirit} node
		 * @param {boolean} skip Skip the element?
		 * @param {boolean} one Skip the subtree?
		 * @param {boolean} force
		 * @param @optional {boolean} webkithack (not an official thing)
		 */
		_maybematerialize: function(node, skip, one, force, webkithack) {
			node = Type.isSpirit(node) ? node.element : node;
			node = Type.isDocument(node) ? node.documentElement : node;
			if (force || this._handles(node, webkithack)) {
				this._materialize(node, skip, one);
			}
		},

		/**
		 * Nuke spirits in reverse document order. This to allow an ascending {gui.Action} to escape
		 * from the subtree of a spirit that decides to remove itself from the DOM during destruction.
		 * TODO: 'one' appears to be unsupported here???
		 * @param {Element} element
		 * @param {boolean} skip Skip the element?
		 * @param {boolean} one Skip the subtree?
		 */
		_materialize: function(element, skip, one) {
			this._collect(element, skip, gui.CRAWLER_MATERIALIZE).reverse().filter(function(spirit) {
				if (spirit.life.attached && !spirit.life.destructed) {
					Spirit.$destruct(spirit);
					return true; // @TODO: handle 'one' arg!
				}
				return false;
			}).forEach(function(spirit) {
				Spirit.$dispose(spirit);
			});
		},

		/**
		 * @param {Element|gui.Spirit} element
		 */
		_maybedetach: function(element) {
			element = Type.isSpirit(element) ? element.element : element;
			if (this._handles(element)) {
				this._collect(element, false, gui.CRAWLER_DETACH).forEach(function(spirit) {
					Spirit.$detach(spirit);
				});
			}
		},

		/**
		 * Channel spirits to CSS selectors.
		 * @param {String} select CSS selector
		 * @param {function|String} klass Constructor or name
		 */
		_channelOne: function(select, klass) {
			var spirit, booting = !!this._todochannels;
			if (gui.initialized) {
				spirit = typeof klass === 'string' ? gui.Object.lookup(klass) : klass;
				if (!gui.debug || Type.isSpiritConstructor(spirit)) {
					if (booting) {
						this._channels.unshift([select, spirit]);
					} else {
						this._channels.push([select, spirit]);
					}
				} else {
					console.error('Bad spirit for selector "' + select + '": ' + spirit);
				}
			} else { // wait for method ready to invoke.
				this._todochannels = this._todochannels || [];
				this._todochannels.push([select, klass]);
			}
		},

		/**
		 * TODO: the 'reverse()' should really not be done here, but in
		 * the condition above, however, that screws it up, huge disaster
		 * and something must be done about it !!!!!!!!!!!!!!!!!!!!!!!!!!
		 */
		_channelAll: function(channels) {
			if (gui.initialized) {
				channels.forEach(function(c) {
					this._channelOne(c[0], c[1]);
				}, this);
			} else {
				this._todochannels = this._todochannels || [];
				this._todochannels = this._todochannels.concat(channels.reverse());
			}
		},

		/**
		 * Some attempt to unreference the spirit.
		 * @param {gui.Spirit} spirit
		 */
		_stoptracking: function(spirit) {
			var incoming = documentspirits.incoming;
			if (incoming.length) {
				var i = incoming.indexOf(spirit);
				if (i > -1) {
					guiArray.remove(incoming, i);
				}
			}
		},

		/**
		 * Update incoming spirits.
		 */
		_updateincoming: function() {
			gui.Guide.$goasync(documentspirits.incoming);
			documentspirits.incoming = [];
		},

		/**
		 * Update spirits not in the DOM.
		 */
		_updateoutside: function() {
			var outside = documentspirits.outside;
			var spirits = gui.Object.each(outside, function(key, spirit) {
				return spirit;
			});
			/*
			 * TODO: make sure that this happens onexit (but not here)
			spirits.forEach ( function ( spirit ) {
				Spirit.$exit ( spirit );
			});
			*/
			spirits.forEach(function(spirit) {
				Spirit.$destruct(spirit);
			});
			spirits.forEach(function(spirit) {
				Spirit.$dispose(spirit);
			});
			documentspirits.outside = Object.create(null);
		},

		// TODO: Externalize .......................................................

		/**
		 * Evaluate spirits visibility. TODO: Off to plugin somehow.
		 * @param {Array<gui.Spirit>}
		 */
		_visibility: function(spirits) {
			if (gui.hasModule('gui-layout@wunderbyte.com')) {
				DOMPlugin.group(spirits).forEach(function(spirit) {
					gui.VisibilityPlugin.$init(spirit);
				}, this);
			}
		}
	};
}(
	gui.Assistant,
	gui.Type,
	gui.Array,
	gui.Broadcast,
	gui.DOMPlugin,
	gui.Spirit,
	gui.Tick,
	gui.Crawler
));



/**
 * Support spirits.
 */
gui.Module.mixin({

	/**
	 * Plugins for all spirits.
	 * @type {Map<String,gui.Plugin>}
	 *
	plugin: null,

	/**
	 * Mixins for all spirits.
	 * @type {Map<String,function>}
	 *
	mixin: null,

	/**
	 * Channeling spirits to CSS selectors.
	 * @type {Map<Array<Array<String,gui.Spirit>>}
	 *
	channel: null,
	*/

	/**
	 * Called before spirits kick in.
	 * @return {Window} context
	 */
	onbeforespiritualize: function() {},

	/**
	 * Called after spirits kicked in.
	 * @return {Window} context
	 */
	onafterspiritualize: function() {},

	// Privileged ................................................................

	/**
	 * Secret constructor.
	 *
	 * 1. Extend {gui.Spirit} with mixins
	 * 2. Channel spirits to CSS selectors
	 * 3. Assign plugins to all {gui.Spirit}
	 * @overwrites {gui.Module.$onconstruct}
	 */
	$onconstruct: function(name) {
		this.$modname = name;
		gui.Module.$init(this);
		this.toString = function() {
			return '[module ' + name + ']';
		};
	}

}, {}, { // Static .............................................................

	/**
	 * @param {gui.Module} module
	 */
	$init: function(module) {
		if (gui.Type.isObject(module.mixin)) {
			gui.Spirit.mixin(module.mixin);
		}
		if (gui.Type.isArray(module.channel)) {
			gui.channel(module.channel);
		}
		if (gui.Type.isObject(module.plugin)) {
			gui.Object.each(module.plugin, function(prefix, Plugin) {
				if (gui.Type.isDefined(Plugin)) {
					gui.Spirit.plugin(prefix, Plugin);
				} else { // TODO: move check into gui.Spirit.plugin
					console.error('Undefined plugin for prefix: ' + prefix);
				}
			});
		}
	}

});

/**
 * @param {Array<gui.Module>} modules
 */
(function catchup(modules) {
	modules.forEach(gui.Module.$init);
}(gui.Module._modules));

/**
 * Hookup modules to spirits lifecycle.
 * Broadcasts dispatched by {gui.Guide}.
 * @param {Array<gui.Module>} modules
 */
(function hookup(modules) {
	gui.Object.each({
		onbeforespiritualize: gui.BROADCAST_WILL_SPIRITUALIZE,
		onafterspiritualize: gui.BROADCAST_DID_SPIRITUALIZE
	}, function associate(action, broadcast) {
		gui.Broadcast.add(broadcast, {
			onbroadcast: function() {
				modules.forEach(function(module) {
					module[action]();
				});
			}
		});
	});
}(gui.Module._modules));



/**
 * Spirits module.
 */
gui.module('gui-spirits@wunderbyte.com', {

	/**
	 * Channel spirits for CSS selectors.
	 */
	channel: [
		['html', gui.DocumentSpirit],
		['.gui-iframe', gui.IframeSpirit],
		['.gui-spirit', gui.Spirit]
	],

	/**
	 * Assign plugins to property names.
	 */
	plugin: {
		'super': gui.SuperPlugin, // TODO: for all gui.Class things!
		action: gui.ActionPlugin,
		broadcast: gui.BroadcastPlugin,
		tick: gui.TickPlugin,
		att: gui.AttPlugin,
		config: gui.ConfigPlugin,
		box: gui.BoxPlugin,
		css: gui.CSSPlugin,
		dom: gui.DOMPlugin,
		event: gui.EventPlugin,
		life: gui.LifePlugin,
		sprite: gui.SpritePlugin
	},

	/**
	 * Add methods to (all) spirits.
	 */
	mixin: {

		/**
		 * Handle action.
		 * @param {gui.Action} action
		 */
		onaction: function(action) {},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} broadcast
		 */
		onbroadcast: function(broadcast) {},

		/**
		 * Handle tick (timed event).
		 * @param {gui.Tick} tick
		 */
		ontick: function(tick) {},

		/**
		 * Handle attribute.
		 * @param {gui.Att} att
		 */
		onatt: function(att) {},

		/**
		 * Handle event.
		 * @param {Event} event
		 */
		onevent: function(event) {},

		/**
		 * Handle lifecycle event.
		 * @param {gui.Life} life
		 */
		onlife: function(life) {},

		/**
		 * Native DOM interface. We'll forward the event to the method `onevent`.
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-EventListener
		 * TODO: Move this code into {gui.EventPlugin}
		 * @param {Event} e
		 */
		handleEvent: function(e) {
			if (e.type === 'webkitTransitionEnd') { // TODO: move to {gui.EventPlugin}
				e = {
					type: 'transitionend',
					target: e.target,
					currentTarget: e.currentTarget,
					propertyName: e.propertyName,
					elapsedTime: e.elapsedTime,
					pseudoElement: e.pseudoElement
				};
			}
			this.onevent(e);
		},

		// presumably some kind of hotfix for not conflicting
		// callbacks with destructed spirits, but why here???
		$ondestruct: gui.Combo.before(function() {
			this.handleEvent = function() {};
		})(gui.Spirit.prototype.$ondestruct)
	}

});



}(self));
(function(window) {

"use strict";


/*
 * Namepace object.
 * @using {gui.Arguments.confirmed}
 */
window.edb = gui.namespace('edb', (function using(confirmed) {
	return {

		/**
		 * Current version (injected during build process).
		 * @see https://www.npmjs.org/package/grunt-spiritual-build
		 * @type {string} (majorversion.minorversion.patchversion)
		 */
		version: '-1.0.0',

		/**
		 * Logging some debug messages? This can be flipped via meta tag:
		 * `<meta name="edb.debug" content="true"/>`
		 * @type {boolean}
		 */
		debug: false,

		/**
		 * While true, any inspection of an {edb.Objects} or {edb.Arrays}
		 * will be be followed by a synchronous broadcast message (below).
		 * @type {object}
		 */
		$accessaware: false,

		/**
		 * Broadcasts.
		 */
		BROADCAST_ACCESS: 'edb-broadcast-access',
		BROADCAST_CHANGE: 'edb-broadcast-change',
		BROADCAST_OUTPUT: 'edb-broadcast-output',
		BROADCAST_SCRIPT_INVOKE: 'edb-broadcast-script-invoke',

		/**
		 * Ticks.
		 */
		TICK_SCRIPT_UPDATE: 'edb-tick-script-update',
		TICK_COLLECT_INPUT: 'edb-tick-collect-input',
		TICK_PUBLISH_CHANGES: 'edb-tick-update-changes',

		/**
		 * @deprecated
		 */
		get: function() {
			console.error('Deprecated API is deprecated: edb.get()');
		}

	};
}(gui.Arguments.confirmed)));

/**
 * Toggle this to force the next model change to notify observers
 * synchronously. The flag will automatically toggle back to false.
 *
(function setup(critical) {
	Object.defineProperty(edb, '$criticalchange', {
		get: function() {
			return critical;
		},
		set: function(value) {
			if((critical = value)) {
				gui.Tick.next(function() {
					critical = false;
				});
			}
		}
	});
}(false));
*/



/**
 * Conceptual superclass for {edb.Object} and {edb.Array}.
 * @using {gui.Combo#chained}
 */
edb.Type = (function using(chained) {
	return gui.Class.create(null, {

		/**
		 * Called after $onconstruct (by `gui.Class` convention).
		 */
		onconstruct: function() {},

		/**
		 * Called before $ondestruct. Cleanup the mess here.
		 */
		ondestruct: function() {},

		/**
		 * Output to context.
		 * @returns {edb.Type}
		 */
		output: chained(function() {
			edb.Output.$output(this);
		}),

		/**
		 * TODO: If this is even possible...
		 * TODO: In which case, also revokeGlobal
		 */
		outputGlobal: chained(function() {
			console.error('Not supported just yet: ' + this + '.outputGlobal()');
		}),

		/**
		 * Revoke output.
		 * TODO: Something similar on constructor (so static).
		 * TODO: Perhaps only on conctructor?
		 * @returns {edb.Type}
		 */
		revoke: chained(function() {
			edb.Output.$revoke(this);
		}),

		/**
		 * Garbage collect now, at least in theory.
		 * TODO: Synchronized types should allow time
		 * to sync this fact before they are destructed.
		 */
		dispose: chained(function() {
			edb.Type.$destruct(this);
		}),

		/**
		 * Serialize to abstract EDB tree. Unlike `toJSON`, this
		 * includes underscore and dollar prefixed properties.
		 * It also features the the object-properties of arrays.
		 * @param @optional {function} filter
		 * @param @optional {String|number} tabs
		 * @returns {String}
		 */
		serializeToString: function(filter, tabs) {
			return new edb.Serializer().serializeToString(this, filter, tabs);
		},

		// Privileged ................................................................

		/**
		 * Synchronization stuff ohoy. Matches the `$instanceid` of a `gui.Class`.
		 * @type {String}
		 */
		$originalid: null,

		/**
		 * Flag destructed so that we don't overkill.
		 * @type {boolean}
		 */
		$destructed: false,

		/**
		 * Called before `onconstruct`.
		 */
		$onconstruct: function() {},

		/**
		 * Called after `ondestruct`.
		 */
		$ondestruct: function() {
			// TODO: This functionality should be provided
			// by the states module (eg. not in the core).
			if (this.constructor.storage) {
				this.persist();
			}
		}

	});
}(gui.Combo.chained));

// Static ......................................................................

edb.Type.mixin(null, null, {

	/**
	 * Something is an instance of {edb.Object} or {edb.Array}?
	 * @param {object} o
	 * @returns {boolean}
	 */
	is: function(o) {
		return edb.Object.is(o) || edb.Array.is(o);
	},

	/**
	 * Something is a Type constructor?
	 * @param {object} o
	 * @returns {boolean}
	 */
	isConstructor: function(o) {
		return gui.Type.isGuiClass(o) &&
			gui.Class.ancestorsAndSelf(o).some(function(C) {
				return C === edb.Object || C === edb.Array;
			});
	},

	/**
	 * Lookup edb.Type constructor for argument (if not already an edb.Type).
	 * TODO: Confirm that it is actually an edb.Type thing...
	 * @param {Window|WorkerGlobalScope} arg
	 * @param {function|string} arg
	 * @returns {function}
	 */
	lookup: function(context, arg) {
		var type = null;
		switch (gui.Type.of(arg)) {
			case 'function':
				type = arg; // TODO: confirm
				break;
			case 'string':
				type = gui.Object.lookup(arg, context);
				break;
			case 'object':
				console.error(this + ': expected edb.Type constructor (not an object)');
				break;
		}
		if (!type) {
			throw new TypeError('The type "' + arg + '" does not exist');
		}
		return type;
	},

	/**
	 * @param {object} value
	 */
	cast: function fix(value) {
		if (gui.Type.isComplex(value) && !edb.Type.is(value)) {
			switch (gui.Type.of(value)) {
				case 'object':
					return edb.Object.from(value);
				case 'array':
					return edb.Array.from(value);
			}
		}
		return value;
	},

	/**
	 * Apply any future mixins to both {edb.Object} and {edb.Array}.
	 * @param {object} proto
	 * @param {object} recurring
	 * @param {object} statics
	 * @returns {edb.Type}
	 */
	mixin: function(protos, xstatics, statics) {
		[edb.Object, edb.Array].forEach(function(Type) {
			Type.mixin(protos, xstatics, statics);
		});
		return this;
	},

	// Privileged ................................................................

	/**
	 * TODO: Use {gui.MapList} !!!!!!!!!!!!!!!
	 * @param {edb.Object|edb.Array} type
	 * @param {edb.IChangeHandler} handler
	 * @returns {edb.Object|edb.Array}
	 */
	$observe: function(type, handler) {
		var id = type.$instanceid;
		var obs = this._observers;
		var handlers = obs[id] || (obs[id] = []);
		if (handlers.indexOf(handler) === -1) {
			handlers.push(handler);
		}
		return type;
	},

	/**
	 * @param {edb.Object|edb.Array} type
	 * @param {edb.IChangeHandler} handler
	 * @returns {edb.Object|edb.Array}
	 */
	$unobserve: function(type, handler) {
		var id = type.$instanceid;
		var obs = this._observers;
		var index, handlers = obs[id];
		if (handlers) {
			if ((index = handlers.indexOf(handler)) > -1) {
				if (gui.Array.remove(handlers, index) === 0) {
					delete obs[id];
				}
			}
		}
		return type;
	},

	/**
	 * Called by {edb.Output} when the output context shuts down
	 * (when the window unloads or the web worker is terminated).
	 */
	$destruct: function(type) {
		new edb.Crawler().crawl(type, {
			ontype: function(t) {
				if (!t.$destructed) {
					type.ondestruct();
					type.$ondestruct();
					type.$destructed = true;
					if (!gui.unloading) {
						gui.Garbage.$nukeallofit(type); // TODO: via `collect` when possible
					}
				}
			}
		});
	}

});

// Mixins ......................................................................

/**
 * Setup mixins for {edb.Object} and {edb.Array}.
 * @using {gui.Arguments.confirmed}
 */
(function using(confirmed) {
	var iomixins = { // input-output methods

		/**
		 * Instance of this Type has been output (in public context)?
		 * @returns {boolean}
		 */
		isOutput: function() {
			return edb.Output.$is(this);
		},

		/**
		 * @deprecated
		 */
		getOutput: function() {
			console.error('Deprecated API is deprecated: getOutput()');
		},

		/**
		 * @deprecated
		 */
		revokeOutput: function() {
			console.error('Deprecated API is deprecated: revokeOutput()');
		}

	};

	var spassermixins = {

		/**
		 * Create *new* instance from argument of fuzzy type.
		 * All nested models will also be instanced as *new*.
		 * @param {String|object|Array|edb.Object|edb.Array} json
		 * @return {edb.Object|edb.Array}
		 */
		from: gui.Arguments.confirmed('(string|object|array|null)')(
			function(json) {
				var Type = this;
				if (json) {
					if (edb.Type.is(json)) {
						json = new edb.Serializer().serializeToString(json);
					}
					if (gui.Type.isString(json)) {
						if (json.includes('$object') || json.includes('$array')) {
							json = new edb.Parser().parseFromString(json, null);
						}
					}
				}
				return new Type(json); // TODO: should `null` even do this?
			}
		),

		/**
		 * Create the `Type.output` object along with the Type.
		 * @overrides {gui.Class#extend}
		 */
		extend: function() {
			var C = gui.Class.extend.apply(this, arguments);
			C.output = new edb.Output(C); // TODO: make readonly!
			return C;
		}

	};

	/**
	 * Declare the fields on edb.Type.
	 */
	[iomixins, spassermixins].forEach(function(mixins) {
		gui.Object.each(mixins, function mixin(key, value) {
			edb.Type[key] = value;
		});
	});

	/**
	 * Create one-liner for mixin to subclass constructors recurring static fields.
	 * @returns {Map<String,String|function>}
	 */
	edb.Type.$staticmixins = function() {
		var mixins = {};
		[iomixins, spassermixins].forEach(function(set) {
			Object.keys(set).forEach(function(key) {
				mixins[key] = set[key];
			}, this);
		}, this);
		return mixins;
	};
}(gui.Arguments.confirmed));



/**
 * edb.Object
 * @extends {edb.Type} at least in principle.
 * @using {gui.Arguments#confirmed}
 * @using {gui.Combo#chained}
 */
edb.Object = (function using(confirmed, chained) {
	return gui.Class.create(Object.prototype, {

		/**
		 * Observe object.
		 * @param @optional {IChangeHandler} handler
		 * @returns {edb.Object}
		 */
		addObserver: confirmed('object|function')(chained(function(handler) {
			edb.Object.observe(this, handler);
		})),

		/**
		 * Unobserve object.
		 * @param @optional {IChangeHandler} handler
		 * @returns {edb.Object}
		 */
		removeObserver: confirmed('object|function')(chained(function(handler) {
			edb.Object.unobserve(this, handler);
		})),

		// Privileged ..............................................................

		/**
		 * Constructor.
		 * @overrides {edb.Type#onconstruct}
		 */
		$onconstruct: function(json) {
			edb.Type.prototype.$onconstruct.apply(this, arguments);
			switch (gui.Type.of(json)) {
				case 'object':
				case 'undefined':
				case 'null':
					var proxy = gui.Object.copy(json || {});
					var types = edb.ObjectPopulator.populate(proxy, this);
					edb.ObjectProxy.approximate(proxy, this, types);
					break;
				default:
					throw new TypeError(
						'Unexpected edb.Object constructor argument of type ' +
						gui.Type.of(json) + ': ' + String(json)
					);
			}
			this.onconstruct();
			if (this.oninit) {
				console.error('Deprecated API is deprecated: ' + this + '.oninit');
			}
		},

		/**
		 * Create clone of this object filtering out
		 * underscore and dollar prefixed properties.
		 * Recursively normalizing nested EDB types.
		 * TODO: WHITELIST stuff that *was* in JSON!
		 * TODO: Something about recursive structure...
		 * @returns {object}
		 */
		toJSON: function() {
			return gui.Object.map(this, function(key, value) {
				var c = key.charAt(0);
				if (c !== '$' && c !== '_') {
					if (edb.Type.is(value)) {
						return value.toJSON();
					}
					return value;
				}
			});
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));

/**
 * Mixin static methods. Recurring static members mixed in from {edb.Type}.
 */
edb.Object.mixin(null, edb.Type.$staticmixins(), {

	/**
	 * Observe.
	 */
	observe: edb.Type.$observe,

	/**
	 * Unobserve.
	 */
	unobserve: edb.Type.$unobserve,

	/**
	 * Publishing change summaries async.
	 * TODO: clean this up...
	 * TODO: Mishandlers should never occur, fix cause!
	 * TODO: move to edb.Type (edb.Type.observe)
	 * @param {gui.Tick} tick
	 */
	ontick: function(tick) {
		var observers = this._observers, exists;
		var snapshot, changes, handlers, mishandlers;
		if (tick.type === edb.TICK_PUBLISH_CHANGES) {
			snapshot = gui.Object.copy(this._changes);
			this._changes = Object.create(null);
			var changelings = []; // so much easier with Map and Set :/
			gui.Object.each(snapshot, function(instanceid, propdef) {
				if ((handlers = observers[instanceid])) {
					changes = [];
					mishandlers = [];
					gui.Object.each(propdef, function(name, change) {
						changes.push(change);
					});
					handlers.filter(function(handler) {
						if (!(exists = !handler.$destructed)) {
							mishandlers.push(handler);
						}
						return exists;
					}).forEach(function(handler) {
						if (!handler.__changes) {
							handler.__changes = [];
						}
						handler.__changes.push(changes);
						if (changelings.indexOf(handler) === -1) {
							changelings.push(handler);
						}
					});
					mishandlers.forEach(function(handler) { // symptom treatment!
						var index = handlers.indexOf(handler);
						gui.Array.remove(handlers, index);
					});
				}
			});
			changelings.forEach(function(handler) {
				var groups = handler.__changes;
				handler.onchange(groups.reduce(function(sum, changesToReduce) {
					return sum.concat(changesToReduce);
				}, []));
				delete handler.__changes;
			});
		}
	},

	// Privileged static .........................................................

	/**
	 * Publish a notification on property accessors.
	 * This should be relevant during script render.
	 */
	$onaccess: function(object, name) {
		if (edb.$accessaware) {
			gui.Broadcast.dispatch(edb.BROADCAST_ACCESS, [
				object, name
			]);
		}
	},

	/**
	 * Register change summary for publication (in next tick).
	 * @param {edb.Object} object
	 * @param {String} name
	 * @param {object} oldval
	 * @param {object} newval
	 */
	$onchange: function(object, name, oldval, newval) {
		if (oldval !== newval) {
			var type = edb.ObjectChange.TYPE_UPDATE;
			var all = this._changes, id = object.$instanceid;
			var set = all[id] || (all[id] = Object.create(null));
			var now = false; // edb.$criticalchange;
			set[name] = new edb.ObjectChange(object, name, type, oldval, newval);
			gui.Tick.dispatch(edb.TICK_PUBLISH_CHANGES, (now ? -1 : 0));
			// edb.$criticalchange = false;
		}
	},

	// Private static ............................................................

	/**
	 * Mapping instanceids to lists of observers.
	 * @type {Map<String,Array<edb.IChangeHandler>>}
	 */
	_observers: Object.create(null),

	/**
	 * Mapping instanceids to lists of changes.
	 * @type {Map<String,Array<edb.ObjectChange>>}
	 */
	_changes: Object.create(null)

});

/*
 * Mixin methods and properties common to both {edb.Object} and {edb.Array}
 */
(function setup() {
	gui.Tick.add(edb.TICK_PUBLISH_CHANGES, edb.Object);
	gui.Object.extendmissing(edb.Object.prototype, edb.Type.prototype);
}());



/**
 * @using {Array.prototype}
 * @using {gui.Combo#chained}
 */
(function using(proto, chained) {
	/**
	 * edb.Array
	 * @extends {edb.Type} (although not really)
	 */
	edb.Array = gui.Class.create(proto, {

		/**
		 * Push.
		 */
		push: function() {
			var idx = this.length;
			var add = convert(this, arguments);
			var res = proto.push.apply(this, add);
			if (observes(this)) {
				onchange(this, idx, null, add);
			}
			return res;
		},

		/**
		 * Pop.
		 */
		pop: function() {
			var idx = this.length - 1;
			var res = proto.pop.apply(this);
			if (observes(this) && idx >= 0) {
				onchange(this, idx, [res], null);
			}
			return res;
		},

		/**
		 * Shift.
		 */
		shift: function() {
			var res = proto.shift.apply(this);
			if (observes(this)) {
				onchange(this, 0, [res], null);
			}
			return res;
		},

		/**
		 * Unshift.
		 */
		unshift: function() {
			var add = convert(this, arguments);
			var res = proto.unshift.apply(this, add);
			if (observes(this)) {
				onchange(this, 0, null, add);
			}
			return res;
		},

		/**
		 * Splice.
		 */
		splice: function() {
			var arg = arguments;
			var idx = arg[0];
			var add = convert(this, [].slice.call(arg, 2));
			var fix = [idx, arg[1]].concat(add);
			var out = proto.splice.apply(this, fix);
			if (observes(this)) {
				onchange(this, idx, out, add);
			}
			return out;
		},

		/**
		 * Reverse.
		 */
		reverse: function() {
			if (observes(this)) {
				var out = this.toJSON();
				var add = proto.reverse.apply(out.slice());
				onchange(this, 0, out, add);
			}
			return proto.reverse.apply(this);
		},

		// Expandos ................................................................

		/**
		 * Just to illustrate that arrays may conveniently get their
		 * content assigned to some variable via the constructor arg.
		 * @param {Array<object>} members (edb.Types all newed up here)
		 */
		onconstruct: function(members) {},

		/**
		 * Observe array (both object properties and list mutations).
		 * @param @optional {IChangeHandler} handler
		 * @returns {edb.Array}
		 */
		addObserver: chained(function(handler) {
			edb.Object.observe(this, handler);
			edb.Array.observe(this, handler);
		}),

		/**
		 * Unobserve array.
		 * @param @optional {IChangeHandler} handler
		 * @returns {edb.Array}
		 */
		removeObserver: chained(function(handler) {
			edb.Object.unobserve(this, handler);
			edb.Array.unobserve(this, handler);
		}),

		/**
		 * The content type can be declared as:
		 *
		 * 1. An edb.Type constructor function (my.ns.MyType)
		 * 2. A filter function to accept JSON (for analysis)
		 *		and return an edb.Type constructor OR instance
		 * @type {function} Type constructor or filter function
		 */
		$of: null,

		/**
		 * Constructor.
		 * @overrides {edb.Type#onconstruct}
		 */
		$onconstruct: function() {
			var object, types;
			edb.Type.prototype.$onconstruct.apply(this, arguments);
			if (arguments.length) {
				object = arguments[0] ? arguments[0].$object || {} : {};
				types = edb.ObjectPopulator.populate(object, this);
				edb.ArrayPopulator.populate(this, arguments);
				edb.ObjectProxy.approximate(object, this, types);
			}
			this.onconstruct([].slice.call(this));
		},

		/**
		 * Get element at index. Use this in EDBML scripts instead of [length]
		 * notation, otherwise the template will not watch this array for changes!
		 * @param {number} index
		 * @returns {object}
		 */
		get: function(index) {
			if (edb.$accessaware) {
				edb.Array.$onaccess(this, index);
			}
			return this[index];
		},

		/**
		 * Get length. Use this in EDBML scripts instead of 'length',
		 * otherwise the template will not watch this array for changes!
		 * @returns {number}
		 */
		getLength: function(index) {
			if (edb.$accessaware) {
				edb.Array.$onaccess(this, index);
			}
			return this.length;
		},

		/*
		 * Stunt accessor for setting the `length`
		 * until proxies come to save us all.
		 * @type {number}
		 */
		setLength: function(length) {
			var out = [];
			while (this.length > length) {
				out.push(this.pop());
			}
			if (out.length) {
				onchange(this, this.length - 1, out);
			}
		},

		/**
		 * Create true array without expando properties, recursively
		 * normalizing nested EDB types. Returns the type of array we
		 * would typically transmit back to the server or something.
		 * @returns {Array}
		 */
		toJSON: function() {
			return Array.map(this, function(thing) {
				if (edb.Type.is(thing)) {
					return thing.toJSON();
				}
				return thing;
			});
		}

	});

	// Helpers ...................................................................

	/**
	 * Convert arguments.
	 * @param {edb.Array} array
	 * @param {Arguments} args
	 * @returns {Array}
	 */
	function convert(array, args) {
		return edb.ArrayPopulator.convert(array, args);
	}

	/**
	 * Shorthand.
	 * @param {edb.Array} array
	 * @param {number} index
	 * @param {Array} removed
	 * @param {Array} added
	 */
	function onchange(array, index, removed, added) {
		edb.Array.$onchange(array, index, removed, added);
	}

	/**
	 * Array is being observed?
	 * @param {edb.Array} array
	 * @returns {boolean}
	 */
	function observes(array) {
		var key = array.$instanceid;
		return !!edb.Array._observers[key];
	}
}(Array.prototype, gui.Combo.chained));

/**
 * Mixin static methods. Recurring static members mixed in from {edb.Type}.
 */
edb.Array.mixin(null, edb.Type.$staticmixins(), {

	/**
	 * Observe.
	 */
	observe: edb.Type.$observe,

	/**
	 * Unobserve.
	 */
	unobserve: edb.Type.$unobserve,

	/**
	 * Something is a subclass constructor of {edb.Array}?
	 * TODO: let's generalize this facility in {gui.Class}
	 */
	isConstructor: function(o) {
		return gui.Type.isConstructor(o) &&
			gui.Class.ancestorsAndSelf(o).indexOf(edb.Array) > -1;
	},

	/**
	 * Publishing change summaries async.
	 * @param {gui.Tick} tick
	 */
	ontick: function(tick) {
		var snapshot, handlers, observers = this._observers;
		if (tick.type === edb.TICK_PUBLISH_CHANGES) {
			snapshot = gui.Object.copy(this._changes);
			this._changes = Object.create(null);
			gui.Object.each(snapshot, function(instanceid, changes) {
				if ((handlers = observers[instanceid])) {
					handlers.forEach(function(handler) {
						handler.onchange(changes);
					});
				}
			});
		}
	},

	// Private static ............................................................

	/**
	 * Mapping instanceids to lists of observers.
	 * @type {Map<String,Array<edb.IChangeHandler>>}
	 */
	_observers: Object.create(null),

	/**
	 * Mapping instanceids to lists of changes.
	 * @type {Map<String,Array<edb.ArrayChange>>}
	 */
	_changes: Object.create(null),

	// Privileged static .........................................................

	/**
	 * TODO.
	 * @param {edb.Array} array
	 * @param {number} index
	 */
	$onaccess: function(array, index) {
		if (edb.$accessaware) {
			gui.Broadcast.dispatch(edb.BROADCAST_ACCESS, [array]);
		}
	},

	/**
	 * Register change summary for publication in next tick.
	 * TODO: http://stackoverflow.com/questions/11919065/sort-an-array-by-the-levenshtein-distance-with-best-performance-in-javascript
	 * @param {edb.Array} array
	 * @param {number} index
	 * @param {Array} removed
	 * @param {Array} added
	 */
	$onchange: function(array, index, removed, added) {
		var key = array.$instanceid;
		var all = this._changes;
		var set = all[key] || (all[key] = []);
		var now = false; // edb.$criticalchange;
		set.push(new edb.ArrayChange(array, index, removed, added));
		gui.Tick.dispatch(edb.TICK_PUBLISH_CHANGES, now ? -1 : 0);
		// edb.$criticalchange = false;
	}

});

/*
 * Overloading array methods.
 * @using {edb.Array.prototype}
 */
(function using(proto) {
	/*
	 * Dispatch a getter broadcast before base function.
	 */
	var beforeaccess = gui.Combo.before(function() {
		if (edb.$accessaware) {
			edb.Array.$onaccess(this, -1);
		}
	});

	/**
	 * Decorate getter methods on prototype.
	 * @param {object} proto Prototype to decorate
	 * @param {Array<String>} methods List of method names
	 * @returns {object}
	 */
	function decorateAccess(protoToDecorate, methods) {
		methods.forEach(function(method) {
			protoToDecorate[method] = beforeaccess(protoToDecorate[method]);
		});
	}

	/*
	 * Dispatch a broadcast whenever the list is inspected or traversed.
	 */
	decorateAccess(proto, [
		'filter',
		'forEach',
		'every',
		'map',
		'some',
		'indexOf',
		'lastIndexOf',
		'slice' // hm,
		// TODO: REDUCE!
	]);
}(edb.Array.prototype));

/*
 * Mixin methods and properties common
 * to both {edb.Object} and {edb.Array}
 */
(function setup() {
	gui.Tick.add(edb.TICK_PUBLISH_CHANGES, edb.Array);
	gui.Object.extendmissing(edb.Array.prototype, edb.Type.prototype);
}());

// BACKUP ......................................................................

/**
 * Dispatch a setter broadcast after base
 * function by decorating setter methods on prototype.
 * @param {object} proto Prototype to decorate
 * @param {Array<String>} methods List of method names
 * @returns {object}
 *
var afterchange = gui.Combo.after ( function () {});
function decorateChange ( proto, methods ) {
	methods.forEach ( function ( method ) {
		proto [ method ] = afterchange ( proto [ method ]);
	});
}

// Dispatch a broadcast whenever the list changes content or structure.
decorateChange ( proto, [
	"push", // add
	"unshift", // add
	"splice", // add or remove
	"slice", // remove
	"pop", // remove
	"shift", // remove
	"reverse" // reversed (copies???????)
]);
*/



/**
 * Populates an {edb.Object} type.
 * @using {gui.Type#isDefined}
 * @using {gui.Type#isComplex},
 * @using {gui.Type#isFunction}
 * @using {gui.Type#isConstructor}
 */
edb.ObjectPopulator = (function using(isdefined, iscomplex, isfunction, isconstructor) {
	/**
	 * List non-private fields names from handler that are not
	 * mixed in from {edb.Type} and not inherited from native.
	 * @param {edb.Object} handler
	 * @returns {Array<String>}
	 */
	function definitions(handler) {
		var Type = edb.Object.is(handler) ? edb.Object : edb.Array;
		var Base = edb.Object.is(handler) ? Object : Array;
		var keys = [],
			classes = [edb.Type, Type, Base];
		gui.Object.all(handler, function(key) {
			if (isregular(key) && classes.every(function(o) {
				return o.prototype[key] === undefined;
			})) {
				keys.push(key);
			}
		});
		return keys;
	}

	/**
	 * TODO: Call this something else...
	 * @param {object} json
	 * @param {edb.Object|edb.Array} type
	 */
	function evalheaders(json, type) {
		var id = json.$originalid || json.$instanceid;
		delete json.$instanceid;
		delete json.$originalid;
		if (id) {
			Object.defineProperty(type, '$originalid', gui.Property.nonenumerable({
				value: id
			}));
		}
	}

	/**
	 * Fail me once.
	 * @param {String} name
	 * @param {String} key
	 */
	function faildefined(name, key) {
		throw new TypeError(
			name + ' declares "' + key + '" as something undefined'
		);
	}

	/**
	 * Fail me twice.
	 * @param {String} name
	 * @param {String} key
	 */
	function failconstructor(name, key) {
		throw new TypeError(
			name + ' "' + key + '" must resolve to a constructor'
		);
	}

	/**
	 * Object key is not a number and doesn't start with exotic character?
	 * @param {String|number} key
	 * @returns {boolean}
	 */
	function isregular(key) {
		return key.match(/^[a-z]/i);
	}

	/**
	 * Lookup property descriptor for key.
	 * @param {object} proto
	 * @param {string} key
	 * @returns {object}
	 */
	function lookupDescriptor(proto, key) {
		if (proto.hasOwnProperty(key)) {
			return Object.getOwnPropertyDescriptor(proto, key);
		} else if ((proto = Object.getPrototypeOf(proto))) {
			return lookupDescriptor(proto, key);
		} else {
			return null;
		}
	}

	return { // Public ...............................................................

		/**
		 * Populate object properties of type instance.
		 * @param {object} json
		 * @param {edb.Object|edb.Array} type
		 * @return {Map<String,edb.Object|edb.Array>} types
		 */
		populate: function(json, type) {
			var Def, def, val, desc, types = Object.create(null);
			var base = type.constructor.prototype;
			var name = type.constructor.$classname;
			var pure = [];
			evalheaders(json, type);
			definitions(type).forEach(function(key) {
				def = type[key];
				val = json[key];
				switch (def) {
					case Object:
						//	console.error('TODO: Support Object in edb.ObjectPopulator');
						if (val && gui.Type.isObject(val)) {
							type[key] = JSON.parse(JSON.stringify(val)); // {};
						} else {
							type[key] = null;
						}
						pure.push(key);
						break;
					case Array:
						if (val && Array.isArray(val)) {
							type[key] = JSON.parse(JSON.stringify(val)); // val.slice();
						} else {
							type[key] = null;
							// type[key] = []; !!!!!!!!!!!!!!
						}
						pure.push(key);
						break;
					default:
						if (isdefined(val)) {
							if (isdefined(def)) {
								if (iscomplex(def)) {
									if (isfunction(def)) {
										if (!isconstructor(def)) {
											def = def(val);
										}
										if (isconstructor(def)) {
											if (val !== null) {
												Def = def;
												types[key] = Def.from(json[key]);
											}
										} else {
											failconstructor(name, key);
										}
									} else {
										types[key] = edb.Type.cast(isdefined(val) ? val : def);
									}
								}
							} else {
								faildefined(name, key);
							}
						} else {
							if (isregular(key) && edb.Type.isConstructor(def)) {
								json[key] = null;
								types[key] = def;
							} else {
								if ((desc = lookupDescriptor(base, key))) {
									Object.defineProperty(json, key, desc);
								}
							}
						}
						break;
				}
			});
			gui.Object.nonmethods(json).filter(function(key) {
				return pure.indexOf(key) === -1;
			}).forEach(function(key) {
				var def_ = json[key];
				if (isregular(key) && gui.Type.isComplex(def_)) {
					if (!types[key]) {
						types[key] = edb.Type.cast(def_);
					}
				}
			});
			return types;
		}
	};
})(
	gui.Type.isDefined,
	gui.Type.isComplex,
	gui.Type.isFunction,
	gui.Type.isConstructor
);



/**
 * Populate `edb.Array` instances in various tricky ways.
 * @using {gui.Type} Type
 */
edb.ArrayPopulator = (function using(Type) {
	/**
	 * Array was declared to contain lists (not objects)?
	 * @param {edb.Array} array
	 * @returns {boolean}
	 */
	function oflist(array) {
		return array.$of && array.$of.prototype.reverse;
	}

	/**
	 * Something is a list?
	 * @param {object} o
	 * @returns {boolean}
	 */
	function islist(o) {
		return Array.isArray(o) || edb.Array.is(o);
	}

	/**
	 * Used in function `guidedconvert`.
	 * @param {Constructor} edbType
	 * @param {Cbject} o
	 * @returns {edb.Type}
	 */
	function constructas(EdbType, o) {
		if (!gui.debug || edb.Type.isConstructor(EdbType)) {
			if (edb.Type.is(o)) {
				if (EdbType.is(o)) {
					return o;
				} else {
					fail(EdbType, o);
				}
			} else {
				return new EdbType(o);
			}
		} else {
			fail('edb.Type', EdbType);
		}
	}

	/**
	 * Used in function `guidedconvert`.
	 * @param {function} filter
	 * @param {object|edb.Type} o
	 * @returns {edb.Type}
	 */
	function filterfrom(filter, o) {
		var t = filter(o);
		if (Type.isConstructor(t)) {
			t = constructas(t, o);
		}
		// else { // if (edb.Type.is(t) || t === null)
			// TODO: Support $of simple object/array here!
			// TODO: At least make sure not `undefined`!
			// t = t;
		// }
		/*
		 else {
			fail(
				'edb.Type constructor or instance',
				gui.Type.of(t),
				'return null for nothing'
			);
		}
		*/
		return t;
	}

	/**
	 * Throw that TypeEror.
	 * @param {string|object} expected
	 * @param {string|object} received
	 * @param @optional {string} message
	 */
	function fail(expected, received, message) {
		throw new TypeError(
			'$of expected ' + expected + ', got ' + received +
			(message ? ' (' + message + ')' : '')
		);
	}

	/**
	 * Convert via constructor or via filter
	 * function which returns a constructor.
	 * @param {Array} args
	 * @param {edb.Array} array
	 * @returns {Array<edb.Type>}
	 */
	function guidedconvert(args, array) {
		return args.map(function(o) {
			if (o !== undefined) {
				if (Type.isConstructor(array.$of)) {
					o = constructas(array.$of, o);
				} else {
					o = filterfrom(function(x) {
						return array.$of(x);
					}, o);
				}
			}
			return o;
		});
	}

	/**
	 * Objects and arrays automatically converts
	 * to instances of {edb.Object} and {edb.Array}
	 * @param {Array} args
	 * @returns {Array}
	 */
	function autoconvert(args) {
		return args.map(function(o) {
			if (!edb.Type.is(o)) {
				switch (Type.of(o)) {
					case 'object':
						return new edb.Object(o);
					case 'array':
						return new edb.Array(o);
				}
			}
			return o;
		});
	}

	return { // Public ...........................................................

		/**
		 * Populate {edb.Array} from constructor arguments. This works like normal
		 * arrays, except for the scenario where 1) the content model of the array
		 * is NOT arrays (ie. not a dimensional array) and 2) the first argument IS
		 * an array OR an {edb.Array} in which case the first members of this list
		 * will populate into the array and the remaining arguments will be ignored.
		 * TODO: read something about http://www.2ality.com/2011/08/spreading.html
		 * @param {edb.Array}
		 * @param {Arguments} args
		 */
		populate: function(array, args) {
			var first = args[0];
			if (first) {
				if (!oflist(array) && islist(first)) {
					args = first;
				}
				Array.prototype.push.apply(array,
					this.convert(array, args)
				);
			}
		},

		/**
		 * Convert arguments.
		 * @param {edb.Array} array
		 * @param {Arguments|array} args
		 * @returns {Array}
		 */
		convert: function(array, args) {
			args = gui.Array.from(args);
			if (!Type.isNull(array.$of)) {
				if (Type.isFunction(array.$of)) {
					return guidedconvert(args, array);
				} else {
					var type = Type.of(array.$of);
					throw new Error(array + ' cannot be $of ' + type);
				}
			} else {
				return autoconvert(args);
			}
		}

	};
}(gui.Type));



/**
 * Proxy all the things.
 */
edb.ObjectProxy = (function scoped() {
	/*
	 * Don't trigger object accessors
	 * while scanning them internally.
	 */
	var suspend = false;

	/**
	 * Create observable getter for key.
	 * @param {String} key
	 * @param {function} base
	 * @returns {function}
	 */
	function getter(key, base) {
		return function() {
			var result = base.apply(this);
			if (edb.$accessaware && !suspend) {
				edb.Object.$onaccess(this, key);
			}
			return result;
		};
	}

	/**
	 * Create observable setter for key.
	 * @param {String} key
	 * @param {function} base
	 * @returns {function}
	 */
	function setter(key, base) {
		return function(newval) {
			suspend = true;
			var oldval = this[key];
			base.apply(this, arguments);
			if ((newval = this[key]) !== oldval) { // TODO: somehow also check `target` for diff!
				edb.Object.$onchange(this, key, oldval, newval);
			}
			suspend = false;
		};
	}

	/**
	 * Since in this case we are not creating models of simple objects and
	 * arrays, we'll need to *clone* the data so that our state doesn't get
	 * entangled into something that another framework depends upon.
	 * @param {object|array} thing
	 * @returns {object|array}
	 */
	function deepclone(thing) {
		try {
			thing = JSON.parse(JSON.stringify(thing));
		} catch (exception) {
			console.error('Could not parse as JSON', exception.message, thing);
		}
		return thing;
	}

	return { // Public ...........................................................

		/**
		 * Simplistic proxy mechanism to dispatch broadcasts on getters and setters.
		 * @param {object} target The object whose properties are being intercepted.
		 * @param {edb.Object|edb.Array} handler The edb.Type instance that
		 *				intercepts the properties
		 */
		approximate: function(target, handler, types) {
			/*
			 * Transfer all methods to the handler.
			 */
			gui.Object.ownmethods(target).forEach(function(key) {
				handler[key] = target[key];
			});

			/*
			 * Clone the first level of properties to make sure we don't entangle the
			 * state of some other system that might still use it for other purposes.
			 * Note that we can't deep clone via JSON parse and stringify because the
			 * next level might still contain *methods* of interest, but that will
			 * again become the first level of any nested Types (so fixed by this).
			 * TODO: We don't need to copy the methods here, so let's not do that ...
			 * TODO: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
			 */
			target = gui.Object.copy(target);

			/*
			 * 1. Objects by default convert to edb.Object
			 * 2. Arrays by default convert to edb.Array
			 * 3. Simple properties get target accessors
			 *
			 * TODO: Setup now proxies array indexes,
			 * unsupport this or re-approximate on changes
			 *
			 * TODO: when resetting array, make sure that
			 * it becomes xx.MyArray (not plain edb.Array)
			 */
			gui.Object.nonmethods(target).forEach(function(key) {
				var desc = Object.getOwnPropertyDescriptor(target, key);
				if (desc.configurable) {
					Object.defineProperty(handler, key, {
						enumerable: desc.enumerable,
						configurable: desc.configurable,
						get: getter(key, function() {
							if (desc.get) {
								return desc.get.call(this);
							} else {
								var inst = types[key];
								if (inst && edb.Type.is(inst)) {
									return inst;
								} else {
									return target[key];
								}
							}
						}),
						set: setter(key, function(value) {
							var Type, type;
							if (desc.set) {
								desc.set.call(this, value);
							} else {
								if ((type = types[key])) {
									if (edb.Type.is(value)) {
										types[key] = value;
									} else {
										if (value === null) {
											types[key] = null; // NOW WE DON't KNOW THE TYPE NEXT TIME!
										} else {
											if (edb.Type.is(type)) {
												Type = type.constructor; // already instantiated
											} else {
												Type = type; // not yet instantiate
											}
											// Type = type.constructor; // TODO: filter function support!
											if (!Type.from) {
												console.error('Bad setup for "' + key + '"');
											}
											types[key] = Type.from(value);
										}
									}
									edb.Object.$onchange(handler, key, type, types[key]);
								} else { // TODO: Clean this up :/
									var oldval = target[key];
									Type = handler.constructor;
									var cast = Type.prototype[key];
									switch (cast) { // TODO: filter function support!
										case Object:
										case Array:
											if (gui.Type.isNull(value) || gui.Type.isComplex(value)) {
												target[key] = deepclone(value); // right?
												if (oldval !== value) { // because clone, this is now always true :/
													// not caught by the setter, let's refactor later
													edb.Object.$onchange(handler, key, oldval, value);
												}
											} else {
												throw new TypeError('Expected ' + cast);
											}
											break;
										default:
											target[key] = edb.Type.cast(value);
											break;
									}
								}
							}
						})
					});
				}
			});
		}
	};
}());



/**
 * Micro change summary.
 */
edb.Change = function() {};
edb.Change.prototype = {

	/**
	 * Type that changed.
	 * @type {edb.Object|edb.Array}
	 */
	object: null,

	/**
	 * Update type.
	 * @type {String}
	 */
	type: null
};



/**
 * edb.Object change summary.
 * @extends {edb.Change}
 * @param {edb.Object} object
 * @param {String} name
 * @param {String} type
 * @param {object} oldval
 * @param {object} newval
 */
edb.ObjectChange = function(object, name, type, oldval, newval) {
	this.object = object;
	this.name = name;
	this.type = type;
	this.oldValue = oldval;
	this.newValue = newval;
};

edb.ObjectChange.prototype = gui.Object.create(edb.Change.prototype, {
	name: null,
	oldValue: undefined,
	newValue: undefined
});

/**
 * We only support type "updated" until
 * native 'Object.observe' comes along.
 * @type {String}
 */
edb.ObjectChange.TYPE_UPDATE = 'update';



/**
 * @see http://wiki.ecmascript.org/doku.php?id=harmony:observe#array.observe
 * @param {edb.Array} array
 */
edb.ArrayChange = function(array, index, removed, added) {
	this.type = edb.ArrayChange.TYPE_SPLICE; // hardcoded for now
	this.object = array;
	this.index = index;
	this.removed = removed || [];
	this.added = added || [];
};

edb.ArrayChange.prototype = gui.Object.create(edb.Change.prototype, {

	/**
	 * Index of change.
	 * @type {}
	 */
	index: -1,

	/**
	 * List removed members.
	 * TODO: What should happen to them?
	 * @type {Array}
	 */
	removed: null,

	/**
	 * List added members.
	 * @type {Array}
	 */
	added: null

});

/*
 * Update types. We'll stick to `splice` for now.
 */
edb.ArrayChange.TYPE_SPLICE = 'splice';

/**
 * Given a `splice` change, compute the arguments required
 * to cause or reproduce the change using `array.splice()`.
 * @see http://mdn.io/splice
 */
edb.ArrayChange.toSpliceParams = function(change) {
	if (change.type === edb.ArrayChange.TYPE_SPLICE) {
		var idx = change.index;
		var out = change.removed.length;
		var add = change.added;
		return [idx, out].concat(add);
	} else {
		throw new TypeError();
	}
};



/**
 * Transmitting output to connected listeners.
 * @see {edb.Input} for related stuff
 * @using {gui.Combo.chained} chained
 */
edb.Output = (function using(chained) {
	return gui.Class.create({

		/**
		 * Get (latest) output of Type.
		 * @returns {edb.Type}
		 */
		get: function() {
			var input = edb.Output.$get(this._type);
			return input ? input.data : null;
		},

		/**
		 * Revoke output of Type.
		 * @param {object} listener
		 * @returns {edb.Output}
		 */
		revoke: chained(function() {
			edb.Output.$revoke(this._type);
		}),

		/**
		 * Add output listener.
		 * @param {object} listener
		 * @returns {edb.Output}
		 */
		connect: chained(function(handler) {
			edb.Input.$connect(this._type, handler);
		}),

		/**
		 * Remove output listener.
		 * @param {object} listener
		 * @returns {edb.Output}
		 */
		disconnect: chained(function(handler) {
			edb.Input.$disconnect(this._type, handler);
		}),

		// Private .................................................................

		/**
		 * The Type we're dealing with here.
		 * @type {constuctor}
		 */
		_type: null,

		// Privileged ..............................................................

		/**
		 * Remember the type.
		 * @param {constructor} Type
		 */
		$onconstruct: function(Type) {
			this._type = Type;
		},

		// Deprecated ..............................................................

		add: function() {
			return this.connect.apply(this, arguments);
		},

		remove: function() {
			return this.disconnect.apply(this, arguments);
		}

	}, {}, { // Static privileged ................................................

		/**
		 * Output Type instance.
		 * @returns {constructor}
		 */
		$output: chained(function(type) {
			var input = this._makeinput(type.constructor, type);
			gui.Broadcast.dispatch(edb.BROADCAST_OUTPUT, input);
			// TODO: if and how to nuke existing output?
		}),

		/**
		 * Revoke type from output. Any subscribers to input of this type
		 * will now recieve an {edb.Input} with `null` as the data value.
		 * @param {constructor|edb.Type} type Accept instance or constructor
		 * @returns {constructor} (this constructor, not that constructor)
		 */
		$revoke: chained(function(type) {
			var Type = edb.Type.is(type) ? type.constructor : type;
			var nullinput = this._makeinput(Type, null);
			gui.Broadcast.dispatch(edb.BROADCAST_OUTPUT, nullinput);
			delete this._map[Type.$classid];
			// TODO: edb.Type.$destruct(type); // think about this...
		}),

		/**
		 * Instance of given Type has been output in public context?
		 * @param {constructor} Type
		 * @returns {boolean}
		 */
		$is: function(Type) {
			if (Type) {
				if (this._map) {
					var classid = Type.$classid;
					var typeobj = this._map[classid];
					return !!typeobj;
				}
				return false;
			} else {
				throw new TypeError('No such Type');
			}
		},

		/**
		 * Get output of given type. Note that this returns an {edb.Input}.
		 * @param {constructor} Type
		 * @returns {edb.Input}
		 */
		$get: function(Type) {
			if (Type) {
				if (this._map) {
					var classid = Type.$classid;
					var typeobj = this._map[classid];
					return typeobj ? new edb.Input(typeobj.constructor, typeobj) : null;
				} else {
					return null;
				}
			} else {
				throw new TypeError('No such Type');
			}
		},

		// Static private ..........................................................

		/**
		 * Mapping Type classname to Type instance.
		 * @type {Map<String,edb.Object|edb.Array>}
		 */
		_map: {},

		/**
		 * Configure Type instance for output.
		 * @param {function} Type constructor
		 * @param {edb.Object|edb.Array} type instance
		 * @returns {edb.Input}
		 */
		_makeinput: function(Type, type) {
			var classid = Type.$classid;
			this._map[classid] = type;
			return new edb.Input(Type, type);
		}

	});
}(gui.Combo.chained));



/**
 * Connecting listeners to output transmissions.
 * @see {edb.Output} for related stuff
 * @using {gui.Combo#chained} chained
 * @using {gui.Combo#memoized} memoized
 * @using {gui.Interface} Interface
 * @using {gui.Type} GuiType
 * @using {gui.Class} GuiType
 */
edb.Input = (function using(chained, memoized, Interface, GuiType, GuiClass) {
	/**
	 * Tracking input handlers (equivalent to "output listeners").
	 * @using {gui.MapList<string,Array<edb.Input.IInputHandler>>} handlers
	 */
	var handlers = new gui.MapList();

	return gui.Class.create({

		/**
		 * Input Type (function constructor)
		 * @type {function}
		 */
		type: null,

		/**
		 * Input instance (instance of this.Type)
		 * @type {object|edb.Type} data
		 */
		data: null,

		/**
		 * Mark as revoked.
		 * @type {boolean}
		 */
		revoked: false,

		/**
		 * Construction time again.
		 * @param {constructor} Type
		 * @param {edb.Object|edb.Array} type
		 */
		onconstruct: function(Type, type) {
			if (edb.Type.is(type) || type === null) {
				this.type = Type;
				this.data = type;
			} else {
				throw new TypeError(type + ' is not a Type instance');
			}
		}

	}, {}, { // Static ...........................................................

		/**
		 * Input handler interface.
		 */
		IInputHandler: {
			oninput: function(i) {},
			toString: function() {
				return '[interface InputHandler]';
			}
		},

		// Privileged static .......................................................

		/**
		 * Add input handler for Type(s).
		 * @param {constructor|Array<constructor>} Types
		 * @param {IInputHandler} handler
		 */
		$connect: chained(function(Types, handler) {
			Types = this.$breakdown(Types);
			if (Interface.validate(this.IInputHandler, handler)) {
				if (Types.every(this._check)) {
					this._add(Types, handler);
				}
			}
		}),

		/**
		 * Remove input handler for Type(s).
		 * @param {constructor|Array<constructor>} Types
		 * @param {IInputHandler} handler
		 */
		$disconnect: chained(function(Types, handler) {
			Types = this.$breakdown(Types);
			if (Interface.validate(this.IInputHandler, handler)) {
				if (Types.every(this._check)) {
					this._remove(Types, handler);
				}
			}
			return Types;
		}),

		/**
		 * Breakdown complicated argument into an
		 * array of one or more type constructors.
		 * @param {object} arg
		 * @returns {constructor|Array<constructor>|string|object}
		 */
		$breakdown: function(arg) {
			if (GuiType.isArray(arg)) {
				return this._breakarray(arg);
			} else {
				return this._breakother(arg);
			}
		},

		/**
		 * Handle output.
		 * @param {edb.Input} input
		 */
		$onoutput: function(input) {
			var Type, type = input.data;
			if (type === null) {
				// TODO: Figure out what to do with revoked output :/
			} else {
				handlers.each(function(classid, list) {
					Type = GuiClass.get(classid);
					if (type instanceof Type) {
						list.slice().forEach(function(handler) {
							handler.oninput(input);
						});
					}
				});
			}
		},

		/**
		 * Lookup identical or ancestor/descandant constructor.
		 * This will come in handy for the {edb.InputPlugin}.
		 * @param {constructor} target type constructor
		 * @param {Array<constructor>} types type constructors
		 * @param {boolean} up Lookup ancestor?
		 * @returns {constructor} edb.Type class
		 */
		$bestmatch: function(target, types, up) {
			return this._bestmatch(target.$classid, types.map(function(type) {
				return type.$classid;
			}), up);
		},

		/**
		 * Rate all types.
		 * @param {function} t
		 * @param {Array<function>} types
		 * @param {boolean} up Rate ancestor?
		 * @param {function} action
		 */
		$rateall: function(target, types, up, action) {
			types.forEach(function(type) {
				action(type, this.$rateone(
					up ? target : type, up ? type : target
				));
			}, this);
		},

		/**
		 * Rate single type. This will come in handy for the {edb.InputPlugin}.
		 * @type {constructor} target
		 * @type {constructor} type
		 * @returns {number} The degree of ancestral separation (-1 for no relation)
		 */
		$rateone: function(target, type) {
			return this._rateone(target.$classid, type.$classid);
		},

		// Private static ..........................................................

		/**
		 * Breakdown array.
		 * @param {Array<function|string|object>}
		 * @returns {Array<constructor>}
		 */
		_breakarray: function(array) {
			return array.map(function(o) {
				switch (GuiType.of(o)) {
					case 'function':
						return o;
					case 'string':
						return gui.Object.lookup(o);
					case 'object':
						console.error('Expected function. Got object.');
				}
			}, this);
		},

		/**
		 * Breakdown not array.
		 * @param {function|String|object} arg
		 * @returns {Array<constructor>}
		 */
		_breakother: function(arg) {
			switch (GuiType.of(arg)) {
				case 'function':
					return [arg];
				case 'string':
					return this._breakarray(arg.split(' '));
				case 'object':
					console.error('Expected function. Got object.');
			}
		},

		/**
		 * Add input handler for types.
		 * @param {Array<constructor>} Types
		 * @param {IInputHandler} handler
		 */
		_add: function(Types, handler) {
			Types.filter(function(Type) {
				return handlers.add(Type.$classid, handler);
			}).forEach(function(Type) {
				GuiClass.descendantsAndSelf(Type, function(T) {
					if (T.isOutput()) {
						var input = edb.Output.$get(Type);
						handler.oninput(input);
					}
				}, this);
			}, this);
		},

		/**
		 * Remove input handler for types.
		 * @param {Array<constructor>} Types
		 * @param {IInputHandler} handler
		 */
		_remove: function(Types, handler) {
			Types.forEach(function(Type) {
				handlers.remove(Type.$classid, handler);
			});
		},

		/**
		 * At least confirm that the Type exists.
		 * @param {constructor} Type
		 * @returns {boolean}
		 */
		_check: function(Type) {
			if (!GuiType.isDefined(Type)) {
				throw new TypeError('Could not register input for undefined Type');
			}
			return true;
		},

		/**
		 * Get identical or ancestor/descandant constructor
		 * by `$classid` and memoize the return value.
		 * @param {string} targetid
		 * @param {Array<string>} typeid
		 * @returns {constructor}
		 */
		_bestmatch: memoized(function(targetid, typeids, up) {
			var best = null,
				rating = Number.MAX_VALUE,
				target = gui.Class.get(targetid),
				types = typeids.map(function(id) {
					return gui.Class.get(id);
				});
			this.$rateall(target, types, up, function(type, rate) {
				if (rate > -1 && rate < rating) {
					rating = rate;
					best = type;
				}
			});
			return best;
		}),

		/**
		 * Rate the degree of separation between classes
		 * by `$classid` and memoize the return value.
		 * @param {string} targetid
		 * @param {string} typeid
		 * @returns {number}
		 */
		_rateone: memoized(function(targetid, typeid) {
			var target = gui.Class.get(targetid);
			var type = gui.Class.get(typeid);
			var r = 0,
				rating = -1,
				parent = target;
			if (target === type) {
				rating = 0;
			} else {
				while ((parent = gui.Class.parent(parent))) {
					r++;
					if (parent === type) {
						parent = null;
						rating = r;
					}
				}
			}
			return rating;
		}),

		// Deprecated ..............................................................

		/**
		 * @deprecated
		 */
		add: function() {
			console.error('Deprecated API is deprecated: edb.Input.add()');
		},

		/**
		 * @deprecated
		 */
		remove: function() {
			console.error('Deprecated API is deprecated: edb.Input.remove()');
		},

		/**
		 * Add input handler for type(s).
		 * @param {constructor|Array<constructor>} Types
		 * @param {IInputHandler} handler
		 */
		$add: function() {
			console.error('Deprecated API is deprecated: edb.Input.$add(). Use edb.Input.$connect()');
			return this.$connect.apply(this, arguments);
		},

		/**
		 * Add input handler for type(s).
		 * @param {constructor|Array<constructor>} Types
		 * @param {IInputHandler} handler
		 */
		$remove: function() {
			console.error('Deprecated API is deprecated: edb.Input.$remove(). Use edb.Input.$disconnect()');
			return this.$disconnect.apply(this, arguments);
		}

	});
}(
	gui.Combo.chained,
	gui.Combo.memoized,
	gui.Interface,
	gui.Type,
	gui.Class)
);

/**
 * Monitor public output.
 */
(function setup() {
	gui.Broadcast.add(edb.BROADCAST_OUTPUT, {
		onbroadcast: function(b) {
			edb.Input.$onoutput(b.data);
		}
	});
}());



/**
 * Crawl structures descending.
 * TODO: Implement 'stop' directive
 */
edb.Crawler = (function() {
	function Crawler() {}
	Crawler.prototype = {

		/**
		 *
		 */
		crawl: function(type, handler) {
			if (edb.Type.is(type)) {
				handle(type, handler);
				crawl(type, handler);
			} else {
				throw new TypeError();
			}
		}
	};

	/**
	 * Note to self: This also crawls array members (via index keys).
	 */
	function crawl(type, handler) {
		gui.Object.each(type, istype).forEach(
			function(oneType) {
				handle(oneType, handler);
				crawl(oneType, handler);
			}
		);
	}

	function istype(key, value) {
		if (edb.Type.is(value)) {
			return value;
		}
	}

	function handle(type, handler) {
		if (handler.ontype) {
			handler.ontype(type);
		}
		if (handler.onarray) {
			if (edb.Array.is(type)) {
				handler.onarray(type);
			}
		}
		if (handler.onobject) {
			if (edb.Object.is(type)) {
				handler.onobject(type);
			}
		}
	}

	return Crawler;
}());



edb.Serializer = (function scoped() {
	function Serializer() {}
	Serializer.prototype = {

		/**
		 * Serialize type.
		 * @param {edb.Object|edb.Array} type
		 * @param @optional {function} filter
		 * @param @optional {String|number} tabs
		 * @returns {String}
		 */
		serializeToString: function(type, filter, tabs) {
			if (isType(type)) {
				return JSON.stringify(parse(type), filter, tabs);
			} else {
				throw new TypeError('Expected edb.Object|edb.Array');
			}
		}
	};

	/**
	 * Match array features leaking into objects.
	 * @type {RegExp}
	 */
	var INTRINSIC = /^length|^\d+/;

	/**
	 * Thing is a type?
	 * @param {object} thing
	 * @returns {boolean}
	 */
	function isType(thing) {
		return edb.Type.is(thing);
	}

	/**
	 * Thing is edb.Array?
	 * @param {object} thing
	 * @returns {boolean}
	 */
	function isArray(type) {
		return edb.Array.is(type);
	}

	/**
	 * Parse as object node or array node.
	 */
	function parse(type) {
		return isArray(type) ? asArray(type) : asObject(type);
	}

	/**
	 * Compute object node.
	 * @param {edb.Object|edb.Array} type
	 * @returns {object}
	 */
	function asObject(type) {
		var map = gui.Object.map(type, mapObject, type);
		return {
			$object: gui.Object.extend({
				$classname: type.$classname,
				$instanceid: type.$instanceid,
				$originalid: type.$originalid
			}, map)
		};
	}

	/**
	 * Compute array node.
	 * @param {edb.Object|edb.Array} type
	 * @returns {object}
	 */
	function asArray(type) {
		return gui.Object.extend(asObject(type), {
			$array: mapArray(type)
		});
	}

	/**
	 * Map the object properties of a type.
	 *
	 * - Skip private (underscore) fields.
	 * - Skip all array intrinsic properties.
	 * - Skip what looks like instance objects.
	 * - Skip getters and setters.
	 * @param {String} key
	 * @param {object} value
	 */
	function mapObject(key, value) {
		var c = key.charAt(0);
		if (c === '_' || c === '$') {
			return undefined;
		} else if (isArray(this) && key.match(INTRINSIC)) {
			return undefined;
		} else if (isType(value)) {
			return parse(value);
		} else if (gui.Type.isComplex(value)) {
			switch (value.constructor) {
				case Object:
				case Array:
					return value;
			}
			return undefined;
		} else {
			if (isType(this)) {
				var base = this.constructor.prototype;
				var desc = Object.getOwnPropertyDescriptor(base, key);
				if (desc && (desc.set || desc.get)) {
					return undefined;
				}
			}
			return value;
		}
	}

	/**
	 * Map array members.
	 * @param {edb.Array} type
	 */
	function mapArray(type) {
		return Array.map(type, function(thing) {
			return isType(thing) ? parse(thing) : thing;
		});
	}

	return Serializer;
}());



edb.Parser = (function() {
	function Parser() {}
	Parser.prototype = {

		/**
		 * @param {String} json
		 * @param @optional {function} type
		 * @returns {edb.Object|edb.Array}
		 */
		parseFromString: function(json, type) {
			try {
				json = JSON.parse(json);
			} catch (JSONException) {
				throw new TypeError('Bad JSON: ' + JSONException.message);
			} finally {
				if (isType(json)) {
					return parse(json, type);
				} else {
					throw new TypeError('Expected serialized edb.Object|edb.Array');
				}
			}
		}
	};

	/**
	 * @returns {edb.Object|edb.Array}
	 */
	function parse(json, type) {
		var Type, name;
		if (type === null) { // eslint-disable-line no-empty
		} else if (type) {
			name = type.$classname || name;
			Type = name ? type : gui.Object.lookup(name);
		} else {
			name = json.$object.$classname;
			Type = gui.Object.lookup(name);
		}
		json = mapValue(json);
		if (type === null) {
			return json;
		} else if (Type) {
			return Type.from(json);
		} else {
			var error = new TypeError(name + ' is not defined');
			if (name === gui.Class.ANONYMOUS) {
				console.error(
					'TODO: Spiritual should make sure ' +
					'that nothing is ever "' + name + '"\n' +
					JSON.stringify(json, null, 4)
				);
			}
			throw error;
		}
	}

	/**
	 * Is typed node?
	 * @param {object} json
	 * @returns {boolean}
	 */
	function isType(json) {
		return gui.Type.isComplex(json) && (json.$array || json.$object);
	}

	/**
	 * Parse node as typed instance.
	 * @param {object} type
	 * @return {object}
	 */
	function asObject(type) {
		return gui.Object.map(type.$object, mapObject);
	}

	/**
	 * Parse array node to a simple array.
	 * Stamp object properties onto array.
	 * @returns {Array}
	 */
	function asArray(type) {
		var members = type.$array.map(mapValue);
		members.$object = type.$object;
		return members;
	}

	/**
	 *
	 */
	function mapObject(key, value) {
		switch (key) {
			case '$classname': // TODO: think about this at some point...
				// case '$instanceid'
				// case '$originalid'
				return undefined;
			default:
				return mapValue(value);
		}
	}

	/**
	 * @returns {}
	 */
	function mapValue(value) {
		if (isType(value)) {
			return value.$array ? asArray(value) : asObject(value);
		}
		return value;
	}

	return Parser;
}());



/**
 * Tracking EDB input. Note that the {edb.ScriptPlugin} is using this
 * plugin, so don't assume the existence of `this.spirit` around here.
 * (the ScriptPlugin residers over in the edbml module, if you wonder).
 * @extends {gui.TrackerPlugin}
 * @using {gui.Combo.chained} chained
 * @using {edb.Input} Input
 */
edb.InputPlugin = (function using(chained, Input) {
	return gui.TrackerPlugin.extend({

		/**
		 * True when one of each expected input type has been collected.
		 * @type {boolean}
		 */
		done: true,

		/**
		 * Construction time.
		 * @overrides {gui.Tracker#onconstruct}
		 */
		onconstruct: function() {
			gui.TrackerPlugin.prototype.onconstruct.call(this);
			this._watches = [];
			this._matches = [];
			this._needing = [];
		},

		/**
		 * Destruction time.
		 */
		ondestruct: function() {
			gui.TrackerPlugin.prototype.ondestruct.call(this);
			this.disconnect(this._watches);
		},

		/**
		 * Connect to output of one or more Types.
		 * @param {edb.Type|String|Array<edb.Type|String>} arg
		 * @param @optional {IInputHandler} handler Defaults to this.spirit
		 * @param @optional {boolean} required
		 * @returns {edb.InputPlugin}
		 */
		connect: chained(function(arg, handler, required) {
			var Types = Input.$breakdown(arg);
			if (Types.length) {
				this.done = this.done && required === false;
				Types.forEach(function(Type) {
					this._addchecks(Type.$classid, [handler || this.spirit]);
					this._watches.push(Type);
					if (required) {
						this._needing.push(Type);
					}
				}, this);
				Input.$connect(Types, this);
			}
		}),

		/**
		 * Disconnect from output of one or more Types.
		 * TODO: Cleanup more stuff?
		 * @param {edb.Type|String|Array<edb.Type|String>} arg
		 * @param @optional {IInputHandler} handler Defaults to this.spirit
		 * @returns {gui.edb.InputPlugin}
		 */
		disconnect: chained(function(arg, handler) {
			var Types = Input.$breakdown(arg);
			if (Types.length) {
				Types.forEach(function(Type) {
					this._removechecks(Type.$classid, [handler || this.spirit]);
					gui.Array.remove(this._watches, Type);
					gui.Array.remove(this._needing, Type);
					this._matches = this._matches.filter(function(input) {
						return input.type !== Type;
					});
				}, this);
				Input.$disconnect(Types, this);
				this.done = this._done();
			}
		}),

		/**
		 * TODO: this
		 */
		one: function() {
			console.error('Not supported just yet: ' + this + '.one()');
		},

		/**
		 * Get Type instance for latest input of Type (or closest match).
		 * TODO: Safeguard somewhat
		 * @param {constructor} Type
		 * @returns {object}
		 */
		get: function(Type) {
			var Types = this._matches.map(function(input) {
				return input.data.constructor;
			});
			var best = Input.$bestmatch(Type, Types, false);
			var input = best ? this._matches.filter(function(inputMatch) {
				return inputMatch.type === best;
			}).shift() : null;
			return input ? input.data : null;
		},

		/**
		 * @implements {Input.IInputHandler}
		 * @param {edb.Input} input
		 */
		oninput: function(input) {
			this.$oninput(input);
		},

		/**
		 * Collect matching input.
		 * @param {Input} input
		 */
		match: function(input) {
			var needstesting = !this._matches.length;
			if (needstesting || this._matches.every(function(match) {
				return match.$instanceid !== input.$instanceid;
			})) {
				return this._maybeinput(input);
			}
			return false;
		},

		// Deprecated ..............................................................

		/**
		 * @deprecated
		 */
		add: function() {
			console.error('Deprecated API is deprecated: input.add(). Use input.connect()');
			return this.connect.apply(this, arguments);
		},

		/**
		 * @deprecated
		 */
		remove: function() {
			console.error('Deprecated API is deprecated: input.remove(). Use input.disconnect()');
			return this.disconnect.apply(this, arguments);
		},

		// Privileged ..............................................................

		/**
		 * Evaluate input.
		 * @param {edb.Input} input
		 */
		$oninput: function(input) {
			if (input) {
				if (input.data === null) {
					this._mayberevoke(input);
					return false;
				} else {
					return this.match(input);
				}
			} else { // debugging...
				throw new TypeError('Bad input: ' + input + ' ' + (this.spirit || ''));
			}
		},

		// Private .................................................................

		/**
		 * Expecting instances of these types (or best match).
		 * @type {Array<constructor>}
		 */
		_watches: null,

		/**
		 * Latest (best) matches, one of each expected type.
		 * @type {Array<Input>}
		 */
		_matches: null,

		/**
		 * Listing strictly `required` types (or best match).
		 * @type {Array<constructor>}
		 */
		_needing: null,

		/**
		 * If input matches registered type, update handlers.
		 * @param {Input} input
		 */
		_maybeinput: function(input) {
			var best = Input.$bestmatch(input.type, this._watches, true);
			if (best) {
				this._updatematch(input, best);
				this.done = this._done();
				this._updatehandlers(input);
				return true;
			}
			return false;
		},

		/**
		 * Evaluate revoked output.
		 * @param {Input} input
		 */
		_mayberevoke: function(input) {
			var matches = this._matches;
			var watches = this._watches;
			var best = Input.$bestmatch(input.type, watches, true);
			if (best) {
				var oldinput = matches.filter(function(inputFilter) {
					return inputFilter.type === best;
				})[0];
				var index = matches.indexOf(oldinput);
				matches.splice(index, 1);
				this.done = this._done();
				if (!this.done) {
					input.revoked = true;
					this._updatehandlers(input);
				}
			}
		},

		/**
		 * Register match for type (remove old match if any).
		 * @param {Input} newinput
		 * @param {constructor} bestmatch
		 */
		_updatematch: function(newinput, bestmatch) {
			var matches = this._matches,
				oldindex = -1,
				oldrating = -1,
				newrating = Input.$rateone(newinput.type, bestmatch);
			matches.forEach(function oldbestmatch(match, i) {
				oldrating = Input.$rateone(match.type, bestmatch);
				if (oldrating > -1 && oldrating <= newrating) {
					oldindex = i;
				}
			});
			if (oldindex > -1) {
				matches[oldindex] = newinput;
			} else {
				matches.push(newinput);
			}
		},

		/**
		 * Update input handlers.
		 * @param {Input} input
		 */
		_updatehandlers: function(input) {
			gui.Class.ancestorsAndSelf(input.type, function(Type) {
				var list = this._trackedtypes[Type.$classid];
				if (list) {
					list.forEach(function(checks) {
						var handler = checks[0];
						handler.oninput(input);
					});
				}
			}, this);
		},

		/**
		 * All required inputs has been aquired?
		 * @returns {boolean}
		 */
		_done: function() {
			var needs = this._needing;
			var haves = this._matches;
			return needs.every(function(Type) {
				return haves.some(function(input) {
					return (input.data instanceof Type);
				});
			});
		},

		/**
		 * Cleanup when destructed.
		 * @param {String} type
		 * @param {Array<object>} checks
		 */
		_cleanup: function(classid, checks) {
			if (this._removechecks(classid, checks)) {
				var Type = gui.Class.get(classid);
				Input.$disconnect(Type, this);
			}
		}

	});
}(gui.Combo.chained, edb.Input));



/*
 * Register module.
 */
gui.module('edb@wunderbyte.com', {

	/*
	 * Register plugins for all spirits
	 * (if the GUI spirits are avilable).
	 */
	plugin: {
		input: edb.InputPlugin
	},

	/**
	 * Register method for all spirits.
	 * (if the GUI spirits are avilable).
	 */
	mixin: {

		/**
		 * Do `typeinstance.output()` to trigger this method.
		 * The `input.data` property points to `typeinstance`
		 * @param {edb.Input} input
		 */
		oninput: function(input) {
			// do something with input.data...
		}
	}

});



/**
 * Synchronization studio.
 */
edb.Synchronizer = (function() {
	/**
	 * Setup type for synchronization.
	 * @param {edb.Type} type
	 * @param {number} ways
	 * @param {boolean} global
	 */
	function sync(type, ways, global) {
		var id = type.$originalid || type.$instanceid;
		if (ways === 4 || ways === 1) {
			syncto(type, id, global);
		}
		if (ways === 4 || ways === 2) {
			syncas(type, id, global);
		}
		type.$synchronizity = ways;
		type.$synchglobally = global || false;
	}

	/**
	 * @param {edb.Type} type
	 * @param {string} id
	 * @param {boolean} global
	 */
	function syncto(type, id, global) {
		var broadcast = edb.SyncTransmitter.BROADCAST + id;
		var addscoped = global ? 'addGlobal' : 'add';
		gui.Broadcast[addscoped](broadcast,
			new edb.SyncReceiver(type)
		);
	}

	/**
	 * @param {edb.Type} type
	 * @param {string} id
	 * @param {boolean} global
	 */
	function syncas(type, id, global) {
		type.addObserver(edb.SyncTransmitter);
		if (global) {
			edb.Synchronizer.globals[id] = true;
		}
	}

	return { // Public ...........................................................

		$NONE: 0,
		$SYNC_AS: 1,
		$SYNC_TO: 2,
		$SYNC: 4,

		/**
		 * Tracking globally synchronized $instanceids.
		 * @type {Map<string,boolean>}
		 */
		globals: Object.create(null),

		/**
		 * @param {edb.Type} type
		 * @param {number} ways
		 * @param {boolean} global
		 */
		sync: gui.Arguments.confirmed('object', 'number', '(boolean)')(
			function(type, ways, global) {
				new edb.Crawler().crawl(type, {
					ontype: function(t) {
						if (!t.$synchronizity) {
							sync(t, ways, global);
						}
					}
				});
				return type;
			}
		)
	};
}());



/**
 *
 * @param {edb.ObjectChange} change
 * @param {String} instanceid
 */
edb.ObjectSync = function(change, instanceid) {
	change = gui.Object.copy(change);
	change = edb.ObjectSync.experimental(change);
	change = edb.ObjectSync.filter(change);
	gui.Object.extend(this, change);
	this.$instanceid = instanceid;
};

edb.ObjectSync.prototype = {
	name: null,
	type: null,
	newValue: null,
	$instanceid: null
};

edb.ObjectSync.experimental = function(change) {
	var old = change.oldValue;
	var neu = change.newValue;
	if (edb.Type.is(old)) {
		change.$synchronizity = old.$synchronizity;
		change.$synchglobally = old.$synchglobally;
		change.newValue = JSON.parse(
			neu.serializeToString()
		);
	}
	return change;
};

/**
 * Reduce the payload by removing `object` and `oldValue`.
 * @param {edb.ObjectChange} change
 * @returns {object}
 */
edb.ObjectSync.filter = function(change) {
	return gui.Object.map(change, function(key, value) {
		if (!key.match(/oldValue|object/)) {
			return value;
		}
	});
};



/**
 *
 * @param {edb.ArrayChange} change
 * @param {String} instanceid
 */
edb.ArraySync = function(change, instanceid) {
	var array = change.object;
	this.$synchronizity = array.$synchronizity;
	this.$synchglobally = array.$synchglobally;
	this.type = edb.ArrayChange.TYPE_SPLICE;
	change.added = change.added.map(function(thing) {
		return edb.Type.is(thing) ?
			JSON.parse(thing.serializeToString()) : thing;
	});
	this.args = edb.ArrayChange.toSpliceParams(change);
	this.$instanceid = instanceid;
};

edb.ArraySync.prototype = {
	type: null,
	args: null,
	$instanceid: null
};



/**
 * Synchronization studio.
 * @using {gui.Arguments#confirmed}
 */
edb.SyncTransmitter = (function using(confirmed) {
	/**
	 * Relay all changes from monitored source to
	 * synchronized targets via broadcast message.
	 * @param {Array<edb.Change>} changes
	 */
	function onchange(changes) {
		var dispatch = {};
		var syncdone = [];
		changes.forEach(function(c) {
			maybechange(c, c.object, dispatch, syncdone);
		});
		gui.Object.each(dispatch, function(id, syncs) {
			var method = edb.Synchronizer.globals[id] ? 'dispatchGlobal' : 'dispatch';
			gui.Broadcast[method](edb.SyncTransmitter.BROADCAST + id, syncs);
		});
		syncdone.forEach(function(type) {
			delete type.$willsync;
		});
	}

	/**
	 * @param {gui.Change} change
	 * @param {edb.Type} type
	 * @param {Map} dispatch
	 * @param {Array} syncdone
	 */
	function maybechange(change, type, dispatch, syncdone) {
		var sourceid = type.$instanceid;
		var targetid = type.$originalid || sourceid;
		if (type.$willsync) {
			syncdone.push(type);
		} else {
			setupsync(change);
			var changes = dispatch[targetid] = (dispatch[targetid] || []);
			changes.push(getchange(change, sourceid));
		}
	}

	/**
	 * @param {edb.Change} change
	 * @param {String} sourceid
	 * @returns {edb.ObjectSync|edb.ArraySync}
	 */
	function getchange(change, sourceid) {
		switch (change.type) {
			case edb.ObjectChange.TYPE_UPDATE:
				return new edb.ObjectSync(change, sourceid);
			case edb.ArrayChange.TYPE_SPLICE:
				return new edb.ArraySync(change, sourceid);
		}
	}

	/**
	 * Setup sync for newly introduced types.
	 * @param {edb.Change} change
	 */
	function setupsync(change) {
		function maybesync(thing) {
			if (edb.Type.is(thing)) {
				edb.Synchronizer.sync(thing,
					change.object.$synchronizity,
					change.object.$synchglobally
				);
			}
		}
		switch (change.type) {
			case edb.ObjectChange.TYPE_UPDATE:
				maybesync(change.newValue);
				break;
			case edb.ArrayChange.TYPE_SPLICE:
				change.added.forEach(maybesync);
				break;
		}
	}

	return { // Public ...........................................................

		/**
		 * Synchronization broadcast to be suffixed with `$instanceid`
		 * (more unique broadcasts implies less overhead in handlers).
		 * @type {String}
		 */
		BROADCAST: 'edb-synchronize-',

		/**
		 * Handle changes.
		 * @implements {IChangeHandler}
		 */
		onchange: function(changes) {
			onchange(changes);
		}
	};
}(gui.Arguments.confirmed));



/**
 * TODO: nuke this thing on type dispose
 * @param {edb.Type} type
 */
edb.SyncReceiver = function(type) {
	this.type = type;
};

edb.SyncReceiver.prototype = {

	/**
	 * Each type associated to an instance of {edb.SyncReceiver}
	 * @type {edb.Type}
	 */
	type: null,

	/**
	 * Handle broadcast.
	 * @param {gui.Broadcast} b
	 */
	onbroadcast: function(b) {
		var type = this.type;
		var changes = b.data;
		if (changes.some(function(c) {
			return c.$instanceid !== type.$instanceid;
		})) {
			changes.forEach(function(c) {
				this._change(type, c);
			}, this);
		}
	},

	/**
	 * Change type somehow.
	 * @param {edb.Object|edb.Array} type
	 * @param {edb.ObjectSync|edb.ArraySync} c
	 */
	_change: function(type, c) {
		switch (c.type) {
			case edb.ObjectChange.TYPE_UPDATE:
				this._objectchange(type, c);
				break;
			case edb.ArrayChange.TYPE_SPLICE:
				this._arraychange(type, c);
				break;
		}
	},

	/**
	 * Change object properties.
	 * @param {edb.Object|edb.Array} type
	 * @param {edb.ObjectSync} c
	 */
	_objectchange: function(type, c) {
		var name = c.name,
			value = c.newValue;
		if (type[name] !== value) {
			if (value && (value.$object || value.$array)) { // TODO is-abstract-edb-tree somehow...
				value = JSON.stringify(value);
				value = new edb.Parser().parseFromString(value);
				edb.Synchronizer.sync(value, c.$synchronizity, c.$synchglobally);
			}
			type.$willsync = true;
			type[name] = value;
		}
	},

	/**
	 * Change array structure.
	 * @param {edb.Array} type
	 * @param {edb.ArraySync} c
	 */
	_arraychange: function(type, c) {
		type.$willsync = true;
		var isobject = gui.Type.isObject;
		var x = c.args.slice(2).map(function(thing) {
			if (isobject(thing) && (thing.$object || thing.$array)) {
				thing = JSON.stringify(thing);
				thing = new edb.Parser().parseFromString(thing);
				edb.Synchronizer.sync(thing, c.$synchronizity, c.$synchglobally);
			}
			return thing;
		});
		x.unshift(c.args[1]);
		x.unshift(c.args[0]);
		type.splice.apply(type, x);
	}
};



/**
 * Sync module.
 */
gui.module('edb-sync@wunderbyte.com', {

	oncontextinitialize: function() {
		/**
		 * Create synchronized instance of Type from source.
		 * @param {edb.Type} type
		 * @param {edb.Type|String} source
		 * @param {number} ways
		 * @param @optional {boolean} global
		 * @returns {edb.Type}
		 */
		function sync(Type, source, ways, global) {
			return edb.Synchronizer.sync(Type.from(source), ways, global);
		}

		/**
		 * Hello.
		 */
		edb.Type.mixin({ // Instance properties ....................................

			/**
			 *
			 */
			$synchronizity: edb.SyncTransmitter.$NONE,

			/**
			 *
			 */
			$synchglobally: false

		}, { // Recurring static ...................................................

			/**
			 * Create out-synchronized instance from source.
			 * @param {edb.Type|String} source
			 * @returns {edb.Type}
			 */
			syncAs: function(source) {
				return sync(this, source, edb.Synchronizer.$SYNC_AS);
			},

			/**
			 * Create in-synchronized instance from source.
			 * @param {edb.Type|String} source
			 * @returns {edb.Type}
			 */
			syncTo: function(source) {
				return sync(this, source, edb.Synchronizer.$SYNC_TO);
			},

			/**
			 * Create synchronized instance from source.
			 * @param {edb.Type|String} source
			 * @returns {edb.Type}
			 */
			sync: function(source) {
				return sync(this, source, edb.Synchronizer.$SYNC);
			},

			/**
			 * Create global out-synchronized instance from source.
			 * @param {edb.Type|String} source
			 * @returns {edb.Type}
			 */
			syncGlobalAs: function(source) {
				return sync(this, source, edb.Synchronizer.$SYNC_AS, true);
			},

			/**
			 * Create global in-synchronized instance from source.
			 * @param {edb.Type|String} source
			 * @returns {edb.Type}
			 */
			syncGlobalTo: function(source) {
				return sync(this, source, edb.Synchronizer.$SYNC_TO, true);
			},

			/**
			 * Create global synchronized instance from source.
			 * @param {edb.Type|String} source
			 * @returns {edb.Type}
			 */
			syncGlobal: function(source) {
				return sync(this, source, edb.Synchronizer.$SYNC, true);
			}

		});
	}
});



}(self));
(function(window) {

"use strict";


/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 MaxArt2501
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function using(root) {
	if (root.atob) {
				// Some browsers' implementation of atob doesn't support whitespaces
				// in the encoded string (notably, IE). This wraps the native atob
				// in a function that strips the whitespaces.
				// The original function can be retrieved in atob.original
		try {
			root.atob(' ');
		} catch (e) {
			root.atob = (function(atob) {
				var func = function(string) {
					return atob(String(string).replace(/[\t\n\f\r ]+/g, ''));
				};
				func.original = atob;
				return func;
			})(root.atob);
		}
		return;
	}

				// base64 character set, plus padding character (=)
	var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
				// Regular expression to check formal correctness of base64 encoded strings
		b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;

	root.btoa = function(string) {
		string = String(string);
		var bitmap, a, b, c,
			result = '', i = 0,
			rest = string.length % 3; // To determine the final padding

		for (; i < string.length;) {
			if ((a = string.charCodeAt(i++)) > 255 || (b = string.charCodeAt(i++)) > 255 || (c = string.charCodeAt(i++)) > 255) {
				throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.");
			}
			bitmap = (a << 16) | (b << 8) | c;
			result += b64.charAt(bitmap >> 18 & 63) + b64.charAt(bitmap >> 12 & 63) + b64.charAt(bitmap >> 6 & 63) + b64.charAt(bitmap & 63);
		}

				// If there's need of padding, replace the last 'A's with equal signs
		return rest ? result.slice(0, rest - 3) + '==='.substring(rest) : result;
	};

	root.atob = function(string) {
				// atob can work with strings with whitespaces, even inside the encoded part,
				// but only \t, \n, \f, \r and ' ', which can be stripped.
		string = String(string).replace(/[\t\n\f\r ]+/g, '');
		if (!b64re.test(string)) {
			throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
		}

				// Adding the padding if missing, for semplicity
		string += '=='.slice(2 - (string.length & 3));
		var bitmap, result = '', r1, r2, i = 0;
		for (; i < string.length;) {
			bitmap = b64.indexOf(string.charAt(i++)) << 18 | b64.indexOf(string.charAt(i++)) << 12 |
										(r1 = b64.indexOf(string.charAt(i++))) << 6 | (r2 = b64.indexOf(string.charAt(i++)));

			result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) :
										r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) :
										String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
		}
		return result;
	};
}(self));



/*
 * The file is called 'ts-namespace.js' because there's another `ts.js` in
 * the game, that's the Runtime bootloader in the root of the `src/runtime/js`.
 */
window.ts = window.ts || { // something called `ts` exists in Grails already...
	toString: function() {
		return '[namespace ts]';
	}
};



gui.$mark('- parse runtime');

/**
 * Don't automatically bootstrap as soon as `DOMContentLoaded` occurs.
 * Instead we bootstrap manually in the method {ts.ui.$maybebootstrap}.
 * @overwrites {gui#bootstrap}
 */
gui.autostrap = false;

/**
 * Namespace object.
 * @using {gui.Client} Client
 * @using {gui.Array} guiArray
 * @using {gui.Arguments.confirmed} confirmed
 * @using {gui.Combo.chained} chained
 */
ts.ui = gui.namespace('ts.ui', (function using(Client, guiArray, confirmed, chained) {
	/*
	 * Supports a temp ad hoc API for breakpoint callbacks.
	 * @type {Array<function>}
	 */
	var breakpointers = [];

	return {

		/**
		 * The tradeshift-ui version goes here (via Gruntfile.js)
		 * @type {string}
		 */
		version: '7.0.0-beta.9',

		/**
		 * Nothing is "greenfield" now. If we should ever need it, we
		 * would default to `true` and switch to `false` if and when
		 * all the tradeshift-ui CSS is loaded into the document.
		 * Note to new readers: The term "greenfield" here covers a
		 * scenario where only the JavaScript APIs are loaded into
		 * the document and the actual UI elements are rendered in
		 * a separate window (in the chrome or an embedded iframe).
		 * @type {boolean}
		 */
		greenfield: false,

		/**
		 * Is running inside the Frankenstein chrome? Issue is that Chrome (the
		 * browser) cannot investigate anything in the containing frame without
		 * throwing security exceptions *if* indeed it's not in Frankenstein,
		 * but we can at least inspect the page location href.
		 * @type {boolean}
		 */
		frankenstein: (function(path) {
			var vendorappid = /[A-Z][A-Za-z]+\.[A-Z][A-Za-z]+/;
			return !!(window !== top &&
				(
					path.includes('/app/') ||
					path.includes('/v4/') ||
					path.match(vendorappid)
				)
			);
		}(window.location.pathname)),

		/**
		 * Should only ever be true in the top frame (chrome).
		 * @type {boolean}
		 */
		topframe: false,

		/**
		 * Should ever only be true inside the second level app host frame.
		 * That is, NOT inside the innermost app frame or in the top frame.
		 * @type {boolean}
		 */
		subframe: false,

		/**
		 * Appframe assumed true unless explicitely denied eg. using meta tag:
		 * <meta name="ts.ui.appframe" content="false"/>
		 */
		appframe: true,

		/**
		 * Current breakpoint.
		 * TODO: This remains `null` until window is resized or what?
		 * @type {string}
		 */
		breakpoint: null,

		/**
		 * Generally use CSS transitions?
		 * @type {boolean}
		 */
		usetransitions: Client.hasTransitions,

		/**
		 * Use pointerevents? Except for IE9, we have that covered via a polyfill.
		 * @type {boolean}
		 */
		hasPointers: Client.hasPointers || !Client.isExplorer9,

		// Miscelaneous ............................................................

		/**
		 * Magic URL substring used on the Dox website
		 * (so perhaps this constant should be renamed).
		 * @type {string}
		 */
		TRADESHIFT_HOME: '/',

		// Units ...................................................................

		UNIT: 22,
		UNIT_HALF: 11,
		UNIT_DOUBLE: 44,
		UNIT_TRIPLE: 66,

		// Classnames ..............................................................

		// browserhacks (synchronized to the browser)
		CLASS_ENGINE: ('ts-engine-' + Client.agent),

		// breakpoints
		CLASS_MOBILE: 'ts-mobile',
		CLASS_TABLET: 'ts-tablet',
		CLASS_DESKTOP: 'ts-desktop',
		CLASS_SELECT: 'ts-select',
		CLASS_MOBILE_ONLY: 'ts-mobile-only',
		CLASS_TABLET_ONLY: 'ts-tablet-only',
		CLASS_DESKTOP_ONLY: 'ts-desktop-only',

		// layout
		CLASS_HAS_TOPBAR: 'ts-has-topbar',
		CLASS_HAS_TOPBAR_TABS: 'ts-has-topbar-tabs',
		CLASS_HAS_NOTE: 'ts-has-note',
		CLASS_USEFLEX: 'ts-useflex',
		CLASS_NOFLEX: 'ts-noflex',
		CLASS_USETRANSITION: 'ts-usetransition',
		CLASS_NOTRANSITION: 'ts-notransition',
		CLASS_TRANSITION: 'ts-transition',

		// abstract
		CLASS_PRIMARY: 'ts-primary',
		CLASS_SECONDARY: 'ts-secondary',
		CLASS_TERTIARY: 'ts-tertiary',
		CLASS_DANGER: 'ts-danger',
		CLASS_VISIBLE: 'ts-visible',
		CLASS_HIDDEN: 'ts-hidden',
		CLASS_LOADING: 'ts-loading',
		CLASS_BLOCKING: 'ts-blocking',
		CLASS_NONBLOCKING: 'ts-nonblocking',
		CLASS_WAITING: 'ts-waiting',
		CLASS_READY: 'ts-ready',
		CLASS_BUSY: 'ts-busy',
		CLASS_OPEN: 'ts-open',
		CLASS_CLOSED: 'ts-closed',
		CLASS_OPENING: 'ts-opening',
		CLASS_CLOSING: 'ts-closing',
		CLASS_TOP: 'ts-top',
		CLASS_RIGHT: 'ts-right',
		CLASS_BOTTOM: 'ts-bottom',
		CLASS_LEFT: 'ts-left',
		CLASS_MICRO: 'ts-micro',
		CLASS_MACRO: 'ts-macro',
		CLASS_CHECKED: 'ts-checked',
		CLASS_SELECTED: 'ts-selected',
		CLASS_SUCCESS: 'ts-success',
		CLASS_WARNING: 'ts-warning',
		CLASS_ERROR: 'ts-error',
		CLASS_INFO: 'ts-info',
		CLASS_OPTIMIZED: 'ts-optimized',

		// widgets - TODO: maybe move to core-gui@tradeshift.com
		CLASS_MAIN: 'ts-main',
		CLASS_IFRAME: 'ts-iframe', // TODO: this should move into the chrome!
		CLASS_MAINFRAME: 'ts-mainframe', // TODO: this should move into the chrome!
		CLASS_TABS: 'ts-tabs',
		CLASS_COVER: 'ts-cover',
		CLASS_ASIDE: 'ts-aside',
		CLASS_DRAWER: 'ts-drawer',
		CLASS_HEADER: 'ts-header',
		CLASS_PANEL: 'ts-panel',
		CLASS_MENU: 'ts-menu',
		CLASS_BUTTON: 'ts-button',
		CLASS_BUTTONS: 'ts-buttons',
		CLASS_LINK: 'ts-link',
		CLASS_DIALOG: 'ts-dialog',
		CLASS_NOTE: 'ts-note',
		CLASS_LOADING_BAR: 'ts-loading-bar',
		CLASS_IS_LOADING: 'ts-is-loading',

		// forms - TODO: maybe move to forms-gui@tradeshift.com
		CLASS_FORM: 'ts-form',
		CLASS_FIELD: 'ts-field',
		CLASS_GROUP: 'ts-group',
		CLASS_TEXT: 'ts-text',
		CLASS_DATE: 'ts-date',
		CLASS_TIME: 'ts-time',
		CLASS_FAKE: 'ts-fake',
		CLASS_TEXTAREA: 'ts-textarea',
		CLASS_FIELDLABEL: 'ts-fieldlabel',
		CLASS_TEXTLABEL: 'ts-textlabel',
		CLASS_DATELABEL: 'ts-datelabel',
		CLASS_FAKELABEL: 'ts-fakelabel',
		CLASS_SWITCHLABEL: 'ts-switchlabel',
		CLASS_CUSTOMICONLABEL: 'ts-customiconlabel',
		CLASS_OPTIONS: 'ts-options',
		CLASS_OPTION: 'ts-option',
		CLASS_FOCUS: 'ts-focus',
		CLASS_FOCUS_ON: 'ts-focus-on',
		CLASS_EMPTY: 'ts-empty',
		CLASS_SWITCHBOX: 'ts-switchbox',
		CLASS_DISABLED: 'ts-disabled',
		CLASS_READONLY: 'ts-readonly',
		CLASS_REQUIRED: 'ts-required',
		CLASS_NOLOCK: 'ts-nolock',
		CLASS_HASLABEL: 'ts-haslabel',

		// background colors
		CLASS_BG_LITE: 'ts-bg-lite',
		CLASS_BG_WHITE: 'ts-bg-white',
		CLASS_BG_DARK: 'ts-bg-dark',
		CLASS_BG_BLUE: 'ts-bg-blue',
		CLASS_BG_GREEN: 'ts-bg-green',
		CLASS_BG_YELLOW: 'ts-bg-yellow',
		CLASS_BG_RED: 'ts-bg-red',
		CLASS_BG_PURPLE: 'ts-bg-purple',

		// amazing colors
		CLASS_BLACK: 'ts-color-black',
		CLASS_DARK: 'ts-color-dark',
		CLASS_MEDIUM: 'ts-color-medium',
		CLASS_LITE: 'ts-color-lite',
		CLASS_WHITE: 'ts-color-white',
		CLASS_BLUE: 'ts-color-blue',
		CLASS_GREEN: 'ts-color-green',
		CLASS_YELLOW: 'ts-color-yellow',
		CLASS_RED: 'ts-color-red',
		CLASS_PURPLE: 'ts-color-purple',

		// Icons ...................................................................

		ICON_CLOSE: 'ts-icon-close',

		// Actions .................................................................

		// local actions
		ACTION_CLICK: 'ts-action-click',
		ACTION_CLOSE: 'ts-action-close',
		ACTION_SWITCH: 'ts-action-switch',
		ACTION_DID_LOAD: 'ts-action-did-load',
		ACTION_CHANGED: 'ts-action-changed',
		ACTION_FRAME_ONDOM: 'ts-action-frame-ondom',
		ACTION_FRAME_ONLOAD: 'ts-action-frame-onload',
		ACTION_FRAME_UNLOAD: 'ts-action-frame-unload',
		ACTION_FRAME_ONHASH: 'ts-action-frame-onhash',
		ACTION_ASIDE_WILL_OPEN: 'ts-action-aside-will-open',
		ACTION_ASIDE_DID_OPEN: 'ts-action-aside-did-open',
		ACTION_ASIDE_WILL_CLOSE: 'ts-action-aside-will-close',
		ACTION_ASIDE_DID_CLOSE: 'ts-action-aside-did-close',
		ACTION_SAFE_LINK: 'ts-action-safe-link',
		ACTION_SAFE_BUTTON: 'ts-action-safe-button',
		ACTION_SAFE_FORM: 'ts-action-safe-form',
		ACTION_PANEL_ATTACH: 'ts-action-panel-attach',
		ACTION_PANEL_DETACH: 'ts-action-panel-detach',
		ACTION_PANEL_SHOW: 'ts-action-panel-show',
		ACTION_PANEL_HIDE: 'ts-action-panel-hide',
		ACTION_PAGER_SELECT: 'ts-action-pager-select',
		ACTION_STATUSBAR_LEVEL: 'ts-action-statusbar-level',
		ACTION_ROOT_CLASSNAMES: 'ts-action-root-classnames',

		// postmessages
		MESSAGE_BUSY: 'ts-busy',
		MESSAGE_DONE: 'ts-done',

		// global actions
		ACTION_GLOBAL_LOAD: 'ts-action-g-load',
		ACTION_GLOBAL_LOAD_HTML: 'ts-action-g-load-html',
		ACTION_GLOBAL_LOCATION_CHANGEHREF: 'ts-action-g-location-changehref',
		ACTION_GLOBAL_LOCATION_CHANGEHASH: 'ts-action-g-location-changehash',
		ACTION_GLOBAL_MODELS_INITIALIZE: 'ts-action-g-models-initialize',
		ACTION_GLOBAL_COMPLETED: 'ts-action-g-completed',
		ACTION_GLOBAL_TERMINATE: 'ts-action-g-terminate',
		ACTION_GLOBAL_MESSAGE_UP: 'ts-action-g-message-up',
		ACTION_GLOBAL_MESSAGE_DOWN: 'ts-action-g-message-down',
		ACTION_GLOBAL_DOCUMENT_TITLE: 'ts-action-g-document-title',
		ACTION_GLOBAL_LOCALSTORAGE_SET: 'ts-action-g-localdata-set',
		ACTION_GLOBAL_LOCALSTORAGE_ERROR: 'ts-action-g-localdata-error',
		ACTION_GLOBAL_ANALYTICS_READY: 'ts-action-g-analytics-ready',
		ACTION_GLOBAL_ANALYTICS_SETUP: 'ts-action-g-analytics-setup',
		ACTION_GLOBAL_ANALYTICS_TRACK: 'ts-action-g-analytics-track',

		// Broadcasts ..............................................................

		// local broadcasts
		BROADCAST_COMPLETED: 'ts-broadcast-completed',
		BROADCAST_TERMINATE: 'ts-broadcast-terminate',
		BROADCAST_DIALOG_WILL_OPEN: 'ts-broadcast-dialog-will-open',
		BROADCAST_DIALOG_GO_OPEN: 'ts-broadcast-dialog-go-open',
		BROADCAST_DIALOG_DID_OPEN: 'ts-broadcast-dialog-did-open',
		BROADCAST_DIALOG_WILL_CLOSE: 'ts-broadcast-dialog-will-close',
		BROADCAST_DIALOG_DID_CLOSE: 'ts-broadcast-dialog-did-close',
		BROADCAST_MODAL_WILL_OPEN: 'ts-broadcast-modal-will-open',
		BROADCAST_MODAL_DID_OPEN: 'ts-broadcast-modal-did-open',
		BROADCAST_MODAL_WILL_CLOSE: 'ts-broadcast-modal-will-close',
		BROADCAST_MODAL_DID_CLOSE: 'ts-broadcast-modal-did-close',
		BROADCAST_ATTENTION_MOVE: 'ts-broadcast-attention-move',
		BROADCAST_PANEL_SYNC_MENU: 'ts-broadcast-panel-sync-to-menu',

		// global broadcasts
		BROADCAST_GLOBAL_MODEL_UPDATE: 'ts-broadcast-g-model-update',
		BROADCAST_GLOBAL_STATUS_BUSY_BLOCKING: 'ts-broadcast-g-status-busy-blocking',
		BROADCAST_GLOBAL_STATUS_DONE_BLOCKING: 'ts-broadcast-g-status-done-blocking',
		BROADCAST_GLOBAL_STATUS_BUSY: 'ts-broadcast-g-status-busy',
		BROADCAST_GLOBAL_STATUS_DONE: 'ts-broadcast-g-status-done',
		BROADCAST_GLOBAL_ALL_BUSY: 'ts-broadcast-g-all-busy',
		BROADCAST_GLOBAL_ALL_DONE: 'ts-broadcast-g-all-done',
		BROADCAST_GLOBAL_DIALOGS_WILL_ON: 'ts-broadcast-g-dialogs-will-on',
		BROADCAST_GLOBAL_DIALOGS_DID_OFF: 'ts-broadcast-g-dialogs-did-off',
		BROADCAST_GLOBAL_DIALOGS_WILL_BLOCK: 'ts-broadcast-g-dialogs-will-block',
		BROADCAST_GLOBAL_DIALOGS_DID_UNBLOCK: 'ts-broadcast-g-dialogs-did-unblock',
		BROADCAST_GLOBAL_ASIDES_WILL_ON: 'ts-broadcast-g-asides-will-on',
		BROADCAST_GLOBAL_ASIDES_DID_ON: 'ts-broadcast-g-asides-did-on',
		BROADCAST_GLOBAL_ASIDES_WILL_OFF: 'ts-broadcast-g-asides-will-off',
		BROADCAST_GLOBAL_ASIDES_DID_OFF: 'ts-broadcast-g-asides-did-off',
		BROADCAST_GLOBAL_ASIDES_DO_CLOSE: 'ts-broadcast-g-asides-do-close',
		BROADCAST_GLOBAL_PROGRESSBAR: 'ts-broadcast-g-progressbar',
		BROADCAST_GLOBAL_APP_LOADING: 'ts-broadcast-g-app-loading',
		BROADCAST_GLOBAL_APP_ABORTED: 'ts-broadcast-g-app-aborted',
		BROADCAST_GLOBAL_APP_COMPLETE: 'ts-broadcast-g-app-complete',
		BROADCAST_GLOBAL_TOPBAR_UPDATE: 'ts-broadcast-g-topbar-update',
		BROADCAST_GLOBAL_TOPBAR_READY: 'ts-broadcast-g-topbar-ready',
		BROADCAST_GLOBAL_TOPBAR_UPDATE_DEFAULT_TITLE: 'ts-broadcast-g-topbar-update-default-title',
		BROADCAST_GLOBAL_USER_WILL_EXIT: 'ts-broadcast-g-user-will-exit',
		BROADCAST_GLOBAL_COVER_TOUCH: 'ts-broadcast-global-cover-touch',
		BROADCAST_GLOBAL_COVER_HOVER: 'ts-broadcast-global-cover-hover',
		BROADCAST_GLOBAL_MENU_OPEN: 'ts-broadcast-g-menu-open',
		BROADCAST_GLOBAL_MENU_CLOSE: 'ts-broadcast-g-menu-close',

		// Events ..................................................................

		EVENT_ASIDE_WILL_OPEN: 'ts-open',
		EVENT_ASIDE_DID_OPEN: 'ts-opened',
		EVENT_ASIDE_WILL_CLOSE: 'ts-close',
		EVENT_ASIDE_DID_CLOSE: 'ts-closed',
		EVENT_FOCUS: 'ts-focus',
		EVENT_BLUR: 'ts-blur',

		// Ticks ...................................................................

		TICK_SELECT_CHECK: 'ts-tick-select-check',

		// Lifecycle ...............................................................

		LIFE_STATUS_BUSY: 'ts-life-status-busy',
		LIFE_STATUS_DONE: 'ts-life-status-done',

		// Animations ..............................................................

		TRANSITION_NOW: 100,
		TRANSITION_FAST: 200,
		TRANSITION_SLOW: 600,
		TRANSITION_DELAY: 30,
		TIMING_SLOWDOWN: 'cubic-bezier(0,1,0,1)',
		TIMING_SPEEDUP: 'cubic-bezier(1,0,1,0)',

		// Z-indexes ...............................................................

		ZINDEX_ASIDE: 2000, // duplicates @ts-zindex-aside in ts-variables.less

		// Methods .................................................................

		/**
		 * Facade `gui.get`: Lookup first spirit instance for argument(s).
		 * @param {String|Element} arg
		 * @param @optional {function} callback
		 * @param @optional {object} thisp
		 * @return {gui.Spirit|gui.Then}
		 */
		get: function() {
			return gui.get.apply(gui, arguments);
		},

		/**
		 * Facade `gui.init`: Do something before the spirits get
		 * here. Or if that's already too late, just do it now.
		 * @param {function} action
		 * @param {Object=} opt_thisp
		 * @returns {Namespace}
		 */
		init: chained(function(action, opt_thisp) {
			gui.init(action, opt_thisp);
		}),

		/**
		 * Facade `gui.ready`: Do something when everything is spiritualized
		 * (after `DOMContentLoaded`). Or if that's already too late, just do it.
		 * @param {function} action
		 * @param @optional {object} opt_thisp
		 * @returns {Namespace}
		 */
		ready: chained(function(action, opt_thisp) {
			gui.ready(action, opt_thisp);
		}),

		/**
		 * Open the main navigation menu (up in the chrome somewhere).
		 * @returns {Namespace}
		 */
		openMenu: chained(function() {
			gui.Broadcast.dispatchGlobal(this.BROADCAST_GLOBAL_MENU_OPEN);
		}),

		/**
		 * Close the main navigation menu.
		 * @returns {Namespace}
		 */
		closeMenu: chained(function() {
			gui.Broadcast.dispatchGlobal(this.BROADCAST_GLOBAL_MENU_CLOSE);
		}),

		/**
		 * @deprecated (but still used in the Client-Docs website, so don't kill).
		 * Load URL as new app. This implies that we create a new iframe instead
		 * of reusing the old one, preventing a temporary flash-of-no-content.
		 * We also get history support (via browsers back and forward buttons).
		 * TODO(jmo@): Separate "error class" for extra long error messages!
		 * @param {string} href The href must be formatted as an app URL
		 * @param @optional {string} target TODO(jmo@): support this argument
		 */
		load: function(href, opt_target) {
			var url = new gui.URL(document, href);
			this.ready(function spiritualized() {
				ts.ui.get('html').action.dispatchGlobal(
					ts.ui.ACTION_GLOBAL_LOAD, {
						href: url.href,
						target: opt_target
					}
				);
			});
		},

		/**
		 * Reflex everything (to tighten up any JS based layout).
		 */
		reflex: chained(function() {
			ts.ui.get(document.documentElement).reflex();
		}),

		/**
		 * Is mobile breakpoint?
		 * @returns {boolean}
		 */
		isMobilePoint: function() {
			return this._getlayout().isMobilePoint();
		},

		/**
		 * Is tablet breakpoint?
		 * @returns {boolean}
		 */
		isTabletPoint: function() {
			return this._getlayout().isTabletPoint();
		},

		/**
		 * Is desktop breakpoint?
		 * @returns {boolean}
		 */
		isDesktopPoint: function() {
			return this._getlayout().isDesktopPoint();
		},

		/**
		 * Add breakpoint listener.
		 * @param {function} callback Two args: newpoint + oldpoint
		 */
		addBreakPointListener: function(callback) {
			breakpointers.push(callback);
		},

		/**
		 * Remove breakpoint listener.
		 * @param {function} callback
		 */
		removeBreakPointListener: function(callback) {
			gui.Array.remove(breakpointers, breakpointers.indexOf(callback));
		},

		/**
		 * Handle model changes.
		 * // TODO: on breakpoint, also dispatch custom event on document node.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				if (c.object instanceof ts.ui.LayoutModel) {
					if (c.name === 'breakpoint') {
						ts.ui.breakpoint = c.newValue;
						breakpointers.forEach(function(callback) {
							callback(c.newValue, c.oldValue);
						});
					}
				}
			});
		},

		// Private .................................................................

		/**
		 * Get that layout model.
		 * @returns {ts.ui.LayoutModel}
		 */
		_getlayout: function() {
			var model = ts.ui.LayoutModel.output.get();
			if (!model) {
				console.error(this + ' is not initialized');
			}
			return model;
		},

		// Privileged ..............................................................

		/**
		 * Toggled on `DOMContentLoaded` at which point we'll attempt to boostrap.
		 * @type {boolean}
		 */
		$domloaded: false,

		/**
		 * Will be set to `true` when all scripts are loaded or when there's no
		 * additional scripts to load (this is basically the localization script).
		 * @type {boolean}
		 */
		$jsloaded: false,

		/**
		 * Called twice: Once when when the localization script has been loaded
		 * and again (or maybe before) when the `DOMContentLoaded` event happens.
		 * @param @optional {boolean} jsloaded
		 */
		$maybebootstrap: function(jsloaded) {
			this.$jsloaded = (this.$jsloaded || !!jsloaded);
			if (this.$domloaded && this.$jsloaded) {
				gui.bootstrap(); // release the spirits
			}
		}

	};
}(gui.Client, gui.Array, gui.Arguments.confirmed, gui.Combo.chained)));

/**
 * Match method names to some background
 * colors for various coloring purposes.
 * @type {Map<string, string>}
 */
ts.ui.BACKGROUND_COLORS = {
	dark: ts.ui.CLASS_BG_DARK,
	lite: ts.ui.CLASS_BG_LITE,
	white: ts.ui.CLASS_BG_WHITE,
	blue: ts.ui.CLASS_BG_BLUE,
	green: ts.ui.CLASS_BG_GREEN,
	purple: ts.ui.CLASS_BG_PURPLE,
	yellow: ts.ui.CLASS_BG_YELLOW,
	red: ts.ui.CLASS_BG_RED
};

/**
 * Match method names to some colors.
 * @type {Map<string, string>}
 */
ts.ui.COLORS = {
	black: ts.ui.CLASS_BLACK,
	dark: ts.ui.CLASS_DARK,
	medium: ts.ui.CLASS_MEDIUM,
	lite: ts.ui.CLASS_LITE,
	white: ts.ui.CLASS_WHITE,
	blue: ts.ui.CLASS_BLUE,
	green: ts.ui.CLASS_GREEN,
	purple: ts.ui.CLASS_PURPLE,
	yellow: ts.ui.CLASS_YELLOW,
	red: ts.ui.CLASS_RED
};

/**
 * Match icon names to icon-font characters
 * @TODO This will be obsolete when we ascend to SVG icons
 * @type {Map<string, string>}
 */
ts.ui.ICONS = {
	'ts-icon-logo-trade': 'K',
	'ts-icon-logo-shift': 'L',
	'ts-icon-logo-t1': 'M',
	'ts-icon-logo-t2': 'N',
	'ts-icon-discovery': 'E',
	'ts-icon-activity': 'f',
	'ts-icon-todo': 'q',
	'ts-icon-network': 'G',
	'ts-icon-createdocument': 'P',
	'ts-icon-alldocuments': 'j',
	'ts-icon-document': ';',
	'ts-icon-sales': 'X',
	'ts-icon-purchases': '$',
	'ts-icon-cart': '$',
	'ts-icon-drafts': 'F',
	'ts-icon-apps': 'a',
	'ts-icon-usersettings': 'U',
	'ts-icon-settings': 'y',
	'ts-icon-companyprofile': 'H',
	'ts-icon-logout': 'Q',
	'ts-icon-support': '?',
	'ts-icon-checked': '3',
	'ts-icon-accept': '3',
	'ts-icon-done': '3',
	'ts-icon-checked-alt': '2',
	'ts-icon-remove': 'D',
	'ts-icon-add': '&',
	'ts-icon-close': '*',
	'ts-icon-location': '@',
	'ts-icon-addfilter': 'k',
	'ts-icon-followed': 'S',
	'ts-icon-unfollowed': '5',
	'ts-icon-search': 's',
	'ts-icon-statuschange': '1',
	'ts-icon-edit': 'p',
	'ts-icon-rating': 'r',
	'ts-icon-share': 'R',
	'ts-icon-industry': 'z',
	'ts-icon-showpicker': '6',
	'ts-icon-warning': '!',
	'ts-icon-timer': 't',
	'ts-icon-comment': 'w',
	'ts-icon-more': '+',
	'ts-icon-users': 'g',
	'ts-icon-ownership': '',
	'ts-icon-companysize': 'g',
	'ts-icon-view': 'I',
	'ts-icon-reject': 'd',
	'ts-icon-dispute': '\\',
	'ts-icon-menuswitch': 'l',
	'ts-icon-delete': '#',
	'ts-icon-cancel': 'd',
	'ts-icon-info': 'i',
	'ts-icon-forums': 'i',
	'ts-icon-addfield': ',',
	'ts-icon-fileaccess': '/',
	'ts-icon-error': '!',
	'ts-icon-appactivate': '&',
	'ts-icon-appactive': '3',
	'ts-icon-fileattach': 'A',
	'ts-icon-reset': 'n',
	'ts-icon-send': 'm',
	'ts-icon-save': 'e',
	'ts-icon-proceed': '>',
	'ts-icon-back': '<',
	'ts-icon-download': 'B',
	'ts-icon-broadcastmessage': 'b',
	'ts-icon-insertfrominventory': '|',
	'ts-icon-triangleright': '6',
	'ts-icon-triangleleft': '8',
	'ts-icon-triangleup': '9',
	'ts-icon-triangledown': '7',
	'ts-icon-arrowright': '>',
	'ts-icon-arrowleft': '<',
	'ts-icon-arrowup': 'u',
	'ts-icon-arrowdown': 'v',
	'ts-icon-preview': 'o',
	'ts-icon-locked': 'V',
	'ts-icon-unlocked': 'W',
	'ts-icon-next': '>',
	'ts-icon-approve': '3',
	'ts-icon-code': 'C',
	'ts-icon-halt': 'h',
	'ts-icon-pay': '_',
	'ts-icon-other': 'O',
	'ts-icon-myapps': 'Y',
	'ts-icon-companyevent': 'c',
	'ts-icon-split': '%',
	'ts-icon-split-alt': '',
	'ts-icon-merge': 'J',
	'ts-icon-associated': '=',
	'ts-icon-radio': '{',
	'ts-icon-radioon': ':',
	'ts-icon-checkbox': '\'',
	'ts-icon-checkboxon': '"',
	'ts-icon-written-request': '(',
	'ts-icon-categories': ')',
	'ts-icon-favorites': '',
	'ts-icon-heart': '',
	'ts-icon-preferred': '',
	'ts-icon-pin': '',
	'ts-icon-previously-requested': '',
	'ts-icon-archive': '',
	'ts-icon-add-to-archive': ''
};

/**
 * Observe that LayoutModel.
 */
ts.ui.ready(function addobserver() {
	var layout = ts.ui.LayoutModel.output.get();
	ts.ui.breakpoint = layout.breakpoint;
	layout.addObserver(ts.ui);
});

/**
 * We attempt to bootstap on `DOMContentLoaded`. Note that it is possible
 * to check whether or not `DOMContentLoaded` has happened via the property
 * `document.readyState` but that doesn't always work quite right in IE9.
 */
addEventListener('DOMContentLoaded', function() {
	ts.ui.$domloaded = true;
	ts.ui.$maybebootstrap();
});



/**
 * Namespace object.
 */
ts.lib = ts.lib || {

	/**
	 * TODO (jmo@): run this file through grunt.template.process()
	 * @type {string}
	 */
	version: '-1.0.0',

	/**
	 * Identification.
	 * @return {String}
	 */
	toString: function() {
		return '[namespace ts.lib]';
	}
};



/**
 * Date functions.
 * @see Tradeshift/Apps/master/src/main/apps/Lib/components/Date/code/Date.js
 */
ts.lib.Date = (function() {
	var regionalDateFormats = [];

	regionalDateFormats['en-US'] = 'mm/dd/yy';
	regionalDateFormats['en-GB'] = 'dd/mm/yy';
	regionalDateFormats.da = 'dd-mm-yy';
	regionalDateFormats.hu = 'yy.mm.dd.';

	// this should be set by the localization engine
	var regionalDateFormat = regionalDateFormats['en-US'];

	function zf(num) {
		if (num < 10) {
			return '0' + num;
		}
		return '' + num;
	}

	function _getDateString(date) {
		if (typeof date === 'undefined') {
			date = new Date();
		}
		var month = zf(date.getMonth() + 1),
			day = zf(date.getDate());
		return date.getFullYear() + '-' + month + '-' + day;
	}

	function _getDateTimeString(date) {
		if (typeof date === 'undefined') {
			date = new Date();
		}
		var hour = zf(date.getHours()),
			min = zf(date.getMinutes()),
			sec = zf(date.getSeconds());
		return _getDateString(date) + ' ' + hour + ':' + min + ':' + sec;
	}

	function _dateStringToObject(dateString) {
		if (dateString.length !== 10) { // yyyy-mm-dd
			return {
				year: _getCurrentFullYear(),
				month: _getCurrentMonth(),
				day: _getCurrentDay()
			};
		}
		var dateArray = dateString.split('-');
		return {
			year: parseInt(dateArray[0], 10),
			month: parseInt((dateArray[1] - 1), 10),
			day: parseInt(dateArray[2], 10)
		};
	}

	function _getCurrentFullYear() {
		return parseInt((new Date()).getFullYear(), 10);
	}

	function _getCurrentMonth() {
		return parseInt((new Date()).getMonth(), 10);
	}

	function _getCurrentDay() {
		return parseInt((new Date()).getDate(), 10);
	}

	function _getLocalizedDateString(date) {
		var dateObj;
		if (typeof date === 'string') {
			dateObj = _dateStringToObject(date);
		} else {
			dateObj = date;
		}
		var year = dateObj.year,
			month = (dateObj.month + 1),
			day = dateObj.day;
		if (month < 10) {
			month = '0' + month;
		} else {
			month = '' + month;
		}
		if (day < 10) {
			day = '0' + day;
		} else {
			day = '' + day;
		}
		year = '' + year;
		var prevChar = 'x',
			returnDate = '';
		for (var i = 0,
			regionalDateFormatLength = regionalDateFormat.length; i < regionalDateFormatLength; ++i) {
			var currentChar = regionalDateFormat[i];
			if (currentChar === 'y') {
				returnDate += year.substr((prevChar === 'y' ? 3 : 2), 1);
			} else if (currentChar === 'm') {
				returnDate += month.substr((prevChar === 'm' ? 1 : 0), 1);
			} else if (currentChar === 'd') {
				returnDate += day.substr((prevChar === 'd' ? 1 : 0), 1);
			} else {
				returnDate += currentChar;
			}
			prevChar = currentChar;
		}
		return returnDate;
	}

	return { // Public ...........................................................

		/**
		 * Get a localized date string
		 * @param {Object|String} date {year,month,day} or yyyy-mm-dd.
		 */
		getLocalizedDateString: _getLocalizedDateString,

		/**
		 * Get a date string relative to today
		 * @param {int} diffDays number of days from today.
		 */
		dateStringRelativeToNow: function(diffDays) {
			var currentDate = new Date(),
				currentYear = currentDate.getFullYear(),
				currentMonth = currentDate.getMonth(),
				currentDay = currentDate.getDate();
			return _getDateString(
				new Date(currentYear, currentMonth, currentDay + diffDays)
			);
		},

		/**
		 * Get current full year (eg: 1986)
		 */
		getCurrentFullYear: _getCurrentFullYear,

		/**
		 * Get current month (eg: 12)
		 */
		getCurrentMonth: _getCurrentMonth,

		/**
		 * Get current day (eg: 19)
		 */
		getCurrentDay: _getCurrentDay,

		/**
		 * Get current timestamp in miliseconds
		 */
		getCurrentTimestamp: function() {
			return (new Date()).getTime();
		},

		/**
		 * Get number of days in a certain month
		 */
		getDaysInMonth: function(year, month) {
			return parseInt((32 - new Date(year, month, 32).getDate()), 10);
		},

		/**
		 * Get first day in a month (0 - Sunday, 1 - Monday, etc..)
		 */
		getFirstDayInMonth: function(year, month) {
			return parseInt((new Date(year, month, 1).getDay()), 10);
		},

		/**
		 * Get an object from a date string
		 * and returns today if something goes wrong
		 * remember that this is for javascript, so months go from 0-11
		 * @type {String} yyyy-mm-dd.
		 */
		dateStringToObject: _dateStringToObject,

		/**
		 * Get milliseconds from an ISO9601 date string
		 * @param {String} isoDate yyyy-MM-dd'T'HH:mm:ss.SSSZ.
		 * @return {Date}
		 */
		getMillisecondsFromISO: function(isoDate) {
			return Date.parse(isoDate);
		},

		/**
		 * @return {string}
		 */
		getDateString: _getDateString,

		/**
		 * @return {string}
		 */
		getDateTimeString: _getDateTimeString,

		/**
		 * @return {string}
		 */
		getCurrentDateString: function() {
			return _getDateString(new Date());
		}
	};
}());



/**
 * Location.
 */
ts.lib.Location = (function() {
	/**
	 * Request for the hosting {ts.ui.FrameSpirit} to update location href.
	 * @param {string} href
	 * @param {string=} opt_target
	 */
	function dohref(href, opt_target) {
		ts.ui.get('html').action.dispatchGlobal(
			ts.ui.ACTION_GLOBAL_LOAD, {
				target: opt_target || null,
				href: href
			}
		);
	}

	/**
	 * Update location hash somehow without appending to history.
	 * TODO (jmo@): Some day rename this whole thing or do it elsehow.
	 * http://stackoverflow.com/questions/9235304/
	 *		 how-to-replace-the-location-hash-and-only-keep-the-last-history-entry
	 * @param {String} hash
	 */
	function dohash(hash) {
		hash = hash.startsWith('#') ? hash.slice(1) : hash;
		location.replace('#' + hash);
	}

	return { // Public ...............................

		/**
		 * Identification.
		 * @return {string}
		 */
		toString: function() {
			return '[object ts.lib.Location]';
		},

		/**
		 * Load something or change the hash *without* updating history;
		 * since this may become a problem at some point...
		 * @param {string} href
		 * @param {string=} opt_target
		 */
		assign: function(href, opt_target) {
			if (href.startsWith('#')) {
				dohash(href);
			} else {
				dohref(href, opt_target);
			}
		},

		/**
		 * Reload.
		 */
		reload: function() {
			console.error('todo');
		}
	};
}());



/**
 * Framework-internal two-way messaging system.
 * @using {ts.ui.ACTION_GLOBAL_MESSAGE_UP} up
 * @using {ts.ui.ACTION_GLOBAL_MESSAGE_DOWN} down
 */
ts.ui.Greenfield = (function using(up, down) {
	/**
	 * Dispatching actions up or down. We'll
	 * redefine this method in `setupactions`
	 * @param {object} data
	 */
	var doaction = function(data) {};

	/**
	 * App frame signals up, host frame signals down.
	 */
	function setupactions() {
		if (ts.ui.appframe) {
			doaction = function(data) {
				gui.Action.ascendGlobal(document, up, data);
				handleactions();
			};
		} else if (ts.ui.subframe) {
			gui.get('main', function(main) {
				doaction = function(data) {
					main.action.descendGlobal(down, data);
				};
			});
		}
	}

	/*
	 * Setup tricky actions if:
	 *
	 * 1. We're in the sub frame (apphost)
	 * 2. We're in the app frame
	 */
	if (ts.ui.subframe || ts.ui.appframe) {
		if (gui.hasModule('core-gui@tradeshift.com')) {
			gui.ready(setupactions);
		} else {
			gui.init(setupactions);
		}
	}

	/**
	 * Handle actions *descending* from the Greenfield host.
	 * An equivalent handler for ascending actions has been
	 * setup in the {ts.ui.GreenfieldMainFrame} spirit.
	 * @param {ts.ui.DocumentSpirit} html
	 */
	function handleactions(html) {
		gui.Action.addGlobal(document, down, {
			onaction: function(a) {
				a.consume();
				if (a.data.action === 'apply') {
					ts.ui.Greenfield.$applyhere(a);
				}
			}
		});
	}

	/**
	 * Apply something in this context.
	 * @param {String} target
	 * @param {String} method
	 * @param {Array} params
	 */
	function applyhere(target, method, params) {
		target = gui.Object.lookup(target);
		target[method].apply(target, params);
		// var summary = target + '.' + method + ' (' + params.join(',') + ')';
		// console.debug('Applied ' + summary + ' in ' + document.title);
	}

	return { // Public ...........................................................

		/**
		 * Identification.
		 * @return {String}
		 */
		toString: function() {
			return '[object ts.ui.Greenfield]';
		},

		/**
		 * Mark function applicable for Greenfield remoting,
		 * creates new function marked with `$api` property.
		 * This property is only verified in the host frame.
		 * @param {function} base
		 * @return {function}
		 */
		api: function(base) {
			function api() {
				return base.apply(this, arguments);
			}
			api.$api = true;
			return api;
		},

		// Secret ..................................................................

		/**
		 * Apply something in reverse context. This method is framework internal
		 * and should not become part of the public API, indeed that is what the
		 * mysterious $dollar notation is supposed to signify.
		 * @param {String} target
		 * @param {String} method
		 * @param {String} method
		 */
		$applyreverse: function(target, method, params) {
			params = gui.Array.from(params);
			doaction({
				action: 'apply',
				target: target,
				method: method,
				params: params
			});
		},

		/**
		 * Apply something in this context.
		 * @see {ts.ui.GreenfieldMainFrame}
		 * @param {gui.Action} a
		 */
		$applyhere: function(a) {
			applyhere(
				a.data.target,
				a.data.method,
				a.data.params
			);
		}

	};
}(
	ts.ui.ACTION_GLOBAL_MESSAGE_UP,
	ts.ui.ACTION_GLOBAL_MESSAGE_DOWN
));



/**
 * Hardcoded string bundle.
 * TODO: What to do with strings?
 * TODO: At least localize strings!
 */
ts.ui.String = {

	/*
	 * Buttons and what not.
	 */
	LABEL_SUBMIT: 'Proceed',
	LABEL_ACCEPT: 'OK',
	LABEL_CANCEL: 'Cancel',
	LABEL_HELP: 'Help',
	LABEL_INFO: 'Read More',
	LABEL_OPTIONS: 'Options',
	LABEL_DATEPICK: 'Select Date',

	/**
	 * notifications.
	 */
	OFFLINE_NOTIFICATION: 'You are offline. Please contact your internet.',
	OFFLINE_TRYRELOADING: 'Try again',
	BAD_SERVICE_NOTIFICATION: 'An unfortunate error has occured',
	BAD_SERVICE_TRYRELOADING: 'Try again',

	/*
	 * Input field validation
	 */
	ERROR_PATTERNMISMATCH: 'The value does not match the specified pattern',
	ERROR_RANGEOVERFLOW: 'Too much',
	ERROR_RANGEUNDERFLOW:	'Not too much',
	ERROR_STEPMISTMATCH:	'Abnormal step',
	ERROR_TOOLONG: 'The value exceeds the specified maxlength',
	ERROR_TYPEMISMATCH: 'The value is not in the required syntax',
	ERROR_BADINPUT: 'That\'s just plain wrong.',
	ERROR_VALUEMISSING: 'Please type something here',

	/**
	 * @depracated (although we should probably reintroduce Runtime validation!)
	 * Get error message for property name in {ts.ui.ValidationStateModel}.
	 * @param {string} error
	 * @returns {string}
	 */
	getError: function(error) {
		if ((error = this + ' ' + error.toUpperCase())) {
			return error;
		} else {
			console.error('No such error', error);
		}
	}
};



/**
 * Convert (super-simplistic subset of) markdown to markup.
 * @see {ts.ui.TextModel}
 @ @see {ts.ui.tablerows.edbml}
 * using {function} linkparser
 */
ts.ui.Markdown = (function using(linkparser) {
	// make sure to always parse tags in the same order (h is for H1-H4)
	var ORDER = ['h', 'strong', 'em', 'strike', 'code', 'a', 'ul', 'ol'];

	// looks complex enough to compile only once...
	var SINGLENEWLINE = /(^|[^\n])\n(?!\n)/g;

	/*
	 * Mapping tagnames to functions that will parse a single line of markdown.
	 * @type Map<string, function>
	 */
	var parsers = {

		// headers H1-H4
		h: blockfunction([
			[/^####/, '<h4>$</h4>'],
			[/^###/, '<h3>$</h3>'],
			[/^##/, '<h2>$</h2>'],
			[/^#/, '<h1>$</h1>']
		]),

		// unordered lists
		ul: blockfunction([
			[/^ {6}\*/, '<ul><ul><ul><ul><li>$</li></ul></ul></ul></ul>'],
			[/^ {4}\*/, '<ul><ul><ul><li>$</li></ul></ul></ul>'],
			[/^ {2}\*/, '<ul><ul><li>$</li></ul></ul>'],
			[/^\*/, '<ul><li>$</li></ul>']
		]),

		// ordered lists
		ol: blockfunction([
			[/^ {6}\d+\./, '<ol><ol><ol><ol><li>$</li></ol></ol></ol></ol>'],
			[/^ {3}\d+\./, '<ol><ol><ol><li>$</li></ol></ol></ol>'],
			[/^ {2}\d+\./, '<ol><ol><li>$</li></ol></ol>'],
			[/^\d+\./, '<ol><li>$</li></ol>']
		]),

		// bold text
		strong: inlinefunction([
			[/\*\*(.*?)\*\*/g, '<strong>$1</strong>']
		]),

		// italic text
		em: inlinefunction([
			[/\*(.*?)\*/g, '<em>$1</em>']
		]),

		// strike text
		strike: inlinefunction([
			[/~~(.*?)~~/g, '<del>$1</del>']
		]),

		// code and tech terms (TODO: also support blockcode ```)
		code: inlinefunction([
			[/`(.*?)`/g, '<code>$1</code>']
		]),

		// links (scroll down for implementation)
		a: linkparser
	};

	/**
	 * Creates a function to parse inline tags.
	 * @param {Array<Array<string|RegExp>} rules
	 * @return {function}
	 */
	function inlinefunction(rules) {
		return function(input) {
			return rules.reduce(function(result, rule) {
				var regx = rule[0];
				var html = rule[1];
				return result.replace(regx, html);
			}, input);
		};
	}

	/**
	 * Creates a function to parse block level content.
	 * @param {Array<Array<string|RegExp>} rules
	 * @return {function}
	 */
	function blockfunction(rules) {
		return function(input, output) {
			rules.some(function(rule) {
				var regx = rule[0];
				var html = rule[1];
				var post;
				if (regx.test(input)) {
					post = input.replace(regx, '');
					output = enclose(html, post);
				}
				return !!output;
			});
			return output;
		};
	}

	/**
	 * Insert that string.
	 * @param {string} outer
	 * @param {string} inner
	 * @returns {string}
	 */
	function enclose(outer, inner) {
		return outer.replace('$', inner.trim());
	}

	/**
	 * Post-processing for valid markup.
	 * TODO(jmo@): Nested lists should still render in items, not next to them!
	 * @param {string} markup
	 * @returns {string}
	 */
	function sanitize(markup) {
		var ul = /<\/ul>\n<ul>/g;
		var ol = /<\/ol>\n<ol>/g;
		var nl = '\n';
		return [1, 2, 3].reduce(function fix(insanity) {
			return insanity.replace(ul, nl).replace(ol, nl);
		}, markup);
	}

	/**
	 * Catch spelling mistakes.
	 * @param {Array|null} tags
	 */
	function validate(tags) {
		(tags || []).forEach(function(tag) {
			if (ORDER.indexOf(tag) === -1) {
				throw new Error('Not supported: "$tag"'.replace('$tag', tag));
			}
		});
		return tags;
	}

	/**
	 * Collect parsers needed to resolve given tagnames. Note
	 * that if no tags are specified, we support all of them.
	 * @param {Array<string} List of tagnames
	 * @return {Array<function>}
	 */
	function getparsers(tags) {
		tags = tags || ORDER;
		return ORDER.filter(function(tag) {
			return tags.indexOf(tag) > -1;
		}).map(function(tag) {
			return parsers[tag];
		});
	}

	/**
	 * Split string on newlines (or double newlines)
	 * and run each segment by a function to fix it.
	 * @param {string} string
	 * @param {function} action
	 * @param {boolean} doubles
	 */
	function eachline(string, action, doubles) {
		var x2 = /\n{2,}/;
		return string.split(
			doubles ? x2 : '\n'
		).map(action).join('\n');
	}

	/**
	 * Parse single line of markdown.
	 * @param {string} line
	 * @returns {string}
	 */
	function parseline(line, lineParsers) {
		return lineParsers.reduce(function(result, parse) {
			return parse(result) || result;
		}, line.trimRight());
	}

	/**
	 * Split on double-newlines, then add paragraph tags
	 * when the first tag isn't a block level element.
	 * @param {string} html All resolved except P tags.
	 * @returns {string}
	 */
	function paragraphs(html) {
		var doubles = true, exclude = /^<(h|ul|ol|li|pre)/;
		return eachline(html, function(section) {
			return unhack(eachline(linehack(section), function(line) {
				return exclude.test(line) ? line : enclose('<p>$</p>', unhack(line, true));
			}));
		}, doubles);
	}

	/**
	 * Markdown requires double newlines (for historic reasons) to render a
	 * paragraph, but we would like to support single newline for `BR` breaks,
	 * so we'll insert a string sequence that may later be parsed in context.
	 * @param {string} string
	 * @returns {string}
	 */
	function linehack(string) {
		return string.replace(SINGLENEWLINE, '$1 %%%'); // some unlikely string
	}

	/**
	 * Replace temp string sequence with either nothing or a `BR` linebreak.
	 * @param {string} string
	 * @param @optional {boolean} breaks
	 * @returns {string}
	 */
	function unhack(string, breaks) {
		return string.replace(/%%%/g, breaks ? '<br/>' : '');
	}

	// Public ....................................................................

	/*
	 * Finally we expose a single method to convert markdown to markup.
	 * @param {string} markdown
	 * @returns {string} HTML
	 * @param {Array<string>} tagnames Optional *whitelist* of tagnames
	 */
	return {
		parse: function(markdown, tagnames) {
			var allParsers = getparsers(validate(tagnames));
			var safetxt = edbml.safetext(markdown);
			return paragraphs(sanitize(eachline(safetxt, function(line) {
				return parseline(line, allParsers);
			})));
		}
	};
}( // LINKS ..................................................................

	/**
	 * Routine to parse links in the format init(text)[href]post.
	 * Regexp for this was not really maintainable (extensible).
	 * @using {RegExp} txt
	 * @using {RegExp} url
	 */
	(function using(txt, url) {
		var init, text, href, post, last, html, test;

		function link() {
			return '<a data-ts="Button" data-ts.type="$type" data-ts.data="$data">$text</a>'
				.replace('$type', ts.ui.ACTION_SAFE_LINK)
				.replace('$data', edbml.safeattr(href))
				.replace('$text', edbml.safetext(text));
		}

		function parsecut(cut, idx, all) {
			var ends = (all.length - 1) === idx;
			if (url.test(cut)) {
				href = gethref(cut.replace(txt, ''), ends);
			}
			var res = (text && href) ? donecut() : '';
			if (txt.test(cut)) {
				text = gettext(cut.replace(url, ''));
			}
			return res;
		}

		function gethref(cut, ends) {
			post = ends ? cut.replace(url, '') : '';
			test = url.exec(cut);
			return test ? test[0].slice(0, -1) : '';
		}

		function gettext(cut) {
			last = cut.lastIndexOf('(');
			init = cut.substr(0, last);
			return cut.slice(last + 1);
		}

		function donecut() {
			html = init + link() + post;
			reset();
			return html;
		}

		function reset() {
			init = '';
			text = '';
			href = '';
			post = '';
		}

		return function linkparser(line) {
			reset();
			return (line.split(')[').map(parsecut).join('')) || line;
		};
	}(/\(.+$/, /^.+\]/))

));



/**
 * Dialog API.
 * @param {object|ts.ui.DialogModel} opt_json
 * @return {ts.ui.DialogModel}
 */
ts.ui.Dialog = function(opt_json) {
	var model = ts.ui.DialogModel.syncGlobal(opt_json);
	model.addObserver(ts.ui.Dialog);
	return model;
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.Dialog.toString = function() {
	return '[function ts.ui.Dialog]';
};

/**
 * Confirmation dialog.
 * @returns {ts.ui.DialogModel}
 */
ts.ui.Dialog.confirm = function(/* ...args */) {};

/**
 * Severe confirmation dialog.
 * @returns {ts.ui.DialogModel}
 */
ts.ui.Dialog.warning = function(/* ...args */) {};

/**
 * Cataclysmic confirmation dialog.
 * @returns {ts.ui.DialogModel}
 */
ts.ui.Dialog.danger = function(/* ...args */) {};

/**
 * Absolute minimum time to display a
 * dialog with no buttons to close it.
 * @type {number} Time in milliseconds
 */
ts.ui.Dialog.DEFAULT_TIME = 1500;

// Implementation ..............................................................

/**
 * @using {ts.ui.Greenfield#api} api
 * @using {gui.Combo#chained} chained
 * @using {gui.Object#hidden} hidden
 * @using {gui.Array} GuiArray
 * @using {gui.Object} GuiObject
 * @using {gui.Type} Type
 */
(function using(api, chained, hidden, GuiArray, GuiObject, Type) {
	var Dialog = ts.ui.Dialog;

	/**
	 * Get spirit for model.
	 * TODO (jmo@): Look into {ts.ui.Aside} for possible method sharing
	 * @param {ts.ui.DialogModel} model
	 * @return {ts.ui.DialogSpirit}
	 */
	function getspirit(model) {
		var id = model.$instanceid;
		return gui.get('#' + id) || (function() {
			var spirit = ts.ui.DialogSpirit.summon(model);
			spirit.dom.id(id).appendTo(document.body);
			return spirit;
		}());
	}

	/**
	 * Apply method to myself in reverse context.
	 * @param {String} method [description].
	 * @param {object} param
	 */
	function applyreverse(method /* ...params */) {
		var myself = 'ts.ui.Dialog';
		var params = [].slice.call(arguments, 1);
		ts.ui.Greenfield.$applyreverse(myself, method, params);
	}

	/**
	 * Toggle model open and closed. Manifest spirit when model is first opened.
	 * @param {ts.ui.DialogModel} model
	 * @param {boolean} open
	 * @return {ts.ui.DialogModel}
	 */
	function toggle(model, open) {
		if (ts.ui.greenfield) {
			if (open) {
				// TODO (jmo@): This implies that we create a new spirit/model
				// constallation in the parent frame for every open, we should
				// rig it for recycling untill `dispose` is called by the user.
				applyreverse('$open', model.serializeToString());
			} else {
				applyreverse('$close', model.$instanceid);
			}
		} else {
			getspirit(model).open(open);
		}
		return model;
	}

	/**
	 * Get argument of object type. Always return an object.
	 * @param {Arguments} args
	 * @returns {<object>}
	 */
	function extractobject(args) {
		return GuiArray.from(args).find(Type.isObject) || {};
	}

	/**
	 * Get list of string-type arguments.
	 * @param {Arguments} args
	 * @return {Array<string>}
	 */
	function extractstring(args) {
		return GuiArray.from(args).filter(gui.Type.isString);
	}

	/**
	 * Never write "undefined" on screen and
	 * don't show buttons with an empty label.
	 * @param {string} string
	 * @returns {string}
	 */
	function tostring(string) {
		return string ? String(string) : undefined;
	}

	/**
	 * @param {Arguments} args
	 */
	function getdialog(type, args, note) {
		var dialog = getmodel(type, note || false,
			extractstring(args),
			extractobject(args)
		);
		dialog.open();
		return dialog;
	}

	/**
	 * Build the DialogModel. Notifications don't have
	 * cancel. The success notifications has nothing.
	 * Dialogs with no buttons will close automatically.
	 * @param {string} type
	 * @param {boolean} note
	 * @param {Array<string>} strings
	 * @param {object} config
	 * @returns {ts.ui.DialogModel}
	 */
	function getmodel(type, note, strings, config) {
		return Dialog(
			GuiObject.extendmissing(config, {
				type: type,
				icon: geticon(type),
				items: [{
					item: 'text',
					text: tostring(strings[0])
				}]
			})
			).acceptButton(type === Dialog.SUCCESS ? null : {
				label: tostring(strings[1])
			}).cancelButton(note ? null : {
				label: tostring(strings[2])
			}
		);
	}

	/**
	 * Get icon for type.
	 * @param {string} type
	 * @returns {string}
	 */
	function geticon(type) {
		switch (type) {
			case Dialog.SUCCESS:
				return 'ts-icon-accept';
			case Dialog.INFO:
				return 'ts-icon-info';
			case Dialog.WARNING:
				return 'ts-icon-warning';
			case Dialog.ERROR:
				return 'ts-icon-error';
			case Dialog.DANGER:
				return 'ts-icon-warning';
			case Dialog.CONFIRM:
				return 'ts-icon-todo';
		}
		return null;
	}

	/**
	 * API methods.
	 */
	GuiObject.extend(Dialog, {

		/*
		 * Dialog types. Note that some of these should
		 * be considered like {ts.ui.Notification} types.
		 */
		INFO: 'ts-dialog-info',
		SUCCESS: 'ts-dialog-success',
		WARNING: 'ts-dialog-warning',
		ERROR: 'ts-dialog-error',
		DANGER: 'ts-dialog-danger',
		CONFIRM: 'ts-dialog-confirm',

		/**
		 * Handle (model) changes.
		 * TODO(jmo@): move this handler out of {ts.ui.Dialog} methods
		 * @param {Array<gui.Change>} changes
		 */
		onchange: hidden(function(changes) {
			changes.forEach(function(c) {
				var model = c.object;
				switch (c.name) {
					case 'isOpen':
						toggle(model, c.newValue);
						break;
					case 'disposed':
						if (!ts.ui.greenfield) {
							var spirit = gui.get('#' + model.$instanceid);
							if (spirit) {
								gui.Tick.time(function() { // TODO (jmo@): why otherwise error?
									spirit.dom.remove();
								}, 100);
							}
						}
						break;
				}
			});
		})
	});

	/**
	 * GUI extras.
	 */
	GuiObject.extend(Dialog, {

		/**
		 * Launch confirm dialog.
		 * @returns {ts.ui.DialogModel}
		 */
		confirm: chained(api(function(/* ...args */) {
			return getdialog(this.CONFIRM, arguments);
		})),

		/**
		 * Launch dangerous dialog.
		 * @returns {ts.ui.DialogModel}
		 */
		warning: chained(api(function(/* ...args */) {
			return getdialog(this.WARNING, arguments);
		})),

		/**
		 * Launch dangerous dialog.
		 * @returns {ts.ui.DialogModel}
		 */
		danger: chained(api(function(/* ...args */) {
			return getdialog(this.DANGER, arguments);
		})),

		// Privileged ..............................................................

		/**
		 * Exposed for Notifications to use.
		 * @param {string} type
		 * @param {Arguments} args
		 * @param @optional {boolean} note
		 * @returns {ts.ui.DialogModel}
		 */
		$getdialog: hidden(api(function(type, args, note) {
			return getdialog(type, args, note);
		})),

		/*
		 * Open dialog in this context.
		 * @param {JSONObject} json
		 */
		$open: hidden(api(function(json) {
			var model = Dialog(json);
			var spirit = getspirit(model);
			spirit.open();
		})),

		/*
		 * Close dialog in this context.
		 * @param {string} id
		 */
		$close: hidden(api(function(id) {
			var spirit = gui.get('#' + id);
			if (spirit && spirit.isOpen) {
				spirit.close();
			}
		}))
	});
}(ts.ui.Greenfield.api, gui.Combo.chained, gui.Object.hidden, gui.Array, gui.Object, gui.Type));



/**
 * Menu API.
 * @param {object|ts.ui.MenuModel} json
 * @return {ts.ui.MenuModel}
 */
ts.ui.Menu = function(json) {
	return ts.ui.MenuModel.from(json);
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.Menu.toString = function() {
	return '[function ts.ui.Menu]';
};



/**
 * Buttons API.
 * @param {object|ts.ui.MenuModel} json
 * @return {ts.ui.MenuModel}
 */
ts.ui.Buttons = function(json) {
	return ts.ui.ButtonMenuModel.from(json);
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.Buttons.toString = function() {
	return '[function ts.ui.Buttons]';
};



/**
 * Aside API.
 * @param {object|ts.ui.AsideModel} json
 * @returns {ts.ui.AsideModel}
 */
ts.ui.Aside = function(json) {
	var model = ts.ui.AsideModel.syncGlobal(json);
	model.addObserver(ts.ui.Aside);
	return model;
};

/**
 * Identification.
 * @returns {string}
 */
ts.ui.Aside.toString = function() {
	return '[function ts.ui.Aside]';
};

/**
 * API proposal: Close all the asides all over the world (not used yet).
 * TODO: Perhaps scope it to this window (or asides opened by this app)?
 * TODO: Return some kind of Promise here
 */
ts.ui.Aside.closeAll = function() {
	gui.Broadcast.dispatchGlobal(
		ts.ui.BROADCAST_GLOBAL_ASIDES_DO_CLOSE
	);
};

// Implementation ..............................................................

/**
 * @using {ts.ui.Greenfield#api} api
 * @using {gui.Object#hidden} hidden
 */
(function using(api, hidden) {
	/**
	 * Get spirit for model.
	 * @param {ts.ui.AsideModel} model
	 * @return {ts.ui.AsideSpirit}
	 */
	function getspirit(model) {
		var id = model.$instanceid;
		return gui.get('#' + id) || (function() {
			var spirit = ts.ui.AsideSpirit.summon(model);
			document.body.appendChild(spirit.element);
			spirit.element.id = id;
			spirit.onclosed = function() {
				model.isOpen = false;
			};
			return spirit;
		}());
	}

	/**
	 * Apply method to myself in reverse context.
	 * @param {String} method [description].
	 * @param {object} param
	 */
	function applyreverse(method /* ...params */) {
		var myself = 'ts.ui.Aside';
		var params = [].slice.call(arguments, 1);
		ts.ui.Greenfield.$applyreverse(myself, method, params);
	}

	/**
	 * Toggle model open and closed. Manifest spirit
	 * in the parent frame when model is first opened.
	 * @param {ts.ui.AsideModel} model
	 * @param {boolean} open
	 * @return {ts.ui.AsideModel}
	 */
	function toggle(model, open) {
		if (ts.ui.greenfield) {
			if (open) {
				// TODO (jmo@): This implies that we create a new spirit/model
				// constallation in the parent frame for every open, we should
				// rig it for recycling untill `dispose` is called by the user.
				applyreverse('$open', model.serializeToString());
			} else {
				applyreverse('$close', model.$instanceid);
			}
		} else {
			getspirit(model).open(open);
		}
		return model;
	}

	/**
	 * API methods.
	 */
	gui.Object.extend(ts.ui.Aside, {

		/**
		 * Handler changes.
		 * @param {Array<gui.Change>} changes
		 */
		onchange: hidden(function(changes) {
			changes.forEach(function(c) {
				var model = c.object;
				switch (c.name) {
					case 'isOpen' :
						toggle(model, c.newValue);
						break;
					case 'disposed' :
						var spirit = gui.get('#' + model.$instanceid);
						if (spirit) {
							gui.Tick.time(function() { // TODO (jmi@): why otherwise error?
								spirit.dom.remove();
							}, 100);
						}
						break;
				}
			});
		})
	});

	/*
	 * GUI extras.
	 */
	gui.Object.extend(ts.ui.Aside, {

		/*
		 * Open aside in this context.
		 * @param {JSONObject} json
		 */
		$open: hidden(api(function(json) {
			var model = ts.ui.Aside(json);
			var spirit = getspirit(model);
			model.addObserver(ts.ui.Aside);
			alert('open');
			spirit.open();
		})),

		/*
		 * Close aside in this context.
		 * @param {string} id
		 */
		$close: hidden(api(function(id) {
			var spirit = gui.get('#' + id);
			if (spirit && spirit.isOpen) {
				spirit.close();
			}
		}))
	});
}(ts.ui.Greenfield.api, gui.Object.hidden));



/**
 * DatePicker API.
 * @param {object|ts.ui.DatePickerModel} json
 * @return {ts.ui.DatePickerModel}
 */
ts.ui.DatePicker = function(json) {
	var model = ts.ui.DatePickerModel.syncGlobal(json);
	model.addObserver(ts.ui.DatePicker);
	return model;
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.DatePicker.toString = function() {
	return '[function ts.ui.DatePicker]';
};

/**
 * Ad-hoc localization interface. Omit the
 * argument to get the current localization.
 * TODO: Greenfield this (add xframe support).
 * @param @optional {Object} config
 * @returns {Object}
 */
ts.ui.DatePicker.localize = function(config) {};

// Implementation ..............................................................

/**
 * @using {ts.ui.Greenfield#api} api
 * @using {gui.Object#hidden} hidden
 */
(function DatePicker(api, hidden) {
	var asides = {};
	var locale = null;

	/**
	 * Toggle model open and closed.
	 * @param {ts.ui.DatePickerModel} model
	 * @param {boolean} open
	 * @return {ts.ui.DatePickerModel}
	 */
	function toggle(model, open) {
		var aside, id = model.$instanceid;
		if (open) {
			asides[id] = (asides[id] || ts.ui.Aside({
				title: model.title,
				items: [model],
				onclosed: function() {
					if (gui.Type.isFunction(model.onclosed)) {
						model.onclosed();
					}
					model.isOpen = false;
				}
			})).open();
		} else {
			if ((aside = asides[id])) {
				gui.Tick.time(function() { // allow user to percieve the update...
					aside.close();
				}, 100);
			}
		}
		return model;
	}

	gui.Object.extend(ts.ui.DatePicker, {

		/**
		 * Localize. Note that this stuff has NOT been
		 * rigged up for xframe (Greenfield) support.
		 * @param {object} newlocale
		 */
		localize: function(newlocale) {
			if (arguments.length) {
				if (!locale || Object.keys(locale).every(function(key) {
					var has = newlocale.hasOwnProperty(key);
					if (!has) {
						console.error('Missing translations for ' + key);
					}
					return has;
				})) {
					locale = newlocale;
				}
			} else {
				return locale;
			}
		},

		/**
		 * Handler changes.
		 * @param {Array<gui.Change>} changes
		 */
		onchange: hidden(function(changes) {
			changes.forEach(function(c) {
				var model = c.object;
				switch (c.name) {
					case 'isOpen' :
						toggle(model, c.newValue);
						break;
					case 'disposed' : // TODO (jmo@): automate this
						model.removeObserver(ts.ui.DatePicker);
						var aside = asides[model.$instanceid];
						if (aside) {
							delete asides[model.$instanceid];
							aside.dispose();
						}
						break;
				}
			});
		})

	});
}(ts.ui.Greenfield.api, gui.Object.hidden));

/**
 * Default-localize the DatePicker. We don't yet use
 * all of these strings, but we might need them for
 * tooltips and quick-select-menus (in the future).
 */
ts.ui.DatePicker.localize({

	/**
	 * The first is always the worst.
	 * @type {number}
	 */
	firstDay: 1,

	/**
	 * Months of the year. How many do you know?
	 * @type {Array<string>}
	 */
	monthNames: [
		'January',
		'February',
		'March',
		'April',
		'May',
		'June',
		'July',
		'August',
		'September',
		'October',
		'November',
		'December'
	],

	/**
	 * Short months.
	 * @type {Array<string>}
	 */
	monthNamesShort: [
		'Jan',
		'Feb',
		'Mar',
		'Apr',
		'May',
		'Jun',
		'Jul',
		'Aug',
		'Sep',
		'Oct',
		'Nov',
		'Dec'
	],

	/**
	 * Day names.
	 * @type {Array<string>}
	 */
	dayNames: [
		'Sunday',
		'Monday',
		'Tuesday',
		'Wednesday',
		'Thursday',
		'Friday',
		'Saturday'
	],

	/**
	 * Short day names.
	 * @type {Array<string>}
	 */
	dayNamesShort: [
		'Sun',
		'Mon',
		'Tue',
		'Wed',
		'Thu',
		'Fri',
		'Sat'
	],

	/**
	 * Compact day names.
	 * @type {Array<string>}
	 */
	dayNamesMin: [
		'Su',
		'Mo',
		'Tu',
		'We',
		'Th',
		'Fr',
		'Sa'
	]

});



/**
 * API.
 */
ts.ui.Notification = {

	/**
	 * Identification.
	 * @returns {string}
	 */
	toString: function() {
		return 'ts.ui.Notification';
	},

	/**
	 * Display info.
	 * @param {string} text
	 * @returns {ts.ui.DialogModel}
	 */
	info: function(text) {},

	/**
	 * Display happy news. This is a non-blocking dialog.
	 * @param {string} text
	 * @returns {ts.ui.DialogModel}
	 */
	success: function(text) {},

	/**
	 * Display warning.
	 * @param {string} text
	 * @returns {ts.ui.DialogModel}
	 */
	warning: function(text) {},

	/**
	 * Display error.
	 * @param {string} text
	 * @returns {ts.ui.DialogModel}
	 */
	error: function(text) {}

};

// Implementation ..............................................................

/**
 * The Notification is basically a facade for a Dialog.
 * @using {ts.ui.Dialog} Dialog
 * @using {gui.Object} GuiObject
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} confirmed
 */
(function using(Dialog, GuiObject, chained, confirmed) {
	/**
	 * Validate argument types.
	 * @param {function} action
	 */
	function confirm(action) {
		return confirmed('string', '(string|object)', '(object)')(action);
	}

	/**
	 * Get dialog for type.
	 * @param {string} type
	 * @param {Arguments} args
	 */
	function getdialog(type, args) {
		return Dialog.$getdialog(type, args, true);
	}

	GuiObject.extend(ts.ui.Notification, {

		/**
		 * Arguments order here is *fuzzy*: One string will specify the message,
		 * another potential string will specify the button text and an object
		 * will configure the dialog `onaccept` callback and some other stuff.
		 * @param {string} text
		 * @param @optional {object} config
		 * @returns {ts.ui.Notification}
		 */
		success: confirm(function(/* ...args */) {
			return getdialog(Dialog.SUCCESS, arguments);
		}),

		/**
		 * @param {string} text
		 * @param @optional {string} label
		 * @param @optional {object} config
		 * @returns {ts.ui.Notification}
		 */
		info: confirm(function(/* ...args */) {
			return getdialog(Dialog.INFO, arguments);
		}),

		/**
		 * @param {string} text
		 * @param @optional {string} label
		 * @param @optional {object} config
		 * @returns {ts.ui.Notification}
		 */
		warning: confirm(function(/* ...args */) {
			return getdialog(Dialog.WARNING, arguments);
		}),

		/**
		 * @param {string} text
		 * @param @optional {string} label
		 * @param @optional {object} config
		 * @returns {ts.ui.Notification}
		 */
		error: confirm(function(/* ...args */) {
			return getdialog(Dialog.ERROR, arguments);
		})

	});
}(ts.ui.Dialog, gui.Object, gui.Combo.chained, gui.Arguments.confirmed));



/**
 * Note API.
 * @param {object|ts.ui.NoteModel} opt_json
 * @returns {*|edb.Type}
 * @constructor
 */
ts.ui.Note = function(opt_json) {
	if (ts.ui.Note._model) {
		console.warn('Note model already exists! There can be only one!');
		return ts.ui.Note._model;
	}
	ts.ui.Note._model = new ts.ui.NoteModel(opt_json);
	ts.ui.Note._model.addObserver(ts.ui.Note);
	ts.ui.Note._addSpirit();
	return ts.ui.Note._model;
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.Note.toString = function() {
	return '[funtion ts.ui.Note]';
};

// Implementation ..............................................................

(function using(api, chained, confirmed) {
	/**
	 * API methods.
	 */
	gui.Object.extend(ts.ui.Note, {
		/**
		 * Add or find the Spirit of the page-level Note
		 * @private
		 */
		_addSpirit: function getspirit() {
			if (document.querySelector('.ts-maincontent ~ .ts-note')) {
				ts.ui.Note._model.$isTopNote = true;
			} else {
				var noteSpirit = ts.ui.NoteSpirit.summon(ts.ui.Note._model);
				ts.ui.Note._model.$isTopNote = true;
				noteSpirit.dom.insertBefore(document.querySelector('.ts-maincontent'));
			}
		},

		/**
		 * Handle (model) changes.
		 */
		onchange: function() {}
	});
}());



/**
 * Features for the Main section.
 * @using {gui.Arguments#confirmed} confirmed
 */
ts.ui.Main = (function using(confirmed) {
	/**
	 * Get the Main spirit.
	 * @returns {ts.ui.MainSpirit}
	 */
	function getmain() {
		var main = ts.ui.get('.ts-main');
		if (main) {
			return main;
		} else {
			throw new Error('The Main component either doesn\'t exist or it is not initialized yet.');
		}
	}

	/**
	 * Get the ToolBar either now or when it is initialized.
	 * @param {function} action
	 * @param @optional {function} cb
	 */
	function getbar(action, cb) {
		if (cb) {
			gui.ready(function() {
				cb(action());
			});
		} else {
			return action();
		}
	}

	return {

		/**
		 * Identification.
		 * @returns {string}
		 */
		toString: function() {
			return '[object ts.ui.Main]';
		},

		/**
		 * Get the TabBar.
		 * @param @optional {function} cb
		 * @returns {ts.ui.TabBarSpirit}
		 */
		tabbar: confirmed('(function)')(function(cb) {
			return getbar(function() {
				return getmain().tabbar();
			}, cb);
		}),

		/**
		 * Get the ToolBar.
		 *	@param @optional {function} cb
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		toolbar: confirmed('(function)')(function(cb) {
			// return getmain().toolbar();
			return getbar(function() {
				return getmain().toolbar();
			}, cb);
		}),

		/**
		 * Get the StatusBar.
		 * @param @optional {function} cb
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		statusbar: confirmed('(function)')(function(cb) {
			return getbar(function() {
				return getmain().statusbar();
			}, cb);
		})

	};
}(gui.Arguments.confirmed));



/**
 * Corporate base model.
 * @extends {edb.Object}
 * @using {gui.Type} Type
 */
ts.ui.Model = (function using(Type) {
	return edb.Object.extend({

		/**
		 * @optional
		 * @type {string}
		 */
		id: null,

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'model',

		/**
		 * Disposed? Flagged by a boolean so that this may be synchronized xframe.
		 * @type {boolean}
		 */
		disposed: false,

		/**
		 * TODO: This (kind of) property should be standard in EDBML.
		 */
		tempdirtyflag: -1,

		/**
		 * Verify that we've set the badly named `item` property which is supposed to
		 * let us match any lump of raw JSON to a particular Model constructor.
		 * TODO (jmo@): The name of this makes sense for menu-items, form-items,
		 * toolbar-items etc. but something more generic would come in handy...
		 */
		onconstruct: function() {
			edb.Object.prototype.onconstruct.call(this);
			if (gui.debug && this.item === 'model') {
				console.error(
					"A unique property 'item' is missing from " + this,
					JSON.stringify(this, null, true)
				);
			}
		},

		/**
		 * Bounce model to HTML string (carelessly mixing "models" and "views").
		 * The returned HTML may often be computed by use of an EDBML template.
		 * @return {string}
		 */
		render: function() {
			return '<p class="todo">' + this.$classname + '.render()</p>';
		},

		/**
		 * Flag as disposed. This would allow any associated spirit to
		 * dispose. This setup has not been fully implemented just yet.
		 * TODO (jmo@): in Spiritual EDB, allow time for synced types!
		 */
		dispose: function() {
			this.disposed = true;
			// this.super.dispose(); // hotfix: not enough time to sync the status!
			gui.Tick.time(function() {
				edb.Type.$destruct(this);
			}, 0, this);
		},

		// Privileged ..............................................................

		/**
		 * Mark model dirty when it can't figure that out.
		 * TODO: This method should be standard in EDBML.
		 */
		$dirty: function() {
			this.tempdirtyflag = Math.random();
		},

		// Private .................................................................

		/**
		 * Invoke that function with optional arguments *only if* it's defined.
		 * If the `action` argument is a string, we'll compile it to a function.
		 * Note that the `this` keyword will in either case point to this model.
		 * TODO: Support multiple args
		 * @param {string|function} action
		 * @returns {boolan} True if the action was called
		 */
		_maybeinvoke: function(action, arg) {
			if (action) {
				var args = [];
				if (arguments.length > 1) {
					args.push(arg);
				}
				if (Type.isString(action)) {
					action = new Function(action);
				}
				action.apply(this, args);
			}
			return !!action;
		}

	});
}(gui.Type));



/**
 * Corporate base collection.
 * @using {gui.Combo.chained} chained
 * @using {gui.Array} guiArray
 * @extends {edb.Array}
 */
ts.ui.Collection = (function using(chained, guiArray) {
	/**
	 * Get model for item type. Mapping is wrapped in a function call
	 * because the actual constructors aren't parsed at this point :/
	 * Propbably this whole list should be maintained somewhere else
	 * and also broken down into *discrete bundles* for future splitup.
	 * @param {string} item
	 * @return {constructor}
	 */
	function getmodel(item) {
		return {
			text: ts.ui.TextModel,
			input: ts.ui.InputModel,
			form: ts.ui.FormModel,
			menu: ts.ui.MenuModel,
			item: ts.ui.ItemModel,
			select: ts.ui.SelectModel,
			textarea: ts.ui.TextAreaModel,
			date: ts.ui.DatePickerModel,
			button: ts.ui.ButtonModel,
			comment: ts.ui.CommentModel,
			action: ts.ui.ActionModel
		}[item] || (function nomatch() {
			console.error('"' + item + '" not matched to nothing');
			return null;
		}());
	}

	/**
	 * Parse collection input to any suitable type.
	 * @param {ts.ui.Collection} collection
	 * @param {JSONObject|ts.ui.Model} input
	 * @param {string} assumed
	 * @return {constructor|ts.ui.Model}
	 */
	function anything(collection, input, assumed) {
		if (input) {
			if (ts.ui.Model.is(input)) {
				return input;
			} else if (input.item) {
				return getmodel(input.item);
			} else if (assumed) {
				return getmodel(assumed);
			} else {
				if (collection.constructor === ts.ui.Collection) {
					return null;	// no enforcement in base class
				} else {
					return nothing(collection);
				}
			}
		}
	}

	/**
	 * Parse collection input to any allowed type. Allowed types may be defined
	 * by a static `allow` property on the collection constructor: `MyCol.allow`
	 * @see {ts.ui.FormItemsCollection} for an example
	 * @param {ts.ui.Collection} collection
	 * @param {JSONObject|ts.ui.Model} input
	 * @param {Array<string>} allowed
	 * @param {string} assumed
	 * @return {constructor|ts.ui.Model}
	 */
	function something(collection, input, allowed, assumed) {
		var Model, item = input.item;
		if (item) {
			if (ts.ui.Model.is(input) && allowed.some(function(it) {
				return (Model = getmodel(it)).is(input);
			})) {
				return input;
			} else if ((Model = getmodel(item))) {
				return Model;
			}
			return badthing(collection, item, allowed);
		} else if (assumed) {
			return getmodel(assumed);
		}
		return nothing(collection);
	}

	/**
	 * Discouraged item type.
	 * @param {ts.ui.Collection} collection
	 * @param {string} item
	 * @param {Array<string>} allowed
	 * @return {null}
	 */
	function badthing(collection, item, allowed) {
		console.error(
			collection + ' doesn\'t accept "' + item +
			'", use one of: ' + allowed
		);
		return null;
	}

	/**
	 * We've got nothing.
	 * @param {ts.ui.Collection} collection
	 * @return {null}
	 */
	function nothing(collection) {
		console.error('Item for ' + collection + ' needs an \'item\' property');
		return null;
	}

	return edb.Array.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'collection',

		/**
		 * Disposed? Flagged by a boolean so that this may be synchronized xframe.
		 * @type {boolean}
		 */
		disposed: false,

		/**
		 * Match the incoming JSONs `item` property to a set of
		 * known model constructors and parse to an appropriate type.
		 * The collection can declare (in the `Static` section):
		 *
		 * 1) Which kind of `item` it is ready to accept
		 * 2) What model should be assumed when `item` is missing
		 *
		 * @param {JSONObject|ts.ui.Model} thing
		 * @return {constructor|ts.ui.Model}
		 */
		$of: function(input) {
			var allowed = this.constructor.allow;
			var assumed = this.constructor.assume;
			if (input) {
				return allowed ?
						something(this, input, allowed, assumed) :
						anything(this, input, assumed);
			}
			return null; // right?
		},

		/**
		 * Get model by ID or index.
		 * @overides {edb.Array#get}
		 * @param {string|number} id
		 */
		get: function(id) {
			switch (gui.Type.of(id)) {
				case 'number':
					return edb.Array.prototype.get.call(this, id);
				case 'string':
					return this.reduce(function(result, model) {
						return result || (model.id && model.id === id ? model : null);
					}, null);
			}
		},

		/**
		 * Bounce collection to HTML string.
		 * @return {string}
		 */
		render: function() {
			return this.map(function(model) {
				return model.render();
			}).join('');
		},

		/**
		 * Remove AND dispose that model.
		 * TODO(jmo@): Support multiple arguments
		 * @returns {ts.ui.Collection} (not the model, since that gets disposed)
		 */
		remove: chained(function(model) {
			guiArray.remove(this, model);
			model.dispose();
		}),

		/**
		 * Contains model?
		 * @param {ts.ui.Model|ts.ui.Collection} model
		 */
		contains: function(model) {
			return this.indexOf(model) > -1;
		},

		/**
		 * Clear this collection. It's always a good idea to reuse a collection
		 * instead of creating a new one, because the existing collection might
		 * have observers attached. @neal: Is this a good name for this method?
		 * @returns {ts.ui.Collection}
		 */
		clear: chained(function() {
			while (this.length) {
				this.pop();
			}
		}),

		/**
		 * Flag as disposed. This would allow associated spirit to dispose
		 * (flagged by a boolean so that this may be synchronized xframe).
		 */
		dispose: function() {
			this.disposed = true;
			edb.Array.prototype.dispose.call(this);
		}

	}, { // Static ...............................................................

		/**
		 * Allowed content models (by `item` property).
		 * @type {Array<string>}
		 */
		allow: null,

		/**
		 * Assumed content model (if 'item' property was undeclared).
		 * @type {string}
		 */
		assume: null

	});
}(gui.Combo.chained, gui.Array));



/**
 * Global layout model.
 * @extends {ts.ui.GlobalModel}
 */
ts.ui.LayoutModel = ts.ui.Model.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'layout',

	/**
	 * True until first app loaded and shown.
	 * @type {boolean}
	 */
	booting: true,

	/**
	 * Current breakpoint. Matches mobile|tablet|desktop.
	 * @type {string}
	 */
	breakpoint: null,

	/**
	 * Derived breakponts: Current breakpoint and everything below.
	 * @type {Array<string>}
	 */
	breakpoints: null,

	/**
	 * Menu is open?
	 * TODO(jmo@): We are currently not maintaining this boolean right.
	 * @type {boolean}
	 */
	menuopen: false,

	/**
	 * Someone is busy doing something that blocks the UI?
	 * TODO(jmo@): We are currently not maintaining this boolean right.
	 * @see {ts.ui.StatusPlugin}
	 * @type {boolean}
	 */
	blocking: false,

	/**
	 * Tracking open asides by `$instanceid` so we can count them.
	 * @type {Array<string>}
	 */
	asides: edb.Array, // TODO: ts.ui.Collection fails for some reason

	/**
	 * Tracking open dialogs by `$instanceid` so we can count them.
	 * TODO(jmo@): We are currently not maintaining this collection right.
	 * @type {Array<string>}
	 */
	dialogs: edb.Array, // TODO: ts.ui.Collection fails for some reason

	/**
	 * Tracking focused spirits by `$instanceid` so we can restore focus.
	 * @type {Array<string>}
	 */
	attention: edb.Array, // TODO: ts.ui.Collection (but focus would break)

	/**
	 * Instantiate collections.
	 */
	onconstruct: function() {
		ts.ui.Model.prototype.onconstruct.call(this);
		this.asides = [];
		this.dialogs = [];
		this.attention = [];
	},

	/**
	 * Is mobile breakpoint?
	 * @returns {boolean}
	 */
	isMobilePoint: function() {
		return this.breakpoint === ts.ui.LayoutModel.BREAKPOINT_MOBILE;
	},

	/**
	 * Is tablet breakpoint?
	 * @returns {boolean}
	 */
	isTabletPoint: function() {
		return this.breakpoint === ts.ui.LayoutModel.BREAKPOINT_TABLET;
	},

	/**
	 * Is desktop breakpoint?
	 * @returns {boolean}
	 */
	isDesktopPoint: function() {
		return this.breakpoint === ts.ui.LayoutModel.BREAKPOINT_DESKTOP;
	}

}, { // Static .................................................................

	BREAKPOINTS: { 1270: 'desktop', 600: 'tablet', 0: 'mobile' },
	BREAKPOINT_MOBILE: 'mobile', // something the size of a phone
	BREAKPOINT_TABLET: 'tablet', // something the size of a tablet
	BREAKPOINT_DESKTOP: 'desktop' // something the size of a table

});



/**
 * Global device model (TODO).
 * @extends {ts.ui.GlobalModel}
 */
ts.ui.DeviceModel = ts.ui.Model.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'device',

	/**
	 * Matches "portrait" or "landscape".
	 * Defaults to landscape for desktop.
	 * @type {string}
	 */
	orientation: 'landscape'

}, { // Static .................................................................

	ORIENTATION_LANDSCAPE: 'landscape',
	ORIENTATION_PORTRAIT: 'portrait'

});



/**
 * Advanced aside model.
 * @extends {ts.ui.Model}
 * @param {function} chained
 */
ts.ui.AsideModel = (function using(chained) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'aside',

		/**
		 * Content collection.
		 * @type {ts.ui.Collection<ts.ui.Model>}
		 */
		items: ts.ui.Collection,

		/**
		 * Aside title.
		 * @type {String}
		 */
		title: null,

		/**
		 * Current aside status (for xframe synchronization).
		 * Matches one of onopen|onopened|onclose|onclosed
		 * @type {string}
		 */
		status: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onopen: null,

		/**
		 * Open for implementation. Related to some kind
		 * of performance hack, not really a public fact.
		 * @type {function}
		 */
		onbeforeopened: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 * @returns {gui.Then} (some performance hack here)
		 */
		onopened: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onclose: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onclosed: null,

		/**
		 * @type {boolean}
		 */
		isOpen: false,

		/**
		 * @type {string}
		 */
		color: null,

		/**
		 * @type {boolean}
		 */
		autofocus: true,

		/**
		 * Internal use only: Monitored by the {ts.ui.AsideSpirit}.
		 * @type {boolean}
		 */
		gofocused: false,

		/**
		 * Block the {ts.ui.AsideSpirit} from declaring itself open. Relates
		 * to some kind of internal performance optimization for SELECT menus.
		 * @type {boolean}
		 */
		suspendopen: false,

		/**
		 * Make sure that `items` exist.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.items = this.items || []; // becomes {ts.ui.Collection}, see above
			this.addObserver(this);
		},

		/**
		 * TODO (jmo@): Destruct is not really implemented (memory implications)
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
		},

		/**
		 * Handle changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				if (c.name === 'status') {
					var method = c.newValue;
					if (this[method]) {
						this[method]();
					}
				}
			}, this);
		},

		/**
		 * Mark as open.
		 * @returns {ts.ui.AsideModel}
		 */
		open: chained(function() {
			this.isOpen = true;
		}),

		/**
		 * Mark as closed.
		 * @returns {ts.ui.AsideModel}
		 */
		close: chained(function() {
			this.isOpen = false;
		}),

		/**
		 * Focus something in the Aside. This toggle gets picked up by
		 * the {ts.ui.AsideSpirit} which will soon set it back to `false`,
		 * @returns {ts.ui.AsideModel}
		 */
		focus: chained(function() {
			this.gofocused = true;
		}),

		/**
		 * Allow the {ts.ui.AsideSpirit} to declare itself open. Again,
		 * these things must be synchronized xframe via property toggles.
		 * @returns {ts.ui.MenuModel}
		 */
		unsuspendopen: chained(function() {
			this.suspendopen = false;
		})

	});
}(gui.Combo.chained));

/**
 * Generate methods `blue` `green` `purple` and so
 * on to change the general color scheme of the Aside.
 * Note that `white` and `lite` both translate to blue!
 * @using {Object} methods
 */
(function generatercode(methods) {
	var proto = ts.ui.AsideModel.prototype;
	gui.Object.each(methods, function(method, classname) {
		proto[method] = function() {
			this.color = classname;
			return this;
		};
	});
}(ts.ui.BACKGROUND_COLORS));



/**
 * Menu item collection.
 * @extends {ts.ui.Collection}
 */
ts.ui.ItemCollection = ts.ui.Collection.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'items'

}, { // Static .................................................................

	assume: 'item'

});



/**
 * Advanced menu model.
 * @extends {ts.ui.Model}
 * @using {gui.Type} Type
 * @using {gui.Combo.chained} chained
 */
ts.ui.MenuModel = (function using(Type, chained) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'menu',

		/**
		 * Items list. Note that this is a just an array of "simple" objects,
		 * that's why the 'onselect' callback is on the menu and not the item.
		 * @type {Array}
		 */
		items: Array,

		/**
		 * Matches one|many.
		 * @type {string}
		 */
		select: 'one',

		/**
		 * Selected index (if selecting one).
		 * @type {number}
		 */
		selectedIndex: -1,

		/**
		 * Selected indexes (if selecting many).
		 * @type {edb.Array<number>}
		 */
		selectedIndexes: edb.Array,

		/**
		 * Experimental.
		 * @type {number}
		 */
		maxItemsShown: -1,

		/**
		 * TODO!
		 * @type {function}
		 */
		search: null,

		/**
		 * Stamp the search term onto a property because
		 * this will be synchronized xframe (greenfield).
		 * @type {string}
		 */
		searchterm: null,

		/**
		 * Terrible. Used to force a refresh of the (EDBML) view.
		 * TODO: Figuer something out, make a model.$dirty method
		 * @type {number}
		 */
		random: -1,

		/**
		 * Callback for item selected. Open for implementation.
		 * @type {function}
		 * @param {number} index This equals the new 'selectedIndex'.
		 */
		onselect: null,

		/**
		 * Label for Done-button (if selecting multiple).
		 * @type {string}
		 */
		donebuttonlabel: ts.ui.String.LABEL_ACCEPT,

		/**
		 * Only used for the Done button in multiple selects.
		 * If needed elsewhere, please rethink implementation.
		 * @see {ts.ui.SelectInputSpirit}
		 * @type {boolean}
		 */
		donebuttonenabled: false,

		/**
		 * Used for the Done button in multiple selects.
		 * @type {boolean}
		 */
		donebuttonpressed: false,

		/**
		 * Not shown, but we can assign one anyway
		 * (it might be used in Aside headers etc).
		 * @type {string}
		 */
		title: null,

		/**
		 * Observe myself and setup the search.
		 * TODO: fire `onidle` also on search cleared
		 * so that we don't need the method `onsearch`
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			var that = this;
			this.addObserver(this);
			if (this.select === 'many') {
				// this.selectedIndexes.addObserver(this);
			}
			this._searchmodel = new ts.ui.SearchModel({
				onsearch: function(value) {
					that.searchterm = value;
				},
				onidle: function(value) {
					that.searchterm = value;
				}
			});
		},

		/**
		 * TODO: Automate this.
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
		},

		/**
		 * Handle (potentially xframe synchronized) changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				switch (c.name) {
					case 'searchterm':
						this._search(c.newValue);
						break;
					case 'selectedIndex':
						if (this.onselect) {
							this.onselect(c.newValue);
						}
						break;
				}
			}, this);
		},

		/**
		 * Show all items (assuming hre that maxItemsShown was enforced).
		 * Again, we can only sync this xframe via simple property changes.
		 * @returns {ts.ui.MenuModel}
		 */
		showallitems: chained(function() {
			this.maxItemsShown = -1;
		}),

		/**
		 * Bounce model to HTML string.
		 * @return {string}
		 */
		render: function() {
			return ts.ui.menu.edbml(this);
		},

		/**
		 * Used for the Done button in multiple selects.
		 */
		done: function() {
			this.donebuttonpressed = true;
		},

		open: function() {
			ts.ui.Aside({
				title: 'Test',
				items: [this]
			}).open();
		},

		/**
		 * We have no idea where this MenuModel is being rendered, but when we're
		 * optimizing SELECT performance, we need the panel of the containing aside
		 * to scroll to some designated position. This method is called directly
		 * from within the EDBML function so that everything is synchronized to a
		 * single screen repaint (eg. not involving any async observer callbacks).
		 * @see {ts.ui.menu.edbml}
		 * @param {number} scrollTop
		 */
		scrollContainingPanel: function(scrollTop) {
			gui.Broadcast.dispatch(ts.ui.BROADCAST_PANEL_SYNC_MENU, {
				menuid: this.$instanceid,
				offset: scrollTop
			});
		},

		// Private .................................................................

		/**
		 * Probably not needed no more.
		 * @type {ts.ui.SearchModel}
		 */
		_searchmodel: null,

		/**
		 * Search will probably be moved into the Aside header,
		 * at which point this code can be deleted for good...
		 * @param {string} value
		 */
		_search: function(value) {
			if (Type.isFunction(this.search)) {
				this.items.forEach(function(item) {
					var bool = this.search(item, value);
					if (Type.isBoolean(bool)) {
						item.visible = bool;
					} else {
						throw new TypeError('Search expected a boolean');
					}
				}, this);
				this._forcerefresh();
			}
		},

		/**
		 * The items list is a simple Array (not a collection of models),
		 * so changes to the JSON will not retrigger the EDBML scripts.
		 * We have however hacked it so that EDBML scripts depend on an
		 * ad-hoc property called `random` which we'll now change...
		 */
		_forcerefresh: function() {
			this.random = Math.random();
		}

	});
}(gui.Type, gui.Combo.chained));



/**
 * Advanced tab model.
 * @extends {ts.ui.Model}
 * @using {gui.Combo#chained}
 */
ts.ui.TabModel = (function using(chained) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'tab',

		/**
		 * Optional ID.
		 * @see {ts.ui.TabCollection#get}
		 * @type {string}
		 */
		id: null,

		/**
		 * Tab text.
		 * @type {String}
		 */
		label: null,

		/**
		 * Tab icon.
		 * @type {String}
		 */
		icon: null,

		/**
		 * Tab selected?
		 * @type {boolean}
		 */
		selected: false,

		/**
		 * Counting whatever you like.
		 * @type {number}
		 */
		counter: 0,

		/**
		 * Something to execute onselect.
		 * @type {function}
		 */
		onselect: null,

		/**
		 * Tab can be closed?
		 * @type {boolean}
		 */
		closeable: false,

		/**
		 * Tab show on the topbar?
		 * @type {boolean}
		 */
		$isontop: true,

		/**
		 * Something to execute onclose.
		 * @type {function}
		 */
		onclose: null,

		/**
		 * Alias {ts.ui.TabModel#closable}.
		 * @see https://uk.answers.yahoo.com/question/index?qid=20070329061734AAtI9Hc
		 */
		closable: {
			getter: function() {
				return this.closeable;
			},
			setter: function(value) {
				this.closeable = value;
			}
		},

		/**
		 * We add an observer to ourselves so that we can evaluate the `onselect`
		 * callback if anyone changes our `selected` property. This is especially
		 * useful in xframe (greenfield) setup where the `selected` property gets
		 * synchronized back from the chrome.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.addObserver(this);
			if (this.selected) {
				this._doselect();
			}
		},

		/**
		 * TODO: automate this step :/
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
		},

		/**
		 * Handle changes.
		 * @param {Array<gui.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				if (c.name === 'selected' && c.newValue) {
					this._doselect();
				}
			}, this);
		},

		/**
		 * Select the tab.
		 * @return {ts.ui.TabModel}
		 */
		select: chained(function() {
			this.selected = true;
		}),

		/**
		 * Don't select the tab.
		 * @return {ts.ui.TabModel}
		 */
		unselect: chained(function() {
			this.selected = false;
		}),

		// Privileged ..............................................................

		/**
		 * Secret `onselect` for system private implementation.
		 * @type {function}
		 */
		$onselect: null,

		// Private .................................................................

		/**
		 * @type {number}
		 */
		_timeout: -1,

		/**
		 * Don't start loading AJAX or something
		 * with the button stuck in :focus mode.
		 */
		_doselect: function() {
			if (this.onselect || this.$onselect) {
				gui.Tick.cancelTime(this._timeout);
				this._timeout = gui.Tick.time(function unfreeze() {
					if (this.$onselect) { // system implementation
						this.$onselect();
					}
					if (this.onselect) { // user configurable
						this.onselect();
					}
				}, 25, this);
			}
		}
	});
}(gui.Combo.chained));



/**
 * Advanced collection of tabs.
 * @extends {ts.ui.Collection}
 * TODO (jmo@): Make sure 'onselect' never triggers twice
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} confirmed
 * @using {gui.Type} Type
 */
ts.ui.TabCollection = (function using(chained, confirmed, Type) {
	return ts.ui.Collection.extend({

		/**
		 * Content model constructor.
		 * @type {function}
		 */
		$of: ts.ui.TabModel,

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'tabs',

		/**
		 * Optional button to add new tab.
		 * @type {ts.ui.ButtonModel}
		 */
		newtabbutton: null,

		/**
		 * Open for implementation: Tab at given index was selected.
		 * @param {number} index
		 */
		onselect: function(index) {},

		/**
		 * Selected index accessor.
		 * @type {number}
		 */
		selectedIndex: {
			getter: function() {
				return this._current ? this.indexOf(this._current) : -1;
			},
			setter: function(i) {
				if (i >= 0 && i < this.length) {
					this._toggle(this[i], this._current);
				} else {
					throw new RangeError('Out of range');
				}
			}
		},

		/**
		 * Show the button to add new tab. The actual adding of
		 * the tabs is done manually (when the callback fires).
		 * @param @optional {function} opt_cb
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		showNew: confirmed('(function)')(
			chained(function(opt_cb) {
				var that = this;
				if (this.newtabbutton) {
					this.newtabbutton.dispose();
				}
				this.newtabbutton = new ts.ui.ButtonModel({
					onclick: function() {
						if (opt_cb) {
							opt_cb.call(that);
						}
					}
				});
			})
		),

		/**
		 * Hide the button to add new tab.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		hideNew: chained(function() {
			if (this.newtabbutton) {
				this.newtabbutton.dispose();
				this.newtabbutton = null;
			}
		}),

		/**
		 * Observe tab selections.
		 * Default select first tab.
		 * @param {Array<gui.TabModel>} tabs
		 */
		onconstruct: function(tabs) {
			ts.ui.Collection.prototype.onconstruct.call(this);
			this.addObserver(this);
			if (this.length) {
				var that = this;
				this.selectedIndex = tabs.reduce(function(x, tab, i) {
					tab.addObserver(that);
					return tab.selected ? i : x;
				}, 0);
			}
		},

		/**
		 * Handle changes (low level API for now).
		 * @param {Array<edb.ObjectChange>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				switch (c.object.item) {
					case 'tab' :
						this._ontabchange(c);
						break;
					case 'tabs' :
						this._onthischange(c);
						break;
				}
			}, this);
		},

		// Private ...................................................................

		/**
		 * Selected tab.
		 * @type {ts.ui.TabModel}
		 */
		_current: null,

		/**
		 * Last known selected index.
		 * @type {number}
		 */
		_lastknownindex: -1,

		/**
		 * Toggle selection.
		 */
		_toggle: function(newtab, oldtab) {
			var oldindex = this._lastknownindex;
			if (newtab !== oldtab) {
				if (oldtab) {
					oldtab.unselect();
				}
				this._current = newtab.select();
				this._lastknownindex = this.selectedIndex;
				if (Type.isFunction(this.onselect)) {
					this.onselect.call(this, this.selectedIndex, oldindex);
				}
			}
		},

		/**
		 * Tab model changed.
		 * @param {edb.ObjectChange} c
		 */
		_ontabchange: function(c) {
			if (c.type === edb.ObjectChange.TYPE_UPDATE) {
				if (c.name === 'selected' && c.newValue) {
					if (c.object !== this._current) {
						this.selectedIndex = this.indexOf(c.object);
					}
				}
			}
		},

		/**
		 * This (TabCollection) changed.
		 * @param {edb.ArrayChange} c
		 */
		_onthischange: function(c) {
			switch (c.type) {
				case edb.ArrayChange.TYPE_SPLICE:
					this._onsplice(c.object, c.removed, c.added);
					break;
			}
		},

		/**
		 * Tabs were added or removed.
		 * @param {ts.ui.TabCollection<ts.ui.TabModel>} tabs
		 * @param {Array<ts.ui.TabModel} removed
		 * @param {Array<ts.ui.TabModel} added
		 */
		_onsplice: function(tabs, removed, added) {
			var that = this, current = this._current;
			if (removed.length) {
				gui.Tick.next(function allow_multiple_operations() {
					removed.filter(function really_removed(tab) {
						return tabs.indexOf(tab) === -1;
					}).forEach(function(tab) {
						tab.removeObserver(that);
						tab.dispose();
					});
				});
			}
			added.forEach(function(tab) {
				tab.addObserver(that);
				if (tab.selected) {
					this._toggle(tab, current);
				}
			}, this);

			/*
			 * TODO: Make us not depend on this timeout,
			 * hacking it now for the Client-Docs stuff.
			 */
			setTimeout(function butwhy() {
				this._fallback();
			}.bind(this));
		},

		/**
		 * Make sure something nice is selected.
		 */
		_fallback: function() {
			if (this.length) {
				if (this.selectedIndex === -1) {
					var last = this._lastknownindex;
					while (last > this.length) {
						last--;
					}
					if (last >= 1) {
						this[last - 1].select();
					} else {
						this[0].select();
					}
				}
			} else {
				this._lastknownindex = -1;
				this._current = null;
			}
		}
	});
}(gui.Combo.chained, gui.Arguments.confirmed, gui.Type));



/**
 * Advanced button model.
 * @extends {ts.ui.Model}
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} confirmed
 * @using {gui.Type} Type
 */
ts.ui.ButtonModel = (function using(chained, confirmed, Type) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'button',

		/**
		 * Button label.
		 * @type {String}
		 */
		label: null,

		/**
		 * Button icon.
		 * @type {String}
		 */
		icon: null,

		/**
		 * Button tooltip.
		 * @type {string}
		 */
		info: null,

		/**
		 * Stretch to fill the space? Support
		 * for this depends on the use case.
		 * @type {number} (treated as truthy for now)
		 */
		flex: 0,

		/**
		 * Type is really the CSS classname. Defaults to "ts-tertiary"
		 * @type {String}
		 */
		type: ts.ui.CLASS_TERTIARY,

		/**
		 * Reverse label and icon? If true,
		 * button width will be set to 100%.
		 * @type {boolean}
		 */
		reverse: false,

		/**
		 * Something to execute onclick.
		 * @type {function}
		 */
		onclick: null,

		/**
		 * Visible?
		 * @type {boolean}
		 */
		visible: true,

		/**
		 * Disabled?
		 * @type {boolean}
		 */
		disabled: false,

		/**
		 * No default keyboard support until the
		 * whole keyboard things has been worked.
		 * @type {number}
		 */
		tabindex: -1,

		/**
		 * HTML should add the `autofocus` attribute?
		 * @type {boolean}
		 */
		autofocus: false,

		/**
		 * Busy message.
		 * @type {string}
		 */
		busystatus: null,

		/**
		 * Button name.
		 * @type {string}
		 */
		name: null,

		/**
		 * Button value.
		 * @type {Any}
		 */
		value: null,

		/**
		 * The `action.type` that will dispatch when clicked (internal use).
		 * @type {string}
		 */
		action: null,

		/**
		 * Dispatched as the `action.data` (internal use).
		 * @type {Any}
		 */
		data: null,

		/**
		 * Click that button.
		 * @returns {ts.ui.ButtonModel}
		 */
		click: chained(function() {
			if (Type.isFunction(this.onclick)) {
				setTimeout(function unfreeze() {
					this.onclick();
				}.bind(this), 50);
			}
		}),

		/**
		 * Show button.
		 * @returns {ts.ui.ButtonModel}
		 */
		show: chained(function() {
			this.visible = true;
		}),

		/**
		 * Hide button.
		 * @returns {ts.ui.ButtonModel}
		 */
		hide: chained(function() {
			this.visible = false;
		}),

		/**
		 * Enable button.
		 * @returns {ts.ui.ButtonModel}
		 */
		enable: chained(function() {
			this.disabled = false;
		}),

		/**
		 * Disable button.
		 * @returns {ts.ui.ButtonModel}
		 */
		disable: chained(function() {
			this.disabled = true;
		}),

		/**
		 * Mark as busy.
		 * @param @optional {string} label
		 * @returns {ts.ui.ButtonModel}
		 */
		busy: confirmed('(string)')(chained(function(label) {
			this.busystatus = label || true;
		})),

		/**
		 * Mark as done.
		 * @returns {ts.ui.ButtonModel}
		 */
		done: chained(function() {
			this.busystatus = null;
		}),

		/**
		 * Bounce model to HTML.
		 * @param @optional {boolean} Is the button as a menu
		 * @return {string}
		 */
		render: function(isButtonMenu) {
			return ts.ui.button.edbml(this, isButtonMenu);
		},

		// Private .................................................................

		/**
		 *
		 */
		_oldlabel: null

	});
}(gui.Combo.chained, gui.Arguments.confirmed, gui.Type));



/**
 * Advanced collection of buttons.
 * @extends {ts.ui.Collection}
 * @using {gui.Arguments.confirmed} confirmed
 * @using {gui.Combo.chained} chained
 */
ts.ui.ButtonCollection = (function using(confirmed, chained) {
	return ts.ui.Collection.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'buttons',

		/**
		 * All buttons (manually made) visible?
		 * TODO: This prop should be observed!
		 * @type {boolean}
		 */
		visible: true,

		/**
		 * All buttons (manually) disabled?
		 * TODO: This prop should be observed!
		 * @type {boolean}
		 */
		disabled: false,

		/**
		 * Content model constructor.
		 * @returns {constructor}
		 */
		$of: confirmed('(object|array)')(function(arg) {
			if (Array.isArray(arg)) {
				return ts.ui.ButtonCollection;
			} else {
				return ts.ui.ButtonModel;
			}
		}),

		/**
		 * Sort primary buttons last (rightmost in toolbar)
		 * and run action for each element in sorted result.
		 * Does not modify the structure of this collection.
		 * @param @optional {function} action
		 * @param @optional {object} opt_thisp
		 * @return {Array<object>} Collect action results.
		 */
		ascending: function(action, opt_thisp) {
			return this._eachOrdered(true, action || function(button) {
				return button;
			}, opt_thisp);
		},

		/**
		 * Run action with buttons first (leftmost in toolbar).
		 * @param @optional {function} action
		 * @param @optional {object} opt_thisp
		 * @return {Array<object>} Collect action results.
		 */
		descending: function(action, opt_thisp) {
			return this._eachOrdered(false, action || function(button) {
				return button;
			}, opt_thisp);
		},

		/**
		 * Bounce collection to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.buttons.edbml(this);
		},

		/**
		 * Hide all buttons.
		 * @returns {ts.ui.ButtonCollection}
		 */
		hide: chained(function() {
			this.visible = false;
			this.forEach(function(button) {
				button.hide();
			});
		}),

		/**
		 * Show all buttons.
		 * @returns {ts.ui.ButtonCollection}
		 */
		show: chained(function() {
			this.visible = true;
			this.forEach(function(button) {
				button.show();
			});
		}),

		/**
		 * Disable all buttons.
		 * @returns {ts.ui.ButtonCollection}
		 */
		disable: chained(function() {
			this.disabled = true;
			this.forEach(function(button) {
				button.disable();
			});
		}),

		/**
		 * Enable all buttons.
		 * @returns {ts.ui.ButtonCollection}
		 */
		enable: chained(function() {
			this.disabled = false;
			this.forEach(function(button) {
				button.enable();
			});
		}),

		// Private .....................................................

		/**
		 * @param {boolean} ascending
		 * @param {function} action
		 * @param {Object=} opt_thisp
		 */
		_eachOrdered: function(ascending, action, opt_thisp) {
			return this._orderedBy(ascending).map(function(button, i) {
				return action.call(opt_thisp, button, i);
			});
		},

		/**
		 * Group the buttons according to priority.
		 * @param {boolean=} opt_ascending
		 */
		_orderedBy: function(opt_ascending) {
			var result = [].concat(
				this._filterBy(ts.ui.CLASS_DANGER),
				this._filterBy(ts.ui.CLASS_PRIMARY),
				this._filterBy(ts.ui.CLASS_SECONDARY),
				this._filterBy(ts.ui.CLASS_TERTIARY)
			);
			return opt_ascending ? result.reverse() : result;
		},

		/**
		 * List buttons of specific priority.
		 * @param {String} klass
		 */
		_filterBy: function(klass) {
			return this.filter(function(member) {
				switch (member.constructor) {
					case ts.ui.ButtonModel:
						return member.type.includes(klass);
					case ts.ui.ButtonCollection:
						return member.length && member[0].type.includes(klass);
				}
			});
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));



ts.ui.ButtonMenuModel = (function() {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'buttonsmenu',

		/**
		 * Buttons.
		 * @type {ts.ui.ButtonCollection<ts.ui.ButtonModel>}
		 */
		items: ts.ui.ButtonCollection,

		/**
		 * Bounce model to HTML.
		 * @return {string}
		 */
		render: function() {
			return ts.ui.buttonsmenu.edbml(this);
		}
	});
}());



/**
 * Advanced datepicker model.
 * @extends {ts.ui.Model}
 * @using {gui.Combo#chained}
 */
ts.ui.DatePickerModel = (function using(chained) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'date',

		/**
		 * DatePickers are often associated to an aside,
		 * in which case this becomes the aside header.
		 * @type {string}
		 */
		title: null,

		/**
		 * Picker is open?
		 */
		isOpen: false,

		/**
		 * @type {string}
		 */
		value: null,

		/**
		 * @type {string}
		 */
		min: null,

		/**
		 * @type {string}
		 */
		max: null,

		/**
		 * Called when selection changes.
		 * @type {function}
		 */
		onselect: null,

		/**
		 * Called when the associated ASIDE is fully closed.
		 * @type {function}
		 */
		onclosed: null,

		/**
		 * Observe myself (because of xframe synchronization).
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.addObserver(this);
		},

		/**
		 * Unobserve myself.
		 * TODO (jmo@): automate this step!
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
		},

		/**
		 * Mark as open.
		 * @returns {ts.ui.DatePickerModel}
		 */
		open: chained(function() {
			this.isOpen = true;
		}),

		/**
		 * Mark as closed.
		 * @return {ts.ui.DatePickerModel}
		 */
		close: chained(function() {
			this.isOpen = false;
		}),

		/**
		 * Handle changes.
		 * @param {Array<gui.Change>} changes
		 */
		onchange: function(changes) {
			if (this.onselect) {
				changes.forEach(function(c) {
					if (c.name === 'value') {
						setTimeout(function unfreeze() {
							this.onselect(c.newValue, c.oldValue);
						}.bind(this));
					}
				}, this);
			}
		},

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.datepicker.edbml(this);
		}

	});
}(gui.Combo.chained));



/**
 * Advanced text model. Renders as one or more paragraphs.
 * @extends {ts.ui.Model}
 * @using {ts.ui.Markdown} Markdown Converts (subset of) markdown to markup
 */
ts.ui.TextModel = (function using(Markdown) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'text',

		/*
		 * The textual message that is intended to be communicated in textual form.
		 * @type {string}
		 */
		text: '',

		/**
		 * Bounce model to HTML. This (at least) produces one or more <p> tags
		 * @param @optional {Array<string>} tags If specified, decides what tags
		 * besides <p> to be parsed. If not, all supported tags will get parsed.
		 * @return {string}
		 */
		render: function(tags) {
			return Markdown.parse(this.text, tags || null);
		}

	});
}(ts.ui.Markdown));



/**
 * Advanced collection of dialog items.
 * @extends {ts.ui.Collection}
 */
ts.ui.DialogItemCollection = ts.ui.Collection.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'dialogitems'

}, { // Static .................................................................

	/**
	 * Allowed content models.
	 * @see {ts.ui.Collection.#$of}
	 * @see {ts.ui.Model#item}
	 * @type {Map<string,constructor>}
	 */
	allow: ['text', 'form', 'menu']

});



/**
 * Advanced dialog model.
 * @extends {ts.ui.Model}
 * @using {ts.ui.Dialog} Dialog
 * @using {gui.Combo#chained} chained
 * @using {gui.Type} Type
 * @using {gui.Object} GuiObject
 * @using {ts.ui.String} Constants
 * @using {string} primary
 * @using {string} secondary
 * @using {string} tertiary
 */
ts.ui.DialogModel = (function using(Dialog, chained, Type, GuiObject, Constants, primary, secondary, tertiary) {
	/**
	 * Get JSON for button where the properties of the passed
	 * JSON will overwrite the given (default) label and type.
	 * The {ts.ui.DialogSpirit} may modify the `type` property.
	 * @param {object} json Button configuration
	 * @param {string} id So that we can find it later
	 * @param {string} label Default label
	 * @param {string} type Default type
	 * @returns {object}
	 */
	function getbutton(json, id, label) {
		return GuiObject.extendmissing(json || {}, {
			type: 'ts-secondary',
			label: label,
			tabindex: 0,
			id: id
		});
	}

	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'dialog',

		/**
		 * This is really just a CSS classname.
		 * @type {string}
		 */
		type: null,

		/**
		 * Dialog content items (excluding the buttons).
		 * @type {ts.ui.Collection<ts.ui.Model>}
		 */
		items: ts.ui.DialogItemCollection,

		/**
		 * Dialog buttons list. You can add custom buttons here much like you would
		 * add buttons to the topbar, see documentation for {ts.ui.TopBar}.
		 * @type {ts.ui.ButtonCollection<ts.ui.Button>}
		 */
		buttons: ts.ui.ButtonCollection,

		/**
		 * Strange property used to synchronize dialog state iframes.
		 * @type {string}
		 */
		state: null,

		/**
		 * Dialog icon.
		 * @type {string}
		 */
		icon: null,

		/**
		 * Is open?
		 * @type {boolean}
		 */
		isOpen: false,

		/**
		 * Is clicked?
		 * @type {boolean}
		 */
		isClicked: false,

		/**
		 * Stub.
		 * @type {function}
		 */
		onaccept: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		oncancel: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		onhelp: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		oninfo: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		onopen: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		onopened: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		onclose: null,

		/**
		 * Stub.
		 * @type {function}
		 */
		onclosed: null,

		/**
		 * Stub for something that should happen when the dialog is clicked.
		 * The dialog becomes something like a big button with this thing on.
		 * @type {function}
		 */
		onclick: null,

		/**
		 * Stub for something that should happen
		 * when a link in the dialog is clicked.
		 * @type {function}
		 */
		onlink: null,

		/**
		 * If (and only if) there's no dialog buttons,
		 * automatically fade away at specified time.
		 * @type {number} in milliseconds
		 */
		time: Dialog.DEFAULT_TIME,

		/**
		 * Limit tags parsed in markdown. if *not* specified, we default
		 * to all supported tags. Not that markdown is currently only
		 * supported in the {ts.ui.TextModel}.
		 * @type {Array<string>}
		 */
		tags: null, // for example ['a', 'strong', 'em', 'code']

		/**
		 * ID of the (default) focused button. Matches accept|cancel|info|help.
		 * The {ts.ui.DialogSpirit} will make sure to focus the button.
		 * @type {string}
		 */
		focused: null,

		/**
		 * ID of the primary button. Matches accept|cancel|info|help.
		 * If there's only one button, the {ts.ui.DialogSpirit} will
		 * make this button primary when it opens the dialog.
		 * @type {number}
		 */
		primary: null,

		/**
		 * Construction time.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.items = this.items || [];
			this.buttons = this.buttons || [];
			this.addObserver(this);
			this.time = this._computetime(this.items.find(function(item) {
				return ts.ui.TextModel.is(item);
			}));
		},

		/**
		 * Handle changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				if (c.name === 'state') {
					var method = c.newValue;
					if (this[method]) {
						this[method]();
					}
				}
			}, this);
		},

		/**
		 * Adds the cancel button which will cancel the operation. If the focused
		 * button has not been specified via JSON input, theis button gets focused.
		 * @param {object} json
		 * @return {ts.ui.DialogModel}
		 */
		cancelButton: chained(function(json) {
			var label = Constants.LABEL_CANCEL;
			if (json !== null) {
				this._addButton(0, getbutton(json, 'cancel', label));
			}
		}),

		/**
		 * Adds the help button for displaying help about the dialog.
		 * @param {object} json
		 * @return {ts.ui.DialogModel}
		 */
		helpButton: chained(function(json) {
			var label = Constants.LABEL_HELP;
			if (json !== null) {
				this._addButton(1, getbutton(json, 'help', label));
			}
		}),

		/**
		 * Adds some kind of button to show more information (disclosure etc).
		 * @param {object} json
		 * @return {ts.ui.DialogModel}
		 */
		infoButton: chained(function(json) {
			var label = Constants.LABEL_INFO;
			if (json !== null) {
				this._addButton(2, getbutton(json, 'info', label));
			}
		}),

		/**
		 * Adds the OK button which will accept whatever is going on.
		 * @param {object} json
		 * @return {ts.ui.DialogModel}
		 */
		acceptButton: chained(function(json) {
			var label = Constants.LABEL_ACCEPT;
			if (json !== null) {
				this._addButton(3, getbutton(json, 'accept', label));
			}
		}),

		/**
		 * Show the dialog.
		 * @return {ts.ui.DialogModel}
		 */
		open: function() {
			var then = new gui.Then();
			ts.ui.ready(function() { // TODO: this would not exist in "Greenfield" :/
				this.isOpen = true;
				gui.Tick.time(function transitiondone() { // TODO(jmo@): hook up right!
					then.now();
				}, ts.ui.TRANSITION_FAST);
			}, this);
			return then;
		},

		/**
		 * Accept the dialog.
		 * @returns {gui.Then}
		 */
		accept: function() {
			if (!this.buttons.length || this.buttons.get('accept')) {
				return this._close(function onfadeout() {
					if (this.onaccept) {
						this.onaccept();
					}
				}, this);
			} else {
				throw new Error('This dialog cannot be accepted');
			}
		},

		/**
		 * Cancel the dialog.
		 * @returns {gui.Then}
		 */
		cancel: function() {
			if (this.buttons.get('cancel')) {
				return this._close(function onfadeout() {
					if (this.oncancel) {
						this.oncancel();
					}
				}, this);
			} else {
				throw new Error('This dialog cannot be canceled. Try dialog.accept()');
			}
		},

		// Privileged ..............................................................

		/**
		 * Determine primary button and focused button just-in-time.
		 * The {ts.ui.DialogSpirit} will call this method when it opens
		 * the dialog, but it should really be computed incrementally
		 * if and when we want to support completely custom dialogs.
		 */
		$finalize: function() {
			if (this._validatestuff()) {
				this._optimusprime(this.buttons, this.primary);
				this._focusdefault(this.buttons, this.focused);
			}
		},

		// Private .................................................................

		/**
		 * Close the dialog. Standard buttons will
		 * automatically invoke this when pressed.
		 * @returns {ts.ui.DialogModel}
		 */
		_close: function(cb, thisp) {
			var then = new gui.Then();
			ts.ui.ready(function() {
				this.isOpen = false;
				// TODO(jmo@): hook up right (in the spirit)!
				gui.Tick.time(function transitiondone() {
					if (cb) {
						cb.call(thisp);
					}
					then.now();
				}, ts.ui.TRANSITION_FAST);
			}, this);
			return then;
		},

		/**
		 * Add that button. Button will close the dialog when clicked.
		 * Note that a method name is matched to an ID string here.
		 * @param {number} index Standard buttons follow an order
		 * @param {object} json
		 * @returns {number} The resulting index of the new button
		 */
		_addButton: function(index, json) {
			var that = this;
			var maxi = this.buttons.length - 1;
			index = index > maxi ? maxi : index;
			this.buttons.splice(index, 0, GuiObject.extend(json, {
				onclick: function() {
					var action = that['on' + json.id];
					that._close().then(function onfadeout() {
						if (action) {
							action.call(that);
						}
					});
				}
			}));
			return index;
		},

		/**
		 * The `time` property is used to figure out how long the
		 * dialog is visible if there's no buttons to close it. We'll
		 * let the text length determine this. Note that this code must
		 * be revisited if we get more complex dialogs at some point,
		 * since at that point we may have multiple text models around.
		 * These models may be added after the dialog is opened and
		 * the missing buttons might also be added later :/
		 * @param {ts.ui.TextModel} model
		 * @returns {number} Time in milliseconds
		 */
		_computetime: function(model) {
			var timer = 180 * (model ? model.text : '').split(' ').length;
			return timer < 1500 ? 1500 : timer;
		},

		/**
		 * Compute the optimal primary button and make it primary.
		 * 1. The user can specify this button via the `primary` prop
		 * 2. If there's only one button, we'll just make that primary.
		 * 3. Or do nothing! It's perfectly fine, not to have a primary
		 */
		_optimusprime: function(buttons, userset) {
			var primaryType = 'ts-primary';
			if (!buttons.some(function(b) {
				return b.type === primaryType;
			})) {
				var b = buttons.get(userset);
				if (!b && buttons.length === 1) {
					b = buttons.get(0);
				}
				if (b) {
					b.type = primaryType;
				}
			}
		},

		/**
		 * Compute the optimal focused button and make it focused.
		 * 1. The user can specify this button via the `focused` prop
		 * 2. If not specified, attempt to always focus Cancel button
		 * 3. If there is none, focus the first (probably only) button
		 */
		_focusdefault: function(buttons, userset) {
			var b = buttons.get(userset || 'cancel') || buttons.get(0);
			if (b) {
				b.autofocus = true;
			}
		},

		/**
		 * Validation of stuff can in theory be performed here.
		 * @returns {boolean}
		 */
		_validatestuff: function() {
			return true;
		}

	});
}(
	ts.ui.Dialog,
	gui.Combo.chained,
	gui.Type,
	gui.Object,
	ts.ui.String,
	ts.ui.CLASS_PRIMARY,
	ts.ui.CLASS_SECONDARY,
	ts.ui.CLASS_TERTIARY
));



/**
 * Advanced pager model.
 */
ts.ui.PagerModel = (function() {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'pager',

		/**
		 * Total pages.
		 * @type {number}
		 */
		pages: -1,

		/**
		 * Current page (zero-based).
		 * TODO: rename `index`!!!!!!
		 * @type {number}
		 */
		page: 0,

		/**
		 * Max amount of buttons to show.
		 * @type {number}
		 */
		max: 5,

		/**
		 * Index of first button to show.
		 * @type {number}
		 */
		init: 0,

		/**
		 * For when used in a flexible scenario (toolbars).
		 * @type {number}
		 */
		flex: 1,

		/**
		 * Open for implementation. Called when the `page` property changes.
		 * @param {number} index
		 * @type {function}
		 */
		onselect: null,

		/**
		 * Observe myself.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.addObserver(this);
		},

		/**
		 * Unobserve myself.
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
		},

		/**
		 * Goto first.
		 */
		first: function() {
			this.page = 0;
			this.init = 0;
		},

		/**
		 * Goto last.
		 */
		last: function() {
			this.page = this.pages - 1;
			this.init = this.pages - this.max;
		},

		/**
		 * Goto next.
		 */
		next: function() {
			this.page ++;
			this._initup();
		},

		/**
		 * Goto previous.
		 */
		prev: function() {
			this.page --;
			this._initdown();
		},

		/**
		 * Handle changes (to myself).
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			if (this.onselect) {
				changes.forEach(function(c) {
					if (c.name === 'page') {
						this.onselect(c.newValue);
						if (c.newValue > c.oldValue) {
							this._initup();
						} else {
							this._initdown();
						}
					}
				}, this);
			}
		},

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.pager.edbml(this);
		},

		// Private .................................................................

		_initup: function() {
			var max = this.max;
			var page = this.page;
			var pages = this.pages;
			while (page >= this.init + max && this.init <= pages - max) {
				this.init ++;
			}
		},

		_initdown: function() {
			var page = this.page;
			while (page < this.init && this.init > 0) {
				this.init --;
			}
		}

	});
}());



/**
 * Note model.
 * @extends {ts.ui.Model}
 * @using {ts.ui.Note} Note
 */
ts.ui.NoteModel = (function using() {
	return ts.ui.Model.extend({
		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'note',

		/**
		 * This is really just a CSS classname.
		 * @type {string}
		 */
		type: '',

		/**
		 * Note icon.
		 * @type {string}
		 */
		icon: '',

		/**
		 * Primary text
		 * @type {string}
		 */
		text: '',

		/**
		 * When toggled `false`, the Note will be closed and disposed.
		 */
		open: true,

		/**
		 * Open for implementation: What to do when closing the Note.
		 * @type {Function}
		 */
		onclose: null,

		/**
		 * TODO: Implement callback for links clicked in the Note!!!
		 * Open for implementation: Callback for when a link is clicked.
		 * @type {Function}
		 */
		onlink: null,

		/**
		 * Close the note.
		 * @returns {ts.ui.NoteModel}
		 */
		close: function() {
			this.open = false;
			return this;
		},

		/**
		 * button in the note.
		 * @type {ts.ui.ButtonCollection<ts.ui.ButtonModel>}
		 */
		buttons: ts.ui.ButtonCollection,

		// Privileged ..............................................................

		/**
		 * Is it the note in the top?
		 * @type {boolean}
		 */
		$isTopNote: false

	});
}());



/**
 * Advanced icon model.
 */
ts.ui.IconModel = (function() {
	return ts.ui.Model.extend({

		/**
		 * The classname of the rendered `<i>` element.
		 * @type {string}
		 */
		type: null,

		/**
		 * Icon color.
		 * @type {string}
		 */
		color: 'dark',

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.icononly.edbml(this);
		}

	});
}());



/**
 * Advanced image model.
 */
ts.ui.ImageModel = (function() {
	var BLANK = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAQAAAAngNWGAAAAFElEQVR42mNkIBIwjiocVTiqEAQAJNYAFd868w4AAAAASUVORK5CYII=';
	return ts.ui.Model.extend({

		/**
		 * The image URL.
		 * @type {string}
		 */
		src: BLANK,

		/**
		 * Optional ALT text.
		 * @type {string}
		 */
		alt: '',

		/**
		 * The image width.
		 * @type {number}
		 */
		width: 0,

		/**
		 * The image height.
		 * @type {number}
		 */
		height: 0,

		/**
		 * Render as `background-image` for enhanced image processing via CSS?
		 * @type {boolean}
		 */
		background: false,

		/**
		 * Confirm dimensions. We'll render all images with a fixed size
		 * so that the page doesn't jump around when the images are loaded.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			if (!this.width || !this.height) {
				throw new Error('Image must have both width and height');
			}
		},

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.image.edbml(this);
		}

	}, { // Static ...............................................................

		/**
		 * For anyone else who might like a 20x20 blank PNG.
		 * @type {string}
		 */
		BLANK: BLANK

	});
}());



/**
 * Core API module.
 */
gui.module('core-api@tradeshift.com');



/**
 * Autocomplete API
 * @returns {ts.ui.AutocompleteDropdownModel}
 * @constructor
 */
ts.ui.Autocomplete = function() {
	return new ts.ui.AutocompleteDropdownModel();
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.Autocomplete.toString = function() {
	return '[function ts.ui.Autocomplete]';
};

/**
 * Ad-hoc localization interface. Omit the
 * argument to get the current localization.
 * @param @optional {Object} config
 * @returns {Object}
 */
ts.ui.Autocomplete.localize = function(config) {};

// Implementation ..............................................................

(function Autocomplete() {
	var locale = null;

	gui.Object.extend(ts.ui.Autocomplete, {

		/**
		 * Localize.
		 * @param {object} newlocale
		 */
		localize: function(newlocale) {
			if (arguments.length) {
				if (!locale || Object.keys(locale).every(function(key) {
					var has = newlocale.hasOwnProperty(key);
					if (!has) {
						console.error('Missing translations for ' + key);
					}
					return has;
				})) {
					locale = newlocale;
				}
			} else {
				return locale;
			}
		}
	});
}());

/**
 * Default-localize the Autocomplete.
 */
ts.ui.Autocomplete.localize({
	/**
	 * String for number of matches found
	 * @param {number} count
	 * @returns {string}
	 */
	matchString: function(count) {
		if (!count) {
			return '';
		} else if (count === 1) {
			return '1 match';
		} else {
			return count + ' matches';
		}
	}
});



/**
 * @param {object|ts.ui.FormModel} json
 * @return {ts.ui.FormModel}
 */
ts.ui.Form = function(json) {
	return ts.ui.FormModel.from(json);
};



/**
 * We can't rely on native HTML5 validation in our browsers;
 * and also, we need model-only (DOM-free) validation support.
 * So we'll do it the hard way. When all the browsers have good
 * support, strategy here would be to createElement('input') with
 * specified attributes and perform `checkValidity` on that element.
 */
ts.ui.ValidityChecker = gui.Class.create(Object.prototype, {

	/**
	 * Check element validity and update validation state.
	 * TODO: Release the regexpert!
	 * @param {HTMLInputElement|ts.ui.InputModel} element
	 * @param {ts.ui.ValidityStateModel} state
	 * @returns {boolean}
	 */
	checkValidity: function(input, state) {
		state.valid = true;
		if (input.required) {
			if (input.value === '') {
				state.valid = false;
				state.valueMissing = true;
			}
		}
		switch (input.type) {
			case 'number':
				if (isNaN(input.value)) {
					state.valid = false;
					state.badInput = true;
				}
				break;
			case 'email':

				break;
			case 'url':

				break;
		}
		return state.valid;
	}

}, { // Static .................................................................

	/**
	 * @type {RegExp}
	 */
	EMAIL: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,6}$./

});



/**
 * Validity state model.
 * @extends {edb.Object}
 */
ts.ui.ValidityStateModel = edb.Object.extend({

	// Matching HTML specification: Do not rename (see custom stuff below) .......

	/**
	 * The element meets all constraint validations
	 * and is therefore considered to be valid.
	 * @type {boolean}
	 */
	valid: true,

	/**
	 * The element's custom validity message has been set to a non-empty
	 * string by calling the element's `setCustomValidity()` method.
	 * @type {boolean}
	 */
	customError: false,

	/**
	 * The value does not match the specified pattern.
	 * @type {boolean}
	 */
	patternMismatch: false,

	/**
	 * The value is greater than the maximum specified by the max attribute.
	 * @type {boolean}
	 */
	rangeOverflow: false,

	/**
	 * The value is less than the minimum specified by the min attribute.
	 */
	rangeUnderflow:	false,

	/**
	 * The value does not fit the rules determined by the step attribute
	 * (that is, it's not evenly divisible by the step value).
	 */
	stepMismatch:	false,

	/**
	 * The value exceeds the specified maxlength. Some browsers block
	 * input at `maxlength`, preventing this. Maybe we should do the same.
	 * @type {boolean}
	 */
	tooLong: false,

	/**
	 * The value is not in the required syntax (when type is email or url).
	 * @type {boolean}
	 */
	typeMismatch: false,

	/**
	 * That's just plain wrong.
	 * @type {boolean}
	 */
	badInput: false,

	/**
	 * The element has a required attribute, but no value.
	 * @type {boolean}
	 */
	valueMissing: false

	// Tradeshift custom stuff ...................................................

	/*
	 * Custom stuff goes here....
	 */

});



/**
 * Advanced select model.
 * @extends {ts.ui.Model}
 */
ts.ui.SelectModel = ts.ui.Model.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'select',

	/**
	 * @type {function}
	 * @param {string} value
	 */
	onchange: null,

	/**
	 * Select option value OR by numeric index.
	 * @param {string|number} what
	 * @return {ts.ui.SelectModel}
	 */
	select: function(what) {
		switch (gui.Type.of(what)) {
			case 'number' :
				this.options.selectedIndex = what;
				break;
			default :
				console.error('TODO: select option by value');
				break;
		}
		return this;
	},

	/**
	 * Bounce model to HTML.
	 * @return {string}
	 */
	render: function() {
		return ts.ui.select.edbml(this);
	},

	/**
	 * Options collection.
	 * @type {ts.ui.Collection}
	 */
	options: ts.ui.Collection({
		item: 'options',
		selectedIndex: -1,
		$of: ts.ui.Model({
			item: 'option',
			label: null,
			value: null
		})
	})

});



/**
 * Advanced input model.
 * @using {gui.Client} Client
 * @using {gui.Combo#chained} chained
 */
ts.ui.InputModel = (function using(Client, chained) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'input',

		/**
		 * Input type matches text|email|search|url|number|password etc.
		 * @type {string}
		 */
		type: 'text',

		/**
		 * Input name.
		 * @type {string}
		 */
		name: '',

		/**
		 * Input value.
		 * @type {string}
		 */
		value: '',

		/**
		 * Input label.
		 * @type {string}
		 */
		label: '',

		/**
		 * Input placeholder.
		 * @type {string}
		 */
		placeholder: '',

		/**
		 * Icon to use, overriding the default (date, select, disabled, etc.)
		 * @type {String}
		 */
		icon: '',

		/**
		 * Is idle? Used for xframe synchronization.
		 * @type {boolean}
		 */
		idle: false,

		/**
		 * Pressed ENTER? Used for xframe synchronization.
		 * @type {boolean}
		 */
		enterkey: false,

		/**
		 * Time before user is considered idle.
		 * @type {number} Timeout in milliseconds
		 */
		idletime: (Client.isTouchDevice ? 750 : 500),

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onidle: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onenterkey: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onfocus: null,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onblur: null,

		/**
		 * Required?
		 * @type {boolean}
		 */
		required: false,

		/**
		 * Read only?
		 * @type {boolean}
		 */
		readonly: false,

		/**
		 * Disabled?
		 * @type {boolean}
		 */
		disabled: false,

		/**
		 * Input has focus?
		 * @type {boolean}
		 */
		focused: false,

		/**
		 * Attempt to focus this field?
		 * TODO(jmo@: Actually support this
		 * @type {boolean}
		 */
		autofocus: false,

		/**
		 * A localized message that describes the validation constraints
		 * that the control does not satisfy (if any).
		 * @type {string}
		 */
		validationMessage: {
			getter: function() {
				return this._validationMessage;
			}
		},

		/**
		 * Tracking input validity state.
		 * @type {ts.ui.ValidityStateModel}
		 */
		validity: ts.ui.ValidityStateModel,

		/**
		 * Observe myself on startup.
		 * @return {[type]} [description]
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.validity = {};
			this.addObserver(this);
		},

		/**
		 * Stop observing myself on shutdown.
		 * TODO (jmo@): Destruct is not really implemented (memory implications)
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
			this._checker = null;
		},

		/**
		 * This stuff is sort of disabled for now. Maybe we'll bring it back.
		 * @returns {boolean}
		 */
		checkValidity: function() {
			this._checker = this._checker || new ts.ui.ValidityChecker();
			return this._checker.checkValidity(this, this.validity);
		},

		/**
		 * Invalidates the field and shows a custom error message.
		 * Use empty string to mark field valid and remove message.
		 * @param {string} error
		 */
		setCustomValidity: function(error) {
			this.validity.customError = !!error;
			this.validity.valid = !error;
			this._validationMessage = error || '';
		},

		/**
		 * Handle changes.
		 * @param {Array<gui.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				this._onpropertychange(c.name, c.newValue);
			}, this);
		},

		/**
		 * Focus the field.
		 */
		focus: function() {
			this.focused = true;
		},

		/**
		 * Blur the field.
		 */
		blur: function() {
			this.focused = false;
		},

		/**
		 * Clear that value.
		 */
		clear: function() {
			this.value = '';
		},

		/**
		 * Bounce model to HTML.
		 * @return {string}
		 */
		render: function() {
			return ts.ui.input.edbml(this);
		},

		// Private .................................................................

		/**
		 * Validity checker (not used now).
		 * @type {ts.ui.ValidityChecker}
		 */
		_checker: null,

		/**
		 * Snapshot the value so that we never fire the
		 * `onidle` callback twice for the same value.
		 * @type {string}
		 */
		_snapshot: null,

		/**
		 * Property was changed (note that this model is observing itself
		 * because of all this xframe synchronization stuff going on).
		 * @param {string} name
		 * @param {string|boolean} value
		 */
		_onpropertychange: function(name, value) {
			var isTrue = (value === true);
			switch (name) {
				case 'idle':
					if (isTrue) {
						this.idle = false;
						if ((value = this.value) !== this._snapshot) {
							this._maybeinvoke(this.onidle, value);
							this._snapshot = value;
						}
					}
					break;
				case 'enterkey':
					if (isTrue) {
						this.enterkey = false;
						this._maybeinvoke(this.onenterkey, this.value);
					}
					break;
				case 'focused':
					if (isTrue) {
						this._maybeinvoke(this.onfocus);
					} else {
						this._maybeinvoke(this.onblur);
					}
					break;
				case 'value':
					this.checkValidity();
					break;
			}
		}

	});
}(gui.Client, gui.Combo.chained));



/**
 * Advanced textarea model.
 * @extends {ts.ui.InputModel}
 */
ts.ui.TextAreaModel = (function() {
	return ts.ui.InputModel.extend({

		/**
		 * Friendly name.
		 */
		item: 'textarea',

		/**
		 * When false, ENTER will make the textarea grow (to a certain limit).
		 * When true, only SHIFT+ENTER will do that (chat comment style) and
		 * the ENTER key can be freed up to other purposes (eg. submit comment).
		 * @type {boolean}
		 */
		entershift: false,

		/**
		 * Rows default to three.
		 * @type {number}
		 */
		rows: 3

	});
}());



/**
 * Advanced search model (as used in the ToolBar component).
 * @extends {ts.ui.InputModel}
 */
ts.ui.SearchModel = ts.ui.InputModel.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'search',

	/**
	 * Input type.
	 * @type {string}
	 */
	type: 'search',

	/**
	 * Placeholder and title (tooltip) string.
	 * TODO: Rename this to info (to conform with ButtonModel)
	 * @type {string}
	 */
	info: null,

	/**
	 * Render as "inset" (via classname `ts-inset`)?
	 * @type {boolean}
	 */
	inset: false,

	/**
	 * Open for implementation: Function to call when user presses ENTER.
	 * NOTE: This is coded in a way that doesn't work xframe (greenfield).
	 * @type {function}
	 * @param {string} value
	 */
	onsearch: null,

	/**
	 * Stretch to fill the space? Support
	 * for this depends on the use case.
	 * @type {number} (treated as truthy for now)
	 */
	flex: 0,

	/**
	 * @deprecated
	 * @type {string}
	 */
	tip: {
		getter: function() {
			return this.info;
		},
		setter: function(value) {
			this.info = value;
			console.warn(
				'SearchModel.tip: Deprecated API is deprecated. Please use `info`'
			);
		}
	},

	/**
	 * Clear value and invoke appropriate callback.
	 */
	clear: function() {
		ts.ui.InputModel.prototype.clear.call(this);
		this._bestcallback(this.value);
	},

	/**
	 * Invoke appropriate callback on ENTER.
	 * @param {string} value
	 */
	onenterkey: function() {
		this._bestcallback(this.value);
	},

	/**
	 * Bounce model to HTML.
	 * @param @optional {boolean} toolbar (temp cornercase!)
	 * @overrides {ts.ui.InputModel#render}
	 * @returns {string}
	 */
	render: function(toolbar) {
		return ts.ui.search.edbml(this);
	},

	// Private ...................................................................

	/**
	 * Call `onsearch` if defined, otherwise call `onidle` (if defined).
	 * @param {string} value
	 */
	_bestcallback: function(value) {
		if (!this._maybeinvoke(this.onsearch, value)) {
			this._maybeinvoke(this.onidle, value);
		}
	}

});



/**
 * Advanced collection of form items.
 * @extends {ts.ui.Collection}
 */
ts.ui.FormItemCollection = ts.ui.Collection.extend({

	/**
	 * Friendly name.
	 * @type {string}
	 */
	item: 'formitems'

}, { // Static .................................................................

	/**
	 * Allowed content models.
	 * @see {ts.ui.Collection.#$of}
	 * @see {ts.ui.Model#item}
	 * @type {Map<string,constructor>}
	 */
	allow: ['text', 'input', 'textarea', 'select']

});



/**
 * Advanced form model.
 * @extends {ts.ui.Model}
 */
ts.ui.FormModel = (function using(chained) {
	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'form',

		/**
		 * Form items constructor.
		 * @type {ts.ui.Collection<ts.ui.Model>}
		 */
		items: ts.ui.FormItemCollection,

		/**
		 * Form buttons collection. Buttons will appear below the form.
		 * They get scaled to full form width to cope with translation.
		 * TODO(jmo@): Render this via ButtonGroup once we actually need it!
		 * @type {ts.ui.ButtonCollection<ts.ui.ButtonModel>}
		 */
		buttons: ts.ui.ButtonCollection,

		/**
		 * [onsubmit description]
		 * @type {[type]}
		 */
		onsubmit: null,

		/**
		 * Observer myself.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.items = this.items || [];
			this.buttons = this.buttons || [];
			this.addObserver(this);
		},

		/**
		 * TODO (jmo@): Destruct is not really implemented (memory implications)
		 */
		ondestruct: function() {
			ts.ui.Model.prototype.ondestruct.call(this);
			this.removeObserver(this);
		},

		/**
		 * Handle changes.
		 * @param {Array<gui.Change>} changes
		 */
		onchange: function(changes) {
			changes.forEach(function(c) {
				if (c.name === 'submitted' && c.newValue) {
					this.submitted = false;
					if (this.onsubmit) {
						this.onsubmit();
					}
				}
			}, this);
		},

		/**
		 * Trigger `onsubmit`.
		 * TODO (jmo@): validation!
		 * @return {ts.ui.FormModel}
		 */
		submit: chained(function() {
			this.submitted = true;
		}),

		/**
		 * Bounce model to HTML.
		 * @return {string}
		 */
		render: function() {
			return ts.ui.form.edbml(this);
		},

		/**
		 * Adds the Submit button which will submit all the things.
		 * @param {string=} opt_label
		 * @param {string=} opt_icon
		 * @return {ts.ui.DialogModel}
		 */
		submitButton: chained(function(opt_label, opt_icon) {
			this._button(
				opt_label || ts.ui.String.LABEL_SUBMIT,
				opt_icon || 'ts-icon-proceed',
				this.submit
			);
		}),

		// Private ...................................................................

		/**
		 * Add that button.
		 * @param {string} label
		 * @param {string} icon
		 * @param {function} action
		 */
		_button: function(label, icon, action) {
			var that = this;
			this.buttons.push({
				label: label,
				icon: icon,
				onclick: function() {
					if (action) {
						action.call(that);
					}
				}
			});
		}

	});
}(gui.Combo.chained));



/**
 * Advanced switch model.
 * @extends {ts.ui.InputModel}
 */
ts.ui.SwitchModel = (function() {
	/**
	 * TODO: Create an `OptionModel` to extend from!
	 */
	return ts.ui.InputModel.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'switch',

		/**
		 * Data associated to the switch (Table scenario).
		 */
		data: null,

		/**
		 * Is checked?
		 * @type {boolean}
		 */
		checked: false,

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.switch.edbml(this);
		}
	});
}());



/**
 * Autocomplete Dropdown Model
 */
ts.ui.AutocompleteDropdownModel = (function using() {
	return ts.ui.Model.extend({
		/**
		 * Friendly name
		 */
		item: 'autocompletedropdown',

		/**
		 * List of all possible items
		 * @type {Array.<{key: String, value: String}>}
		 */
		autocompleteList: null,

		/**
		 * Filter string in the input
		 * @type {String}
		 */
		filter: '',

		/**
		 * List of items shown currently.
		 * TODO: Is this used and/or updated?
		 * @type {Array.<{key: String, value: String}>}
		 */
		filteredAutocompleteList: null,

		/**
		 * Initialize.
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.autocompleteList = [];
			this.filteredAutocompleteList = [];
		},

		/**
		 * Filter the list based on the filter string
		 * @param {String} filter
		 * @returns {Array.<{key: String, value: String}>} filtered list of items
		 */
		onfilter: function(filter) {
			var filteredAutocompleteList = [];
			if (this.autocompleteList) {
				var idx = -1;
				var length = this.autocompleteList.length;
				while (++idx < length) {
					var item = this.autocompleteList[idx];
					if (item.value.indexOf(filter) !== -1) {
						filteredAutocompleteList.push(item);
					}
				}
			}
			return filteredAutocompleteList;
		},

		/**
		 * On selecting an item, the value will be put into the original input field
		 * @param {{key: String, value: String}} item
		 * @returns {String} value to put in the input field
		 */
		onselect: function(item) {
			return item.value;
		}
	});
})();



/**
 * TODO: Perhaps `connectionTypes` should be
 * moved from {ts.ui.CompanyCard} to here!!!
 */
ts.ui.Card = {

	/**
	 * Default rendering (cardlike).
	 * @type {string}
	 */
	TYPE_DEFAULT: 'ts-default',

	/**
	 * Details rendering (in Aside).
	 * @type {string}
	 */
	TYPE_DETAILS: 'ts-details',

	/**
	 * Compact rendering.
	 * @type {string}
	 */
	TYPE_COMPACT: 'ts-compact',

	/**
	 * Inline rendering (just the name).
	 * @type {string}
	 */
	TYPE_INLINE: 'ts-inline'

};



/**
 * API.
 */
ts.ui.CompanyCard = {

	/**
	 * @param {object|array} arg
	 */
	render: function(arg) {},

	/**
	 * Get card by GUID.
	 * @param {string} id
	 */
	get: function(id) {},

	/**
	 * Connection types (array index matches the number in JSON).
	 * @type {Array<Array<string, string>>}
	 */
	connectionTypes: [
		['Your company', 'ts-icon-network'],
		['Request sent', 'ts-icon-network'],
		['Connected', 'ts-icon-network'],
		['Registration in progress', 'ts-icon-network'],
		['In your Google Contacts', 'ts-icon-network'],
		['Via email only', 'ts-icon-network']
	],

	/**
	 * Industry types.
	 * @type {Array<string>}
	 */
	industryTypes: [
		'Airline',
		'Corporation',
		'Educational Organization',
		'Government Organization',
		'Local Business',
		'NGO',
		'Software & IT',
		'Performing Group',
		'Sports Team'
	],

	/**
	 * Company sizes.
	 * @type {Array<string>}
	 */
	companySizes: [
		'1',
		'110',
		'1100',
		'100249',
		'250-500',
		'500-1000'
	]

};

// Implementation ..............................................................

/**
 * @using {gui.Array}
 * @using {gui.Object}
 */
(function using(GuiArray, GuiObject) {
	var collection = null;

	GuiObject.extend(ts.ui.CompanyCard, {

		/**
		 * Render cards for argument.
		 * @param {object|array} arg
		 */
		render: function(arg) {
			var objects;
			if (arguments.length) {
				objects = GuiArray.make(arg);
				if (collection) {
					objects.forEach(function(o) {
						collection.push(o);
					});
				} else {
					collection = new ts.ui.CompanyCardCollection(objects);
					collection.output();
				}
			} else {
				// return collection?
			}
		},

		/**
		 * Get card by GUID.
		 * @param {string} guid
		 */
		get: function(id) {
			return collection ? collection.get(id) : null;
		}

	});
}(gui.Array, gui.Object));



/**
 * UserCard API.
 * @param {object|ts.ui.UserCardModel} json
 * @returns {ts.ui.UserCardModel}
 */
ts.ui.UserCard = function(json) {
	var model = ts.ui.UserCardModel.from(json);
	model.addObserver(ts.ui.UserCard);
	return model;
};

/**
 * Identification.
 * @return {string}
 */
ts.ui.UserCard.toString = function() {
	return '[function ts.ui.UserCard]';
};

/**
 * Ad-hoc localization interface. Omit the
 * argument to get the current localization.
 * TODO: Greenfield this (add xframe support).
 * @param @optional {object|string} config
 * @returns {object}
 */
ts.ui.UserCard.localize = function(config) {};

// Implementation ..............................................................

/**
 * @using {ts.ui.Greenfield#api} api
 * @using {gui.Object#hidden} hidden
 * @using {gui.Combo#chained} chained
 */
(function UserCard(api, hidden, chained) {
	var locale = null;

	/**
	 * GUI extras.
	 */
	gui.Object.extend(ts.ui.UserCard, {

		/**
		 * Handle (model) changes.
		 * TODO(jmo@): move this handler out of {ts.ui.Dialog} methods
		 * @param {Array<gui.Change>} changes
		 */
		onchange: hidden(function(changes) {
			var that = this;
			changes.forEach(function(c) {
				var model = c.object;
				switch (c.name) {
					case 'isOpen':
						var clone = ts.ui.UserCardModel.from(model);
						clone.type = 'ts-details';
						ts.ui.Aside({
							title: that.localize('userDetails'),
							items: [
								clone
							],
							onclosed: function() {
								this.dispose();
							}
						}).open();
						break;
				}
			});
		}),

		/**
		 * TODO: This is copy-pasted from some other API, refactor for common
		 * inheritance chain (and supress "privacy" concerns for simpler code).
		 */
		localize: api(chained(function(arg) {
			if (arguments.length) {
				switch (gui.Type.of(arg)) {
					case 'object':
						var newlocale = arg;
						if (!locale || Object.keys(locale).every(function(key) {
							var has = newlocale.hasOwnProperty(key);
							if (!has) {
								console.error('Missing translations for ' + key);
							}
							return has;
						})) {
							locale = newlocale;
						}
						break;
					case 'string':
						var key = arg;
						if (locale && locale.hasOwnProperty(key)) {
							return locale[key];
						} else {
							console.error('Missing translations for ' + key);
						}
						break;
				}
			} else {
				return locale;
			}
		}))

	});
}(ts.ui.Greenfield.api, gui.Object.hidden, gui.Combo.chained));

/**
 * Default-localize the UserCard.
 */
ts.ui.UserCard.localize({

	currentUserDisplayName: 'You',
	userDetails: 'User Details'

});



/**
 * Advanced object model.
 * @see {ts.ui.CompanyCardModel}
 * @extends {ts.ui.Model}
 * @using {gui.Arguments#confirmed} confirmed
 */
ts.ui.ObjectModel = (function using(confirmed) {
	return ts.ui.Model.extend({

		/**
		 * Typically a GUID from the database.
		 * @type {string}
		 */
		id: null,

		/**
		 * Friendly name.
		 * @type {String}
		 */
		item: 'object',

		/**
		 * True if the model is used as mockup for a "preloader" type of rendering.
		 * @type {boolean}
		 */
		mock: false,

		/**
		 * The `data` is declared as a simple object in case we need to embed UBL
		 * documents and what not. This means that changes to the date will not
		 * automatically trigger EDBML renderings (the data cannot be observed).
		 * @type {JSONObject}
		 */
		data: Object,

		/**
		 * Bounce model to HTML.
		 * @param @optional {boolean} contentonly Omit the root <div ts-companycard><div> ?
		 * @param @optional {string} classconfig The spirits classname may serve as config
		 * @returns {string}
		 */
		render: confirmed('(boolean)', '(string)')(
			function(contentonly, classconfig) {
				return this._edbml()(
					this, contentonly || false, classconfig || 'ts-default'
				);
			}
		),

		/**
		 * We should probably insist on the ID.
		 * @param {object} json
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			if (!this.id) {
				throw new Error(this + ' requires a unique id');
			}
		},

		// Private .................................................................

		/**
		 * Get EDBML function for this object.
		 * Note: Subclass must implement this.
		 * @returns {function}
		 */
		_edbml: function() {
			console.error(this + ' needs an EDBML function');
		}

	});
}(gui.Arguments.confirmed));



/**
 * Advanced object collection.
 * @see {ts.ui.CompanyCardCollection}
 * @extends {ts.ui.Collection}
 */
ts.ui.ObjectCollection = ts.ui.Collection.extend({

	/**
	 * Content model.
	 * @type {constructor}
	 */
	$of: ts.ui.ObjectModel

});



/**
 * Advanced card model.
 * @see {ts.ui.CompanyCardModel}
 * @see {ts.ui.UserCardModel}
 */
ts.ui.CardModel = (function() {
	return ts.ui.ObjectModel.extend({

		/**
		 * When creating cards via JSON API, this will work like the rendered
		 * spirits classname. When creating cards in HTML, just use classname!
		 * @type {string}
		 */
		type: null

	});
}());



/**
 * Advanced company card model.
 * @extends {ts.ui.CardModel}
 * @using {gui.Type} type
 * @using {ts.ui.CompanyCard} Card
 */
ts.ui.CompanyCardModel = (function using(Type, Card) {
	/**
	 * Confirm lookup in (user configurable) array.
	 * @type {number} type
	 * @param {object|string} result
	 */
	function confirm(index, result) {
		if (!Type.isDefined(result)) {
			throw new RangeError(index + ' out of reach');
		}
		return result;
	}

	/**
	 * Lookup connection type.
	 * @param {number} index
	 * @returns {string}
	 */
	function connections(index) {
		return Card.connectionTypes[index];
	}

	/**
	 * Lookup industry.
	 * @param {number} index
	 * @returns {string}
	 */
	function industries(index) {
		return Card.industryTypes[index];
	}

	/**
	 * Lookup company size.
	 * @param {number} index
	 * @returns {string}
	 */
	function sizes(index) {
		return Card.companySizes[index];
	}

	return ts.ui.CardModel.extend({

		/**
		 * Friendly name.
		 */
		item: 'companycard',

		/**
		 * {
		 *	name: null,
		 *	logo: null,
		 *	location: null,
		 *	industry: null,
		 *	size: null,
		 *	connection: null,
		 * }
		 */
		data: Object,

		// Privileged ..............................................................

		/**
		 * Compute text and icon for connection status based on given number.
		 * @see {ts.ui.companycard.edbml}
		 * @returns {object}
		 */
		$computeConnection: function() {
			var type, index = this.data.connection;
			if (Type.isDefined(index)) {
				if (Type.isNumber(index)) {
					if ((type = connections(index)) && confirm(index, type)) {
						return {
							text: type[0],
							icon: type[1]
						};
					}
				} else {
					throw new TypeError('The connectionType *must* be a number');
				}
			}
			return null;
		},

		/**
		 * Compute the industry string (based on
		 * hardcoded string or index for lookup).
		 * @see {ts.ui.companycard.edbml}
		 * @returns {string}
		 */
		$computeIndustry: function() {
			var type = this.data.industry;
			switch (Type.of(type)) {
				case 'string':
					return type;
				case 'number':
					return confirm(type, industries(type));
			}
		},

		/**
		 * Compute the company size (based on
		 * hardcoded string or index for lookup).
		 * @see {ts.ui.companycard.edbml}
		 * @returns {string}
		 */
		$computeSize: function() {
			var type = this.data.size;
			switch (Type.of(type)) {
				case 'string':
					return type;
				case 'number':
					return confirm(type, sizes(type));
			}
		},

		// Private .................................................................

		/**
		 * Get EDBML function for this card.
		 * @see {ts.ui.ObjectModel#_edbml}
		 * @returns {function}
		 */
		_edbml: function() {
			return ts.ui.companycard.edbml;
		}

	});
}(gui.Type, ts.ui.CompanyCard));



/**
 * Advanced collection of company cards.
 * @extends {ts.ui.ObjectCollection}
 */
ts.ui.CompanyCardCollection = ts.ui.ObjectCollection.extend({

	$of: ts.ui.CompanyCardModel

});



/**
 * Advanced user image model.
 */
ts.ui.UserImageModel = ts.ui.Model.extend({

	/**
	 * The user name. If no image exists, an
	 * image will be autogenerated based on this.
	 * @type {string}
	 */
	name: '',

	/**
	 * User photo or avatar.
	 * @type {string}
	 */
	src: '',

	/**
	 * Image dimension. Zero implies default (44px).
	 * @type {number}
	 */
	size: 0,

	/**
	 * Bounce model to HTML.
	 * @returns {string}
	 */
	render: function() {
		return ts.ui.userimage.edbml(this);
	}
});



/**
 * Advanced usercard model.
 * @extends {ts.ui.CardModel}
 * @using {ts.ui.Card}
 * @using {ts.ui.CardModel}
 */
ts.ui.UserCardModel = (function using(Card, CardModel) {
	return CardModel.extend({

		/**
		 * the type of the user component.
		 * the value of the type: ts-default, ts-inline, ts-details
		 * TODO: This is "presentation data", should be deprecated!
		 * @type {string}
		 */
		type: ts.ui.Card.TYPE_DEFAULT,

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'user',

		/**
		 * {
		 *	title: null,
		 *	role: null,
		 *	company: null,
		 *	companyUrl: null,
		 *	image: null,
		 *	name: null,
		 *	email: null,
		 * }
		 */
		data: Object,

		/**
		 * Card is detailed in Aside?
		 * @type {boolean}
		 */
		isOpen: false,

		/**
		 * Show details in Aside.
		 * @returns {ts.ui.CardModel}
		 */
		open: function() {
			this.isOpen = true;
			return this;
		},

		// Private .................................................................

		/**
		 * Get EDBML function for this card.
		 * @returns {function}
		 */
		_edbml: function() {
			return ts.ui.usercard.edbml;
		}

	});
}(ts.ui.Card, ts.ui.CardModel));



/**
 * Advanced collection of users.
 * @extends {ts.ui.ObjectCollection}
 */
ts.ui.UserCardCollection = ts.ui.ObjectCollection.extend({

	/**
	 * Content model.
	 * @type {constructor}
	 */
	$of: ts.ui.UserCardModel

});



/**
 * Objects GUI module.
 */
gui.module('objects-api@tradeshift.com');



/**
 * Superclass for toolbars and topbars, who for
 * complicated reasons cannot extend each other.
 * @extends {ts.ui.Model}
 * @using {ts.ui.ButtonCollection} ButtonCollection
 */
ts.ui.BarModel = (function using(ButtonCollection) {
	return ts.ui.Model.extend({

		// Privileged ................................................................

		/**
		 * List buttons ascending: In they order they were added, but
		 * grouped into primary, sencondary and tertiary button types.
		 * @returns	 {Array<ts.ui.ButtonModel|ts.ui.ButtonCollection>}
		 */
		$allbuttons: function() {
			return this.buttons.ascending().filter(function(thing) {
				if (ButtonCollection.is(thing)) {
					return thing.every(function(button) {
						return button.visible;
					});
				} else {
					return thing.visible;
				}
			});
		},

		/**
		 * Get primary and secondary buttons (ascending).
		 * @returns {Array<ts.ui.ButtonModel>}
		 */
		$specialbuttons: function() {
			return this._sortbuttons(this.$allbuttons(), true);
		},

		/**
		 * Get tertiary buttons (ascending).
		 * @returns {Array<ts.ui.ButtonModel>}
		 */
		$normalbuttons: function() {
			return this._sortbuttons(this.$allbuttons(), false);
		},

		// Private .................................................................

		/**
		 * Sort buttons for distribution into ASIDE.
		 * This methods gets invoked by the EDBML.
		 * @see ts.ui.TopBarSpirit.edbml
		 * @param {boolean} special
		 * @returns {Array<ts.ui.ButtonModel>}
		 */
		_sortbuttons: function(buttons, special) {
			return buttons.filter(function(thing) {
				var button = thing;
				if (ButtonCollection.is(thing)) {
					button = thing[0];
				}
				if (button.type === ts.ui.CLASS_TERTIARY) {
					if (!special) {
						return true;
					}
				} else {
					return special;
				}
			});
		}

	});
}(ts.ui.ButtonCollection));



/**
 * Advanced toolbar model.
 * @extends {ts.ui.BarModel}
 */
ts.ui.ToolBarModel = (function using(chained) {
	return ts.ui.BarModel.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'toolbar',

		/**
		 * Has tabs or buttons or anything at all really?
		 * @type {boolean}
		 */
		hascontent: false,

		/**
		 * Has now or has ever had tabs or buttons and stuf?
		 * @type {boolean}
		 */
		hadcontent: false,

		/**
		 * Base background color (which also affects tabs and button color).
		 * @type {string}
		 */
		color: ts.ui.CLASS_BG_LITE,

		/**
		 * Toolbar title (or statusbar message).
		 * @type {string}
		 */
		title: null,

		/**
		 * Toolbar search model.
		 * @type {ts.ui.InputModel}
		 */
		search: null,

		/**
		 * Attempt to economize space by automatically transferring
		 * any assigned buttons (especially tertiary) into an Aside?
		 * @type {boolean}
		 */
		compact: true,

		/**
		 * Tabs.
		 * @type {ts.ui.TabCollection}
		 */
		tabs: ts.ui.TabCollection,

		/**
		 * Toolbar button collection.
		 * @type {ts.ui.ButtonCollection<ts.ui.ButtonModel>}
		 */
		buttons: ts.ui.ButtonCollection,

		/**
		 * Reserved for the closing "X" in Aside headers and so forth.
		 * @type {ts.ui.ButtonModel}
		 */
		closebutton: ts.ui.ButtonModel,

		/**
		 * Newup defaults.
		 */
		onconstruct: function() {
			ts.ui.BarModel.prototype.onconstruct.call(this);
			this.buttons = this.buttons || [];
			this.tabs = this.tabs || [];
			this._watchmodels(true);
			this._updatehascontent();
		},

		/**
		 * Don't observe tabs and buttons.
		 * TODO: Automate this step :/
		 */
		ondestruct: function() {
			ts.ui.BarModel.prototype.ondestruct.call(this);
			this._watchmodels(false);
		},

		/**
		 * Handle model changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			var has = 'hascontent';
			var had = 'hadcontent';
			if (!this.hadcontent) {
				this.hadcontent = changes.some(function(c) {
					return c.name === has && c.newValue;
				});
			}
			if (changes.some(function(c) {
				return c.name !== has && c.name !== had;
			}, this)) {
				this._updatehascontent();
			}
		},

		/**
		 * Clear the stuff.
		 * @returns {ts.ui.ToolBarModel}
		 */
		clear: chained(function() {
			this.tabs.clear();
			this.buttons.clear();
			this.search = null;
			this.title = null;
			this._updatehascontent();
		}),

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.toolbar.edbml(this);
		},

		// Private .................................................................

		/**
		 * Watch myself and my collections.
		 * @param {boolean} doit
		 */
		_watchmodels: function(doit) {
			[this, this.buttons, this.tabs].forEach(function(model) {
				if (doit) {
					model.addObserver(this);
				} else {
					model.removeObserver(this);
				}
			}, this);
		},

		/**
		 * Compute the property `hascontent` so that others
		 * won't have to remember this long list of checks.
		 * @returns {boolean} True when there's content...
		 */
		_updatehascontent: function() {
			this.hascontent = !!(
				this.tabs.length ||
				this.buttons.length ||
				this.title ||
				this.search ||
				this.closebutton
			);
			return this.hascontent;
		}

	});
}(gui.Combo.chained));



/**
 * Advanced statusbar model.
 * @extends {ts.ui.ToolBarModel}
 */
ts.ui.StatusBarModel = (function using(chained) {
	return ts.ui.ToolBarModel.extend({

		/**
		 * @type {ts.ui.PagerModel}
		 */
		pager: null,

		/**
		 * Status message may contain links?
		 * @type {boolean}
		 */
		linkable: false,

		/**
		 * Bounce model to HTML.
		 * @returns {string}
		 */
		render: function() {
			return ts.ui.statusbar.edbml(this);
		},

		/**
		 * Handle model changes.
		 * @param {Array<edb.Change>} changes
		 * @returns {boolean} True when updated
		 */
		onchange: function(changes) {
			ts.ui.ToolBarModel.prototype.onchange.call(this, changes);
			changes.forEach(function(c) {
				if (c.name === 'pager') {
					this._updatehascontent();
				}
			}, this);
		},

		/**
		 * Account for the pager.
		 * @returns {boolean}
		 */
		_updatehascontent: function() {
			if (!ts.ui.ToolBarModel.prototype._updatehascontent.call(this)) {
				this.hascontent = !!this.pager;
			}
			return this.hascontent;
		}

	});
}());



/**
 * Advanced topbar model.
 * @extends {ts.ui.BarModel}
 */
ts.ui.TopBarModel = (function using(chained) {
	var UPDATE_DEFAULT_TITLE = ts.ui.BROADCAST_GLOBAL_TOPBAR_UPDATE_DEFAULT_TITLE;

	return ts.ui.ToolBarModel.extend({

		/**
		 * Monitored by the {ts.ui.TopBar}. Remember, we're setting a property
		 * instead of calling a method so that this can be syncrhonized xframe
		 * (noting that this setup can be safely deprecated by now).
		 * @type {string} Matches back|next
		 */
		navigate: null,

		/**
		 * Back/Forward buttons.
		 * @type {ts.ui.ButtonCollection}
		 */
		navigation: ts.ui.ButtonCollection,

		/**
		 * Menuswitch button (burger button) for mobile view.
		 * @type {ts.ui.ButtonModel}
		 */
		menubutton: ts.ui.ButtonModel,

		/**
		 * It's a dark.
		 * @overrides {ts.ui.ToolBarModel#color}
		 */
		color: ts.ui.CLASS_BG_DARK,

		/**
		 * visible.
		 * @type {boolean}
		 */
		visible: true,

		/**
		 * Observe tabs and buttons.
		 * Create menu-toggle button.
		 */
		onconstruct: function() {
			this.navigation = this.navigaton || [];
			ts.ui.ToolBarModel.prototype.onconstruct.call(this);
			gui.Broadcast.addGlobal([
				UPDATE_DEFAULT_TITLE
			], this);
			this.menubutton = {
				id: 'ts-button-menuswitch',
				icon: 'ts-icon-menuswitch',
				type: 'ts-tertiary ts-topbar-menubutton',
				onclick: function() {
					ts.ui.openMenu();
				}
			};
		},

		/**
		 * Show a "spinner" in the (mobile breakpoint) menu button while loading.
		 * These broadcasts are only really transmitted in the Client-Docs chrome
		 * (the documentation website), so we will not bundle a real spinner yet.
		 * TODO: Perhaps the {ts.ui.TopBarSpirit} should manage these icons instead.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			switch (b.type) {
				case UPDATE_DEFAULT_TITLE:
					this.defaultTitle = b.data;
					break;
			}
		},

		/**
		 * Handle model changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.ToolBarModel.prototype.onchange.call(this, changes);
			if (changes.some(function(c) {
				return c.name === 'defaultTitle';
			})) {
				this._updatehascontent();
			}
		},

		/**
		 * Clear everything.
		 * @returns {ts.ui.TopBarModel}
		 */
		clear: chained(function() {
			this.navigation.clear();
			ts.ui.ToolBarModel.prototype.clear.call(this);
		}),

		// Private .................................................................

		/**
		 * Also watch the navigation collection (of buttons).
		 * @override {ts.ui.ToolBarModel#_watchmodels}
		 * @param {boolean} doit
		 */
		_watchmodels: function(doit) {
			ts.ui.ToolBarModel.prototype._watchmodels.call(this, doit);
			var nav = this.navigation;
			if (doit) {
				nav.addObserver(this);
			} else {
				nav.removeObserver(this);
			}
		},

		/**
		 * Compute the property `hascontent` with some expanded fields.
		 * @override {ts.ui.ToolBarModel#_updatehascontent}
		 * @returns {boolean} True when there's content
		 */
		_updatehascontent: function() {
			if (!(ts.ui.ToolBarModel.prototype._updatehascontent.call(this))) {
				this.hascontent = !!(this.navigation.length || this.defaultTitle);
			}
			return this.hascontent;
		}

	});
}(gui.Combo.chained));



/**
 * TopBar API.
 * TODO (jmo@): clear methods
 */
ts.ui.TopBar = {

	/**
	 * @deprecated so don't use this!
	 * Get or set tabs and/or buttons.
	 * @param @optional {object} opt_json
	 * @returns {ts.ui.TopBarModel}
	 */
	setup: function(opt_json) {},

	/**
	 * Get or set tabs.
	 * @param @optional {Array<object>} opt_json
	 * @returns {ts.ui.TabCollection}
	 */
	tabs: function(opt_json) {},

	/**
	 * Get or set buttons.
	 * @param @optional {Array<object>} opt_json
	 * @returns {ts.ui.ButtonCollection}
	 */
	buttons: function(opt_json) {},

	/**
	 * @param {string} title
	 * @returns {ts.ui.TopBarModel}
	 */
	title: function(title) {},

	/**
	 * @param {string} title
	 * @returns {ts.ui.TopBarModel}
	 */
	defaultTitle: function(defaultTitle) {},

	/**
	 * Setup to show Back button (with associated callback).
	 * Use 'null' argument to remove the button.
	 * @param {function|null} callback
	 * @returns {ts.ui.TopBarModel}
	 */
	showBack: function(callback) {},

	/**
	 * Setup to show Forward button (with associated callback).
	 * Use 'null' argument to remove the button.
	 * @param {function|null} callback
	 * @returns {ts.ui.TopBarModel}
	 */
	showNext: function(callback) {},

	/**
	 * Hide the Back button.
	 * @returns {ts.ui.TopBarModel}
	 */
	hideBack: function() {},

	/**
	 * Hide the Forward button.
	 * @returns {ts.ui.TopBarModel}
	 */
	hideNext: function() {},

	/**
	 * Setup to show ts.ui.Topbar.
	 * @returns {ts.ui.TopBarModel}
	 */
	show: function() {},

	/**
	 * Hide the ts.ui.Topbar.
	 * @returns {ts.ui.TopBarModel}
	 */
	hide: function() {},

	/**
	 * Generally dark appearance.
	 */
	dark: function() {},

	/**
	 * Generally green appearance.
	 */
	green: function() {},

	/**
	 * Generally blue appearance.
	 */
	blue: function() {},

	/**
	 * Generally purple appearance.
	 */
	purple: function() {},

	/**
	 * Identification.
	 * @returns {string}
	 */
	toString: function() {
		return '[object ts.ui.TopBar]';
	},

	/**
	 * Ad-hoc localization interface. Omit the
	 * argument to get the current localization.
	 * TODO: Greenfield this (add xframe support).
	 * @param @optional {Object} config
	 * @returns {Object}
	 */
	localize: function(config) {}
};

// Implementation ..............................................................

/**
 * @using {ts.ui.Greenfield#api} api
 * @using {gui.Object#hidden} hidden
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} confirmed
 * @using {gui.Type} Type
 */
(function using(api, hidden, chained, confirmed, Type) {
	var topbar = null; // {ts.ui.TopBarModel}
	var locale = null;

	/**
	 * Setup to initialize the topbar whenever any method is called upon it.
	 * @param {function) base
	 * @returns {function}
	 */
	function init(base) {
		return function() {
			topbar = topbar || new ts.ui.TopBarModel();
			return base.apply(null, arguments);
		};
	}

	/**
	 * Append or remove Back/Forward button.
	 * We always nuke the existing button.
	 * @param {string} insert (unshift|push)
	 * @param {object} button
	 */
	function navigation(insert, button) {
		var nav = topbar.navigation;
		var but = nav.get(button.id);
		var add = button.onclick !== null;
		if (but) {
			nav.remove(but);
		}
		if (add) {
			nav[insert](button);
		}
	}

	/**
	 * API methods.
	 */
	gui.Object.extend(ts.ui.TopBar, {

		/**
		 * @deprecated (never documented)
		 * @param @optional {object} opt_json
		 */
		setup: api(chained(function(opt_json) {
			console.error('Deprecated API is deprected');
		})),

		/**
		 * Get or set new tab collection.
		 * @param @optional {Array<object>} opt_json
		 * @returns {object|ts.ui.TabCollection}
		 */
		tabs: api(chained(confirmed('(array)')(
			init(function(opt_json) {
				if (opt_json) {
					topbar.tabs.clear();
					opt_json.forEach(function(json) {
						topbar.tabs.push(json);
					});
				}
				if (!arguments.length) {
					return topbar.tabs;
				}
			})
		))),

		/**
		 * Get or set new button collection.
		 * @param @optional {Array<object>} opt_json
		 * @return {object|ts.ui.ButtonCollection}
		 */
		buttons: api(chained(confirmed('(array)')(
			init(function(opt_json) {
				if (opt_json) {
					topbar.buttons.clear();
					opt_json.forEach(function(json) {
						topbar.buttons.push(json);
					});
				}
				if (!arguments.length) {
					return topbar.buttons;
				}
			})
		))),

		/**
		 * Set topbar title.
		 * @param @optional {string} title
		 * @returns {object|string}
		 */
		title: api(chained(confirmed('(string)')(
			init(function(title) {
				if (arguments.length) {
					topbar.title = title;
				} else {
					return topbar.title;
				}
			})
		))),

		/**
		 * Set topbar default title.
		 * @param @optional {string} defaultTitle
		 * @returns {object|string}
		 */
		defaultTitle: api(chained(confirmed('(string)')(
			init(function(defaultTitle) {
				if (arguments.length) {
					topbar.defaultTitle = defaultTitle;
				} else {
					return topbar.defaultTitle;
				}
			})
		))),

		/**
		 * Append or remove Back button with a callback.
		 * Pass 'null' as callback to remove the button.
		 * @param {function|null} callback
		 */
		showBack: api(chained(confirmed('function|null')(
			init(function(callback) {
				navigation('unshift', {
					icon: 'ts-icon-back',
					onclick: callback,
					id: 'back'
				});
			}))
		)),

		/**
		 * Append or remove Forward button with a callback.
		 * Pass 'null' as callback to remove the button.
		 * Pass 'null' to remove the button.
		 * @param {function|null} callback
		 */
		showNext: api(chained(confirmed('function|null')(
			init(function(callback) {
				navigation('push', {
					icon: 'ts-icon-next',
					onclick: callback,
					id: 'next'
				});
			}))
		)),

		/**
		 * Remove Back button.
		 * @returns {ts.ui.TopBar}
		 */
		hideBack: api(chained(function() {
			this.showBack(null);
		})),

		/**
		 * Remove Forward button.
		 * @returns {ts.ui.TopBar}
		 */
		hideNext: api(chained(function() {
			this.showNext(null);
		})),

		/**
		 * Show ts.ui.Topbar.
		 * @returns {ts.ui.TopBar}
		 */
		show: api(chained(function() {
			topbar.visible = true;
		})),

		/**
		 * Hide ts.ui.Topbar. Because this won't have any effect in
		 * mobile	breakpoint, we'll also clear the TopBar (so that
		 * in mobile, the effect is simply to clear the TopBar).
		 * @returns {ts.ui.TopBar}
		 */
		hide: api(chained(function() {
			topbar.visible = false;
			topbar.clear();
		})),

		/**
		 * Clear the tabs and buttons and title and so on.
		 * @returns {ts.ui.TopBar}
		 */
		clear: api(chained(function() {
			topbar.clear();
		})),

		// Privileged ..............................................................

		/**
		 *
		 * @see {ts.ui.TopBarSpirit#onconfigure}
		 */
		$getmodel: init(function() {
			return topbar;
		}),

		/**
		 * TODO: This is copy-pasted from some other API, refactor for common
		 * inheritance chain (and supress "privacy" concerns for simpler code).
		 */
		localize: api(chained(function(arg) {
			if (arguments.length) {
				switch (gui.Type.of(arg)) {
					case 'object':
						var newlocale = arg;
						if (!locale || Object.keys(locale).every(function(key) {
							var has = newlocale.hasOwnProperty(key);
							if (!has) {
								console.error('Missing translations for ' + key);
							}
							return has;
						})) {
							locale = newlocale;
						}
						break;
					case 'string':
						var key = arg;
						if (locale && locale.hasOwnProperty(key)) {
							return locale[key];
						} else {
							console.error('Missing translations for ' + key);
						}
						break;
				}
			} else {
				return locale;
			}
		}))

	});

	/**
	 * Generate methods `blue` `green` `purple` and so
	 * on to change the general color scheme of the TopBar.
	 */
	gui.Object.each(ts.ui.BACKGROUND_COLORS, function(methodname, classname) {
		ts.ui.TopBar[methodname] = init(function() {
			topbar.color = classname;
			return ts.ui.TopBar;
		});
	});
}(
	ts.ui.Greenfield.api, // TODO: This is not used no more...
	gui.Object.hidden, // TODO: This also makes litte sense now...
	gui.Combo.chained,
	gui.Arguments.confirmed,
	gui.Type
));

/**
 * Default-localize the TopBar.
 */
ts.ui.TopBar.localize({
	options: 'Options',
	more: 'More...'
});



/**
 * Bars API module.
 */
gui.module('bars-api@tradeshift.com');



/**
 * Advanced table row collection.
 * @extends {ts.ui.Collection}
 * @using {ts.ui.Collection} Collection
 * @using {gui.Array} GuiArray
 * @using {gui.Arguments.confirmed} TODO: something faster (big data scenario)
 */
ts.ui.TableRowCollection = (function using(Collection, GuiArray, confirmed) {
	var Super = Collection.prototype;

	/**
	 * This should really be fixed in the core somewhere, but anyways:
	 * We know for a fact that folks will serve their Angular models
	 * directly to the Table so that our state and Angulars state
	 * become entangled. Thus, we'll need to deepclone the data and
	 * work on *copies* of the data. Note that this is only a problem
	 * because we don't create models from the data (for performance
	 * reasons), since otherwise this would be sorted out already.
	 */
	function deepclone(thing) {
		return JSON.parse(JSON.stringify(thing));
	}

	return Collection.extend({

		/**
		 * Need to do this because we can accept both objects and
		 * arrays and I guess we never though about that before.
		 * TODO(jmo@): verify that this is needed and fix it in {edb.ArrayPopulator}
		 */
		$of: confirmed('object|array')(
			function(json) {
				return json;
			}
		),

		/**
		 * Deepclone before adding.
		 * @overwrites {ts.ui.Collection#push}
		 */
		push: function() {
			var args = GuiArray.from(arguments);
			var list = this._suspended ? args : deepclone(args);
			return Super.push.apply(this, list);
		},

		/**
		 * Deepclone before adding.
		 * @overwrites {ts.ui.Collection#unshift}
		 */
		unshift: function() {
			var args = GuiArray.from(arguments);
			var list = this._suspended ? args : deepclone(args);
			return Super.unshift.apply(this, list);
		},

		/**
		 * Deepclone before adding.
		 * @overwrites {ts.ui.Collection#splice}
		 */
		splice: function() {
			if (this._suspended) {
				Super.splice.apply(this, arguments);
			} else {
				var args = GuiArray.from(arguments);
				return Super.splice.apply(this, args.map(function(arg, index) {
					return index > 1 ? deepclone(arg) : arg;
				}));
			}
		},

		// Privileged ..............................................................

		/**
		 * We should only deepclone stuff that the user injects, not the
		 * stuff that we (ourself) array-manipulate inside the component.
		 * This method will disable deepcloning while performing an action.
		 * @param {function} action
		 * @param @optional {object} thisp
		 */
		$suspend: function(action, thisp) {
			this._suspended = true;
			var res = action.call(thisp);
			this._suspended = false;
			return res;
		},

		// Private .................................................................

		/**
		 * While true, we will not deepclone the
		 * stuff that gets added to the collection.
		 * @type {boolean}
		 */
		_suspended: false

	});
}(ts.ui.Collection, gui.Array, gui.Arguments.confirmed));



/**
 * Advanced table column model.
 * @extends {ts.ui.Model}
 * @using {gui.Combo.chained} chained
 */
ts.ui.TableColModel = (function using(chained) {
	// remove special characters from
	// alphabetic sorting sequence
	var SPECIAL = /[^A-z\d ]/gi;

	/**
	 * Sort numerically.
	 * @param {number} n1
	 * @param {number} n1
	 * @param {boolean} ascending
	 */
	function sortnum(n1, n2, ascending) {
		if (n1 < n2) {
			return ascending ? -1 : 1;
		}
		if (n1 > n2) {
			return ascending ? 1 : -1;
		}
		return 0;
	}

	/**
	 * Sort alphabetically in a non-sophisticated way.
	 * @param {string} s1
	 * @param {string} s2
	 * @param {boolean} ascending
	 */
	function sortalpha(a, b, ascending) {
		var com = compare(normalize(a), normalize(b));
		if (com < 0) {
			return ascending ? -1 : 1;
		}
		if (com > 0) {
			return ascending ? 1 : -1;
		}
		return 0;
	}

	/**
	 * This seems to tweak the alphabetical sorting favourably.
	 * @param {string} string
	 * @returns {string}
	 */
	function normalize(string) {
		return string.toLowerCase().replace(SPECIAL, '');
	}

	/**
	 * You can apparently `localeCompare` strings for
	 * better resolution of strange regional characters.
	 * @see http://mdn.io/localeCompare
	 * TODO(jmo@): Support futher locale options
	 */
	function compare(string1, string2) {
		if (string1.localeCompare) {
			return string1.localeCompare(string2);
		} else {
			return string1 > string2;
		}
	}

	return ts.ui.Model.extend({

		/**
		 * Friendly name
		 * @type {string}
		 */
		item: 'tablecol',

		/**
		 * Column (cell) content type. Matches `ts-text` or `ts-number`.
		 * @type {string}
		 */
		type: 'ts-text',

		/**
		 * Col is hidden for some reason?
		 * @type {boolean}
		 */
		visible: true,

		/**
		 * Col is selected (when sorting)?
		 * @type {boolean}
		 */
		selected: false,

		/**
		 * Sorting ascending?
		 * @type {boolean}
		 */
		ascending: true,

		/**
		 * Cells in this column are editable? Please note that
		 * this is assumed `true` unless explicitly denied!
		 * @type {boolean}
		 */
		editable: true,

		/**
		 * Column flex.
		 * @type {number}
		 */
		flex: 1,

		/**
		 * Wrap text (in the cells)?
		 * @type {boolean}
		 */
		wrap: false,

		/**
		 * Minimum width in pixels (zero means no such).
		 * @type {number}
		 */
		minwidth: 0,

		/**
		 * Search config.
		 * @type {ts.ui.SearchModel}
		 */
		search: ts.ui.SearchModel,

		/**
		 * Button config.
		 * @type {ts.ui.ButtonModel}
		 */
		button: ts.ui.ButtonModel,

		/**
		 * Hide the column.
		 * @returns {ts.ui.TableColModel}
		 */
		hide: chained(function() {
			this.visible = false;
		}),

		/**
		 * Show the column.
		 * @returns {ts.ui.TableColModel}
		 */
		show: chained(function() {
			this.visible = true;
		}),

		/**
		 * Default sort mechanism.
		 * TODO: Perhaps we should document the fact that you can overwrite this?
		 * @param {string|number} val1
		 * @param {string|number} val2
		 * @param {boolean} numberically
		 * @returns {number}
		 */
		sort: function(val1, val2, numerically) {
			var ascending = this.ascending;
			if (numerically) {
				return sortnum(val1, val2, ascending);
			} else {
				return sortalpha(val1, val2, ascending);
			}
		},

		/**
		 * Is (cell content) of type number?
		 * @returns {boolean}
		 */
		isNumber: function() {
			return this.type.split(' ').indexOf('ts-number') > -1;
		},

		/**
		 * Temp API updated warning.
		 * Can be removed later on...
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			var type = this.type;
			if (type === 'text' || type === 'number') {
				this.type = 'ts-' + type;
				console.warn(
					'The column `type` property must be changed ' +
					'from "' + type + '" to "ts-' + type + '"'
				);
			}
		}

	});
}(gui.Combo.chained));



/**
 * Advanced table column collection.
 * @extends {ts.ui.Collection}
 */
ts.ui.TableColCollection = ts.ui.Collection.extend({
	$of: ts.ui.TableColModel
});



/**
 * Advanced table model.
 * @extends {ts.ui.Model}
 * @using {ts.ui.TableRowCollection} RowCollection
 * @using {gui.Type} Type
 * @using {ts.ui.Model} Model
 */
ts.ui.TableModel = (function using(RowCollection, Type, Model) {
	/**
	 * Something is visible? Optimized for non-yet-moddeled JSON thing.
	 * @param {JSONObject|ts.ui.TableColModel|ts.ui.TableRowModel} thing
	 * @returns {boolean}
	 */
	function isvisible(thing) {
		return thing.visible !== false;
	}

	/**
	 * Exception on using `null` as cell content.
	 * @param {object|string|number|boolean} thing
	 * @returns {boolean}
	 */
	function validcell(thing) {
		var is = (thing !== undefined && thing !== null);
		if (!is) {
			console.error('Cell content cannot be of type ' + Type.of(thing));
		}
		return is;
	}

	/**
	 * Table input may be in object and/or array format.
	 * This will "normalize" the input to object format
	 * so that we don't have to account for both in all
	 * scenarios (for example in the EDBML rendering).
	 * @param {Array|object} x
	 * @param @optional {number} i (internal use)
	 * @returns {ts.ui.TableRowModel}
	 */
	function rowify(x, i) {
		if (Array.isArray(x)) {
			x = {
				cells: x,
				selected: !!x.selected
			};
		}
		x.cells = x.cells.map(cellify);
		if (i !== undefined) {
			x.$index = i;
		}
		return x;
	}

	/**
	 * Normalize cell format for various (internal) purposes.
	 * TODO: validate object-with-value-property
	 * @param {object|string|number|boolean} x
	 * @param @optional @internal {number} i (internal use)
	 * @returns {object}
	 */
	function cellify(x, i) {
		if (validcell(x)) {
			if (primitive(x)) {
				x = {
					value: x,
					text: String(x)
				};
			} else {
				// TODO: validate object-with-value-property
			}
			if (!Model.is(x)) {
				x.valid = x.valid !== false;
				x.message = x.message || null;
			}
			if (i !== undefined) {
				x.$index = i;
			}
		}
		return x;
	}

	/**
	 * If the cell contains a JSON object and the object has an `item` property,
	 * we will convert it into the corresponding model. The model instance will
	 * replace the JSON object so the this conversion is permanent. Note that
	 * the conversion happens as table cells are being rendered in the *view*,
	 * ie. we don't convert everything at once (for performance in big data).
	 * @param {ts.ui.TableModel} table
	 * @param {Array<object>} row (rowified into objects)
	 */
	function modelify(table, row) {
		var ModelC, rowindex, celindex;
		row.cells = row.cells.map(function(cell) {
			if (cell.item && !Model.is(cell)) {
				ModelC = getmodel(cell.item);
				rowindex = row.$index;
				celindex = cell.$index;
				cell = new ModelC(cell);
				cell.$index = celindex;
				table.setcell(rowindex, celindex, cell);
			}
			return cell;
		});
		return row;
	}

	/**
	 * Get model constructor by friendly name. For more
	 * potential models, see the file {ts.ui.Collection}.
	 * TODO: All "friendly names" should be PascalCased!
	 * @param {string} item
	 * @return {Constructor}
	 */
	function getmodel(item) {
		return {
			// 'select': ts.ui.SelectModel, // TODO: support
			// 'date': ts.ui.DatePickerModel, // TODO: support
			image: ts.ui.ImageModel,
			button: ts.ui.ButtonModel,
			'switch': ts.ui.SwitchModel,
			userimage: ts.ui.UserImageModel,
			icon: ts.ui.IconModel
		}[item.toLowerCase()] || (function nomatch() {
			console.error('"' + item + '" not matched to nothing');
			return null;
		}());
	}

	/**
	 * Is something simple?
	 * @param {object|string|number|boolean} x
	 * @returns {boolean}
	 */
	function primitive(x) {
		switch (Type.of(x)) {
			case 'string':
			case 'number':
			case 'boolean':
				return true;
		}
		return false;
	}

	/**
	 * Something is selected?
	 * @param {object} x
	 * @returns {boolean}
	 */
	function selected(x) {
		return !!x.selected;
	}

	/**
	 * Compute appropriate sort value for cell
	 * (the input data can be in fuzzy format).
	 * @eeturns {string|number} (or anything really!)
	 */
	function getsortvalue(row, index) {
		if (Array.isArray(row)) {
			return row[index];
		} else {
			var cel = row.cells[index];
			var txt = cel.text;
			var val = cel.value;
			return val !== undefined ? val : txt;
		}
	}

	return ts.ui.Model.extend({

		/**
		 * Friendly name.
		 * @type {string}
		 */
		item: 'table',

		/**
		 * Max number of rows to show per pagination-page (zero shows all rows).
		 * TODO: Rename this!
		 * @type {number}
		 */
		maxrows: 0,

		/**
		 * Current page (mostly relevant when maxrows is set to something).
		 * Please use `this.pager.page` to change the page, this property
		 * is only public so that the EDBML renders whenever we change it.
		 * @type {number}
		 */
		page: 0,

		/**
		 * Total rows that might *not* be mounted, but may *later* be loaded from
		 * the enterprise portal server. This has to do with the pagination stuff.
		 * @type {number}
		 */
		total: 0,

		/**
		 * Rows are selectable?
		 * @type {boolean}
		 */
		selectable: false,

		/**
		 * Cols are sortable?
		 * @type {boolean}
		 */
		sortable: false,

		/**
		 * The Table should render links via Markdown?
		 * @type {boolean}
		 */
		linkable: false,

		/**
		 * @type {boolean}
		 */
		editable: false,

		/**
		 * @type {boolean}
		 */
		numbered: false,

		/**
		 * Columns.
		 * @type {ts.ui.CollCollection}
		 */
		cols: ts.ui.TableColCollection,

		/**
		 * Rows are complicated.
		 * TODO: Explain this :/
		 * @type {Array<object|Array|ts.ui.TableRowCollection<ts.ui.TableRowModel>}
		 */
		rows: ts.ui.TableRowCollection,

		/**
		 * Pager.
		 * @type {ts.ui.PagerModel}
		 */
		pager: ts.ui.PagerModel,

		/**
		 * StatusBar.
		 * TODO: Rename the property `statusbar` knowing that the Table will need testing!
		 * @type {ts.ui.StatusBarModel}
		 */
		toolbar: ts.ui.StatusBarModel,

		/**
		 * Selection menu is open?
		 * @type {boolean}
		 */
		menuopen: false,

		/**
		 * TODO: This (kind of) property should be standard in EDBML.
		 */
		tempdirtyflag: -1,

		/**
		 * Render toolbar as a statusbar (multiline in mobile view).
		 */
		onconstruct: function() {
			ts.ui.Model.prototype.onconstruct.call(this);
			this.cols = this.cols || [];
			this.rows = this.rows || [];
			this.toolbar = {};
		},

		/**
		 * Compute visible columns.
		 * @returns {Array<ts.ui.ColModel}
		 */
		visibleCols: function() {
			return this.cols.filter(isvisible);
		},

		/**
		 * Compute visible rows (the ones in the current page).
		 * TODO: Cache something until new rows are added or removed
		 * @returns {Array<ts.ui.TableRowModel}
		 */
		visibleRows: function() {
			var all = this.rows;
			var vis = this._layoutrows();
			var fix = this.maxrows > 0;
			var min = this.maxrows * this.page;
			var max = min + this.maxrows;
			return vis.filter(function(row, i) {
				return fix ? (i >= min && i < max) : true;
			}).map(function(row) {
				return rowify(row, all.indexOf(row));
			}).map(function(row) {
				return modelify(this, row);
			}, this);
		},

		/**
		 * Compute visible cells for row (the column is not hidden).
		 * @returns {Array<object>}
		 */
		visibleCells: function(row) {
			var cols = this.cols;
			var cels = rowify(row).cells;
			return cels.filter(function(cell, i) {
				return cols[i].visible;
			});
		},

		/**
		 * First visible row (the one on top).
		 * @returns {ts.ui.TableRowModel}
		 */
		firstVisibleRow: function() {
			return this.visibleRows()[0] || null;
		},

		/**
		 * Something (might be) wrapping multiline?
		 * @returns {boolean}
		 */
		isWrapping: function() {
			return this.cols.some(function(col) {
				return col.wrap;
			});
		},

		/**
		 * Any visible row is selected? That is,
		 * any row on the currently shown page.
		 * @returns {boolean}
		 */
		isVisibleRowSelected: function() {
			return this.visibleRows().filter(function(row) {
				return row.selectable !== false;
			}).some(selected);
		},

		/**
		 * Do the default search.
		 * @param {number} index
		 * @param {string} value
		 */
		search: function(index, value) {
			this._ownsearch(index, value);
		},

		/**
		 * Sort that column.
		 * @param {ts.ui.TableColModel} col
		 */
		sort: function(col) {
			if (col) {
				this._sortcol = col;
			}
		},

		/**
		 * Toggle row selection.
		 * @param {number} index
		 */
		togglerow: function(index) {
			if (this.rowselected(index)) {
				this.unselectrow(index);
			} else {
				this.selectrow(index);
			}
		},

		/**
		 * Is single row selected?
		 * @param {number} index
		 */
		rowselected: function(index) {
			var row = this.getrow(index);
			var sel = !!row.selected;
			return sel === true;
		},

		/**
		 * Select single row at index.
		 * @param {number} index
		 * @returns {boolean} True if changed
		 */
		selectrow: function(index) {
			var row = this.getrow(index);
			var sel = !!row.selected;
			if (sel === false) {
				row = this.getrow(index, true, true);
				row.selected = true;
				this.$dirty();
				return true;
			}
			return false;
		},

		/**
		 * Unselect single row at index.
		 * @param {number} index
		 * @returns {boolean} True if changed
		 */
		unselectrow: function(index) {
			var row = this.getrow(index);
			var sel = !!row.selected;
			if (sel === true) {
				row.selected = false;
				this.$dirty();
				return true;
			}
			return false;
		},

		/**
		 * Get indexes of all selected rows.
		 * @returns {Array<number>}
		 */
		selectedrows: function() {
			var indexes = [];
			this.rows.forEach(function(row, i) {
				var sel = !!row.selected;
				if (sel === true && row.selectable !== false) {
					indexes.push(i);
				}
			});
			return indexes;
		},

		/**
		 * Compute number of pages based on `maxrows` (per page).
		 * @returns {number}
		 */
		pageCount: function() {
			if (this.maxrows) {
				var show = this.rows.filter(isvisible);
				var rows = show.length;
				return Math.ceil(rows / this.maxrows);
			} else {
				return 0;
			}
		},

		/**
		 * Find the page that shows the given rowindex somewhere.
		 * @param {number} index
		 * @param {number} chuncks
		 * @returns {number}
		 */
		getPage: function(index) {
			var fit = this.maxrows;
			var row = this.rows[index];
			var all = this._layoutrows();
			var now = -1;
			return all.reduce(function(result, next, i) {
				if (result === -1) {
					now += i % fit === 0 ? 1 : 0;
					if (next === row) {
						result = now;
					}
				}
				return result;
			}, -1);
		},

		/**
		 * Get row in whatever format it was given us OR in the form of an
		 * object. Also validates that the row even exists to begin with.
		 * TODO(jmo@): The option to "persist" the reformatted row is most
		 * likely not needed anyways, because now that I think of it, you
		 * can just assign properties such as `selected` and `type` to an
		 * array without converting it into an object first. Doh! This
		 * comes with a performance overhead (and thus some workarounds)
		 * for very big tables, so let's investigate if it can be removed.
		 * @param {number} i
		 * @param @optional {boolean} asobject Convert array to object?
		 * @param @optional {boolean} persist Persist as an object?
		 * @returns {object|array}
		 */
		getrow: function(rowindex, asobject, persist) {
			var row = this.rows[rowindex];
			if (row) {
				if (asobject && Array.isArray(row)) {
					if (persist) {
						row = rowify(row, rowindex);
						this.rows.$suspend(function() {
							this.rows.splice(rowindex, 1, row);
						}, this);
					} else {
						row = rowify(row);
					}
				}
			} else {
				throw new RangeError('Row index ' + rowindex + ' is out of reach');
			}
			return row;
		},

		/**
		 * Set that row.
		 * @param {number} i
		 * @param {object|array}	row
		 */
		setrow: function(rowindex, row) {
			var oldrow = this.getrow(rowindex);
			if (oldrow) {
				this.rows.$suspend(function() {
					this.rows.splice(rowindex, 1, row);
				}, this);
				this.$dirty();
			}
		},

		/**
		 * Get that cell (always as an object) - probably not needed no more!
		 * @deprecated
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @returns {object}
		 */
		getcell: function(rowindex, cellindex) {
			var row = this.getrow(rowindex, true);
			var cell = row.cells[cellindex];
			if (cell) {
				delete cell.$index; // because this is only user-facing for now...
				return cell;
			} else {
				throw new RangeError('Cell index ' + cellindex + ' is out of reach');
			}
		},

		/**
		 * Set that cell.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @param {object|string|number} json
		 */
		setcell: function(rowindex, cellindex, json) {
			var row = this.getrow(rowindex, true, true);
			row.cells.splice(cellindex, 1, json);
			this.$dirty();
		},

		/**
		 * Mark cell as valid/invalid with an optional message.
		 * @param {boolean} valid
		 * @param {number} rowindex
		 * @param {number} rowindex
		 * @param @optional {string} message
		 */
		setvalidity: function(valid, rowindex, cellindex, message) {
			var row = this.getrow(rowindex, true, true);
			var cell = row.cells[cellindex];
			var now = !!cell.valid;
			if (valid !== now) {
				cell.message = valid ? null : (message || null);
				cell.valid = valid;
				this.$dirty();
			}
		},

		/**
		 * Move to specific or relative position (this
		 * all relates to the keyboard focus outline).
		 * @param {gui.Position|string|null}
		 * @returns {gui.Position}
		 */
		moveposition: function(arg) {
			switch (Type.of(arg)) {
				case 'object':
					this.position = arg;
					break;
				case 'string':
					this._moverelative(
						arg.toLowerCase()
					);
					break;
				case 'null':
					this.position = null;
					break;
			}
			return this.position;
		},

		// Privileged ..............................................................

		/**
		 * Compute unique ID for cell at given index.
		 * This is used both in EDBML and straight JS.
		 * @param {number} rowindex
		 * @param {number} celindex
		 * @returns {string}
		 */
		$cellid: function(rowindex, celindex) {
			return [this.$instanceid, 'cell', rowindex, celindex].join('-');
		},

		// Private .................................................................

		/**
		 * Tracking multiple search terms by column index.
		 * @type {Map<number, string>}
		 */
		_searches: null,

		/**
		 * Sort table by this column.
		 * @type {ts.ui.ColModel}
		 */
		_sortcol: null,

		/**
		 * Get (all) visible rows in correct sorted order.
		 * @returns {Array<ts.ui.TableRowModel}
		 */
		_layoutrows: function() {
			var shown = this.rows.filter(isvisible);
			var fixed = this._sort(shown, this._sortcol);
			return fixed;
		},

		/**
		 * Sort rows (if sort column exists).
		 * @param {Array<ts.ui.RowModel>} rows
		 * @param {ts.ui.TableColModel} col
		 * returns {Array<ts.ui.RowModel>}
		 */
		_sort: function(rows, col) {
			if (col) {
				var i = col.$index;
				var n = !rows.map(function columnvalue(r) {
					return getsortvalue(r, i);
				}).some(isNaN);
				rows.sort(function(r1, r2) {
					var c1 = getsortvalue(r1, i);
					var c2 = getsortvalue(r2, i);
					return col.sort(c1, c2, n);
				});
			}
			return rows;
		},

		/**
		 * Show only the rows whose cell at given index contains the given
		 * value using an advanced search algorithm based on `indexOf`.
		 * TODO: Make a real (public) API for hiding and showing rows
		 * TODO: Account for columns that might be hidden by config
		 * @param {number} index
		 * @param {string} value
		 */
		_ownsearch: function(index, value) {
			value = String(value).toLowerCase();
			this._searches = this._searches || {};
			if (value.length) {
				this._searches[index] = value;
			} else {
				delete this._searches[index];
			}
			var indexes = Object.keys(this._searches);
			var showall = !indexes.length;
			this.rows.forEach(function(row) {
				row.visible = showall || this._showrow(row, indexes);
			}, this);
		},

		/**
		 * Show the row, what with multiple search terms supported?
		 * @param {object|array} row
		 * @param {Array<number>} indexes
		 * @returns {boolean}
		 */
		_showrow: function(row, indexes) {
			return indexes.every(function(index) {
				var value = this._searches[index];
				return this._rowcontains(row, index, value);
			}, this);
		},

		/**
		 * Cell at given index contains given value?
		 * @param {number} index Cell index
		 * @param {string} value (lowercased already)
		 * @returns {boolean}
		 */
		_rowcontains: function(row, index, value) {
			var is = Array.isArray(row);
			var cell = is ? row[index] : row.cells[index];
			var text = String(is ? cell : cell.value).toLowerCase();
			return text.includes(value);
		}

	});
}(ts.ui.TableRowCollection, gui.Type, ts.ui.Model));



/**
 * Tables API module.
 */
gui.module('tables-api@tradeshift.com');



}(self));
(function() {

//! moment.js
//! version : 2.12.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function(global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		global.moment = factory();
}(this, function() {
	'use strict';

	var hookCallback;

	function utils_hooks__hooks() {
		return hookCallback.apply(null, arguments);
	}

		// This is done to register the method called with moment()
		// without creating circular dependencies.
	function setHookCallback(callback) {
		hookCallback = callback;
	}

	function isArray(input) {
		return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}

	function isDate(input) {
		return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}

	function map(arr, fn) {
		var res = [], i;
		for (i = 0; i < arr.length; ++i) {
			res.push(fn(arr[i], i));
		}
		return res;
	}

	function hasOwnProp(a, b) {
		return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
		for (var i in b) {
			if (hasOwnProp(b, i)) {
				a[i] = b[i];
			}
		}

		if (hasOwnProp(b, 'toString')) {
			a.toString = b.toString;
		}

		if (hasOwnProp(b, 'valueOf')) {
			a.valueOf = b.valueOf;
		}

		return a;
	}

	function create_utc__createUTC(input, format, locale, strict) {
		return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
				// We need to deep clone this object.
		return {
			empty: false,
			unusedTokens: [],
			unusedInput: [],
			overflow: -2,
			charsLeftOver: 0,
			nullInput: false,
			invalidMonth: null,
			invalidFormat: false,
			userInvalidated: false,
			iso: false
		};
	}

	function getParsingFlags(m) {
		if (m._pf == null) {
			m._pf = defaultParsingFlags();
		}
		return m._pf;
	}

	function valid__isValid(m) {
		if (m._isValid == null) {
			var flags = getParsingFlags(m);
			m._isValid = !isNaN(m._d.getTime()) &&
								flags.overflow < 0 &&
								!flags.empty &&
								!flags.invalidMonth &&
								!flags.invalidWeekday &&
								!flags.nullInput &&
								!flags.invalidFormat &&
								!flags.userInvalidated;

			if (m._strict) {
				m._isValid = m._isValid &&
										flags.charsLeftOver === 0 &&
										flags.unusedTokens.length === 0 &&
										flags.bigHour === undefined;
			}
		}
		return m._isValid;
	}

	function valid__createInvalid(flags) {
		var m = create_utc__createUTC(NaN);
		if (flags != null) {
			extend(getParsingFlags(m), flags);
		}		else {
			getParsingFlags(m).userInvalidated = true;
		}

		return m;
	}

	function isUndefined(input) {
		return input === void 0;
	}

		// Plugins that add properties should also add the key here (null value),
		// so we can properly clone ourselves.
	var momentProperties = utils_hooks__hooks.momentProperties = [];

	function copyConfig(to, from) {
		var i, prop, val;

		if (!isUndefined(from._isAMomentObject)) {
			to._isAMomentObject = from._isAMomentObject;
		}
		if (!isUndefined(from._i)) {
			to._i = from._i;
		}
		if (!isUndefined(from._f)) {
			to._f = from._f;
		}
		if (!isUndefined(from._l)) {
			to._l = from._l;
		}
		if (!isUndefined(from._strict)) {
			to._strict = from._strict;
		}
		if (!isUndefined(from._tzm)) {
			to._tzm = from._tzm;
		}
		if (!isUndefined(from._isUTC)) {
			to._isUTC = from._isUTC;
		}
		if (!isUndefined(from._offset)) {
			to._offset = from._offset;
		}
		if (!isUndefined(from._pf)) {
			to._pf = getParsingFlags(from);
		}
		if (!isUndefined(from._locale)) {
			to._locale = from._locale;
		}

		if (momentProperties.length > 0) {
			for (i in momentProperties) {
				prop = momentProperties[i];
				val = from[prop];
				if (!isUndefined(val)) {
					to[prop] = val;
				}
			}
		}

		return to;
	}

	var updateInProgress = false;

		// Moment prototype object
	function Moment(config) {
		copyConfig(this, config);
		this._d = new Date(config._d != null ? config._d.getTime() : NaN);
				// Prevent infinite loop in case updateOffset creates new moment
				// objects.
		if (updateInProgress === false) {
			updateInProgress = true;
			utils_hooks__hooks.updateOffset(this);
			updateInProgress = false;
		}
	}

	function isMoment(obj) {
		return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}

	function absFloor(number) {
		if (number < 0) {
			return Math.ceil(number);
		} else {
			return Math.floor(number);
		}
	}

	function toInt(argumentForCoercion) {
		var coercedNumber = +argumentForCoercion,
			value = 0;

		if (coercedNumber !== 0 && isFinite(coercedNumber)) {
			value = absFloor(coercedNumber);
		}

		return value;
	}

		// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
		var len = Math.min(array1.length, array2.length),
			lengthDiff = Math.abs(array1.length - array2.length),
			diffs = 0,
			i;
		for (i = 0; i < len; i++) {
			if ((dontConvert && array1[i] !== array2[i]) ||
								(!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
				diffs++;
			}
		}
		return diffs + lengthDiff;
	}

	function warn(msg) {
		if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
								(typeof console !== 'undefined') && console.warn) {
			console.warn('Deprecation warning: ' + msg);
		}
	}

	function deprecate(msg, fn) {
		var firstTime = true;

		return extend(function() {
			if (firstTime) {
				warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
				firstTime = false;
			}
			return fn.apply(this, arguments);
		}, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
		if (!deprecations[name]) {
			warn(msg);
			deprecations[name] = true;
		}
	}

	utils_hooks__hooks.suppressDeprecationWarnings = false;

	function isFunction(input) {
		return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}

	function isObject(input) {
		return Object.prototype.toString.call(input) === '[object Object]';
	}

	function locale_set__set(config) {
		var prop, i;
		for (i in config) {
			prop = config[i];
			if (isFunction(prop)) {
				this[i] = prop;
			} else {
				this['_' + i] = prop;
			}
		}
		this._config = config;
				// Lenient ordinal parsing accepts just a number in addition to
				// number + (possibly) stuff coming from _ordinalParseLenient.
		this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
		var res = extend({}, parentConfig), prop;
		for (prop in childConfig) {
			if (hasOwnProp(childConfig, prop)) {
				if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
					res[prop] = {};
					extend(res[prop], parentConfig[prop]);
					extend(res[prop], childConfig[prop]);
				} else if (childConfig[prop] != null) {
					res[prop] = childConfig[prop];
				} else {
					delete res[prop];
				}
			}
		}
		return res;
	}

	function Locale(config) {
		if (config != null) {
			this.set(config);
		}
	}

		// internal storage for locale config files
	var locales = {};
	var globalLocale;

	function normalizeLocale(key) {
		return key ? key.toLowerCase().replace('_', '-') : key;
	}

		// pick the locale from the array
		// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
		// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
		var i = 0, j, next, locale, split;

		while (i < names.length) {
			split = normalizeLocale(names[i]).split('-');
			j = split.length;
			next = normalizeLocale(names[i + 1]);
			next = next ? next.split('-') : null;
			while (j > 0) {
				locale = loadLocale(split.slice(0, j).join('-'));
				if (locale) {
					return locale;
				}
				if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
										// the next array item is better than a shallower substring of this one
					break;
				}
				j--;
			}
			i++;
		}
		return null;
	}

	function loadLocale(name) {
		var oldLocale = null;
				// TODO: Find a better way to register and load all the locales in Node
		if (!locales[name] && (typeof module !== 'undefined') &&
								module && module.exports) {
			try {
				oldLocale = globalLocale._abbr;
				require('./locale/' + name);
								// because defineLocale currently also sets the global locale, we
								// want to undo that for lazy loaded locales
				locale_locales__getSetGlobalLocale(oldLocale);
			} catch (e) { }
		}
		return locales[name];
	}

		// This function will load locale and then set the global locale.	If
		// no arguments are passed in, it will simply return the current global
		// locale key.
	function locale_locales__getSetGlobalLocale(key, values) {
		var data;
		if (key) {
			if (isUndefined(values)) {
				data = locale_locales__getLocale(key);
			}			else {
				data = defineLocale(key, values);
			}

			if (data) {
								// moment.duration._locale = moment._locale = data;
				globalLocale = data;
			}
		}

		return globalLocale._abbr;
	}

	function defineLocale(name, config) {
		if (config !== null) {
			config.abbr = name;
			if (locales[name] != null) {
				deprecateSimple('defineLocaleOverride',
												'use moment.updateLocale(localeName, config) to change ' +
												'an existing locale. moment.defineLocale(localeName, ' +
												'config) should only be used for creating a new locale');
				config = mergeConfigs(locales[name]._config, config);
			} else if (config.parentLocale != null) {
				if (locales[config.parentLocale] != null) {
					config = mergeConfigs(locales[config.parentLocale]._config, config);
				} else {
										// treat as if there is no base config
					deprecateSimple('parentLocaleUndefined',
														'specified parentLocale is not defined yet');
				}
			}
			locales[name] = new Locale(config);

						// backwards compat for now: also set the locale
			locale_locales__getSetGlobalLocale(name);

			return locales[name];
		} else {
						// useful for testing
			delete locales[name];
			return null;
		}
	}

	function updateLocale(name, config) {
		if (config != null) {
			var locale;
			if (locales[name] != null) {
				config = mergeConfigs(locales[name]._config, config);
			}
			locale = new Locale(config);
			locale.parentLocale = locales[name];
			locales[name] = locale;

						// backwards compat for now: also set the locale
			locale_locales__getSetGlobalLocale(name);
		} else {
						// pass null for config to unupdate, useful for tests
			if (locales[name] != null) {
				if (locales[name].parentLocale != null) {
					locales[name] = locales[name].parentLocale;
				} else if (locales[name] != null) {
					delete locales[name];
				}
			}
		}
		return locales[name];
	}

		// returns locale data
	function locale_locales__getLocale(key) {
		var locale;

		if (key && key._locale && key._locale._abbr) {
			key = key._locale._abbr;
		}

		if (!key) {
			return globalLocale;
		}

		if (!isArray(key)) {
						// short-circuit everything else
			locale = loadLocale(key);
			if (locale) {
				return locale;
			}
			key = [key];
		}

		return chooseLocale(key);
	}

	function locale_locales__listLocales() {
		return Object.keys(locales);
	}

	var aliases = {};

	function addUnitAlias(unit, shorthand) {
		var lowerCase = unit.toLowerCase();
		aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
		return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
		var normalizedInput = {},
			normalizedProp,
			prop;

		for (prop in inputObject) {
			if (hasOwnProp(inputObject, prop)) {
				normalizedProp = normalizeUnits(prop);
				if (normalizedProp) {
					normalizedInput[normalizedProp] = inputObject[prop];
				}
			}
		}

		return normalizedInput;
	}

	function makeGetSet(unit, keepTime) {
		return function(value) {
			if (value != null) {
				get_set__set(this, unit, value);
				utils_hooks__hooks.updateOffset(this, keepTime);
				return this;
			} else {
				return get_set__get(this, unit);
			}
		};
	}

	function get_set__get(mom, unit) {
		return mom.isValid() ?
						mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}

	function get_set__set(mom, unit, value) {
		if (mom.isValid()) {
			mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
		}
	}

		// MOMENTS

	function getSet(units, value) {
		var unit;
		if (typeof units === 'object') {
			for (unit in units) {
				this.set(unit, units[unit]);
			}
		} else {
			units = normalizeUnits(units);
			if (isFunction(this[units])) {
				return this[units](value);
			}
		}
		return this;
	}

	function zeroFill(number, targetLength, forceSign) {
		var absNumber = '' + Math.abs(number),
			zerosToFill = targetLength - absNumber.length,
			sign = number >= 0;
		return (sign ? (forceSign ? '+' : '') : '-') +
						Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

		// token:		'M'
		// padded:	 ['MM', 2]
		// ordinal:	'Mo'
		// callback: function () { this.month() + 1 }
	function addFormatToken(token, padded, ordinal, callback) {
		var func = callback;
		if (typeof callback === 'string') {
			func = function() {
				return this[callback]();
			};
		}
		if (token) {
			formatTokenFunctions[token] = func;
		}
		if (padded) {
			formatTokenFunctions[padded[0]] = function() {
				return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
			};
		}
		if (ordinal) {
			formatTokenFunctions[ordinal] = function() {
				return this.localeData().ordinal(func.apply(this, arguments), token);
			};
		}
	}

	function removeFormattingTokens(input) {
		if (input.match(/\[[\s\S]/)) {
			return input.replace(/^\[|\]$/g, '');
		}
		return input.replace(/\\/g, '');
	}

	function makeFormatFunction(format) {
		var array = format.match(formattingTokens), i, length;

		for (i = 0, length = array.length; i < length; i++) {
			if (formatTokenFunctions[array[i]]) {
				array[i] = formatTokenFunctions[array[i]];
			} else {
				array[i] = removeFormattingTokens(array[i]);
			}
		}

		return function(mom) {
			var output = '';
			for (i = 0; i < length; i++) {
				output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
			}
			return output;
		};
	}

		// format date using native date object
	function formatMoment(m, format) {
		if (!m.isValid()) {
			return m.localeData().invalidDate();
		}

		format = expandFormat(format, m.localeData());
		formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

		return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
		var i = 5;

		function replaceLongDateFormatTokens(input) {
			return locale.longDateFormat(input) || input;
		}

		localFormattingTokens.lastIndex = 0;
		while (i >= 0 && localFormattingTokens.test(format)) {
			format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
			localFormattingTokens.lastIndex = 0;
			i -= 1;
		}

		return format;
	}

	var match1 = /\d/;						//			 0 - 9
	var match2 = /\d\d/;					//			00 - 99
	var match3 = /\d{3}/;				 //		 000 - 999
	var match4 = /\d{4}/;				 //		0000 - 9999
	var match6 = /[+-]?\d{6}/;		// -999999 - 999999
	var match1to2 = /\d\d?/;				 //			 0 - 99
	var match3to4 = /\d\d\d\d?/;		 //		 999 - 9999
	var match5to6 = /\d\d\d\d\d\d?/; //	 99999 - 999999
	var match1to3 = /\d{1,3}/;			 //			 0 - 999
	var match1to4 = /\d{1,4}/;			 //			 0 - 9999
	var match1to6 = /[+-]?\d{1,6}/;	// -999999 - 999999

	var matchUnsigned = /\d+/;					 //			 0 - inf
	var matchSigned = /[+-]?\d+/;			//		-inf - inf

	var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

		// any word (or two) characters or numbers including two/three word month in arabic.
		// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

	var regexes = {};

	function addRegexToken(token, regex, strictRegex) {
		regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
			return (isStrict && strictRegex) ? strictRegex : regex;
		};
	}

	function getParseRegexForToken(token, config) {
		if (!hasOwnProp(regexes, token)) {
			return new RegExp(unescapeFormat(token));
		}

		return regexes[token](config._strict, config._locale);
	}

		// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
		return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
			return p1 || p2 || p3 || p4;
		}));
	}

	function regexEscape(s) {
		return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}

	var tokens = {};

	function addParseToken(token, callback) {
		var i, func = callback;
		if (typeof token === 'string') {
			token = [token];
		}
		if (typeof callback === 'number') {
			func = function(input, array) {
				array[callback] = toInt(input);
			};
		}
		for (i = 0; i < token.length; i++) {
			tokens[token[i]] = func;
		}
	}

	function addWeekParseToken(token, callback) {
		addParseToken(token, function(input, array, config, token) {
			config._w = config._w || {};
			callback(input, config._w, config, token);
		});
	}

	function addTimeToArrayFromToken(token, input, config) {
		if (input != null && hasOwnProp(tokens, token)) {
			tokens[token](input, config._a, config, token);
		}
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	function daysInMonth(year, month) {
		return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	}

		// FORMATTING

	addFormatToken('M', ['MM', 2], 'Mo', function() {
		return this.month() + 1;
	});

	addFormatToken('MMM', 0, 0, function(format) {
		return this.localeData().monthsShort(this, format);
	});

	addFormatToken('MMMM', 0, 0, function(format) {
		return this.localeData().months(this, format);
	});

		// ALIASES

	addUnitAlias('month', 'M');

		// PARSING

	addRegexToken('M', match1to2);
	addRegexToken('MM', match1to2, match2);
	addRegexToken('MMM', function(isStrict, locale) {
		return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function(isStrict, locale) {
		return locale.monthsRegex(isStrict);
	});

	addParseToken(['M', 'MM'], function(input, array) {
		array[MONTH] = toInt(input) - 1;
	});

	addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
		var month = config._locale.monthsParse(input, token, config._strict);
				// if we didn't find a month name, mark the date as invalid.
		if (month != null) {
			array[MONTH] = month;
		} else {
			getParsingFlags(config).invalidMonth = input;
		}
	});

		// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths(m, format) {
		return isArray(this._months) ? this._months[m.month()] :
						this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort(m, format) {
		return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
						this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	function localeMonthsParse(monthName, format, strict) {
		var i, mom, regex;

		if (!this._monthsParse) {
			this._monthsParse = [];
			this._longMonthsParse = [];
			this._shortMonthsParse = [];
		}

		for (i = 0; i < 12; i++) {
						// make the regex if we don't have it already
			mom = create_utc__createUTC([2000, i]);
			if (strict && !this._longMonthsParse[i]) {
				this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
				this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
			}
			if (!strict && !this._monthsParse[i]) {
				regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
				this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
			}
						// test the regex
			if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
				return i;
			} else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
				return i;
			} else if (!strict && this._monthsParse[i].test(monthName)) {
				return i;
			}
		}
	}

		// MOMENTS

	function setMonth(mom, value) {
		var dayOfMonth;

		if (!mom.isValid()) {
						// No op
			return mom;
		}

		if (typeof value === 'string') {
			if (/^\d+$/.test(value)) {
				value = toInt(value);
			} else {
				value = mom.localeData().monthsParse(value);
								// TODO: Another silent failure?
				if (typeof value !== 'number') {
					return mom;
				}
			}
		}

		dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
		mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
		return mom;
	}

	function getSetMonth(value) {
		if (value != null) {
			setMonth(this, value);
			utils_hooks__hooks.updateOffset(this, true);
			return this;
		} else {
			return get_set__get(this, 'Month');
		}
	}

	function getDaysInMonth() {
		return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex(isStrict) {
		if (this._monthsParseExact) {
			if (!hasOwnProp(this, '_monthsRegex')) {
				computeMonthsParse.call(this);
			}
			if (isStrict) {
				return this._monthsShortStrictRegex;
			} else {
				return this._monthsShortRegex;
			}
		} else {
			return this._monthsShortStrictRegex && isStrict ?
								this._monthsShortStrictRegex : this._monthsShortRegex;
		}
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex(isStrict) {
		if (this._monthsParseExact) {
			if (!hasOwnProp(this, '_monthsRegex')) {
				computeMonthsParse.call(this);
			}
			if (isStrict) {
				return this._monthsStrictRegex;
			} else {
				return this._monthsRegex;
			}
		} else {
			return this._monthsStrictRegex && isStrict ?
								this._monthsStrictRegex : this._monthsRegex;
		}
	}

	function computeMonthsParse() {
		function cmpLenRev(a, b) {
			return b.length - a.length;
		}

		var shortPieces = [], longPieces = [], mixedPieces = [],
			i, mom;
		for (i = 0; i < 12; i++) {
						// make the regex if we don't have it already
			mom = create_utc__createUTC([2000, i]);
			shortPieces.push(this.monthsShort(mom, ''));
			longPieces.push(this.months(mom, ''));
			mixedPieces.push(this.months(mom, ''));
			mixedPieces.push(this.monthsShort(mom, ''));
		}
				// Sorting makes sure if one month (or abbr) is a prefix of another it
				// will match the longer piece.
		shortPieces.sort(cmpLenRev);
		longPieces.sort(cmpLenRev);
		mixedPieces.sort(cmpLenRev);
		for (i = 0; i < 12; i++) {
			shortPieces[i] = regexEscape(shortPieces[i]);
			longPieces[i] = regexEscape(longPieces[i]);
			mixedPieces[i] = regexEscape(mixedPieces[i]);
		}

		this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		this._monthsShortRegex = this._monthsRegex;
		this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
		this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
	}

	function checkOverflow(m) {
		var overflow;
		var a = m._a;

		if (a && getParsingFlags(m).overflow === -2) {
			overflow =
								a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
								a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
								a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
								a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
								a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
								a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
								-1;

			if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
				overflow = DATE;
			}
			if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
				overflow = WEEK;
			}
			if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
				overflow = WEEKDAY;
			}

			getParsingFlags(m).overflow = overflow;
		}

		return m;
	}

		// iso 8601 regex
		// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
				['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
				['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
				['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
				['GGGG-[W]WW', /\d{4}-W\d\d/, false],
				['YYYY-DDD', /\d{4}-\d{3}/],
				['YYYY-MM', /\d{4}-\d\d/, false],
				['YYYYYYMMDD', /[+-]\d{10}/],
				['YYYYMMDD', /\d{8}/],
				// YYYYMM is NOT allowed by the standard
				['GGGG[W]WWE', /\d{4}W\d{3}/],
				['GGGG[W]WW', /\d{4}W\d{2}/, false],
				['YYYYDDD', /\d{7}/]
	];

		// iso time formats and regexes
	var isoTimes = [
				['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
				['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
				['HH:mm:ss', /\d\d:\d\d:\d\d/],
				['HH:mm', /\d\d:\d\d/],
				['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
				['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
				['HHmmss', /\d\d\d\d\d\d/],
				['HHmm', /\d\d\d\d/],
				['HH', /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

		// date from iso format
	function configFromISO(config) {
		var i, l,
			string = config._i,
			match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
			allowTime, dateFormat, timeFormat, tzFormat;

		if (match) {
			getParsingFlags(config).iso = true;

			for (i = 0, l = isoDates.length; i < l; i++) {
				if (isoDates[i][1].exec(match[1])) {
					dateFormat = isoDates[i][0];
					allowTime = isoDates[i][2] !== false;
					break;
				}
			}
			if (dateFormat == null) {
				config._isValid = false;
				return;
			}
			if (match[3]) {
				for (i = 0, l = isoTimes.length; i < l; i++) {
					if (isoTimes[i][1].exec(match[3])) {
												// match[2] should be 'T' or space
						timeFormat = (match[2] || ' ') + isoTimes[i][0];
						break;
					}
				}
				if (timeFormat == null) {
					config._isValid = false;
					return;
				}
			}
			if (!allowTime && timeFormat != null) {
				config._isValid = false;
				return;
			}
			if (match[4]) {
				if (tzRegex.exec(match[4])) {
					tzFormat = 'Z';
				} else {
					config._isValid = false;
					return;
				}
			}
			config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
			configFromStringAndFormat(config);
		} else {
			config._isValid = false;
		}
	}

		// date from iso format or fallback
	function configFromString(config) {
		var matched = aspNetJsonRegex.exec(config._i);

		if (matched !== null) {
			config._d = new Date(+matched[1]);
			return;
		}

		configFromISO(config);
		if (config._isValid === false) {
			delete config._isValid;
			utils_hooks__hooks.createFromInputFallback(config);
		}
	}

	utils_hooks__hooks.createFromInputFallback = deprecate(
				'moment construction falls back to js Date. This is ' +
				'discouraged and will be removed in upcoming major ' +
				'release. Please refer to ' +
				'https://github.com/moment/moment/issues/1407 for more info.',
				function(config) {
	config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
}
		);

	function createDate(y, m, d, h, M, s, ms) {
				// can't just apply() to create a date:
				// http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
		var date = new Date(y, m, d, h, M, s, ms);

				// the date constructor remaps years 0-99 to 1900-1999
		if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
			date.setFullYear(y);
		}
		return date;
	}

	function createUTCDate(y) {
		var date = new Date(Date.UTC.apply(null, arguments));

				// the Date.UTC function remaps years 0-99 to 1900-1999
		if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
			date.setUTCFullYear(y);
		}
		return date;
	}

		// FORMATTING

	addFormatToken('Y', 0, 0, function() {
		var y = this.year();
		return y <= 9999 ? '' + y : '+' + y;
	});

	addFormatToken(0, ['YY', 2], 0, function() {
		return this.year() % 100;
	});

	addFormatToken(0, ['YYYY', 4], 0, 'year');
	addFormatToken(0, ['YYYYY', 5], 0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

		// ALIASES

	addUnitAlias('year', 'y');

		// PARSING

	addRegexToken('Y', matchSigned);
	addRegexToken('YY', match1to2, match2);
	addRegexToken('YYYY', match1to4, match4);
	addRegexToken('YYYYY', match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);

	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function(input, array) {
		array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function(input, array) {
		array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function(input, array) {
		array[YEAR] = parseInt(input, 10);
	});

		// HELPERS

	function daysInYear(year) {
		return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
		return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

		// HOOKS

	utils_hooks__hooks.parseTwoDigitYear = function(input) {
		return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};

		// MOMENTS

	var getSetYear = makeGetSet('FullYear', false);

	function getIsLeapYear() {
		return isLeapYear(this.year());
	}

		// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
		var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
			fwd = 7 + dow - doy,
						// first-week day local weekday -- which local weekday is fwd
			fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

		return -fwdlw + fwd - 1;
	}

		// http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
		var localWeekday = (7 + weekday - dow) % 7,
			weekOffset = firstWeekOffset(year, dow, doy),
			dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
			resYear, resDayOfYear;

		if (dayOfYear <= 0) {
			resYear = year - 1;
			resDayOfYear = daysInYear(resYear) + dayOfYear;
		} else if (dayOfYear > daysInYear(year)) {
			resYear = year + 1;
			resDayOfYear = dayOfYear - daysInYear(year);
		} else {
			resYear = year;
			resDayOfYear = dayOfYear;
		}

		return {
			year: resYear,
			dayOfYear: resDayOfYear
		};
	}

	function weekOfYear(mom, dow, doy) {
		var weekOffset = firstWeekOffset(mom.year(), dow, doy),
			week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
			resWeek, resYear;

		if (week < 1) {
			resYear = mom.year() - 1;
			resWeek = week + weeksInYear(resYear, dow, doy);
		} else if (week > weeksInYear(mom.year(), dow, doy)) {
			resWeek = week - weeksInYear(mom.year(), dow, doy);
			resYear = mom.year() + 1;
		} else {
			resYear = mom.year();
			resWeek = week;
		}

		return {
			week: resWeek,
			year: resYear
		};
	}

	function weeksInYear(year, dow, doy) {
		var weekOffset = firstWeekOffset(year, dow, doy),
			weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
		return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

		// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
		if (a != null) {
			return a;
		}
		if (b != null) {
			return b;
		}
		return c;
	}

	function currentDateArray(config) {
				// hooks is actually the exported moment object
		var nowValue = new Date(utils_hooks__hooks.now());
		if (config._useUTC) {
			return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
		}
		return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

		// convert an array to a date.
		// the array should mirror the parameters below
		// note: all values past the year are optional and will default to the lowest possible value.
		// [year, month, day , hour, minute, second, millisecond]
	function configFromArray(config) {
		var i, date, input = [], currentDate, yearToUse;

		if (config._d) {
			return;
		}

		currentDate = currentDateArray(config);

				// compute day of the year from weeks and weekdays
		if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
			dayOfYearFromWeekInfo(config);
		}

				// if the day of the year is set, figure out what it is
		if (config._dayOfYear) {
			yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

			if (config._dayOfYear > daysInYear(yearToUse)) {
				getParsingFlags(config)._overflowDayOfYear = true;
			}

			date = createUTCDate(yearToUse, 0, config._dayOfYear);
			config._a[MONTH] = date.getUTCMonth();
			config._a[DATE] = date.getUTCDate();
		}

				// Default to current date.
				// * if no year, month, day of month are given, default to today
				// * if day of month is given, default month and year
				// * if month is given, default only year
				// * if year is given, don't default anything
		for (i = 0; i < 3 && config._a[i] == null; ++i) {
			config._a[i] = input[i] = currentDate[i];
		}

				// Zero out whatever was not defaulted, including time
		for (; i < 7; i++) {
			config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
		}

				// Check for 24:00:00.000
		if (config._a[HOUR] === 24 &&
								config._a[MINUTE] === 0 &&
								config._a[SECOND] === 0 &&
								config._a[MILLISECOND] === 0) {
			config._nextDay = true;
			config._a[HOUR] = 0;
		}

		config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
				// Apply timezone offset from input. The actual utcOffset can be changed
				// with parseZone.
		if (config._tzm != null) {
			config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
		}

		if (config._nextDay) {
			config._a[HOUR] = 24;
		}
	}

	function dayOfYearFromWeekInfo(config) {
		var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

		w = config._w;
		if (w.GG != null || w.W != null || w.E != null) {
			dow = 1;
			doy = 4;

						// TODO: We need to take the current isoWeekYear, but that depends on
						// how we interpret now (local, utc, fixed offset). So create
						// a now version of current config (take local/utc/offset flags, and
						// create now).
			weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
			week = defaults(w.W, 1);
			weekday = defaults(w.E, 1);
			if (weekday < 1 || weekday > 7) {
				weekdayOverflow = true;
			}
		} else {
			dow = config._locale._week.dow;
			doy = config._locale._week.doy;

			weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
			week = defaults(w.w, 1);

			if (w.d != null) {
								// weekday -- low day numbers are considered next week
				weekday = w.d;
				if (weekday < 0 || weekday > 6) {
					weekdayOverflow = true;
				}
			} else if (w.e != null) {
								// local weekday -- counting starts from begining of week
				weekday = w.e + dow;
				if (w.e < 0 || w.e > 6) {
					weekdayOverflow = true;
				}
			} else {
								// default to begining of week
				weekday = dow;
			}
		}
		if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
			getParsingFlags(config)._overflowWeeks = true;
		} else if (weekdayOverflow != null) {
			getParsingFlags(config)._overflowWeekday = true;
		} else {
			temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
			config._a[YEAR] = temp.year;
			config._dayOfYear = temp.dayOfYear;
		}
	}

		// constant that refers to the ISO standard
	utils_hooks__hooks.ISO_8601 = function() {};

		// date from string and format string
	function configFromStringAndFormat(config) {
				// TODO: Move this to another part of the creation flow to prevent circular deps
		if (config._f === utils_hooks__hooks.ISO_8601) {
			configFromISO(config);
			return;
		}

		config._a = [];
		getParsingFlags(config).empty = true;

				// This array is used to make a Date, either with `new Date` or `Date.UTC`
		var string = '' + config._i,
			i, parsedInput, tokens, token, skipped,
			stringLength = string.length,
			totalParsedInputLength = 0;

		tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

		for (i = 0; i < tokens.length; i++) {
			token = tokens[i];
			parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
						// console.log('token', token, 'parsedInput', parsedInput,
						//				 'regex', getParseRegexForToken(token, config));
			if (parsedInput) {
				skipped = string.substr(0, string.indexOf(parsedInput));
				if (skipped.length > 0) {
					getParsingFlags(config).unusedInput.push(skipped);
				}
				string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
				totalParsedInputLength += parsedInput.length;
			}
						// don't parse if it's not a known token
			if (formatTokenFunctions[token]) {
				if (parsedInput) {
					getParsingFlags(config).empty = false;
				}				else {
					getParsingFlags(config).unusedTokens.push(token);
				}
				addTimeToArrayFromToken(token, parsedInput, config);
			}			else if (config._strict && !parsedInput) {
				getParsingFlags(config).unusedTokens.push(token);
			}
		}

				// add remaining unparsed input length to the string
		getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
		if (string.length > 0) {
			getParsingFlags(config).unusedInput.push(string);
		}

				// clear _12h flag if hour is <= 12
		if (getParsingFlags(config).bigHour === true &&
								config._a[HOUR] <= 12 &&
								config._a[HOUR] > 0) {
			getParsingFlags(config).bigHour = undefined;
		}
				// handle meridiem
		config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

		configFromArray(config);
		checkOverflow(config);
	}

	function meridiemFixWrap(locale, hour, meridiem) {
		var isPm;

		if (meridiem == null) {
						// nothing to do
			return hour;
		}
		if (locale.meridiemHour != null) {
			return locale.meridiemHour(hour, meridiem);
		} else if (locale.isPM != null) {
						// Fallback
			isPm = locale.isPM(meridiem);
			if (isPm && hour < 12) {
				hour += 12;
			}
			if (!isPm && hour === 12) {
				hour = 0;
			}
			return hour;
		} else {
						// this is not supposed to happen
			return hour;
		}
	}

		// date from string and array of format strings
	function configFromStringAndArray(config) {
		var tempConfig,
			bestMoment,

			scoreToBeat,
			i,
			currentScore;

		if (config._f.length === 0) {
			getParsingFlags(config).invalidFormat = true;
			config._d = new Date(NaN);
			return;
		}

		for (i = 0; i < config._f.length; i++) {
			currentScore = 0;
			tempConfig = copyConfig({}, config);
			if (config._useUTC != null) {
				tempConfig._useUTC = config._useUTC;
			}
			tempConfig._f = config._f[i];
			configFromStringAndFormat(tempConfig);

			if (!valid__isValid(tempConfig)) {
				continue;
			}

						// if there is any input that was not parsed add a penalty for that format
			currentScore += getParsingFlags(tempConfig).charsLeftOver;

						// or tokens
			currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

			getParsingFlags(tempConfig).score = currentScore;

			if (scoreToBeat == null || currentScore < scoreToBeat) {
				scoreToBeat = currentScore;
				bestMoment = tempConfig;
			}
		}

		extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
		if (config._d) {
			return;
		}

		var i = normalizeObjectUnits(config._i);
		config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
			return obj && parseInt(obj, 10);
		});

		configFromArray(config);
	}

	function createFromConfig(config) {
		var res = new Moment(checkOverflow(prepareConfig(config)));
		if (res._nextDay) {
						// Adding is smart enough around DST
			res.add(1, 'd');
			res._nextDay = undefined;
		}

		return res;
	}

	function prepareConfig(config) {
		var input = config._i,
			format = config._f;

		config._locale = config._locale || locale_locales__getLocale(config._l);

		if (input === null || (format === undefined && input === '')) {
			return valid__createInvalid({nullInput: true});
		}

		if (typeof input === 'string') {
			config._i = input = config._locale.preparse(input);
		}

		if (isMoment(input)) {
			return new Moment(checkOverflow(input));
		} else if (isArray(format)) {
			configFromStringAndArray(config);
		} else if (format) {
			configFromStringAndFormat(config);
		} else if (isDate(input)) {
			config._d = input;
		} else {
			configFromInput(config);
		}

		if (!valid__isValid(config)) {
			config._d = null;
		}

		return config;
	}

	function configFromInput(config) {
		var input = config._i;
		if (input === undefined) {
			config._d = new Date(utils_hooks__hooks.now());
		} else if (isDate(input)) {
			config._d = new Date(+input);
		} else if (typeof input === 'string') {
			configFromString(config);
		} else if (isArray(input)) {
			config._a = map(input.slice(0), function(obj) {
				return parseInt(obj, 10);
			});
			configFromArray(config);
		} else if (typeof (input) === 'object') {
			configFromObject(config);
		} else if (typeof (input) === 'number') {
						// from milliseconds
			config._d = new Date(input);
		} else {
			utils_hooks__hooks.createFromInputFallback(config);
		}
	}

	function createLocalOrUTC(input, format, locale, strict, isUTC) {
		var c = {};

		if (typeof (locale) === 'boolean') {
			strict = locale;
			locale = undefined;
		}
				// object construction must be done this way.
				// https://github.com/moment/moment/issues/1423
		c._isAMomentObject = true;
		c._useUTC = c._isUTC = isUTC;
		c._l = locale;
		c._i = input;
		c._f = format;
		c._strict = strict;

		return createFromConfig(c);
	}

	function local__createLocal(input, format, locale, strict) {
		return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
				 'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
				 function() {
	var other = local__createLocal.apply(null, arguments);
	if (this.isValid() && other.isValid()) {
		return other < this ? this : other;
	} else {
		return valid__createInvalid();
	}
}
		 );

	var prototypeMax = deprecate(
				'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
				function() {
	var other = local__createLocal.apply(null, arguments);
	if (this.isValid() && other.isValid()) {
		return other > this ? this : other;
	} else {
		return valid__createInvalid();
	}
}
		);

		// Pick a moment m from moments so that m[fn](other) is true for all
		// other. This relies on the function fn to be transitive.
		//
		// moments should either be an array of moment objects or an array, whose
		// first element is an array of moment objects.
	function pickBy(fn, moments) {
		var res, i;
		if (moments.length === 1 && isArray(moments[0])) {
			moments = moments[0];
		}
		if (!moments.length) {
			return local__createLocal();
		}
		res = moments[0];
		for (i = 1; i < moments.length; ++i) {
			if (!moments[i].isValid() || moments[i][fn](res)) {
				res = moments[i];
			}
		}
		return res;
	}

		// TODO: Use [].sort instead?
	function min() {
		var args = [].slice.call(arguments, 0);

		return pickBy('isBefore', args);
	}

	function max() {
		var args = [].slice.call(arguments, 0);

		return pickBy('isAfter', args);
	}

	var now = function() {
		return Date.now ? Date.now() : +(new Date());
	};

	function Duration(duration) {
		var normalizedInput = normalizeObjectUnits(duration),
			years = normalizedInput.year || 0,
			quarters = normalizedInput.quarter || 0,
			months = normalizedInput.month || 0,
			weeks = normalizedInput.week || 0,
			days = normalizedInput.day || 0,
			hours = normalizedInput.hour || 0,
			minutes = normalizedInput.minute || 0,
			seconds = normalizedInput.second || 0,
			milliseconds = normalizedInput.millisecond || 0;

				// representation for dateAddRemove
		this._milliseconds = +milliseconds +
						seconds * 1e3 + // 1000
						minutes * 6e4 + // 1000 * 60
						hours * 36e5; // 1000 * 60 * 60
				// Because of dateAddRemove treats 24 hours as different from a
				// day when working around DST, we need to store them separately
		this._days = +days +
						weeks * 7;
				// It is impossible translate months into days without knowing
				// which months you are are talking about, so we have to store
				// it separately.
		this._months = +months +
						quarters * 3 +
						years * 12;

		this._data = {};

		this._locale = locale_locales__getLocale();

		this._bubble();
	}

	function isDuration(obj) {
		return obj instanceof Duration;
	}

		// FORMATTING

	function offset(token, separator) {
		addFormatToken(token, 0, 0, function() {
			var offset = this.utcOffset();
			var sign = '+';
			if (offset < 0) {
				offset = -offset;
				sign = '-';
			}
			return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
		});
	}

	offset('Z', ':');
	offset('ZZ', '');

		// PARSING

	addRegexToken('Z', matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function(input, array, config) {
		config._useUTC = true;
		config._tzm = offsetFromString(matchShortOffset, input);
	});

		// HELPERS

		// timezone chunker
		// '+10:00' > ['10',	'00']
		// '-1530'	> ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
		var matches = ((string || '').match(matcher) || []);
		var chunk = matches[matches.length - 1] || [];
		var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
		var minutes = +(parts[1] * 60) + toInt(parts[2]);

		return parts[0] === '+' ? minutes : -minutes;
	}

		// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
		var res, diff;
		if (model._isUTC) {
			res = model.clone();
			diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
						// Use low-level api, because this fn is low-level api.
			res._d.setTime(+res._d + diff);
			utils_hooks__hooks.updateOffset(res, false);
			return res;
		} else {
			return local__createLocal(input).local();
		}
	}

	function getDateOffset(m) {
				// On Firefox.24 Date#getTimezoneOffset returns a floating point.
				// https://github.com/moment/moment/pull/1871
		return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

		// HOOKS

		// This function will be called whenever a moment is mutated.
		// It is intended to keep the offset in sync with the timezone.
	utils_hooks__hooks.updateOffset = function() {};

		// MOMENTS

		// keepLocalTime = true means only change the timezone, without
		// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
		// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
		// +0200, so we adjust the time as needed, to be valid.
		//
		// Keeping the time actually adds/subtracts (one hour)
		// from the actual represented time. That is why we call updateOffset
		// a second time. In case it wants us to change the offset again
		// _changeInProgress == true case, then we have to adjust, because
		// there is no such time in the given timezone.
	function getSetOffset(input, keepLocalTime) {
		var offset = this._offset || 0,
			localAdjust;
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
		if (input != null) {
			if (typeof input === 'string') {
				input = offsetFromString(matchShortOffset, input);
			} else if (Math.abs(input) < 16) {
				input = input * 60;
			}
			if (!this._isUTC && keepLocalTime) {
				localAdjust = getDateOffset(this);
			}
			this._offset = input;
			this._isUTC = true;
			if (localAdjust != null) {
				this.add(localAdjust, 'm');
			}
			if (offset !== input) {
				if (!keepLocalTime || this._changeInProgress) {
					add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
				} else if (!this._changeInProgress) {
					this._changeInProgress = true;
					utils_hooks__hooks.updateOffset(this, true);
					this._changeInProgress = null;
				}
			}
			return this;
		} else {
			return this._isUTC ? offset : getDateOffset(this);
		}
	}

	function getSetZone(input, keepLocalTime) {
		if (input != null) {
			if (typeof input !== 'string') {
				input = -input;
			}

			this.utcOffset(input, keepLocalTime);

			return this;
		} else {
			return -this.utcOffset();
		}
	}

	function setOffsetToUTC(keepLocalTime) {
		return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal(keepLocalTime) {
		if (this._isUTC) {
			this.utcOffset(0, keepLocalTime);
			this._isUTC = false;

			if (keepLocalTime) {
				this.subtract(getDateOffset(this), 'm');
			}
		}
		return this;
	}

	function setOffsetToParsedOffset() {
		if (this._tzm) {
			this.utcOffset(this._tzm);
		} else if (typeof this._i === 'string') {
			this.utcOffset(offsetFromString(matchOffset, this._i));
		}
		return this;
	}

	function hasAlignedHourOffset(input) {
		if (!this.isValid()) {
			return false;
		}
		input = input ? local__createLocal(input).utcOffset() : 0;

		return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime() {
		return (
						this.utcOffset() > this.clone().month(0).utcOffset() ||
						this.utcOffset() > this.clone().month(5).utcOffset()
		);
	}

	function isDaylightSavingTimeShifted() {
		if (!isUndefined(this._isDSTShifted)) {
			return this._isDSTShifted;
		}

		var c = {};

		copyConfig(c, this);
		c = prepareConfig(c);

		if (c._a) {
			var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
			this._isDSTShifted = this.isValid() &&
								compareArrays(c._a, other.toArray()) > 0;
		} else {
			this._isDSTShifted = false;
		}

		return this._isDSTShifted;
	}

	function isLocal() {
		return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset() {
		return this.isValid() ? this._isUTC : false;
	}

	function isUtc() {
		return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}

		// ASP.NET json date format regex
	var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

		// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
		// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
		// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-)?P(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)W)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?$/;

	function create__createDuration(input, key) {
		var duration = input,
						// matching against regexp is expensive, do it on demand
			match = null,
			sign,
			ret,
			diffRes;

		if (isDuration(input)) {
			duration = {
				ms: input._milliseconds,
				d: input._days,
				M: input._months
			};
		} else if (typeof input === 'number') {
			duration = {};
			if (key) {
				duration[key] = input;
			} else {
				duration.milliseconds = input;
			}
		} else if (match = aspNetRegex.exec(input)) {
			sign = (match[1] === '-') ? -1 : 1;
			duration = {
				y: 0,
				d: toInt(match[DATE]) * sign,
				h: toInt(match[HOUR]) * sign,
				m: toInt(match[MINUTE]) * sign,
				s: toInt(match[SECOND]) * sign,
				ms: toInt(match[MILLISECOND]) * sign
			};
		} else if (match = isoRegex.exec(input)) {
			sign = (match[1] === '-') ? -1 : 1;
			duration = {
				y: parseIso(match[2], sign),
				M: parseIso(match[3], sign),
				w: parseIso(match[4], sign),
				d: parseIso(match[5], sign),
				h: parseIso(match[6], sign),
				m: parseIso(match[7], sign),
				s: parseIso(match[8], sign)
			};
		} else if (duration == null) { // checks for null or undefined
			duration = {};
		} else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
			diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

			duration = {};
			duration.ms = diffRes.milliseconds;
			duration.M = diffRes.months;
		}

		ret = new Duration(duration);

		if (isDuration(input) && hasOwnProp(input, '_locale')) {
			ret._locale = input._locale;
		}

		return ret;
	}

	create__createDuration.fn = Duration.prototype;

	function parseIso(inp, sign) {
				// We'd normally use ~~inp for this, but unfortunately it also
				// converts floats to ints.
				// inp may be undefined, so careful calling replace on it.
		var res = inp && parseFloat(inp.replace(',', '.'));
				// apply sign while we're at it
		return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
		var res = {milliseconds: 0, months: 0};

		res.months = other.month() - base.month() +
						(other.year() - base.year()) * 12;
		if (base.clone().add(res.months, 'M').isAfter(other)) {
			--res.months;
		}

		res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

		return res;
	}

	function momentsDifference(base, other) {
		var res;
		if (!(base.isValid() && other.isValid())) {
			return {milliseconds: 0, months: 0};
		}

		other = cloneWithOffset(other, base);
		if (base.isBefore(other)) {
			res = positiveMomentsDifference(base, other);
		} else {
			res = positiveMomentsDifference(other, base);
			res.milliseconds = -res.milliseconds;
			res.months = -res.months;
		}

		return res;
	}

	function absRound(number) {
		if (number < 0) {
			return Math.round(-1 * number) * -1;
		} else {
			return Math.round(number);
		}
	}

		// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
		return function(val, period) {
			var dur, tmp;
						// invert the arguments, but complain about it
			if (period !== null && !isNaN(+period)) {
				deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
				tmp = val; val = period; period = tmp;
			}

			val = typeof val === 'string' ? +val : val;
			dur = create__createDuration(val, period);
			add_subtract__addSubtract(this, dur, direction);
			return this;
		};
	}

	function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
		var milliseconds = duration._milliseconds,
			days = absRound(duration._days),
			months = absRound(duration._months);

		if (!mom.isValid()) {
						// No op
			return;
		}

		updateOffset = updateOffset == null ? true : updateOffset;

		if (milliseconds) {
			mom._d.setTime(+mom._d + milliseconds * isAdding);
		}
		if (days) {
			get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
		}
		if (months) {
			setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
		}
		if (updateOffset) {
			utils_hooks__hooks.updateOffset(mom, days || months);
		}
	}

	var add_subtract__add = createAdder(1, 'add');
	var add_subtract__subtract = createAdder(-1, 'subtract');

	function moment_calendar__calendar(time, formats) {
				// We want to compare the start of today, vs this.
				// Getting start-of-today depends on whether we're local/utc/offset or not.
		var now = time || local__createLocal(),
			sod = cloneWithOffset(now, this).startOf('day'),
			diff = this.diff(sod, 'days', true),
			format = diff < -6 ? 'sameElse' :
								diff < -1 ? 'lastWeek' :
								diff < 0 ? 'lastDay' :
								diff < 1 ? 'sameDay' :
								diff < 2 ? 'nextDay' :
								diff < 7 ? 'nextWeek' : 'sameElse';

		var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

		return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	}

	function clone() {
		return new Moment(this);
	}

	function isAfter(input, units) {
		var localInput = isMoment(input) ? input : local__createLocal(input);
		if (!(this.isValid() && localInput.isValid())) {
			return false;
		}
		units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
		if (units === 'millisecond') {
			return +this > +localInput;
		} else {
			return +localInput < +this.clone().startOf(units);
		}
	}

	function isBefore(input, units) {
		var localInput = isMoment(input) ? input : local__createLocal(input);
		if (!(this.isValid() && localInput.isValid())) {
			return false;
		}
		units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
		if (units === 'millisecond') {
			return +this < +localInput;
		} else {
			return +this.clone().endOf(units) < +localInput;
		}
	}

	function isBetween(from, to, units) {
		return this.isAfter(from, units) && this.isBefore(to, units);
	}

	function isSame(input, units) {
		var localInput = isMoment(input) ? input : local__createLocal(input),
			inputMs;
		if (!(this.isValid() && localInput.isValid())) {
			return false;
		}
		units = normalizeUnits(units || 'millisecond');
		if (units === 'millisecond') {
			return +this === +localInput;
		} else {
			inputMs = +localInput;
			return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
		}
	}

	function isSameOrAfter(input, units) {
		return this.isSame(input, units) || this.isAfter(input, units);
	}

	function isSameOrBefore(input, units) {
		return this.isSame(input, units) || this.isBefore(input, units);
	}

	function diff(input, units, asFloat) {
		var that,
			zoneDelta,
			delta, output;

		if (!this.isValid()) {
			return NaN;
		}

		that = cloneWithOffset(input, this);

		if (!that.isValid()) {
			return NaN;
		}

		zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

		units = normalizeUnits(units);

		if (units === 'year' || units === 'month' || units === 'quarter') {
			output = monthDiff(this, that);
			if (units === 'quarter') {
				output = output / 3;
			} else if (units === 'year') {
				output = output / 12;
			}
		} else {
			delta = this - that;
			output = units === 'second' ? delta / 1e3 : // 1000
								units === 'minute' ? delta / 6e4 : // 1000 * 60
								units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
								units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
								units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
								delta;
		}
		return asFloat ? output : absFloor(output);
	}

	function monthDiff(a, b) {
				// difference in months
		var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
						// b is in (anchor - 1 month, anchor + 1 month)
			anchor = a.clone().add(wholeMonthDiff, 'months'),
			anchor2, adjust;

		if (b - anchor < 0) {
			anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
						// linear across the month
			adjust = (b - anchor) / (anchor - anchor2);
		} else {
			anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
						// linear across the month
			adjust = (b - anchor) / (anchor2 - anchor);
		}

		return -(wholeMonthDiff + adjust);
	}

	utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

	function toString() {
		return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}

	function moment_format__toISOString() {
		var m = this.clone().utc();
		if (m.year() > 0 && m.year() <= 9999) {
			if (isFunction(Date.prototype.toISOString)) {
								// native implementation is ~50x faster, use it when we can
				return this.toDate().toISOString();
			} else {
				return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
			}
		} else {
			return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
		}
	}

	function format(inputString) {
		var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
		return this.localeData().postformat(output);
	}

	function from(time, withoutSuffix) {
		if (this.isValid() &&
								((isMoment(time) && time.isValid()) ||
								 local__createLocal(time).isValid())) {
			return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
		} else {
			return this.localeData().invalidDate();
		}
	}

	function fromNow(withoutSuffix) {
		return this.from(local__createLocal(), withoutSuffix);
	}

	function to(time, withoutSuffix) {
		if (this.isValid() &&
								((isMoment(time) && time.isValid()) ||
								 local__createLocal(time).isValid())) {
			return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
		} else {
			return this.localeData().invalidDate();
		}
	}

	function toNow(withoutSuffix) {
		return this.to(local__createLocal(), withoutSuffix);
	}

		// If passed a locale key, it will set the locale for this
		// instance.	Otherwise, it will return the locale configuration
		// variables for this instance.
	function locale(key) {
		var newLocaleData;

		if (key === undefined) {
			return this._locale._abbr;
		} else {
			newLocaleData = locale_locales__getLocale(key);
			if (newLocaleData != null) {
				this._locale = newLocaleData;
			}
			return this;
		}
	}

	var lang = deprecate(
				'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
				function(key) {
	if (key === undefined) {
		return this.localeData();
	} else {
		return this.locale(key);
	}
}
		);

	function localeData() {
		return this._locale;
	}

	function startOf(units) {
		units = normalizeUnits(units);
				// the following switch intentionally omits break keywords
				// to utilize falling through the cases.
		switch (units) {
			case 'year':
				this.month(0);
						/* falls through */
			case 'quarter':
			case 'month':
				this.date(1);
						/* falls through */
			case 'week':
			case 'isoWeek':
			case 'day':
				this.hours(0);
						/* falls through */
			case 'hour':
				this.minutes(0);
						/* falls through */
			case 'minute':
				this.seconds(0);
						/* falls through */
			case 'second':
				this.milliseconds(0);
		}

				// weeks are a special case
		if (units === 'week') {
			this.weekday(0);
		}
		if (units === 'isoWeek') {
			this.isoWeekday(1);
		}

				// quarters are also special
		if (units === 'quarter') {
			this.month(Math.floor(this.month() / 3) * 3);
		}

		return this;
	}

	function endOf(units) {
		units = normalizeUnits(units);
		if (units === undefined || units === 'millisecond') {
			return this;
		}
		return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	}

	function to_type__valueOf() {
		return +this._d - ((this._offset || 0) * 60000);
	}

	function unix() {
		return Math.floor(+this / 1000);
	}

	function toDate() {
		return this._offset ? new Date(+this) : this._d;
	}

	function toArray() {
		var m = this;
		return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject() {
		var m = this;
		return {
			years: m.year(),
			months: m.month(),
			date: m.date(),
			hours: m.hours(),
			minutes: m.minutes(),
			seconds: m.seconds(),
			milliseconds: m.milliseconds()
		};
	}

	function toJSON() {
				// new Date(NaN).toJSON() === null
		return this.isValid() ? this.toISOString() : null;
	}

	function moment_valid__isValid() {
		return valid__isValid(this);
	}

	function parsingFlags() {
		return extend({}, getParsingFlags(this));
	}

	function invalidAt() {
		return getParsingFlags(this).overflow;
	}

	function creationData() {
		return {
			input: this._i,
			format: this._f,
			locale: this._locale,
			isUTC: this._isUTC,
			strict: this._strict
		};
	}

		// FORMATTING

	addFormatToken(0, ['gg', 2], 0, function() {
		return this.weekYear() % 100;
	});

	addFormatToken(0, ['GG', 2], 0, function() {
		return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken(token, getter) {
		addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken('gggg', 'weekYear');
	addWeekYearFormatToken('ggggg', 'weekYear');
	addWeekYearFormatToken('GGGG', 'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');

		// ALIASES

	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');

		// PARSING

	addRegexToken('G', matchSigned);
	addRegexToken('g', matchSigned);
	addRegexToken('GG', match1to2, match2);
	addRegexToken('gg', match1to2, match2);
	addRegexToken('GGGG', match1to4, match4);
	addRegexToken('gggg', match1to4, match4);
	addRegexToken('GGGGG', match1to6, match6);
	addRegexToken('ggggg', match1to6, match6);

	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
		week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
		week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	});

		// MOMENTS

	function getSetWeekYear(input) {
		return getSetWeekYearHelper.call(this,
								input,
								this.week(),
								this.weekday(),
								this.localeData()._week.dow,
								this.localeData()._week.doy);
	}

	function getSetISOWeekYear(input) {
		return getSetWeekYearHelper.call(this,
								input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear() {
		return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear() {
		var weekInfo = this.localeData()._week;
		return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
		var weeksTarget;
		if (input == null) {
			return weekOfYear(this, dow, doy).year;
		} else {
			weeksTarget = weeksInYear(input, dow, doy);
			if (week > weeksTarget) {
				week = weeksTarget;
			}
			return setWeekAll.call(this, input, week, weekday, dow, doy);
		}
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
		var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
			date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

		this.year(date.getUTCFullYear());
		this.month(date.getUTCMonth());
		this.date(date.getUTCDate());
		return this;
	}

		// FORMATTING

	addFormatToken('Q', 0, 'Qo', 'quarter');

		// ALIASES

	addUnitAlias('quarter', 'Q');

		// PARSING

	addRegexToken('Q', match1);
	addParseToken('Q', function(input, array) {
		array[MONTH] = (toInt(input) - 1) * 3;
	});

		// MOMENTS

	function getSetQuarter(input) {
		return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

		// FORMATTING

	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

		// ALIASES

	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');

		// PARSING

	addRegexToken('w', match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W', match1to2);
	addRegexToken('WW', match1to2, match2);

	addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
		week[token.substr(0, 1)] = toInt(input);
	});

		// HELPERS

		// LOCALES

	function localeWeek(mom) {
		return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
		dow: 0, // Sunday is the first day of the week.
		doy: 6	// The week that contains Jan 1st is the first week of the year.
	};

	function localeFirstDayOfWeek() {
		return this._week.dow;
	}

	function localeFirstDayOfYear() {
		return this._week.doy;
	}

		// MOMENTS

	function getSetWeek(input) {
		var week = this.localeData().week(this);
		return input == null ? week : this.add((input - week) * 7, 'd');
	}

	function getSetISOWeek(input) {
		var week = weekOfYear(this, 1, 4).week;
		return input == null ? week : this.add((input - week) * 7, 'd');
	}

		// FORMATTING

	addFormatToken('D', ['DD', 2], 'Do', 'date');

		// ALIASES

	addUnitAlias('date', 'D');

		// PARSING

	addRegexToken('D', match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function(isStrict, locale) {
		return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	});

	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function(input, array) {
		array[DATE] = toInt(input.match(match1to2)[0], 10);
	});

		// MOMENTS

	var getSetDayOfMonth = makeGetSet('Date', true);

		// FORMATTING

	addFormatToken('d', 0, 'do', 'day');

	addFormatToken('dd', 0, 0, function(format) {
		return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken('ddd', 0, 0, function(format) {
		return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken('dddd', 0, 0, function(format) {
		return this.localeData().weekdays(this, format);
	});

	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');

		// ALIASES

	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');

		// PARSING

	addRegexToken('d', match1to2);
	addRegexToken('e', match1to2);
	addRegexToken('E', match1to2);
	addRegexToken('dd', matchWord);
	addRegexToken('ddd', matchWord);
	addRegexToken('dddd', matchWord);

	addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
		var weekday = config._locale.weekdaysParse(input, token, config._strict);
				// if we didn't get a weekday name, mark the date as invalid
		if (weekday != null) {
			week.d = weekday;
		} else {
			getParsingFlags(config).invalidWeekday = input;
		}
	});

	addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
		week[token] = toInt(input);
	});

		// HELPERS

	function parseWeekday(input, locale) {
		if (typeof input !== 'string') {
			return input;
		}

		if (!isNaN(input)) {
			return parseInt(input, 10);
		}

		input = locale.weekdaysParse(input);
		if (typeof input === 'number') {
			return input;
		}

		return null;
	}

		// LOCALES

	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays(m, format) {
		return isArray(this._weekdays) ? this._weekdays[m.day()] :
						this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	}

	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort(m) {
		return this._weekdaysShort[m.day()];
	}

	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin(m) {
		return this._weekdaysMin[m.day()];
	}

	function localeWeekdaysParse(weekdayName, format, strict) {
		var i, mom, regex;

		if (!this._weekdaysParse) {
			this._weekdaysParse = [];
			this._minWeekdaysParse = [];
			this._shortWeekdaysParse = [];
			this._fullWeekdaysParse = [];
		}

		for (i = 0; i < 7; i++) {
						// make the regex if we don't have it already

			mom = local__createLocal([2000, 1]).day(i);
			if (strict && !this._fullWeekdaysParse[i]) {
				this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
				this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
				this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
			}
			if (!this._weekdaysParse[i]) {
				regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
				this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
			}
						// test the regex
			if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
				return i;
			} else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
				return i;
			} else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
				return i;
			} else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
				return i;
			}
		}
	}

		// MOMENTS

	function getSetDayOfWeek(input) {
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
		var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		if (input != null) {
			input = parseWeekday(input, this.localeData());
			return this.add(input - day, 'd');
		} else {
			return day;
		}
	}

	function getSetLocaleDayOfWeek(input) {
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
		var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
		return input == null ? weekday : this.add(input - weekday, 'd');
	}

	function getSetISODayOfWeek(input) {
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
				// behaves the same as moment#day except
				// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
				// as a setter, sunday should belong to the previous week.
		return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	}

		// FORMATTING

	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

		// ALIASES

	addUnitAlias('dayOfYear', 'DDD');

		// PARSING

	addRegexToken('DDD', match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function(input, array, config) {
		config._dayOfYear = toInt(input);
	});

		// HELPERS

		// MOMENTS

	function getSetDayOfYear(input) {
		var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
		return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}

		// FORMATTING

	function hFormat() {
		return this.hours() % 12 || 12;
	}

	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);

	addFormatToken('hmm', 0, 0, function() {
		return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken('hmmss', 0, 0, function() {
		return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
						zeroFill(this.seconds(), 2);
	});

	addFormatToken('Hmm', 0, 0, function() {
		return '' + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken('Hmmss', 0, 0, function() {
		return '' + this.hours() + zeroFill(this.minutes(), 2) +
						zeroFill(this.seconds(), 2);
	});

	function meridiem(token, lowercase) {
		addFormatToken(token, 0, 0, function() {
			return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
		});
	}

	meridiem('a', true);
	meridiem('A', false);

		// ALIASES

	addUnitAlias('hour', 'h');

		// PARSING

	function matchMeridiem(isStrict, locale) {
		return locale._meridiemParse;
	}

	addRegexToken('a', matchMeridiem);
	addRegexToken('A', matchMeridiem);
	addRegexToken('H', match1to2);
	addRegexToken('h', match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);

	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);

	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['a', 'A'], function(input, array, config) {
		config._isPm = config._locale.isPM(input);
		config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function(input, array, config) {
		array[HOUR] = toInt(input);
		getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function(input, array, config) {
		var pos = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos));
		array[MINUTE] = toInt(input.substr(pos));
		getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function(input, array, config) {
		var pos1 = input.length - 4;
		var pos2 = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos1));
		array[MINUTE] = toInt(input.substr(pos1, 2));
		array[SECOND] = toInt(input.substr(pos2));
		getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function(input, array, config) {
		var pos = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos));
		array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function(input, array, config) {
		var pos1 = input.length - 4;
		var pos2 = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos1));
		array[MINUTE] = toInt(input.substr(pos1, 2));
		array[SECOND] = toInt(input.substr(pos2));
	});

		// LOCALES

	function localeIsPM(input) {
				// IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
				// Using charAt should be more compatible.
		return ((input + '').toLowerCase().charAt(0) === 'p');
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem(hours, minutes, isLower) {
		if (hours > 11) {
			return isLower ? 'pm' : 'PM';
		} else {
			return isLower ? 'am' : 'AM';
		}
	}

		// MOMENTS

		// Setting the hour should keep the time, because the user explicitly
		// specified which hour he wants. So trying to maintain the same hour (in
		// a new timezone) makes sense. Adding/subtracting hours does not follow
		// this rule.
	var getSetHour = makeGetSet('Hours', true);

		// FORMATTING

	addFormatToken('m', ['mm', 2], 0, 'minute');

		// ALIASES

	addUnitAlias('minute', 'm');

		// PARSING

	addRegexToken('m', match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);

		// MOMENTS

	var getSetMinute = makeGetSet('Minutes', false);

		// FORMATTING

	addFormatToken('s', ['ss', 2], 0, 'second');

		// ALIASES

	addUnitAlias('second', 's');

		// PARSING

	addRegexToken('s', match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);

		// MOMENTS

	var getSetSecond = makeGetSet('Seconds', false);

		// FORMATTING

	addFormatToken('S', 0, 0, function() {
		return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, ['SS', 2], 0, function() {
		return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function() {
		return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function() {
		return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function() {
		return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function() {
		return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
		return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
		return this.millisecond() * 1000000;
	});

		// ALIASES

	addUnitAlias('millisecond', 'ms');

		// PARSING

	addRegexToken('S', match1to3, match1);
	addRegexToken('SS', match1to3, match2);
	addRegexToken('SSS', match1to3, match3);

	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
		addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
		array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}

	for (token = 'S'; token.length <= 9; token += 'S') {
		addParseToken(token, parseMs);
	}
		// MOMENTS

	var getSetMillisecond = makeGetSet('Milliseconds', false);

		// FORMATTING

	addFormatToken('z', 0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');

		// MOMENTS

	function getZoneAbbr() {
		return this._isUTC ? 'UTC' : '';
	}

	function getZoneName() {
		return this._isUTC ? 'Coordinated Universal Time' : '';
	}

	var momentPrototype__proto = Moment.prototype;

	momentPrototype__proto.add = add_subtract__add;
	momentPrototype__proto.calendar = moment_calendar__calendar;
	momentPrototype__proto.clone = clone;
	momentPrototype__proto.diff = diff;
	momentPrototype__proto.endOf = endOf;
	momentPrototype__proto.format = format;
	momentPrototype__proto.from = from;
	momentPrototype__proto.fromNow = fromNow;
	momentPrototype__proto.to = to;
	momentPrototype__proto.toNow = toNow;
	momentPrototype__proto.get = getSet;
	momentPrototype__proto.invalidAt = invalidAt;
	momentPrototype__proto.isAfter = isAfter;
	momentPrototype__proto.isBefore = isBefore;
	momentPrototype__proto.isBetween = isBetween;
	momentPrototype__proto.isSame = isSame;
	momentPrototype__proto.isSameOrAfter = isSameOrAfter;
	momentPrototype__proto.isSameOrBefore = isSameOrBefore;
	momentPrototype__proto.isValid = moment_valid__isValid;
	momentPrototype__proto.lang = lang;
	momentPrototype__proto.locale = locale;
	momentPrototype__proto.localeData = localeData;
	momentPrototype__proto.max = prototypeMax;
	momentPrototype__proto.min = prototypeMin;
	momentPrototype__proto.parsingFlags = parsingFlags;
	momentPrototype__proto.set = getSet;
	momentPrototype__proto.startOf = startOf;
	momentPrototype__proto.subtract = add_subtract__subtract;
	momentPrototype__proto.toArray = toArray;
	momentPrototype__proto.toObject = toObject;
	momentPrototype__proto.toDate = toDate;
	momentPrototype__proto.toISOString = moment_format__toISOString;
	momentPrototype__proto.toJSON = toJSON;
	momentPrototype__proto.toString = toString;
	momentPrototype__proto.unix = unix;
	momentPrototype__proto.valueOf = to_type__valueOf;
	momentPrototype__proto.creationData = creationData;

		// Year
	momentPrototype__proto.year = getSetYear;
	momentPrototype__proto.isLeapYear = getIsLeapYear;

		// Week Year
	momentPrototype__proto.weekYear = getSetWeekYear;
	momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

		// Quarter
	momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

		// Month
	momentPrototype__proto.month = getSetMonth;
	momentPrototype__proto.daysInMonth = getDaysInMonth;

		// Week
	momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
	momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
	momentPrototype__proto.weeksInYear = getWeeksInYear;
	momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

		// Day
	momentPrototype__proto.date = getSetDayOfMonth;
	momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
	momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
	momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	momentPrototype__proto.dayOfYear = getSetDayOfYear;

		// Hour
	momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

		// Minute
	momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

		// Second
	momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

		// Millisecond
	momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

		// Offset
	momentPrototype__proto.utcOffset = getSetOffset;
	momentPrototype__proto.utc = setOffsetToUTC;
	momentPrototype__proto.local = setOffsetToLocal;
	momentPrototype__proto.parseZone = setOffsetToParsedOffset;
	momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	momentPrototype__proto.isDST = isDaylightSavingTime;
	momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
	momentPrototype__proto.isLocal = isLocal;
	momentPrototype__proto.isUtcOffset = isUtcOffset;
	momentPrototype__proto.isUtc = isUtc;
	momentPrototype__proto.isUTC = isUtc;

		// Timezone
	momentPrototype__proto.zoneAbbr = getZoneAbbr;
	momentPrototype__proto.zoneName = getZoneName;

		// Deprecations
	momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

	var momentPrototype = momentPrototype__proto;

	function moment__createUnix(input) {
		return local__createLocal(input * 1000);
	}

	function moment__createInZone() {
		return local__createLocal.apply(null, arguments).parseZone();
	}

	var defaultCalendar = {
		sameDay: '[Today at] LT',
		nextDay: '[Tomorrow at] LT',
		nextWeek: 'dddd [at] LT',
		lastDay: '[Yesterday at] LT',
		lastWeek: '[Last] dddd [at] LT',
		sameElse: 'L'
	};

	function locale_calendar__calendar(key, mom, now) {
		var output = this._calendar[key];
		return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
		LTS: 'h:mm:ss A',
		LT: 'h:mm A',
		L: 'MM/DD/YYYY',
		LL: 'MMMM D, YYYY',
		LLL: 'MMMM D, YYYY h:mm A',
		LLLL: 'dddd, MMMM D, YYYY h:mm A'
	};

	function longDateFormat(key) {
		var format = this._longDateFormat[key],
			formatUpper = this._longDateFormat[key.toUpperCase()];

		if (format || !formatUpper) {
			return format;
		}

		this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
			return val.slice(1);
		});

		return this._longDateFormat[key];
	}

	var defaultInvalidDate = 'Invalid date';

	function invalidDate() {
		return this._invalidDate;
	}

	var defaultOrdinal = '%d';
	var defaultOrdinalParse = /\d{1,2}/;

	function ordinal(number) {
		return this._ordinal.replace('%d', number);
	}

	function preParsePostFormat(string) {
		return string;
	}

	var defaultRelativeTime = {
		future: 'in %s',
		past: '%s ago',
		s: 'a few seconds',
		m: 'a minute',
		mm: '%d minutes',
		h: 'an hour',
		hh: '%d hours',
		d: 'a day',
		dd: '%d days',
		M: 'a month',
		MM: '%d months',
		y: 'a year',
		yy: '%d years'
	};

	function relative__relativeTime(number, withoutSuffix, string, isFuture) {
		var output = this._relativeTime[string];
		return (isFunction(output)) ?
						output(number, withoutSuffix, string, isFuture) :
						output.replace(/%d/i, number);
	}

	function pastFuture(diff, output) {
		var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var prototype__proto = Locale.prototype;

	prototype__proto._calendar = defaultCalendar;
	prototype__proto.calendar = locale_calendar__calendar;
	prototype__proto._longDateFormat = defaultLongDateFormat;
	prototype__proto.longDateFormat = longDateFormat;
	prototype__proto._invalidDate = defaultInvalidDate;
	prototype__proto.invalidDate = invalidDate;
	prototype__proto._ordinal = defaultOrdinal;
	prototype__proto.ordinal = ordinal;
	prototype__proto._ordinalParse = defaultOrdinalParse;
	prototype__proto.preparse = preParsePostFormat;
	prototype__proto.postformat = preParsePostFormat;
	prototype__proto._relativeTime = defaultRelativeTime;
	prototype__proto.relativeTime = relative__relativeTime;
	prototype__proto.pastFuture = pastFuture;
	prototype__proto.set = locale_set__set;

		// Month
	prototype__proto.months = localeMonths;
	prototype__proto._months = defaultLocaleMonths;
	prototype__proto.monthsShort = localeMonthsShort;
	prototype__proto._monthsShort = defaultLocaleMonthsShort;
	prototype__proto.monthsParse = localeMonthsParse;
	prototype__proto._monthsRegex = defaultMonthsRegex;
	prototype__proto.monthsRegex = monthsRegex;
	prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
	prototype__proto.monthsShortRegex = monthsShortRegex;

		// Week
	prototype__proto.week = localeWeek;
	prototype__proto._week = defaultLocaleWeek;
	prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

		// Day of Week
	prototype__proto.weekdays = localeWeekdays;
	prototype__proto._weekdays = defaultLocaleWeekdays;
	prototype__proto.weekdaysMin = localeWeekdaysMin;
	prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
	prototype__proto.weekdaysShort = localeWeekdaysShort;
	prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	prototype__proto.weekdaysParse = localeWeekdaysParse;

		// Hours
	prototype__proto.isPM = localeIsPM;
	prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	prototype__proto.meridiem = localeMeridiem;

	function lists__get(format, index, field, setter) {
		var locale = locale_locales__getLocale();
		var utc = create_utc__createUTC().set(setter, index);
		return locale[field](utc, format);
	}

	function list(format, index, field, count, setter) {
		if (typeof format === 'number') {
			index = format;
			format = undefined;
		}

		format = format || '';

		if (index != null) {
			return lists__get(format, index, field, setter);
		}

		var i;
		var out = [];
		for (i = 0; i < count; i++) {
			out[i] = lists__get(format, i, field, setter);
		}
		return out;
	}

	function lists__listMonths(format, index) {
		return list(format, index, 'months', 12, 'month');
	}

	function lists__listMonthsShort(format, index) {
		return list(format, index, 'monthsShort', 12, 'month');
	}

	function lists__listWeekdays(format, index) {
		return list(format, index, 'weekdays', 7, 'day');
	}

	function lists__listWeekdaysShort(format, index) {
		return list(format, index, 'weekdaysShort', 7, 'day');
	}

	function lists__listWeekdaysMin(format, index) {
		return list(format, index, 'weekdaysMin', 7, 'day');
	}

	locale_locales__getSetGlobalLocale('en', {
		ordinalParse: /\d{1,2}(th|st|nd|rd)/,
		ordinal: function(number) {
			var b = number % 10,
				output = (toInt(number % 100 / 10) === 1) ? 'th' :
								(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
								(b === 3) ? 'rd' : 'th';
			return number + output;
		}
	});

		// Side effect imports
	utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

	var mathAbs = Math.abs;

	function duration_abs__abs() {
		var data = this._data;

		this._milliseconds = mathAbs(this._milliseconds);
		this._days = mathAbs(this._days);
		this._months = mathAbs(this._months);

		data.milliseconds = mathAbs(data.milliseconds);
		data.seconds = mathAbs(data.seconds);
		data.minutes = mathAbs(data.minutes);
		data.hours = mathAbs(data.hours);
		data.months = mathAbs(data.months);
		data.years = mathAbs(data.years);

		return this;
	}

	function duration_add_subtract__addSubtract(duration, input, value, direction) {
		var other = create__createDuration(input, value);

		duration._milliseconds += direction * other._milliseconds;
		duration._days += direction * other._days;
		duration._months += direction * other._months;

		return duration._bubble();
	}

		// supports only 2.0-style add(1, 's') or add(duration)
	function duration_add_subtract__add(input, value) {
		return duration_add_subtract__addSubtract(this, input, value, 1);
	}

		// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function duration_add_subtract__subtract(input, value) {
		return duration_add_subtract__addSubtract(this, input, value, -1);
	}

	function absCeil(number) {
		if (number < 0) {
			return Math.floor(number);
		} else {
			return Math.ceil(number);
		}
	}

	function bubble() {
		var milliseconds = this._milliseconds;
		var days = this._days;
		var months = this._months;
		var data = this._data;
		var seconds, minutes, hours, years, monthsFromDays;

				// if we have a mix of positive and negative values, bubble down first
				// check: https://github.com/moment/moment/issues/2166
		if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
								(milliseconds <= 0 && days <= 0 && months <= 0))) {
			milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
			days = 0;
			months = 0;
		}

				// The following code bubbles up values, see the tests for
				// examples of what that means.
		data.milliseconds = milliseconds % 1000;

		seconds = absFloor(milliseconds / 1000);
		data.seconds = seconds % 60;

		minutes = absFloor(seconds / 60);
		data.minutes = minutes % 60;

		hours = absFloor(minutes / 60);
		data.hours = hours % 24;

		days += absFloor(hours / 24);

				// convert days to months
		monthsFromDays = absFloor(daysToMonths(days));
		months += monthsFromDays;
		days -= absCeil(monthsToDays(monthsFromDays));

				// 12 months -> 1 year
		years = absFloor(months / 12);
		months %= 12;

		data.days = days;
		data.months = months;
		data.years = years;

		return this;
	}

	function daysToMonths(days) {
				// 400 years have 146097 days (taking into account leap year rules)
				// 400 years have 12 months === 4800
		return days * 4800 / 146097;
	}

	function monthsToDays(months) {
				// the reverse of daysToMonths
		return months * 146097 / 4800;
	}

	function as(units) {
		var days;
		var months;
		var milliseconds = this._milliseconds;

		units = normalizeUnits(units);

		if (units === 'month' || units === 'year') {
			days = this._days + milliseconds / 864e5;
			months = this._months + daysToMonths(days);
			return units === 'month' ? months : months / 12;
		} else {
						// handle milliseconds separately because of floating point math errors (issue #1867)
			days = this._days + Math.round(monthsToDays(this._months));
			switch (units) {
				case 'week' : return days / 7 + milliseconds / 6048e5;
				case 'day' : return days + milliseconds / 864e5;
				case 'hour' : return days * 24 + milliseconds / 36e5;
				case 'minute' : return days * 1440 + milliseconds / 6e4;
				case 'second' : return days * 86400 + milliseconds / 1000;
								// Math.floor prevents floating point math errors here
				case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
				default: throw new Error('Unknown unit ' + units);
			}
		}
	}

		// TODO: Use this.as('ms')?
	function duration_as__valueOf() {
		return (
						this._milliseconds +
						this._days * 864e5 +
						(this._months % 12) * 2592e6 +
						toInt(this._months / 12) * 31536e6
		);
	}

	function makeAs(alias) {
		return function() {
			return this.as(alias);
		};
	}

	var asMilliseconds = makeAs('ms');
	var asSeconds = makeAs('s');
	var asMinutes = makeAs('m');
	var asHours = makeAs('h');
	var asDays = makeAs('d');
	var asWeeks = makeAs('w');
	var asMonths = makeAs('M');
	var asYears = makeAs('y');

	function duration_get__get(units) {
		units = normalizeUnits(units);
		return this[units + 's']();
	}

	function makeGetter(name) {
		return function() {
			return this._data[name];
		};
	}

	var milliseconds = makeGetter('milliseconds');
	var seconds = makeGetter('seconds');
	var minutes = makeGetter('minutes');
	var hours = makeGetter('hours');
	var days = makeGetter('days');
	var months = makeGetter('months');
	var years = makeGetter('years');

	function weeks() {
		return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
		s: 45,	// seconds to minute
		m: 45,	// minutes to hour
		h: 22,	// hours to day
		d: 26,	// days to month
		M: 11	 // months to year
	};

		// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
		return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
		var duration = create__createDuration(posNegDuration).abs();
		var seconds = round(duration.as('s'));
		var minutes = round(duration.as('m'));
		var hours = round(duration.as('h'));
		var days = round(duration.as('d'));
		var months = round(duration.as('M'));
		var years = round(duration.as('y'));

		var a = seconds < thresholds.s && ['s', seconds] ||
								minutes <= 1 && ['m'] ||
								minutes < thresholds.m && ['mm', minutes] ||
								hours <= 1 && ['h'] ||
								hours < thresholds.h && ['hh', hours] ||
								days <= 1 && ['d'] ||
								days < thresholds.d && ['dd', days] ||
								months <= 1 && ['M'] ||
								months < thresholds.M && ['MM', months] ||
								years <= 1 && ['y'] || ['yy', years];

		a[2] = withoutSuffix;
		a[3] = +posNegDuration > 0;
		a[4] = locale;
		return substituteTimeAgo.apply(null, a);
	}

		// This function allows you to set a threshold for relative time strings
	function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
		if (thresholds[threshold] === undefined) {
			return false;
		}
		if (limit === undefined) {
			return thresholds[threshold];
		}
		thresholds[threshold] = limit;
		return true;
	}

	function humanize(withSuffix) {
		var locale = this.localeData();
		var output = duration_humanize__relativeTime(this, !withSuffix, locale);

		if (withSuffix) {
			output = locale.pastFuture(+this, output);
		}

		return locale.postformat(output);
	}

	var iso_string__abs = Math.abs;

	function iso_string__toISOString() {
				// for ISO strings we do not use the normal bubbling rules:
				//	* milliseconds bubble up until they become hours
				//	* days do not bubble at all
				//	* months bubble up until they become years
				// This is because there is no context-free conversion between hours and days
				// (think of clock changes)
				// and also not between days and months (28-31 days per month)
		var seconds = iso_string__abs(this._milliseconds) / 1000;
		var days = iso_string__abs(this._days);
		var months = iso_string__abs(this._months);
		var minutes, hours, years;

				// 3600 seconds -> 60 minutes -> 1 hour
		minutes = absFloor(seconds / 60);
		hours = absFloor(minutes / 60);
		seconds %= 60;
		minutes %= 60;

				// 12 months -> 1 year
		years = absFloor(months / 12);
		months %= 12;

				// inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		var Y = years;
		var M = months;
		var D = days;
		var h = hours;
		var m = minutes;
		var s = seconds;
		var total = this.asSeconds();

		if (!total) {
						// this is the same as C#'s (Noda) and python (isodate)...
						// but not other JS (goog.date)
			return 'P0D';
		}

		return (total < 0 ? '-' : '') +
						'P' +
						(Y ? Y + 'Y' : '') +
						(M ? M + 'M' : '') +
						(D ? D + 'D' : '') +
						((h || m || s) ? 'T' : '') +
						(h ? h + 'H' : '') +
						(m ? m + 'M' : '') +
						(s ? s + 'S' : '');
	}

	var duration_prototype__proto = Duration.prototype;

	duration_prototype__proto.abs = duration_abs__abs;
	duration_prototype__proto.add = duration_add_subtract__add;
	duration_prototype__proto.subtract = duration_add_subtract__subtract;
	duration_prototype__proto.as = as;
	duration_prototype__proto.asMilliseconds = asMilliseconds;
	duration_prototype__proto.asSeconds = asSeconds;
	duration_prototype__proto.asMinutes = asMinutes;
	duration_prototype__proto.asHours = asHours;
	duration_prototype__proto.asDays = asDays;
	duration_prototype__proto.asWeeks = asWeeks;
	duration_prototype__proto.asMonths = asMonths;
	duration_prototype__proto.asYears = asYears;
	duration_prototype__proto.valueOf = duration_as__valueOf;
	duration_prototype__proto._bubble = bubble;
	duration_prototype__proto.get = duration_get__get;
	duration_prototype__proto.milliseconds = milliseconds;
	duration_prototype__proto.seconds = seconds;
	duration_prototype__proto.minutes = minutes;
	duration_prototype__proto.hours = hours;
	duration_prototype__proto.days = days;
	duration_prototype__proto.weeks = weeks;
	duration_prototype__proto.months = months;
	duration_prototype__proto.years = years;
	duration_prototype__proto.humanize = humanize;
	duration_prototype__proto.toISOString = iso_string__toISOString;
	duration_prototype__proto.toString = iso_string__toISOString;
	duration_prototype__proto.toJSON = iso_string__toISOString;
	duration_prototype__proto.locale = locale;
	duration_prototype__proto.localeData = localeData;

		// Deprecations
	duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	duration_prototype__proto.lang = lang;

		// Side effect imports

		// FORMATTING

	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');

		// PARSING

	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function(input, array, config) {
		config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function(input, array, config) {
		config._d = new Date(toInt(input));
	});

		// Side effect imports

	utils_hooks__hooks.version = '2.12.0';

	setHookCallback(local__createLocal);

	utils_hooks__hooks.fn = momentPrototype;
	utils_hooks__hooks.min = min;
	utils_hooks__hooks.max = max;
	utils_hooks__hooks.now = now;
	utils_hooks__hooks.utc = create_utc__createUTC;
	utils_hooks__hooks.unix = moment__createUnix;
	utils_hooks__hooks.months = lists__listMonths;
	utils_hooks__hooks.isDate = isDate;
	utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
	utils_hooks__hooks.invalid = valid__createInvalid;
	utils_hooks__hooks.duration = create__createDuration;
	utils_hooks__hooks.isMoment = isMoment;
	utils_hooks__hooks.weekdays = lists__listWeekdays;
	utils_hooks__hooks.parseZone = moment__createInZone;
	utils_hooks__hooks.localeData = locale_locales__getLocale;
	utils_hooks__hooks.isDuration = isDuration;
	utils_hooks__hooks.monthsShort = lists__listMonthsShort;
	utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
	utils_hooks__hooks.defineLocale = defineLocale;
	utils_hooks__hooks.updateLocale = updateLocale;
	utils_hooks__hooks.locales = locale_locales__listLocales;
	utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
	utils_hooks__hooks.normalizeUnits = normalizeUnits;
	utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	utils_hooks__hooks.prototype = momentPrototype;

	var _moment = utils_hooks__hooks;

	return _moment;
}));


}).call(ts.ui);
(function() {

/**
 * Copyright (c) 2011-2014 Felix Gnass
 * Licensed under the MIT license
 * http://spin.js.org/
 *
 * Example:
		var opts = {
			lines: 12						 // The number of lines to draw
		, length: 7						 // The length of each line
		, width: 5							// The line thickness
		, radius: 10						// The radius of the inner circle
		, scale: 1.0						// Scales overall size of the spinner
		, corners: 1						// Roundness (0..1)
		, color: '#000'				 // #rgb or #rrggbb
		, opacity: 1/4					// Opacity of the lines
		, rotate: 0						 // Rotation offset
		, direction: 1					// 1: clockwise, -1: counterclockwise
		, speed: 1							// Rounds per second
		, trail: 100						// Afterglow percentage
		, fps: 20							 // Frames per second when using setTimeout()
		, zIndex: 2e9					 // Use a high z-index by default
		, className: 'spinner'	// CSS class to assign to the element
		, top: '50%'						// center vertically
		, left: '50%'					 // center horizontally
		, shadow: false				 // Whether to render a shadow
		, hwaccel: false				// Whether to use hardware acceleration (might be buggy)
		, position: 'absolute'	// Element positioning
		}
		var target = document.getElementById('foo')
		var spinner = new Spinner(opts).spin(target)
 */
;(function(root, factory) {
	/* CommonJS */
	if (typeof module === 'object' && module.exports) module.exports = factory();

	/* AMD module */
	else if (typeof define === 'function' && define.amd) define(factory);

	/* Browser global */
	else root.Spinner = factory();
}(this, function() {
	'use strict';

	var prefixes = ['webkit', 'Moz', 'ms', 'O'], /* Vendor prefixes */
		animations = {}, /* Animation rules keyed by their name */
		useCssAnimations, /* Whether to use CSS animations or setTimeout */
		sheet; /* A stylesheet to hold the @keyframe or VML rules. */

	/**
	 * Utility function to create elements. If no tag name is given,
	 * a DIV is created. Optionally properties can be passed.
	 */
	function createEl(tag, prop) {
		var el = document.createElement(tag || 'div'),
			n;

		for (n in prop) el[n] = prop[n];
		return el;
	}

	/**
	 * Appends children and returns the parent.
	 */
	function ins(parent /* child1, child2, ... */) {
		for (var i = 1, n = arguments.length; i < n; i++) {
			parent.appendChild(arguments[i]);
		}

		return parent;
	}

	/**
	 * Creates an opacity keyframe animation rule and returns its name.
	 * Since most mobile Webkits have timing issues with animation-delay,
	 * we create separate rules for each line/segment.
	 */
	function addAnimation(alpha, trail, i, lines) {
		var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-'),
			start = 0.01 + i / lines * 100,
			z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha),
			prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase(),
			pre = prefix && '-' + prefix + '-' || '';

		if (!animations[name]) {
			sheet.insertRule(
				'@' + pre + 'keyframes ' + name + '{' +
				'0%{opacity:' + z + '}' +
				start + '%{opacity:' + alpha + '}' +
				(start + 0.01) + '%{opacity:1}' +
				(start + trail) % 100 + '%{opacity:' + alpha + '}' +
				'100%{opacity:' + z + '}' +
				'}', sheet.cssRules.length);

			animations[name] = 1;
		}

		return name;
	}

	/**
	 * Tries various vendor prefixes and returns the first supported property.
	 */
	function vendor(el, prop) {
		var s = el.style,
			pp,
			i;

		prop = prop.charAt(0).toUpperCase() + prop.slice(1);
		if (s[prop] !== undefined) return prop;
		for (i = 0; i < prefixes.length; i++) {
			pp = prefixes[i] + prop;
			if (s[pp] !== undefined) return pp;
		}
	}

	/**
	 * Sets multiple style properties at once.
	 */
	function css(el, prop) {
		for (var n in prop) {
			el.style[vendor(el, n) || n] = prop[n];
		}

		return el;
	}

	/**
	 * Fills in default values.
	 */
	function merge(obj) {
		for (var i = 1; i < arguments.length; i++) {
			var def = arguments[i];
			for (var n in def) {
				if (obj[n] === undefined) obj[n] = def[n];
			}
		}
		return obj;
	}

	/**
	 * Returns the line color from the given string or array.
	 */
	function getColor(color, idx) {
		return typeof color === 'string' ? color : color[idx % color.length];
	}

	// Built-in defaults

	var defaults = {
		lines: 12,						 // The number of lines to draw
		length: 7,						 // The length of each line
		width: 5,							// The line thickness
		radius: 10,						// The radius of the inner circle
		scale: 1.0,						// Scales overall size of the spinner
		corners: 1,						// Roundness (0..1)
		color: '#000',				 // #rgb or #rrggbb
		opacity: 1 / 4,					// Opacity of the lines
		rotate: 0,						 // Rotation offset
		direction: 1,					// 1: clockwise, -1: counterclockwise
		speed: 1,							// Rounds per second
		trail: 100,						// Afterglow percentage
		fps: 20,							 // Frames per second when using setTimeout()
		zIndex: 2e9,					 // Use a high z-index by default
		className: 'spinner',	// CSS class to assign to the element
		top: '50%',						// center vertically
		left: '50%',					 // center horizontally
		shadow: false,				 // Whether to render a shadow
		hwaccel: false,				// Whether to use hardware acceleration (might be buggy)
		position: 'absolute'	// Element positioning
	};

	/** The constructor */
	function Spinner(o) {
		this.opts = merge(o || {}, Spinner.defaults, defaults);
	}

	// Global defaults that override the built-ins:
	Spinner.defaults = {};

	merge(Spinner.prototype, {
		/**
		 * Adds the spinner to the given target element. If this instance is already
		 * spinning, it is automatically removed from its previous target b calling
		 * stop() internally.
		 */
		spin: function(target) {
			this.stop();

			var self = this,
				o = self.opts,
				el = self.el = createEl(null, {className: o.className});

			css(el, {
				position: o.position,
				width: 0,
				zIndex: o.zIndex,
				left: o.left,
				top: o.top
			});

			if (target) {
				target.insertBefore(el, target.firstChild || null);
			}

			el.setAttribute('role', 'progressbar');
			self.lines(el, self.opts);

			if (!useCssAnimations) {
				// No CSS animation support, use setTimeout() instead
				var i = 0,
					start = (o.lines - 1) * (1 - o.direction) / 2,
					alpha,
					fps = o.fps,
					f = fps / o.speed,
					ostep = (1 - o.opacity) / (f * o.trail / 100),
					astep = f / o.lines

					;(function anim() {
						i++;
						for (var j = 0; j < o.lines; j++) {
							alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity);

							self.opacity(el, j * o.direction + start, alpha, o);
						}
						self.timeout = self.el && setTimeout(anim, ~~(1000 / fps));
					})();
			}
			return self;
		},

		/**
		 * Stops and removes the Spinner.
		 */
		stop: function() {
			var el = this.el;
			if (el) {
				clearTimeout(this.timeout);
				if (el.parentNode) el.parentNode.removeChild(el);
				this.el = undefined;
			}
			return this;
		},

		/**
		 * Internal method that draws the individual lines. Will be overwritten
		 * in VML fallback mode below.
		 */
		lines: function(el, o) {
			var i = 0,
				start = (o.lines - 1) * (1 - o.direction) / 2,
				seg;

			function fill(color, shadow) {
				return css(createEl(), {
					position: 'absolute',
					width: o.scale * (o.length + o.width) + 'px',
					height: o.scale * o.width + 'px',
					background: color,
					boxShadow: shadow,
					transformOrigin: 'left',
					transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.scale * o.radius + 'px' + ',0)',
					borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'
				});
			}

			for (; i < o.lines; i++) {
				seg = css(createEl(), {
					position: 'absolute',
					top: 1 + ~(o.scale * o.width / 2) + 'px',
					transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
					opacity: o.opacity,
					animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
				});

				if (o.shadow) ins(seg, css(fill('#000', '0 0 4px #000'), {top: '2px'}));
				ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')));
			}
			return el;
		},

		/**
		 * Internal method that adjusts the opacity of a single line.
		 * Will be overwritten in VML fallback mode below.
		 */
		opacity: function(el, i, val) {
			if (i < el.childNodes.length) el.childNodes[i].style.opacity = val;
		}

	});

	function initVML() {
		/* Utility function to create a VML tag */
		function vml(tag, attr) {
			return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr);
		}

		// No CSS transforms but VML support, add a CSS rule for VML elements:
		sheet.addRule('.spin-vml', 'behavior:url(#default#VML)');

		Spinner.prototype.lines = function(el, o) {
			var r = o.scale * (o.length + o.width),
				s = o.scale * 2 * r;

			function grp() {
				return css(
					vml('group', {
	coordsize: s + ' ' + s,
	coordorigin: -r + ' ' + -r
})
				, { width: s, height: s }
				);
			}

			var margin = -(o.width + o.length) * o.scale * 2 + 'px',
				g = css(grp(), {position: 'absolute', top: margin, left: margin}),
				i;

			function seg(i, dx, filter) {
				ins(
					g
				, ins(
						css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx})
					, ins(
							css(
								vml('roundrect', {arcsize: o.corners})
							, { width: r,
	height: o.scale * o.width,
	left: o.scale * o.radius,
	top: -o.scale * o.width >> 1,
	filter: filter
}
							)
						, vml('fill', {color: getColor(o.color, i), opacity: o.opacity})
						, vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
						)
					)
				);
			}

			if (o.shadow) {
				for (i = 1; i <= o.lines; i++) {
					seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)');
				}
			}

			for (i = 1; i <= o.lines; i++) seg(i);
			return ins(el, g);
		};

		Spinner.prototype.opacity = function(el, i, val, o) {
			var c = el.firstChild;
			o = o.shadow && o.lines || 0;
			if (c && i + o < c.childNodes.length) {
				c = c.childNodes[i + o]; c = c && c.firstChild; c = c && c.firstChild;
				if (c) c.opacity = val;
			}
		};
	}

	if (typeof document !== 'undefined') {
		sheet = (function() {
			var el = createEl('style', {type: 'text/css'});
			ins(document.getElementsByTagName('head')[0], el);
			return el.sheet || el.styleSheet;
		}());

		var probe = css(createEl('group'), {behavior: 'url(#default#VML)'});

		if (!vendor(probe, 'transform') && probe.adj) initVML();
		else useCssAnimations = vendor(probe, 'animation');
	}

	return Spinner;
}));


}).call(ts.ui);
(function(window) {

;(function() {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/* jslint browser:true, node:true */
	/* global define, Event, Node */

	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;

		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;

		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;

		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;

		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;

		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;

		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;

		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}

		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {
			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf('Windows Phone') >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;

	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;

	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);

	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
			case 'button':
			case 'select':
			case 'textarea':
				if (target.disabled) {
					return true;
				}

				break;
			case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
				if ((deviceIsIOS && target.type === 'file') || target.disabled) {
					return true;
				}

				break;
			case 'label':
			case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
			case 'video':
				return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};

	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
			case 'textarea':
				return true;
			case 'select':
				return !deviceIsAndroid;
			case 'input':
				switch (target.type) {
					case 'button':
					case 'checkbox':
					case 'file':
					case 'image':
					case 'radio':
					case 'submit':
						return false;
				}

			// No point in attempting to focus disabled inputs
				return !target.disabled && !target.readOnly;
			default:
				return (/\bneedsfocus\b/).test(target.className);
		}
	};

	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {
		// Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};

	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};

	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};

	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};

	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {
			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {
				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};

	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};

	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};

	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {
		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};

	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {
			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {
			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};

	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};

	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {
		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {
				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};

	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};

	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};

	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

		if (chromeVersion) {
			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};

	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());


}(self));
(function(window) {

"use strict";


/**
 * Tweening away.
 */
gui.Tween = (function using(confirmed, chained) {
	return gui.Class.create(Object.prototype, {

		/**
		 * Tween type.
		 * @type {string}
		 */
		type: null,

		/**
		 * Default duration.
		 * @type {number} Time in in milliseconds.
		 */
		duration: 200,

		/**
		 * Equivalent to transition-timing-function.
		 * @type {number}
		 */
		timing: 'none',

		/**
		 * Optional tween data.
		 * @type {object}
		 */
		data: null,

		/**
		 * Between zero and one.
		 * @type {number}
		 */
		value: 0,

		/**
		 * True when value is zero.
		 * @type {Boolean}
		 */
		init: true,

		/**
		 * True when value is one.
		 * @type {boolean}
		 */
		done: false,

		/**
		 * @param {string} type
		 * @param @optional {object} config
		 * @param @optional {object} data
		 */
		onconstruct: function(type, config, data) {
			this.type = type;
			this.data = (data !== undefined ? data : null);
			if (config) {
				if (config.duration !== undefined) {
					this.duration = config.duration;
				}
				if (config.timing !== undefined) {
					this.timing = config.timing;
				}
			}
		}

	}, {}, { // Static ...........................................................

		/**
		 * Coordinate tween.
		 * @param {string} type
		 * @param @optional {object} config
		 * @param @optional {object} data
		 * @returns {gui.Tween} but why?
		 */
		dispatch: function(type, config, data) {
			var tween = new gui.Tween(type, config, data);
			var timer = gui.Client.hasPerformance ? window.performance : Date;
			var start = timer.now();
			function step() {
				var value = 1;
				var time = timer.now();
				var progress = time - start;
				if (progress < tween.duration) {
					value = progress / tween.duration;
					if (tween.timing !== 'none') {
						value = value * 90 * Math.PI / 180;
						switch (tween.timing) {
							case 'ease-in':
								value = 1 - Math.cos(value);
								break;
							case 'ease-out':
								value = Math.sin(value);
								break;
						}
					}
				}
				/*
				if (value === 1) {
					tween.value = 1;
					tween.done = true;
				} else {
					tween.value = value;
					requestAnimationFrame(step);
				}
				*/
				tween.value = value;
				if (tween.value === 1) {
					tween.done = true;
				}
				gui.Broadcast.dispatch(gui.BROADCAST_TWEEN, tween);
				tween.init = false;
				if (!tween.done) {
					requestAnimationFrame(step);
				}
			}
			step(start);
			return tween;
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));



/**
 * Tracking tweens.
 * TODO: Support 'handler' typeument!
 * @extends {gui.TrackerPlugin}
 * @using {gui.Combo#chained}
 * @using {gui.Arguments#confirmed}
 */
gui.TweenPlugin = (function using(chained, confirmed) {
	return gui.TrackerPlugin.extend({

		/**
		 * Add tween listener(s).
		 * @param {String|Array<String>} type
		 * @returns {gui.TweenPlugin}
		 */
		add: chained(confirmed('string')(function(type) {
			gui.Array.make(type).forEach(function(_type) {
				if (this._addchecks(_type)) {
					gui.Broadcast.add(gui.BROADCAST_TWEEN, this);
				}
			}, this);
		})),

		/**
		 * Remove tween listener(s).
		 * @param {String|Array<String>} type
		 * @returns {gui.TweenPlugin}
		 */
		remove: chained(confirmed('string')(function(type) {
			gui.Array.make(type).forEach(function(_type) {
				if (this._removechecks(_type)) {
					gui.Broadcast.remove(gui.BROADCAST_TWEEN, this);
				}
			}, this);
		})),

		/**
		 * Dispatch tween(s).
		 * @param {String|Array<String>} type
		 * @param @optional {object} options Configure timing etc.
		 * @param @optional {object} data Optional data thingy
		 * @returns {gui.Tween} TODO: Don't return anything!!!
		 */
		dispatch: confirmed('string')(function(type, options, data) {
			var result = null;
			gui.Array.make(type).forEach(function(_type) {
				result = gui.Tween.dispatch(_type, options, data);
			}, this);
			return result;
		}),

		/**
		 * Add tween listener and dispatch this tween.
		 * TODO: We have to find a different setup for this,
		 *			 at least we have to change this method name.
		 * @param {String|Array<String>} type
		 * @param @optional {object} options Configure timing etc.
		 * @param @optional {object} data Optional data thingy
		 * @returns {gui.Tween}
		 */
		addDispatch: function(type, options, data) {
			return this.add(type).dispatch(type, options, data);
		},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			switch (b.type) {
				case gui.BROADCAST_TWEEN:
					var tween = b.data;
					if (this._containschecks(tween.type)) {
						if (!this.spirit.life.destructed) {
							this.spirit.ontween(tween);
						}
					}
					break;
			}
		},

		/**
		 * [ondestruct description]
		 * @return {[type]} [description]
		 */
		ondestruct: function() {
			gui.Broadcast.remove(gui.BROADCAST_TWEEN, this);
			gui.TrackerPlugin.prototype.ondestruct.call(this);
		}

	});
}(gui.Combo.chained, gui.Arguments.confirmed));



/**
 * Experimental CSS transitioning plugin. Work in progress.
 * @extends {gui.Plugin}
 * @TODO Just add the transitonend listener on construct?
 */
gui.TransitionPlugin = gui.Plugin.extend({

	/**
	 * Handle event.
	 * @type {TransitionEvent} e
	 */
	onevent: function(e) {
		if (e.type === this._endevent && e.target === this.spirit.element) {
			this._transitionend(e);
		}
	},

	/**
	 * Set transition properties.
	 * @param {String} props White-space separated list of CSS properties.
	 * @returns {gui.TransitionPlugin}
	 */
	property: function(props) {
		if (props) {
			this.spirit.css.set('-beta-transition-property', props);
		}
		return this._init();
	},

	/**
	 * Set transition duration.
	 * @param {object} time CSS-string or milliseconds as number.
	 * @returns {gui.TransitionPlugin}
	 */
	duration: function(time) {
		if (time) {
			time = gui.Type.isNumber(time) ? this._convert(time) : time;
			this.spirit.css.set('-beta-transition-duration', time);
		}
		return this._init();
	},

	/**
	 * Set transition timing function.
	 * @param {String} timing Bezier or keyword
	 * @returns {gui.TransitionPlugin}
	 */
	timing: function(timing) {
		if (timing) {
			this.spirit.css.set('-beta-transition-timing-function', timing);
		}
		return this._init();
	},

	/**
	 * Ease in.
	 * @returns {gui.TransitionPlugin}
	 */
	easeIn: function() {
		return this.timing('ease-in');
	},

	/**
	 * Ease out.
	 * @returns {gui.TransitionPlugin}
	 */
	easeOut: function() {
		return this.timing('ease-out');
	},

	/**
	 * Ease in and out.
	 * @returns {gui.TransitionPlugin}
	 */
	easeInOut: function() {
		return this.timing('ease-in-out');
	},

	/**
	 * Cubic-bezier.
	 * @param {number} n1
	 * @param {number} n2
	 * @param {number} n3
	 * @param {number} n4
	 * @returns {gui.TransitionPlugin}
	 */
	cubicBezier: function(n1, n2, n3, n4) {
		return this.timing('cubic-bezier(' + n1 + ',' + n2 + ',' + n3 + ',' + n4 + ')');
	},

	/**
	 * Suspend transitions.
	 * @returns {gui.TransitionPlugin}
	 */
	none: function() {
		return this.property('none');
	},

	/**
	 * Cosmetically clear traces of transition from (inline) HTML.
	 * @TODO: clear out the non transition related CSS declarations!
	 */
	reset: function() {
		this.property('');
		this.timing('');
	},

	/**
	 * Configure transition and run one or CSS updates. Any key in the config
	 * argument that matches a method name in this plugin will be invoked with
	 * the property value as argument; the rest will be treated as CSS updates.
	 * @param {Map<String,object>} config
	 * @returns {object}
	 */
	run: function(config) {
		var css = Object.create(null);
		this._count = 0;
		gui.Object.each(config, function(key, value) {
			if (gui.Type.isFunction(this[key])) {
				this[key](value);
			} else {
				css[key] = value;
			}
		}, this);
		var now = this.spirit.css.compute('-beta-transition-property') === 'none';
		var then = this._then = new gui.Then();
		// Firefox needs a break before setting the styles.
		// http://stackoverflow.com/questions/6700137/css-3-transitions-with-opacity-chrome-and-firefox
		var spirit = this.spirit;
		if ((this._count = Object.keys(css).length)) {
			setImmediate(function() {
				spirit.css.style(css);
				if (now && then) {
					setImmediate(function() {
						then.now(null); // don't wait for transitionend
					});
				}
			});
		}
		return then;
	},

	// Private ..............................................................................

	/**
	 * Default transition duration time milliseconds.
	 * @TODO actually default this
	 * @type {number}
	 */
	_default: 1000,

	/**
	 * Browsers's take on transitionend event name.
	 * @type {String}
	 */
	_endevent: null,

	/**
	 * Hello.
	 * @type {number}
	 */
	_count: 0,

	/**
	 * Monitor transitions using vendor-prefixed event name.
	 * @TODO confirm VendorTransitionEnd on documentElement
	 * @TODO Firefox is down
	 * @TODO this.duration ( this._default )
	 * @TODO this on static, not per instance
	 * @returns {gui.TransitionPlugin}
	 */
	_init: function() {
		if (this._endevent === null) {
			var names = {
				webkit: 'webkitTransitionEnd',
				explorer: 'transitionend',
				gecko: 'transitionend',
				opera: 'oTransitionEnd'
			};
			this._endevent = names[gui.Client.agent] || 'transitionend';
			this.spirit.event.add(this._endevent, this.spirit.element, this);
		}
		return this;
	},

	/**
	 * Execute and reset callback on transition end.
	 * @param {TransitionEvent} e
	 */
	_transitionend: function(e) {
		var t = new gui.Transition(e.propertyName, e.elapsedTime);
		this._ontransition(t);
		this.spirit.ontransition(t);
	},

	/**
	 * Invoke callback when properties transitioned via run() has finished.
	 * @param	{gui.Transition} t
	 */
	_ontransition: function(t) {
		if (--this._count === 0) {
			this._now();
		}
	},

	/**
	 * Now what.
	 */
	_now: function() {
		var then = this._then;
		if (then) {
			then.now(null); // don't wait for transitionend
		}
	},

	/**
	 * Compute milliseconds duration in CSS terms.
	 * @param @optional {number} ms Duration in milliseconds
	 * @returns {String} Duration as string
	 */
	_convert: function(ms) {
		ms = ms || this._default;
		return (ms / 1000) + 's';
	}

});



/**
 * Details for ended CSS transition.
 * @param {String} propertyName
 * @param {number} elapsedTime
 */
gui.Transition = function(propertyName, elapsedTime) {
	this.duration = Math.round(elapsedTime / 1000);
	this.type = propertyName;
};

gui.Transition.prototype = {

	/**
	 * Property that finished transitioning ("width","height").
	 * @TODO un-camelcase this to CSS syntax.
	 * @TODO adjust vendor prefix to "beta".
	 * @type {String}
	 */
	type: null,

	/**
	 * Elapsed time in milliseconds. This may
	 * not be identical to the specified time.
	 * @type {number}
	 */
	duration: 0
};



/**
 * Visibility is an abstract status. When you mark a spirit as visible or
 * invisible, the methods `onvisible` or `oninvisible` will be called on
 * spirit and descendants. Current visibility status can be read in the
 * {gui.LifePlugin}: `spirit.life.visible`. Visibility is resolved async,
 * so this property is `undefined` on startup. If you need to take an action
 * that depends on visibility, just wait for `onvisible` to be invoked.
 * @TODO: Could document.elementFromPoint() be used to detect hidden stuff?
 * @TODO: hook this up to http://www.w3.org/TR/page-visibility/
 * @TODO: Make sure that visibility is updated after `appendChild`
 * @extends {gui.Plugin}
 * @using {gui.Combo#chained}
 */
gui.VisibilityPlugin = (function using(chained) {
	return gui.Plugin.extend({

		/**
		 * Mark spirit visible.
		 * @returns {gui.VisibilityPlugin}
		 */
		on: chained(function() {
			gui.VisibilityPlugin.on(this.spirit);
		}),

		/**
		 * Mark spirit invisible.
		 * @returns {gui.VisibilityPlugin}
		 */
		off: chained(function() {
			gui.VisibilityPlugin.off(this.spirit);
		})

	}, {}, { // Static ...........................................................

		/**
		 * Mark spirit visible. This will remove the `._gui-invisible`
		 * classname and invoke `onvisible` on spirit and descendants.
		 * Once visibility has been resolved on startup, the target
		 * spirit must be marked invisible for this to have effect.
		 * @param {gui.Spirit} spirit
		 */
		on: function(spirit) {
			var classname = gui.CLASS_INVISIBLE;
			if (spirit.life.visible === undefined || spirit.css.contains(classname)) {
				spirit.css.remove(classname);
				this._go(spirit, true);
			}
		},

		/**
		 * Mark spirit invisible. This will append the `._gui-invisible`
		 * classname and invoke `oninvisible` on spirit and descendants.
		 * @param {gui.Spirit} spirit
		 */
		off: function(spirit) {
			var classname = gui.CLASS_INVISIBLE;
			switch (spirit.life.visible) {
				case true:
				case undefined:
					spirit.css.add(classname);
					this._go(spirit, false);
					break;
			}
		},

		// Privileged static .......................................................

		/**
		 * Initialize spirit visibility.
		 * @TODO again after `appendChild` to another position.
		 * Invoked by the {gui.Guide}.
		 * @param {gui.Spirit} spirit
		 */
		$init: function(spirit) {
			this._go(spirit, !this._invisible(spirit));
		},

		// Private static ..........................................................

		/**
		 * Spirit is invisible? The point here is to not evaluate these potentially
		 * costly selectors for all new spirits, so do prefer not to use this method.
		 * Wait instread for methods `onvisible` and `oninvisible` to be invoked.
		 * @param {gui.Spirit} spirit
		 * @returns {boolean}
		 */
		_invisible: function(spirit) {
			return spirit.css.contains(gui.CLASS_INVISIBLE) ||
				spirit.css.matches('.' + gui.CLASS_INVISIBLE + ' *');
		},

		/**
		 * Recursively update spirit and descendants visibility.
		 * @param {gui.Spirit} first
		 * @param {boolean} show
		 */
		_go: function(first, visible) {
			var type = visible ? gui.CRAWLER_VISIBLE : gui.CRAWLER_INVISIBLE;
			new gui.Crawler(type).descendGlobal(first, {
				handleSpirit: function(spirit) {
					var init = spirit.life.visible === undefined;
					if (spirit !== first && spirit.css.contains(gui.CLASS_INVISIBLE)) {
						return gui.Crawler.SKIP_CHILDREN;
					} else if (visible) {
						if (!spirit.life.visible || init) {
							spirit.life.visible = true;
							spirit.life.dispatch(gui.LIFE_VISIBLE); // TODO: somehow after the fact!
							spirit.onvisible();
						}
					} else {
						if (spirit.life.visible || init) {
							spirit.life.visible = false;
							spirit.life.dispatch(gui.LIFE_INVISIBLE);
							spirit.oninvisible();
						}
					}
				}
			});
		}

	});
}(gui.Combo.chained));



/**
 * It's the layout module.
 */
gui.module('gui-layout@wunderbyte.com', {

	/**
	 * Assign plugins to prefixes for all {gui.Spirit}.
	 */
	plugin: {
		tween: gui.TweenPlugin,
		transition: gui.TransitionPlugin,
		visibility: gui.VisibilityPlugin
	},

	/**
	 * Methods added to {gui.Spirit.prototype}
	 */
	mixin: {

		/**
		 * Handle tween.
		 * @param {gui.Tween}
		 */
		ontween: function(tween) {},

		/**
		 * Handle transiton end.
		 * @param {gui.TransitionEnd} transition
		 */
		ontransition: function(transition) {},

		/**
		 * Handle visibility.
		 */
		onvisible: function() {},

		/**
		 * Handle invisibility.
		 */
		oninvisible: function() {}
	}

});



/**
 * Key event summary.
 * @TODO check out http://mozilla.pettay.fi/moztests/events/browser-keyCodes.htm
 * @param {boolean} down
 * @param {number} n KeyCode
 * @param {number} c Character
 * @param {boolean} g Global?
 */
gui.Key = function Key(down, type, isglobal) {
	this.down = down;
	this.type = type;
	this.global = isglobal;
};

gui.Key.prototype = {

	/**
	 * Key down? Otherwise up.
	 * @type {boolean}
	 */
	down: false,

	/**
	 * Reducing 'key', 'char' and potentially 'keyCode' to a single string. If
	 * the string length is greater than one, we are dealing with a special key.
	 * @TODO: Note about the SPACE character - how exactly should we handle it?
	 * @type {[type]}
	 */
	type: null,

	/**
	 * Global key?
	 * @TODO Deprecate this?
	 * @type {boolean}
	 */
	global: false
};

// Static .........................................................................................

/**
 * Key modifiers.
 * @TODO: platform specific variations "accelDown" and "accessDown" (get a Mac and figure this out)
 * @TODO Update from http://askubuntu.com/questions/19558/what-are-the-meta-super-and-hyper-keys
 */
(function keymodifiers() {
	gui.Object.each({
		shiftDown: false, // The Shift key.
		ctrlDown: false, // The Control key.
		altDown: false, // The Alt key. On the Macintosh, this is the Option key
		metaDown: false, // The Meta key. On the Macintosh, this is the Command key.
		accelDown: false, // The key used for keyboard shortcuts on the user's platform. Usually, this would be the value you would use.
		accessDown: false // The access key for activating menus and other elements. On Windows, this is the Alt key, used in conjuction with an element's accesskey.
	}, function(key, value) {
		gui.Key[key] = value;
	});
}());

/**
 * Mapping DOM0 key codes to DOM3 key values. Note that keycodes aren't used on an API level.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#key-values
 */
(function keymappings() {
	gui.Key.$key = gui.Object.extend({

		// navigation

		33: 'PageUp',
		34: 'PageDown',
		38: 'Up',
		40: 'Down',
		37: 'Left',
		39: 'Right',

		// modifiers

		18: 'Alt',
		17: 'Control',
		16: 'Shift',
		32: 'Space',

		// extras

		27: 'Esc',
		13: 'Enter'

	}, Object.create(null));
}());

/*
"Alt"
"AltGraph"
"CapsLock"
"Control"
"Fn"
"FnLock"
"Meta"
"Process"
"NumLock"
"Shift"
"SymbolLock"
"OS"
"Compose"
*/

/**
 * Create constant 'gui.Key.DOWN' to alias the string "Down" for those who prefer such a syntax.
 * @TODO Compute appropriate translation of pascal-case to underscores.
 */
(function keyconstants() {
	gui.Object.each(gui.Key.$key, function(key, value) {
		gui.Key[value.toUpperCase()] = value;
	});
}());

/**
 * These key codes "do not usually change" with keyboard layouts.
 * @TODO Read http://www.w3.org/TR/DOM-Level-3-Events/#key-values
 * @TODO http://www.w3.org/TR/DOM-Level-3-Events/#fixed-virtual-key-codes
 * @TODO http://www.w3.org/TR/DOM-Level-3-Events/#key-values-list
 *
( function keyconstants () {
	gui.Object.each ({
		BACKSPACE :	8,
		TAB	: 9,
		ENTER	: 13,
		SHIFT	: 16,
		CONTROL	: 17,
		ALT	: 18,
		CAPSLOCK : 20,
		ESCAPE : 27,
		SPACE	: 32,
		PAGE_UP	: 33,
		PAGE_DOWN	: 34,
		END	: 35,
		HOME : 36,
		LEFT : 37,
		UP : 38,
		RIGHT : 39,
		DOWN : 40,
		DELETE : 46
	}, function ( key, value ) {
		gui.Key [ key ] = value;
	});
}());
*/

/**
 * These codes are somewhat likely to match a US or European keyboard,
 * but they are not listed in "do not usually change" section above.
 *
( function questionablekeys () {
	gui.Object.each ({
		PLUS: 187,
		MINUS: 189,
		NUMPLUS: 107,
		NUMMINUS: 109
	}, function ( key, value ) {
		gui.Key [ key ] = value;
	});
}());
*/



/**
 * Tracking keys.
 * @extends {gui.TrackerPlugin}
 * @using {gui.Arguments#confirmed}
 * @using {gui.Combo#chained}
 */
gui.KeyPlugin = (function using(confirmed, chained) {
	return gui.TrackerPlugin.extend({

		/**
		 * Add one or more action handlers.
		 * @param {Array<String,Number>|String|number} arg @TODO Strings!
		 * @param @optional {object|function} handler
		 * @returns {gui.KeyPlugin}
		 */
		add: confirmed('array|string', '(object|function)')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.IKeyHandler, handler)) {
					gui.Array.make(arg).forEach(function(a) {
						if (this._addchecks(String(a), [handler, this._global])) {
							this._setupbroadcast(true);
						}
					}, this);
				}
			})
		),

		/**
		 * Remove one or more action handlers.
		 * @param {Array<String,Number>|String|number} arg
		 * @param @optional {object} handler
		 * @returns {gui.KeyPlugin}
		 */
		remove: confirmed('array|string', '(object|function)')(
			chained(function(arg, handler) {
				handler = handler || this.spirit;
				if (gui.Interface.validate(gui.IKeyHandler, handler)) {
					gui.Array.make(arg).forEach(function(a) {
						if (this._removechecks(String(a), [handler, this._global])) {
							if (!this._hashandlers()) {
								this._setupbroadcast(false);
							}
						}
					}, this);
				}
			})
		),

		/**
		 * Add handlers for global key(s).
		 * @param {object} arg
		 * @param @optional {gui.IKeyListener} handler (defaults to spirit)
		 * @returns {gui.KeyPlugin}
		 */
		addGlobal: function(arg, handler) {
			return this._globalize(function() {
				return this.add(arg, handler);
			});
		},

		/**
		 * Add handlers for global keys(s).
		 * @param {object} arg
		 * @param @optional {gui.IKeyListener} handler (defaults to spirit)
		 * @returns {gui.KeyPlugin}
		 */
		removeGlobal: function(arg, handler) {
			return this._globalize(function() {
				return this.remove(arg, handler);
			});
		},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			var list, handler, isglobal;
			if (b.type === gui.BROADCAST_KEYEVENT) {
				var down = b.data.down,
					type = b.data.type;
				if ((list = (this._trackedtypes[type]))) {
					list.forEach(function(checks) {
						handler = checks[0];
						isglobal = checks[1];
						if (isglobal === b.global) {
							handler.onkey(new gui.Key(down, type, isglobal));
						}
					});
				}
			}
		},

		// Private .....................................................................

		/**
		 * Start and stop listening for broadcasted key event details.
		 * @param {boolean} add
		 */
		_setupbroadcast: function(add) {
			var act, sig = this.context.gui.$contextid;
			var type = gui.BROADCAST_KEYEVENT;
			if (this._global) {
				act = add ? 'addGlobal' : 'removeGlobal';
				gui.Broadcast[act](type, this);
			} else {
				act = add ? 'add' : 'remove';
				gui.Broadcast[act](type, this, sig);
			}
		},

		/**
		 * Remove delegated handlers.
		 * @TODO same as in gui.ActionPlugin, perhaps superize this stuff somehow...
		 */
		_cleanup: function(type, checks) {
			var handler = checks[0],
				global = checks[1];
			if (global) {
				this.removeGlobal(type, handler);
			} else {
				this.remove(type, handler);
			}
		}

	});
}(gui.Arguments.confirmed, gui.Combo.chained));



/**
 * Interface KeyHandler
 */
gui.IKeyHandler = {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object IKeyHandler]';
	},

	/**
	 * Handle key
	 * @param {gui.Key} key
	 */
	onkey: function(key) {}
};



/**
 * Note: Just because this happens to be the last loaded module (in Spiritual).
 */
gui.$stop('- parse spiritual');

/**
 * Keys module.
 * @TODO http://www.w3.org/TR/DOM-Level-3-Events/#events-keyboardevents
 * @TODO http://dev.opera.com/articles/view/functional-key-handling-in-opera-tv-store-applications/
 */
gui.KeysModule = gui.module('gui-keys@wunderbyte.com', {

	/*
	 * Plugins (for all spirits).
	 * @TODO: combo
	 */
	plugin: {
		key: gui.KeyPlugin
	},

	/*
	 * Mixins (for all spirits).
	 */
	mixin: {

		/**
		 * Handle key.
		 * @param {gui.Key} key
		 * @implements {gui.IKeyHandler}
		 */
		onkey: function(key) {}
	},

	/**
	 * Context init.
	 * @param {Window} context
	 */
	oncontextinitialize: function(context) {
		this._keymap = Object.create(null);
		['keydown', 'keypress', 'keyup'].forEach(function(type) {
			context.document.addEventListener(type, this, false);
		}, this);
	},

	/**
	 * Handle event.
	 * @param {KeyEvent} e
	 */
	handleEvent: function(e) {
		this._modifiers(e);
		this._oldschool(e);
		/*
		if ( gui.Type.isDefined ( e.repeat )) { // bypass DOM3 for now
			this._newschool ( e );
		} else {
			this._oldschool ( e );
		}
		*/
	},

	// Private ..........................................................

	/**
	 * Mapping keycodes to characters between keydown and keypress event.
	 * @type {Map<number,String>}
	 */
	_keymap: null,

	/*
	 * Snapshot latest broadcast to prevent
	 * doubles in mysterious Gecko cornercase.
	 * @type {String}
	 */
	_snapshot: null,

	/**
	 * DOM3 style events. Skipped for now since Opera 12 appears
	 * to fire all events repeatedly while key pressed, that correct?
	 * Also, event.repeat is always false, that doesn't make sense...
	 * @param {Event} e
	 */
	_newschool: function(e) {},

	/**
	 * Conan the Barbarian style events.
	 * At least they suck in a known way.
	 * @param {Event} e
	 */
	_oldschool: function(e) {
		var n = e.keyCode,
			c = this._keymap[n];
		var id = e.currentTarget.defaultView.gui.$contextid;

		/*
		// TODO: THIS!
		if ( e.ctrlKey && gui.Key.$key [ e.keyCode ] !== "Control" ) {
			e.preventDefault ();
		}
		*/

		switch (e.type) {
			case 'keydown':
				if (c === undefined) {
					this._keycode = n;
					this._keymap[n] = null;
					this._keymap[n] = String.fromCharCode(e.which).toLowerCase();
					gui.Tick.next(function() {
						c = this._keymap[n];
						this._broadcast(true, null, c, n, id);
						this._keycode = null;
					}, this);
				}
				break;
			case 'keypress':
				if (this._keycode) {
					c = this._keychar(e.keyCode, e.charCode, e.which);
					this._keymap[this._keycode] = c;
				}
				break;
			case 'keyup':
				if (c !== undefined) {
					this._broadcast(false, null, c, n, id);
					delete this._keymap[n];
				}
				break;
		}
	},

	/**
	 * Broadcast key details globally. Details reduced to a boolean 'down' and a 'type'
	 * string to represent typed character (eg "b") or special key (eg "Shift" or "Alt").
	 * Note that the SPACE character is broadcasted as the multi-letter type "Space" (TODO!)
	 * @TODO what other pseudospecial keys are mapped to typed characters (like SPACE)?
	 * @param {boolean} down
	 * @param {String} key Newschool ABORTED FOR NOW
	 * @param {String} c (char) Bothschool
	 * @param {number} code Oldschool
	 * @param {String} sig Contextkey
	 */
	_broadcast: function(down, key, c, code, sig) {
		var type, msg, arg;
		type = gui.Key.$key[code] || c;
		type = type === ' ' ? gui.Key.SPACE : type;
		msg = gui.BROADCAST_KEYEVENT;
		arg = {
			down: down,
			type: type
		};
		/*
		 * Never broadcast same message twice. Fixes something about Firefox
		 * registering multiple keystrokes on certain chars (notably the 's').
		 */
		var snapshot = JSON.stringify(arg);
		if (snapshot !== this._snapshot) {
			gui.Broadcast.dispatch(msg, arg, sig); // do we want this?
			gui.Broadcast.dispatchGlobal(msg, arg);
			this._snapshot = snapshot;
		}
	},

	/**
	 * Update key modifiers state.
	 * @TODO Cross platform abstractions "accelDown" and "accessDown"
	 * @param {KeyEvent} e
	 */
	_modifiers: function(e) {
		gui.Key.ctrlDown = e.ctrlKey;
		gui.Key.shiftDown = e.shiftKey;
		gui.Key.altDown = e.altKey;
		gui.Key.metaDown = e.metaKey;
	},

	/**
	 * Get character for event details on keypress only.
	 * Returns null for special keys such as arrows etc.
	 * http://javascript.info/tutorial/keyboard-events
	 * @param {number} n
	 * @param {number} c
	 * @param {number} which
	 * @return {String}
	 */
	_keychar: function(n, c, which) {
		if (which === null || which === undefined) {
			return String.fromCharCode(n); // IE (below 9 or what?)
		} else if (which !== 0 && c) { // c != 0
			return String.fromCharCode(which); // the rest
		}
		return null;
	}

});

/*
 * Register broadcast type.
 */
gui.BROADCAST_KEYEVENT = 'gui-broadcast-keyevent';



}(self));
(function(window) {

"use strict";


/**
 * Namepspace object.
 */
window.edbml = gui.namespace('edbml', {

	/**
	 * Spirits will dispatch this action when EDBML has rendered.
	 */
	ACTION_RENDER: 'edbml-action-render',

	/**
	 * Automatically load EDBML scripts by naming convention?
	 * (ns.MySpirit would automatically load ns.MySpirit.edbml)
	 * @type {boolean}
	 */
	bootload: false,

	/**
	 * EDBML script declaration micro DSL.
	 * @param {String} id
	 */
	declare: function(id) {
		var configured;
		return {
			as: function($edbml) {
				configured = edbml.$runtimeconfigure($edbml);
				configured = gui.Object.assert(id, configured);
				configured.lock = function(out) {
					return function lockedout() {
						$edbml.$out = out;
						return configured.apply(this, arguments);
					};
				};
				return this;
			},
			withInstructions: function(pis) {
				configured.$instructions = pis;
			}
		};
	},

	/**
	 * Escape potentially unsafe string for use in HTML body context.
	 * @param {string} string
	 * @returns {string}
	 */
	safetext: function(string) {
		return edbml.Security.$safetext(string);
	},

	/**
	 * Escape potentially unsafe string for use in HTML attribute value.
	 * @param {string} string
	 * @returns {string}
	 */
	safeattr: function(string) {
		return edbml.Security.$safeattr(string);
	},

	// Privileged ................................................................

	/**
	 * Register action to execute later.
	 * @param {function} action
	 * @param {object} thisp
	 * @returns {function}
	 */
	$set: function(action, thisp) {
		return edbml._assign(action, thisp);
	},

	/**
	 * Get something from registered action.
	 * NOTE: {gui.ConfigPlugin} hardcoded `$edb.get`
	 * TODO: {gui.ConfigPlugin} should not hardcode
	 * @param {string} key
	 * @param @optional {string} sig
	 */
	$get: function(key) {
		return edbml._request(key);
	},

	/**
	 * Execute action with no return value.
	 * NOTE: {edb.FunctionUpdate} hardcoded `edb.$run`
	 * TODO: why was this split up in two steps? Sandboxing?
	 * @param {Element} elm
	 * @param {string} key
	 * @param @optional {string} sig
	 */
	$run: function(elm, key) {
		this._invoke(key, elm.value, elm.checked);
	},

	/**
	 * Garbage collect function that isn't called by the
	 * GUI using whatever strategy they prefer nowadays.
	 */
	$revoke: function(key) {
		this._invokables[key] = null; // garbage one
		delete this._invokables[key]; // garbage two
	},

	/**
	 * Configure EDBML function for runtime use. Note
	 * that `this` refers to the spirit instance here.
	 * @see {ts.gui.ScriptPlugin#_runtimeconfigure}
	 * @param {function} $edbml The (compiled) function as served to the page
	 * @returns {function}
	 */
	$runtimeconfigure: (function scoped() {
		function setupbefore($edbml, spirit) {
			$edbml.$out = $edbml.$out || new edbml.Out();
			$edbml.$att = new edbml.Att();
			if (spirit) {
				$edbml.$input = function(Type) {
					return spirit.script.$input.get(Type);
				};
			}
		}
		function cleanupafter($edbml, spirit) {
			$edbml.$out = null;
			$edbml.$att = null;
			if (spirit) {
				$edbml.$input = null;
			}
		}
		return function($edbml) {
			return function configured($in) {
				setupbefore($edbml, this);
				var res = $edbml.apply(this, arguments);
				cleanupafter($edbml, this);
				return res;
			};
		};
	}()),

	// Private ...................................................................

	/**
	 * Mapping EDBML-internal functions to keys
	 * so that they may later be recalled to run.
	 * @type {Map<String,function>}
	 */
	_invokables: {},

	/**
	 * Map function to generated key and return the key.
	 * @param {function} func
	 * @param {object} thisp
	 * @returns {String}
	 */
	_assign: function(func, thisp) {
		var key = gui.KeyMaster.generateKey();
		this._invokables[key] = function(value, checked) {
			return func.apply(thisp, [gui.Type.cast(value), checked]);
		};
		return key;
	},

	/*
	 *
	 */
	_invoke: function(key, value, checked) {
		var func = this._invokables[key];
		if (func) {
			gui.Tick.time(function() {
				func(value, checked);
			});
		} else {
			console.error('Out of synch');
		}
	},

	/**
	 * Get invokable function by key.
	 * @param {string} key
	 * @returns {function}
	 */
	_request: function(key, sig) {
		var func;
		if (sig) { // TODO: this
			console.error('Not supported');
		} else {
			if ((func = this._invokables[key])) {
				return func();
			} else {
				console.error('Out of synch');
			}
		}
	}

});



/**
 * Converts JS props to HTML attributes during EDBML rendering phase.
 * Any methods added to this prototype will become available in EDBML
 * scripts as `$att.mymethod()`
 * @param @optional Map<String,object> atts Default properties
 */
edbml.Att = function Att(atts) {
	if (atts) {
		gui.Object.extend(this, atts);
	}
};

edbml.Att.prototype = gui.Object.create(null, {

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object edbml.Att]';
	},

	// Privileged ................................................................

	/**
	 * Resolve single key-value to HTML attribute declaration.
	 * @param {String} att
	 * @returns {String}
	 */
	$: function(att) {
		var val = this[att],
			html = '';
		switch (gui.Type.of(val)) {
			case 'null':
			case 'undefined':
				break;
			default:
				val = edbml.Att.$encode(this[att]);
				html += att + '="' + val + '" ';
				break;
		}
		return html;
	},

	/**
	 * Resolve key-value, then delete it to prevent reuse.
	 * @param {String} att
	 */
	$pop: function(att) {
		var html = this.$(att);
		delete this[att];
		return html;
	},

	/**
	 * Resolve all key-values to HTML attribute declarations.
	 * @returns {String}
	 */
	$all: function() {
		var html = '';
		gui.Object.nonmethods(this).forEach(function(att) {
			html += this.$(att);
		}, this);
		return html;
	}

});

// Static privileged ...........................................................

/**
 * Stringify stuff to be used as HTML attribute values.
 * TODO: in "string", support simple/handcoded JSON object/array.
 * @param {object} data
 * @returns {String}
 */
edbml.Att.$encode = function(data) {
	var type = gui.Type.of(data);
	switch (type) {
		case 'string':
			data = edbml.safeattr(data);
			break;
		case 'number':
		case 'boolean':
			data = String(data);
			break;
		case 'object':
		case 'array':
			try {
				data = encodeURIComponent(JSON.stringify(data));
			} catch (jsonex) {
				throw new Error('Could not create HTML attribute: ' + jsonex);
			}
			break;
		case 'date':
			throw new Error('TODO: edbml.Att.encode standard date format?');
		default:
			throw new Error('Could not create HTML attribute for ' + type);
	}
	return data;
};



/**
 * Collects HTML output during EDBML rendering phase.
 * Any methods added to this prototype will become
 * available in EDBML scripts as: out.mymethod()
 */
edbml.Out = function Out() {};

edbml.Out.prototype = {

	/**
	 * HTML string (not well-formed while parsing).
	 * @type {String}
	 */
	html: '',

	/**
	 * Identification.
	 * @returns {String}
	 */
	toString: function() {
		return '[object edbml.Out]';
	},

	/**
	 * Get HTML result (output override scenario).
	 * @returns {String}
	 */
	write: function() {
		return this.html;
	}
};



/**
 * Year!
 */
edbml.Update = gui.Class.create(Object.prototype, {

	/**
	 * Matches hard|atts|insert|append|remove|function
	 * @type {String}
	 */
	type: null,

	/**
	 * Identifies associated element in one of two ways:
	 *
	 * 1) It's the id of an element. Or if no id:
	 * 2) It's the $instanceid of a {gui.Spirt}
	 * @see	{edbml.Update#element}
	 * @type {String}
	 */
	id: null,

	/**
	 * Tracking ancestor element IDs. We use this to regulate whether an
	 * update should be discarded because a hard replace has obsoleted it.
	 * @type {Map<String,boolean>}
	 */
	ids: null,

	/**
	 * Update context window.
	 * @type {Window}
	 */
	window: null,

	/**
	 * Update context document.
	 * @type {Document}
	 */
	document: null,

	/**
	 * Prepare debug summary.
	 */
	onconstruct: function() {
		this._summary = [];
	},

	/**
	 * The update method performs the actual update. Expect methods
	 * _beforeUpdate and _afterUpdate to be invoked at this point.
	 */
	update: function() {},

	/**
	 * Get element associated to this.id. Depending on update type,
	 * this element will be removed or added or updated and so on.
	 * The root element (the one whose spirit is assigned the script)
	 * may be indexed by "$instanceid" if no ID attribute is specified.
	 * @param @optional {function} cb Pathching https://github.com/Tradeshift/docs/issues/141
	 * @param @optional {object} thisp
	 * @returns {Element}
	 */
	element: function(cb, thisp) {
		var spirit, element = null;
		if (gui.KeyMaster.isKey(this.id)) {
			if ((spirit = gui.get(this.id))) {
				element = spirit.element;
			}
		}
		if (!element) {
			element = document.querySelector('#' + this.id);
		}
		if (element) {
			if (cb) {
				cb.call(this, element);
			}
		} else {
			if (edbml.debug) {
				console.error('No element to match @id: ' + this.id);
			}
		}
		return element;
	},

	/**
	 * Clean stuff up for what it's worth.
	 */
	dispose: function() {
		this._summary = null;
	},

	// Private ...................................................................

	/**
	 * Tracking attribute changes for debugging.
	 * @type {Array<String>}
	 */
	_summary: null,

	/**
	 * When something changed, dispatch pre-update event.
	 * @param {Element} element
	 * @return {boolean}
	 */
	_beforeUpdate: function(element) {
		var event = 'x-beforeupdate-' + this.type;
		return this._dispatch(element, event);
	},

	/**
	 * When something changed, dispatch post-update event.
	 * @param {Element} element
	 * @return {boolean}
	 */
	_afterUpdate: function(element) {
		var event = 'x-afterupdate-' + this.type;
		return this._dispatch(element, event);
	},

	/**
	 * Dispatch bubbling DOM event for potential handlers to intercept the update.
	 * TODO: Investigate CustomEvent support in our browser stack...
	 * @param {Element} element
	 * @param {String} name
	 * @return {boolean} False if event was canceled
	 */
	_dispatch: function(element, name) {
		if (element) { // hotfix https://github.com/Tradeshift/docs/issues/141
			var event = document.createEvent('UIEvents');
			event.initEvent(name, true, true);
			return element.dispatchEvent(event);
		} else {
			console.error('Occasional EDBML dysfunction just happened');
		}
	},

	/**
	 * Report update in debug mode.
	 * @param {String} report
	 */
	_report: function(report) {
		if (edbml.debug) {
			if (gui.KeyMaster.isKey(this.id)) {
				report = report.replace(this.id, '(anonymous)');
			}
			console.debug(report, this.element());
		}
	}

}, {}, { // Static .............................................................

	/**
	 * Default replace update. A section of the DOM tree is replaced.
	 * {@see ReplaceUpdate}
	 * @type {String}
	 */
	TYPE_HARD: 'hard',

	/**
	 * Attribute update. The element must have an ID specified.
	 * {@see UpdateManager#hasSoftAttributes}
	 * {@see AttributesUpdate}
	 * @type {String}
	 */
	TYPE_ATTS: 'atts',

	/**
	 * Insertion update: Inserts a child without replacing the parent. Child
	 * siblings must all be Elements and they must all have an ID specified.
	 * {@see SiblingUpdate}
	 * @type {String}
	 */
	TYPE_INSERT: 'insert',

	/**
	 * {@see SiblingUpdate}
	 * @type {String}
	 */
	TYPE_APPEND: 'append',

	/**
	 * Removal update: Removes a child without replacing the parent. Child
	 * siblings must all be Elements and they must all have an ID specified.
	 * {@see SiblingUpdate}
	 * @type {String}
	 */
	TYPE_REMOVE: 'remove',

	/**
	 * EDB function update. Dereferencing functions bound to GUI
	 * events that are no longer associated to any DOM element.
	 * @type {String}
	 */
	TYPE_FUNCTION: 'function'

});



/**
 * Update attributes. Except for the ID which
 * is required to be the same before and after.
 * @using {gui.CSSPlugin} CSSPlugin
 */
edbml.AttsUpdate = (function using(CSSPlugin) {
	return edbml.Update.extend({

		/**
		 * Update type.
		 * @type {String}
		 */
		type: edbml.Update.TYPE_ATTS,

		/**
		 * Setup update.
		 * @param {String} id
		 * @param {Element} xnew
		 * @param {Element} xold
		 * @returns {edbml.AttsUpdate}
		 */
		onconstruct: function(id, xnew, xold) {
			edbml.Update.prototype.onconstruct.call(this);
			this.id = id;
			this._xnew = xnew;
			this._xold = xold;
		},

		/**
		 * Update attributes.
		 */
		update: function() {
			edbml.Update.prototype.update.call(this);
			this.element(function(element) {
				if (this._beforeUpdate(element)) {
					this._update(element);
					this._afterUpdate(element);
					this._report();
				}
			});
		},

		/**
		 * Better not keep a reference to any DOM element around here.
		 * @overrides {edbml.Update#dispose}
		 */
		dispose: function() {
			edbml.Update.prototype.dispose.call(this);
			delete this._xold;
			delete this._xnew;
		},

		// Private .................................................................

		/**
		 * (XML) element before update.
		 * @type {Element}
		 */
		_xold: null,

		/**
		 * (XML) element after update.
		 * @type {Element}
		 */
		_xnew: null,

		/**
		 * Actually update attributes.
		 * 1. Create and update attributes.
		 * 2. Remove attributes
		 * @param {HTMLElement} element
		 */
		_update: function(element) {
			Array.forEach(this._xnew.attributes, function(newatt) {
				var oldatt = this._xold.getAttribute(newatt.name);
				if (oldatt === null || oldatt !== newatt.value) {
					if (newatt.name === 'class') {
						this._classlist(element, this._xold, newatt.value);
					} else {
						this._set(element, newatt.name, newatt.value);
					}
					this._summary.push(
						'@' + newatt.name + '="' + newatt.value + '"' +
						(element.id ? ' (#' + element.id + ')' : '')
					);
				}
			}, this);
			Array.forEach(this._xold.attributes, function(oldatt) {
				if (!this._xnew.hasAttribute(oldatt.name)) {
					if (oldatt.name === 'class') {
						this._classlist(element, this._xold, '');
					} else {
						this._del(element, oldatt.name, null);
					}
					this._summary.push(
						'removed @' + oldatt.name +
						(element.id ? ' (#' + element.id + ')' : '')
					);
				}
			}, this);
		},

		/**
		 * Set element attribute.
		 * @param {Element} element
		 * @param {String} name
		 * @param {String} value
		 * @return
		 */
		_set: function(element, name, value) {
			var spirit = element.spirit;
			if (spirit) {
				spirit.att.set(name, value);
			} else {
				element.setAttribute(name, value);
				switch (name) {
					case 'checked':
						if (!element.checked) {
							element.checked = true;
						}
						break;
					case 'value':
						if (element.value !== value) {
							element.value = String(value); // ?
						}
						break;
				}
			}
		},

		/**
		 * Set element attribute.
		 * @param {Element} element
		 * @param {String} name
		 * @param {String} value
		 * @return
		 */
		_del: function(element, name) {
			var spirit = element.spirit;
			if (spirit) {
				spirit.att.del(name);
			} else {
				switch (name) {
					case 'checked':
						element.checked = false;
						break;
					default:
						element.removeAttribute(name);
						break;
				}
			}
		},

		/**
		 * Maintain the class attribute non-destructively
		 * so that outside agencies may contribute to it.
		 * @param {Element} element The actual DOM
		 * @param {Element} xelement The virtual DOM
		 * @param {string} classname
		 */
		_classlist: function(element, xelement, classname) {
			var newnames = classname.split(' ');
			var oldnames = xelement.className.split(' ');
			oldnames.forEach(function(oldname) {
				if (oldname && newnames.indexOf(oldname) === -1) {
					CSSPlugin.remove(element, oldname);
				}
			});
			newnames.forEach(function(newname) {
				if (newname && oldnames.indexOf(newname) === -1) {
					CSSPlugin.add(element, newname);
				}
			});
		},

		/**
		 * Debug changes.
		 */
		_report: function() {
			var summary = this._summary.join(', ');
			var message = 'edbml.AttsUpdate "#' + this.id + '" ' + summary;
			edbml.Update.prototype._report.call(this, message);
		}

	});
}(gui.CSSPlugin));



/**
 * Hey.
 * @using {gui.DOMPlugin} DOMPlugin
 */
edbml.HardUpdate = (function using(DOMPlugin) {
	return edbml.Update.extend({

		/**
		 * Update type.
		 * @type {String}
		 */
		type: edbml.Update.TYPE_HARD,

		/**
		 * XML element.
		 * @type {Element}
		 */
		xelement: null,

		/**
		 * Setup update.
		 * @param {String} id
		 * @param {Element} xelement
		 */
		onconstruct: function(id, xelement) {
			edbml.Update.prototype.onconstruct.call(this);
			this.id = id;
			this.xelement = xelement;
		},

		/**
		 * Replace target subtree.
		 */
		update: function() {
			edbml.Update.prototype.update.call(this);
			this.element(function(element) {
				if (this._beforeUpdate(element)) {
					gui.DOMPlugin.html(element, this.xelement.innerHTML);
					this._afterUpdate(element);
					this._report();
				}
			});
		},

		/**
		 * Clean up.
		 */
		dispose: function() {
			edbml.Update.prototype.dispose.call(this);
			delete this.xelement;
		},

		// Private ...................................................................

		/**
		 * Hello.
		 */
		_report: function() {
			var message = 'edbml.HardUpdate #' + this.id;
			edbml.Update.prototype._report.call(this, message);
		}
	});
}(gui.DOMPlugin));



/**
 * Soft update.
 * @extends {edbml.Update}
 */
edbml.SoftUpdate = edbml.Update.extend({

	/**
	 * XML element stuff (not used by edbml.RemoveUpdate).
	 * @type {Element}
	 */
	xelement: null,

	/**
	 * Update type defined by descendants.
	 * Matches insert|append|remove
	 * @type {String}
	 */
	type: null,

	/**
	 * Clean stuff up for what it's worth.
	 */
	dispose: function() {
		edbml.Update.prototype.dispose.call(this);
		delete this.xelement;
	},

	// Private ...................................................................

	/**
	 * TODO: make static, argument xelement
	 * Convert XML element to HTML element. Method document.importNode can not
	 * be used in Firefox, it will kill stuff such as the document.forms object.
	 * TODO: Support namespaces and what not
	 * @param {HTMLElement} element
	 */
	_import: function(parent) {
		var temp = document.createElement(parent.nodeName);
		temp.innerHTML = this.xelement.outerHTML;
		return temp.firstChild;
	}
});



/**
 * Insert.
 * @extends {edbml.SoftUpdate}
 */
edbml.InsertUpdate = edbml.SoftUpdate.extend({

	/**
	 * Update type.
	 * @type {String}
	 */
	type: edbml.Update.TYPE_INSERT,

	/**
	 * XML element.
	 * @type {Element}
	 */
	xelement: null,

	/**
	 * Setup update.
	 * @param {String} id Insert before this ID
	 * @param {Element} xelement
	 */
	onconstruct: function(id, xelement) {
		this.id = id;
		this.xelement = xelement;
	},

	/**
	 * Execute update.
	 */
	update: function() {
		var parent, child;
		this.element(function(sibling) {
			parent = sibling.parentNode;
			child = this._import(parent);
			if (this._beforeUpdate(parent)) {
				parent.insertBefore(child, sibling);
				this._afterUpdate(child);
				this._report();
			}
		});
	},

	// Private ...................................................................

	/**
	 * Report.
	 * TODO: Push to update manager.
	 */
	_report: function() {
		var message = 'edbml.InsertUpdate #' + this.xelement.getAttribute('id');
		edbml.SoftUpdate.prototype._report.call(this, message);
	}
});



/**
 * Append.
 * @extends {edbml.SoftUpdate}
 */
edbml.AppendUpdate = edbml.SoftUpdate.extend({

	/**
	 * Update type.
	 * @type {String}
	 */
	type: edbml.Update.TYPE_APPEND,

	/**
	 * Setup update.
	 * @param {String} id
	 * @param {Element} xelement
	 */
	onconstruct: function(id, xelement) {
		this.id = id;
		this.xelement = xelement;
	},

	/**
	 * Execute update.
	 */
	update: function() {
		this.element(function(parent) {
			var child = this._import(parent);
			if (this._beforeUpdate(parent)) {
				parent.appendChild(child);
				this._afterUpdate(child);
				this._report();
			}
		});
	},

	/**
	 * Report.
	 * TODO: Push to update manager.
	 */
	_report: function() {
		var message = 'edbml.AppendUpdate #' + this.xelement.getAttribute('id');
		edbml.SoftUpdate.prototype._report.call(this, message);
	}
});



/**
 * Remove.
 * @extends {edbml.SoftUpdate}
 */
edbml.RemoveUpdate = edbml.SoftUpdate.extend({

	/**
	 * Update type.
	 * @type {String}
	 */
	type: edbml.Update.TYPE_REMOVE,

	/**
	 * Setup update.
	 * @param {String} id
	 */
	onconstruct: function(id) {
		this.id = id;
	},

	/**
	 * Execute update.
	 */
	update: function() {
		this.element(function(element) {
			var parent = element.parentNode;
			if (this._beforeUpdate(element)) {
				parent.removeChild(element);
				this._afterUpdate(parent);
				this._report();
			}
		});
	},

	// Private ...................................................................

	/**
	 * Report.
	 * TODO: Push to update manager.
	 */
	_report: function() {
		var message = 'edbml.RemoveUpdate #' + this.id;
		edbml.SoftUpdate.prototype._report.call(this, message);
	}
});



/**
 * Updating the functions it is.
 * TODO: revoke all functions from destructed spirit (unless window.unload)
 */
edbml.FunctionUpdate = edbml.Update.extend({

	/**
	 * Update type.
	 * @type {String}
	 */
	type: edbml.Update.TYPE_FUNCTION,

	/**
	 * Setup update.
	 * @param {String} id
	 * @param @optional {Map<String,String>} map
	 */
	onconstruct: function(id, map) {
		edbml.Update.prototype.onconstruct.call(this);
		this.id = id;
		this._map = map || null;
	},

	/**
	 * Do the update.
	 */
	update: function() {
		var count = 0;
		this.element(function(elm) {
			if (this._map) {
				if ((count = edbml.FunctionUpdate._remap(elm, this._map))) {
					this._report('remapped ' + count + ' keys');
				}
			} else {
				if ((count = edbml.FunctionUpdate._revoke(elm))) {
					this._report('revoked ' + count + ' keys');
				}
			}
		});
	},

	// Private ...................................................................

	/**
	 * Report the update.
	 * @param {String} report
	 */
	_report: function(report) {
		var message = 'edbml.FunctionUpdate ' + report + ' (' + this.$instanceid + ')';
		edbml.Update.prototype._report.call(this, message);
	}

}, { // Static .................................................................

	/**
	 * @param {Element} element
	 */
	_revoke: function(element) {
		var att, count = 0,
			keys;
		this._getatts(element).forEach(function(x) {
			att = x[1];
			keys = gui.KeyMaster.extractKey(att.value);
			if (keys) {
				keys.forEach(function(key) {
					edbml.$revoke(key);
					count++;
				});
			}
		});
		return count;
	},

	/**
	 * @param {Element} element
	 * @param {Map<String,String>} map
	 */
	_remap: function(element, map) {
		var count = 0,
			oldkeys, newkey, newval;
		if (Object.keys(map).length) {
			this._getatts(element).forEach(function(x) {
				var elm = x[0];
				var att = x[1];
				if ((oldkeys = gui.KeyMaster.extractKey(att.value))) {
					oldkeys.forEach(function(oldkey) {
						if ((newkey = map[oldkey])) {
							newval = att.value.replace(oldkey, newkey);
							elm.setAttribute(att.name, newval);
							edbml.$revoke(oldkey);
							count++;
						}
					});
				}
			});
		}
		return count;
	},

	/**
	 * Collect attributes from DOM subtree that
	 * somewhat resemble EDBML poke statements.
	 * @returns {Array<Array<Node>>}
	 */
	_getatts: function(element) {
		var val, atts = [];
		new gui.Crawler('edbml-crawler-functionupdate').descend(element, {
			handleElement: function(elm) {
				if (elm !== element) {
					Array.forEach(elm.attributes, function(att) {
						val = att.value;
						if (val.includes('edbml.$run') || val.includes('edbml.$get')) {
							atts.push([elm, att]);
						}
					});
					if (elm.spirit && elm.spirit.script.loaded) { // ... not our DOM tree
						return gui.Crawler.SKIP_CHILDREN;
					}
				}
			}
		});
		return atts;
	}

});



/**
 * We collect updates over-aggresively in an attempt to traverse
 * the DOM tree in one direction only. The fellow will helps us
 * reduce the collected updates to the minimum required subset.
 */
edbml.UpdateCollector = gui.Class.create(Object.prototype, {

	/**
	 * Setup.
	 */
	onconstruct: function() {
		this._updates = [];
		this._hardupdates = {};
	},

	/**
	 * Collect update candidate. All updates may not be evaluated, see below.
	 * @param {edbml.Update} update
	 * @param {Map<String,boolean>} ids Indexing ID of ancestor elements
	 * @returns {edbml.UpdateCollector}
	 */
	collect: function(update, ids) {
		this._updates.push(update);
		if (update.type === edbml.Update.TYPE_HARD) {
			this._hardupdates[update.id] = true;
		} else {
			update.ids = ids || {};
		}
		return this;
	},

	/**
	 * Will this element be hardupdated?
	 * @param {String} id Element ID
	 * @returns {boolean}
	 */
	hardupdates: function(id) {
		return !!this._hardupdates[id];
	},

	/**
	 * Apply action to all relevant updates. For example:
	 * An attribute update is not considered relevant if
	 * the parent is scheduled to perform a full replace
	 * of it's children.
	 * @param {function} action
	 */
	eachRelevant: function(action) {
		var hardupdates = this._hardupdates;
		this._updates.filter(function(update) {
			return (
				update.type === edbml.Update.TYPE_HARD ||
				Object.keys(update.ids).every(function(id) {
					return !hardupdates.hasOwnProperty(id);
				})
			);
		}).forEach(function(update) {
			action(update);
		});
	},

	/**
	 * TODO: At some point, figure out what exactly to do here.
	 */
	dispose: function() {
		this._hardupdates = null;
		this._updates = null;
	},

	// Private ...................................................................

	/**
	 * Collecting updates.
	 * @type {Array<edbml.Update>}
	 */
	_updates: null,

	/**
	 * Tracking hard-updated element IDs.
	 * @type {Set<String>}
	 */
	_hardupdates: null

});



/**
 * Utilities for the {edbml.UpdateManager}.
 */
edbml.UpdateAssistant = {

	/**
	 * Parse markup to element.
	 * TODO: Use DOMParser versus "text/html" for browsers that support it?
	 * TODO: All sorts of edge cases for IE6 compatibility. Hooray for HTML5.
	 * TODO: Evaluate well-formedness in debug mode for XHTML documents.
	 * @param {String} markup
	 * @param {String} id
	 * @param {Element} element
	 * @returns {Element}
	 */
	parse: function(markup, id, element) { // gonna need to know the parent element type here...
		/*
		 * TODO: run this by the gui.HTMLParser for maximum backwards lameness with TABLE and friends
		 */
		element = document.createElement(element.localName);
		element.innerHTML = markup;
		element.id = id;
		// TODO: Plugin this!
		Array.forEach(element.querySelectorAll('option'), function(option) {
			switch (option.getAttribute('selected')) {
				case 'true':
					option.setAttribute('selected', 'selected');
					break;
				case 'false':
					option.removeAttribute('selected');
					break;
			}
		});
		// TODO: Plugin this!
		var inputs = 'input[type=checkbox],input[type=radio]';
		Array.forEach(element.querySelectorAll(inputs), function(option) {
			switch (option.getAttribute('checked')) {
				case 'true':
					option.setAttribute('checked', 'checked');
					break;
				case 'false':
					option.removeAttribute('checked');
					break;
			}
		});
		return element;
	},

	/**
	 * Mapping element id to it's ordinal position.
	 * @returns {Map<String,number>}
	 */
	order: function(nodes) {
		var order = {};
		Array.forEach(nodes, function(node, index) {
			if (node.nodeType === Node.ELEMENT_NODE) {
				order[node.id] = index;
			}
		}, this);
		return order;
	},

	/**
	 * Convert an NodeList into an ID-to-element map.
	 * @param {NodeList} nodes
	 * @return {Map<String,Element>}
	 */
	index: function(nodes) {
		var result = Object.create(null);
		Array.forEach(nodes, function(node, index) {
			if (node.nodeType === Node.ELEMENT_NODE) {
				result[node.id] = node;
			}
		}, this);
		return result;
	}
};



/**
 * It's the update manager.
 * @using {edbml.UpdateCollector} UpdateCollector
 * @using {edbml.HardUpdate} HardUpdate
 * @using {edbml.AttsUpdate} AttsUpdate
 * @using {edbml.InsertUpdate} InsertUpdate
 * @using {edbml.RemoveUpdate} RemoveUpdate
 * @using {edbml.AppendUpdate} AppendUpdate
 * @using {edbml.FunctionUpdate} FunctionUpdate
 * @using {gui.Object} GuiObject
 * @using {gui.KeyMaster} KeyMaster
 */
edbml.UpdateManager = (function using(UpdateCollector, HardUpdate, AttsUpdate, InsertUpdate, RemoveUpdate, AppendUpdate, FunctionUpdate, GuiObject, KeyMaster) {
	return gui.Class.create(Object.prototype, {

		/**
		 * @param {gui.Spirit} spirit
		 */
		onconstruct: function(spirit) {
			this._keyid = spirit.dom.id() || spirit.$instanceid;
			this._spirit = spirit;
		},

		/**
		 * Update.
		 * @param {String} html
		 */
		update: function(html) {
			if (!this._spirit.life.destructed) {
				this._updates = new UpdateCollector();
				this._functions = {};
				if (!this._olddom) {
					this._first(html);
				} else {
					this._next(html);
					this._updates.collect(
						new FunctionUpdate(this._keyid, this._functions)
					);
				}
				this._updates.eachRelevant(function(update) {
					update.update();
					update.dispose();
				});
				if (this._updates) { // huh? how can it be null?
					this._updates.dispose();
				}
				this._updates = null;
			}
		},

		// Private ...................................................................

		/**
		 * This can be one of two:
		 * 1) Spirit element ID (if element has ID).
		 * 2) Spirits $instanceid (if no element ID).
		 * @type {String}
		 */
		_keyid: null,

		/**
		 * Spirit document.
		 * @type {Document}
		 */
		_doc: null,

		/**
		 * Associated spirit.
		 * @type {gui.Spirit}
		 */
		_spirit: null,

		/**
		 * Current DOM subtree.
		 * @type {Document}
		 */
		_olddom: null,

		/**
		 * Incoming DOM subtree.
		 * @type {Document}
		 */
		_nedwdom: null,

		/**
		 * List of updates to apply.
		 * @type {[type]}
		 */
		_updates: null,

		/**
		 * Assistant utilities.
		 * @type {edbml.UpdateAssistant}
		 */
		_assistant: edbml.UpdateAssistant,

		/**
		 * First update (always a hard update).
		 * @param {String} html
		 */
		_first: function(html) {
			this._olddom = this._parse(html);
			this._updates.collect(
				new HardUpdate(this._keyid, this._olddom)
			);
		},

		/**
		 * Next update.
		 * @param {String} html
		 */
		_next: function(html) {
			this._newdom = this._parse(html);
			this._crawl(this._newdom, this._olddom, this._newdom, this._keyid, {});
			this._olddom = this._newdom;
		},

		/**
		 * Parse markup to element.
		 * @param {String} html
		 * @returns {Element}
		 */
		_parse: function(html) {
			return this._assistant.parse(html, this._keyid, this._spirit.element);
		},

		/**
		 * Crawl.
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @param {Element} lastnode
		 * @param {String} id
		 * @param {Map<String,boolean>} ids
		 * @returns {boolean}
		 */
		_crawl: function(newchild, oldchild, lastnode, id, ids) {
			var result = true;
			while (newchild && oldchild && !this._updates.hardupdates(id)) {
				switch (newchild.nodeType) {
					case Node.TEXT_NODE:
						result = this._check(newchild, oldchild, lastnode, id, ids);
						break;
					case Node.ELEMENT_NODE:
						result = this._scan(newchild, oldchild, lastnode, id, ids);
						break;
				}
				newchild = newchild.nextSibling;
				oldchild = oldchild.nextSibling;
			}
			return result;
		},

		/**
		 * Scan elements.
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @param {Element} lastnode
		 * @param {String} id
		 * @param {Map<String,boolean>} ids
		 * @returns {boolean}
		 */
		_scan: function(newnode, oldnode, lastnode, id, ids) {
			var result = true, oldid = oldnode.id;
			if ((result = this._check(newnode, oldnode, lastnode, id, ids))) {
				if (oldid) {
					ids = GuiObject.copy(ids);
					lastnode = newnode;
					ids[oldid] = true;
					id = oldid;
				}
				result = this._crawl(newnode.firstChild, oldnode.firstChild, lastnode, id, ids);
			}
			return result;
		},

		/**
		 * Hello.
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @param {Element} lastnode
		 * @param {String} id
		 * @param {Map<String,boolean>} ids
		 * @returns {boolean}
		 */
		_check: function(newnode, oldnode, lastnode, id, ids) {
			var result = true;
			var isSoftUpdate = false;
			var isPluginUpdate = false; // TODO: plugins...
			if ((newnode && !oldnode) || (!newnode && oldnode)) {
				result = false;
			} else if ((result = newnode.nodeType === oldnode.nodeType)) {
				switch (oldnode.nodeType) {
					case Node.TEXT_NODE:
						if (newnode.data !== oldnode.data) {
							result = false;
						}
						break;
					case Node.ELEMENT_NODE:
						if ((result = this._familiar(newnode, oldnode))) {
							if ((result = this._checkatts(newnode, oldnode, ids))) {
								if (this._maybesoft(newnode, oldnode)) {
									if (this._confirmsoft(newnode, oldnode)) {
										this._updatesoft(newnode, oldnode, ids);
										isSoftUpdate = true; // prevents the replace update
									}
									result = false; // crawling continued in _updatesoft
								} else {
									if (oldnode.localName !== 'textarea') { // TODO: better forms support!
										result = newnode.childNodes.length === oldnode.childNodes.length;
										if (!result && oldnode.id) {
											lastnode = newnode;
											id = oldnode.id;
										}
									}
								}
							}
						}
						break;
				}
			}
			if (!result && !isSoftUpdate && !isPluginUpdate) {
				this._updates.collect(new FunctionUpdate(id));
				this._updates.collect(new HardUpdate(id, lastnode));
			}
			return result;
		},

		/**
		 * Roughly estimate whether two elements could be identical.
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @returns {boolean}
		 */
		_familiar: function(newnode, oldnode) {
			return ['namespaceURI', 'localName'].every(function(prop) {
				return newnode[prop] === oldnode[prop];
			});
		},

		/**
		 * Same id trigges attribute synchronization;
		 * different id triggers hard update of ancestor.
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @param {Map<String,boolean>} ids
		 * @returns {boolean} When false, replace "hard" and stop crawling.
		 */
		_checkatts: function(newnode, oldnode, ids) {
			var result = true;
			var update = null;
			if (this._attschanged(newnode.attributes, oldnode.attributes, ids)) {
				var newid = newnode.id;
				var oldid = oldnode.id;
				if (newid && newid === oldid) {
					update = new AttsUpdate(oldid, newnode, oldnode);
					this._updates.collect(update, ids);
				} else {
					result = false;
				}
			}
			return result;
		},

		/**
		 * Attributes changed? When an attribute update is triggered by an EDB poke,
		 * we verify that this was the *only* thing that changed and substitute the
		 * default update with a {FunctionUpdate}.
		 * @see {FunctionUpdate}
		 * @param {NodeList} newatts
		 * @param {NodeList} oldatts
		 * @param {?} ids
		 * @returns {boolean}
		 */
		_attschanged: function(newatts, oldatts, ids) {
			var changed = newatts.length !== oldatts.length;
			if (!changed) {
				changed = !Array.every(newatts, function ischanged(newatt) {
					var oldatt = oldatts.getNamedItem(newatt.name);
					return oldatt && (oldatt.value === newatt.value ||
						this._onlyedbmlchange(newatt.value, oldatt.value));
				}, this);
			}
			return changed;
		},

		/**
		 * Attribute change was an `edbml.$run` or `edbml.$get` statement?
		 * @param {string} newval
		 * @param {string} oldval
		 * @returns {boolean}
		 */
		_onlyedbmlchange: function(newval, oldval) {
			if ([newval, oldval].every(function(val) {
				return val.includes('edbml.$');
			})) {
				var newkey;
				var newkeys = KeyMaster.extractKey(newval);
				var oldkeys = KeyMaster.extractKey(oldval);
				if (newkeys && oldkeys) {
					oldkeys.forEach(function(oldkey, i) {
						newkey = newkeys[i];
						newval = newval.replace(newkey, '');
						oldval = oldval.replace(oldkey, '');
						this._functions[oldkey] = newkey;
					}, this);
					return newval === oldval;
				}
			}
			return false;
		},

		/**
		 * Are element children candidates for "soft" sibling updates?
		 * 1) Both parents must have the same ID
		 * 2) All children must have a specified ID
		 * 3) All children must be elements or whitespace-only textnodes
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @return {boolean}
		 */
		_maybesoft: function(newnode, oldnode) {
			if (newnode && oldnode) {
				return newnode.id && newnode.id === oldnode.id &&
					this._maybesoft(newnode) &&
					this._maybesoft(oldnode);
			} else {
				return Array.every(newnode.childNodes, function(node) {
					var res = true;
					switch (node.nodeType) {
						case Node.TEXT_NODE:
							res = node.data.trim() === '';
							break;
						case Node.ELEMENT_NODE:
							res = node.id !== '';
							break;
					}
					return res;
				}, this);
			}
		},

		/**
		 * "soft" siblings can only be inserted and removed. This method verifies that
		 * elements retain their relative positioning before and after an update. Changing
		 * the ordinal position of elements is not supported since this might destruct UI
		 * state (moving eg. an iframe around using DOM methods would reload the iframe).
		 * TODO: Default support ordering and make it opt-out instead?
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @returns {boolean}
		 */
		_confirmsoft: function(newnode, oldnode) {
			var res = true,
				prev = null;
			var oldorder = this._assistant.order(oldnode.childNodes);
			return Array.every(newnode.childNodes, function(node, index) {
				if (node.nodeType === Node.ELEMENT_NODE) {
					var id = node.id;
					if (oldorder.hasOwnProperty(id) && oldorder.hasOwnProperty(prev)) {
						res = oldorder[id] > oldorder[prev];
					}
					prev = id;
				}
				return res;
			}, this);
		},

		/**
		 * Update "soft" siblings by adding and removing elements.
		 * @param {Element} newnode
		 * @param {Element} oldnode
		 * @param {Map<String,boolean>} ids
		 * @return {boolean}
		 */
		_updatesoft: function(newnode, oldnode, ids) {
			var updates = [];
			var news = this._assistant.index(newnode.childNodes);
			var olds = this._assistant.index(oldnode.childNodes);

			// add elements?
			var child = newnode.lastElementChild,
				topid = oldnode.id,
				oldid = null,
				newid = null;
			while (child) {
				newid = child.id;
				if (!olds[newid]) {
					if (oldid) {
						updates.push(
							new InsertUpdate(oldid, child)
						);
					} else {
						updates.push(
							new AppendUpdate(topid, child)
						);
					}
				} else {
					oldid = newid;
				}
				child = child.previousElementSibling;
			}

			// remove elements?
			Object.keys(olds).forEach(function(id) {
				if (!news[id]) {
					updates.push(
						new RemoveUpdate(id)
					);
					updates.push(
						new FunctionUpdate(id)
					);
				} else { // note that crawling continues here...
					var n1 = news[id];
					var n2 = olds[id];
					this._scan(n1, n2, n1, id, ids);
				}
			}, this);

			// register updates
			updates.reverse().forEach(function(update) {
				this._updates.collect(update, ids);
			}, this);
		}

	});
}(
	edbml.UpdateCollector,
	edbml.HardUpdate,
	edbml.AttsUpdate,
	edbml.InsertUpdate,
	edbml.RemoveUpdate,
	edbml.AppendUpdate,
	edbml.FunctionUpdate,
	gui.Object,
	gui.KeyMaster
));



/**
 * The ScriptPlugin shall render the spirits HTML.
 * @extends {gui.Plugin}
 * @using {gui.Combo.chained}
 * @using {gui.Arguments.confirmed}
 * @using {gui.Type} Type
 * @using {gui.Tick} Tick
 * @using {gui.Object} guiObject
 * @using {gui.Array} guiArray
 * @using {gui.DOMPlugin} DOMPlugin
 * @using {gui.Broadcast} Broadcast
 */
edbml.ScriptPlugin = (function using(chained, confirmed, Type, Tick, guiObject, guiArray, DOMPlugin, Broadcast) {
	return gui.Plugin.extend({

		/**
		 * Script has been loaded?
		 * @type {boolean}
		 */
		loaded: false,

		/**
		 * Script has been run? Flipped after first run.
		 * TODO: deprecate and use 'spirit.life.rendered'
		 * @type {boolean}
		 */
		ran: false,

		/**
		 * Log development stuff to console?
		 * @type {boolean}
		 */
		debug: false,

		/**
		 * Rendering suspended?
		 * @type {boolean}
		 */
		suspended: false,

		/**
		 * Construction time.
		 */
		onconstruct: function() {
			gui.Plugin.prototype.onconstruct.call(this);
			this._oldprops = {};
			this._newprops = {};
		},

		/**
		 * Destruction time.
		 */
		ondestruct: function() {
			gui.Plugin.prototype.ondestruct.call(this);
			if (this.loaded) {
				Tick.cancelFrame(this._frameindex);
				this.spirit.life.remove(gui.LIFE_ENTER, this);
				Broadcast.remove(edb.BROADCAST_ACCESS, this);
				if (this.$input) { // TODO: interface for this (dispose)
					this.$input.ondestruct();
					this.$input.$ondestruct();
				}
				var oldprops = this._oldprops;
				Object.keys(oldprops).forEach(function(id) {
					try {
						oldprops[id].object.removeObserver(this);
					} catch (exception) { // could this possibly fail?
						console.error('Please tell jmo@ that you got this exception');
					}
				}, this);
			}
		},

		/**
		 * Load EDBML script.
		 * @param {function|String} script
		 * @returns {edb.ScriptPlugin}
		 */
		load: chained(confirmed('function|string')(function(script) {
			script = Type.isFunction(script) ? script : guiObject.lookup(script);
			if (script) {
				this.loaded = true;
				this._script = script;
				this._updater = new edbml.UpdateManager(this.spirit);
				this._process(script.$instructions);
				if (!this.$input) {
					this.run();
				}
			}
		})),

		/**
		 * Handle input.
		 * @param {edb.Input} input
		 */
		oninput: function(input) {
			if (this.loaded) {
				if (input.revoked) {
					this.write('');
				} else {
					if (!this.$input || this.$input.done) {
						this._schedule();
					}
				}
			} else {
				this._notloaded();
			}
		},

		/**
		 * Run script and write result to DOM (if needed).
		 */
		run: function(/* arguments */) {
			Tick.cancelFrame(this._frameindex);
			if (this.loaded) {
				if (!this.$input || this.$input.done) {
					if (this.spirit.life.entered) {
						this.write(this._run.apply(this, arguments));
					} else {
						this.spirit.life.add(gui.LIFE_ENTER, this);
						this._arguments = arguments;
					}
				} else {
					this._notready();
				}
			} else {
				this._notloaded();
			}
		},

		/**
		 * Write the actual HTML to screen. You should probably only
		 * call this method if you are producing your own markup
		 * somehow, ie. not using EDBML templates out of the box.
		 * @param {String} html
		 */
		write: function(html) {
			if (!this.suspended) {
				var changed = this._html !== html;
				var focused = this._focusedfield();
				if (changed) {
					this._html = html;
					this._updater.update(html);
					if (focused) {
						this._restorefocus(focused);
					}
				}
				this._status(this.spirit);
				this.ran = true;
			} else {
				if (edbml.debug) {
					console.debug('(ScriptPlugin was suspended)', this.$instanceid);
				}
			}
		},

		/**
		 * Privately input types(s) using `this.script.input(type)`
		 * @param {edb.Type|Array<edb.Type>}
		 * @returns {edb.Type|Array<edb.Type>}
		 */
		input: function(/* ...arguments */) {
			var inputs, input;
			if ((input = this.$input)) {
				if (this.loaded) {
					inputs = guiArray.make(arguments).map(function(type) {
						return new edb.Input(type.constructor, type);
					});
					/*
					 * This will give the user a chance to update
					 * the Type before we evaluate it internally.
					 * TODO: this would break the CoverSpirit CSS
					 * animation, look into how this works out...
					 */
					var that = this;
					// gui.Tick.next(function disabled_for_now() {
					if (!that.$destructed) {
						inputs.forEach(function(i) {
							input.$oninput(i);
						});
					}
					// });
					return inputs.length > 1 ? inputs : inputs[0]; // TODO: not return???
				} else {
					this._notloaded();
				}
			} else {
				this._noinputexpected();
			}
		},

		/**
		 * Privately revoke type(s). Accepts instances or constructors. Not tested!
		 */
		revoke: function(/* arguments */) {
			guiArray.make(arguments).forEach(function(type) {
				var edbType = edb.Type.is(type) ? type.constructor : type;
				this.$input.$oninput(
					new edb.Input(edbType, null)
				);
			}, this);
		},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} broadcast
		 */
		onbroadcast: function(b) {
			var keys = this._newprops;
			switch (b.type) {
				case edb.BROADCAST_ACCESS:
					var type = b.data[0];
					var name = b.data[1];
					var id = type.$instanceid;
					if (!keys[id]) {
						keys[id] = {
							object: type
						};
					}
					if (name) {
						if (!keys[id].properties) {
							keys[id].properties = {};
						}
						keys[id].properties[name] = true;
					}
					break;
			}
		},

		/**
		 * Handle change.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			if (changes.some(function(c) {
				var id = c.object.$instanceid,
					clas = c.object.$classname,
					name = c.name;
				if (edbml.$rendering && edbml.$rendering[id]) {
					console.error(
						'Don\'t update "' + name + '" of the ' + clas + ' while ' +
						'rendering, it will cause the rendering to run in an endless loop. '
					);
				} else if (this._oldprops[id]) {
					var props = this._oldprops[id].properties;
					try {
						if (!name || props[name]) {
							return true;
						}
					} catch (todoexception) {
						// console.error(this._oldprops[id].toString(), name);
						// TODO: fix sceario with selectedIndex................
					}
					return false;
				} else {
					console.error('Out of synch: ' + id);
				}
			}, this)) {
				this._schedule();
			}
		},

		/**
		 * Handle life.
		 * @param {gui.Life} life
		 */
		onlife: function(l) {
			if (l.type === gui.LIFE_ENTER) {
				if (!this.spirit.life.rendered) { // spirit did a manual run?
					this.run.apply(this, this._arguments || []);
				}
				this.spirit.life.remove(l.type, this);
				this._arguments = null;
			}
		},

		/**
		 *
		 */
		suspend: chained(function() {
			this.suspended = true;
			if (edbml.debug) {
				console.debug('(Supending ScriptPlugin)', this.$instanceid);
			}
		}),

		unsuspend: chained(function(run) {
			this.suspended = false;
			if (edbml.debug) {
				console.debug('(Unsupending ScriptPlugin)', this.$instanceid);
			}
		}),

		// Privileged ..............................................................

		/**
		 * Hijacking the {edb.InputPlugin} which has been
		 * designed to work without an associated spirit.
		 * Accessed by method {edbml#$runtimeconfigure}
		 * @type {edb.InputPlugin}
		 */
		$input: null,

		// Private .................................................................

		/**
		 * Script SRC.
		 * @type {String}
		 */
		_src: null,

		/**
		 * It's a function.
		 * @type {function}
		 */
		_script: null,

		/**
		 * Update manager.
		 * @type {edbml.UpdateManager}
		 */
		_updater: null,

		/**
		 * Tracking what arrays and objects (and what properties) to observe.
		 * @type {Map<String,boolean>}
		 */
		_oldprops: null,

		/**
		 * Something related to the above.
		 * @type {Map<String,boolean>}
		 */
		_newprops: null,

		/**
		 * Cache arguments for postponed execution.
		 * @type {Arguments}
		 */
		_arguments: null,

		/**
		 * Snapshot latest HTML to avoid parsing duplicates.
		 * @type {String}
		 */
		_html: null,

		/**
		 * AnimationFrame index.
		 * @type {number}
		 */
		_frameindex: -1,

		/**
		 * Parse processing instructions. Add input listeners in
		 * batch to prevent prematurly getting a `this.$input.done`
		 * @param {Array<object>} pis
		 */
		_process: function(pis) {
			if (pis) {
				var optional = [];
				var required = [];
				if (pis.reduce(function(hasinput, pi) {
					var keys = Object.keys(pi);
					var name = keys[0];
					var atts = pi[name];
					if (name === 'input') {
						var list = atts.required === false ? optional : required;
						list.push(guiObject.lookup(atts.type));
						return true;
					}
					return hasinput;
				}, false)) {
					this.$input = new edb.InputPlugin();
					this.$input.connect(required, this, true);
					this.$input.connect(optional, this, false);
				}
			}
		},

		/**
		 * Start it.
		 */
		_start: function() {
			edbml.$rendering = this._oldprops || {};
			Broadcast.add(edb.BROADCAST_ACCESS, this);
			edb.$accessaware = true;
			this._newprops = {};
		},

		/**
		 * Stop it.
		 */
		_stop: function() {
			var oldprops = this._oldprops,
				newprops = this._newprops;
			edbml.$rendering = null;
			Broadcast.remove(edb.BROADCAST_ACCESS, this);
			edb.$accessaware = false;
			Object.keys(oldprops).forEach(function(id) {
				if (!newprops[id]) {
					oldprops[id].object.removeObserver(this);
					delete oldprops[id];
				}
			}, this);
			Object.keys(newprops).forEach(function(id) {
				var oldx = oldprops[id];
				var newx = newprops[id];
				if (oldx) {
					if (newx.properties) {
						oldx.properties = newx.properties;
					}
				} else {
					oldprops[id] = newprops[id];
					oldprops[id].object.addObserver(this);
					delete newprops[id];
				}
			}, this);
			this._newprops = null;
		},

		/**
		 * Schedule rendering.
		 */
		_schedule: function() {
			Tick.cancelFrame(this._frameindex);
			var spirit = this.spirit;
			var input = this.$input;
			var runnow = function() {
				if (!spirit.life.destructed && (!input || input.done)) {
					this.run();
				}
			}.bind(this);
			if (spirit.life.entered) {
				if (spirit.life.rendered) {
					this._frameindex = Tick.nextFrame(runnow);
				} else {
					runnow();
				}
			} else {
				spirit.life.add(gui.LIFE_ENTER, this);
			}
		},

		/**
		 * TODO: Wonder about dispatching stuff if nothing has changed...
		 * @param {gui.Spirit} spirit
		 */
		_status: function(spirit) {
			spirit.life.rendered = true;
			spirit.onrender({ // TODO: some kind of RenderSummary...
				first: !this.ran
			});
			spirit.life.dispatch(gui.LIFE_RENDER); // TODO: move to `edbml` namespace
			spirit.action.dispatch(edbml.ACTION_RENDER);
		},

		/**
		 * Run the script while monitoring edb.Type inspections.
		 * @returns {String}
		 */
		_run: function(/* arguments */) {
			this._start();
			var html = this._script.apply(this.spirit, arguments);
			this._stop();
			return html;
		},

		/**
		 * This seems to hotfix a scenario where the script has multiple
		 * (global) inputs defined and you then inject a private input.
		 * This action results in calling `run` immediately without
		 * waiting for the global inputs to be registered. When fixed,
		 * revert back to throwing an error (for manually running a
		 * waiting script).
		 */
		_notready: function() {
			var input = this.$input,
				type;
			(input._watches || []).forEach(function(edbType) {
				if ((type = edb.get(edbType))) {
					input.$oninput(
						new edb.Input(edbType, type)
					);
				}
			}, this);
			/*
			if(gui.debug) {
				// Alert the user when manually running a script that is not ready.
				console.warn ( this.spirit + " can't run (waiting for input)" );
			}
			*/
		},

		/**
		 * Operation failed because no script was loaded.
		 */
		_notloaded: function() {
			console.error('Spiritual EDBML: No script loaded for ' + this.spirit);
		},

		/**
		 * No input expected.
		 */
		_noinputexpected: function() {
			console.error('Spiritual EDBML: No input expected for ' + this.spirit);
		},

		/**
		 * Focus is inside the spirit? Compute a fitting	CSS selector so that we
		 * may restore focus if and when the focused field gets replaced. This will
		 * in given case nuke the undo stack, but you can't both forget to scope
		 * your input fields (with an ID) and have a pleasent website, so please do.
		 * TODO: warning in debug mode when an ID is missing.
		 * @returns {string}
		 */
		_focusedfield: function() {
			var focused;
			try {
				focused = document.activeElement;
			} catch (ieException) { // Occasional IE failure
				focused = null;
			}
			if (focused && Type.isElement(focused)) { // Ridiculous IE 11 failure
				if (DOMPlugin.contains(this.spirit.element, focused)) {
					return this._focusselector(focused);
				}
			}
			return null;
		},

		/**
		 * Compute selector for form field. We scope it to
		 * nearest element ID or fallback to document body.
		 * @param {Element} element
		 * @returns {string}
		 */
		_focusselector: function(elm) {
			var index = -1;
			var parts = [];
			function hasid(elem) {
				if (elem.id) {
					try {
						DOMPlugin.q(elem.parentNode, elem.id);
						return true;
					} catch (malformedexception) {}
				}
				return false;
			}
			while (elm && elm.nodeType === Node.ELEMENT_NODE) {
				if (hasid(elm)) {
					parts.push('#' + elm.id);
					elm = null;
				} else {
					if (elm.localName === 'body') {
						parts.push('body');
						elm = null;
					} else {
						index = DOMPlugin.ordinal(elm) + 1;
						parts.push('>' + elm.localName + ':nth-child(' + index + ')');
						elm = elm.parentNode;
					}
				}
			}
			return parts.reverse().join('');
		},

		/**
		 * Refocus that form field.
		 * @param {string} selector
		 */
		_restorefocus: function(selector) {
			var texts = 'textarea, input:not([type=checkbox]):not([type=radio])';
			var field = DOMPlugin.qdoc(selector);
			var focus;
			try {
				focus = document.activeElement;
			} catch (ieException) { // Occasional IE failure
				focus = null;
			}
			if (field && field !== focus) { // Occasional IE error
				field.focus();
				if (gui.CSSPlugin.matches(field, texts)) {
					field.setSelectionRange(
						field.value.length,
						field.value.length
					);
				}
			}
		}

	});
}(
	gui.Combo.chained,
	gui.Arguments.confirmed,
	gui.Type,
	gui.Tick,
	gui.Object,
	gui.Array,
	gui.DOMPlugin,
	gui.Broadcast
));



/**
 * Spirit of the SCRIPT tag that
 * contains the (compiled) EDBML.
 */
edbml.ScriptSpirit = gui.Spirit.extend({

	/**
	 * Configured via inline HTML (so by Grunt).
	 * @type {string}
	 */
	scriptid: null,

	/**
	 * Load script into parent spirit. This spirit will
	 * automatically destruct when the script executes.
	 */
	onconfigure: function() {
		gui.Spirit.prototype.onconfigure.call(this);
		if (this.dom.embedded()) {
			var id, parent = this.dom.parent(gui.Spirit);
			if (parent && (id = this.scriptid)) {
				parent.script.load(gui.Object.lookup(id));
			}
		}
	}

});



/**
 * Central security service.
 * @using {HTMLDivElement} safeelm
 * @using {Map<string,string>} safemap
 * @using {RegExp} unsafexp
 */
edbml.Security = (function using(safeelm, safemap, unsafexp) {
	return {

		/**
		 * Escape potentially unsafe string for use in HTML element context.
		 * @param {string} string
		 * @returns {string}
		 */
		$safetext: function(string) {
			safeelm.firstChild.data = String(string);
			return safeelm.innerHTML;
		},

		/**
		 * Escape potentially unsafe string for use in HTML attribute context.
		 * TODO(jmo@): This is UNSAFE. We should look into more security stuff.
		 * @see https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.232_-_Attribute_Escape_Before_Inserting_Untrusted_Data_into_HTML_Common_Attributes
		 * @param {string} string
		 * @returns {string}
		 */
		$safeattr: function(string) {
			return String(string).replace(unsafexp, function(c) {
				return safemap[c];
			});
		}
	};
}( // Using ....................................................................

	/*
	 * Creates an element for escaping
	 * text that goes into HTML markup.
	 */
	(function safeelm() {
		var div = document.createElement('div');
		var txt = document.createTextNode('');
		div.appendChild(txt);
		return div;
	}()),

	/*
	 * Creates a basic (UNSAFE) map for escaping
	 * text that goes into HTML attribute context.
	 * We'll need to figure out something better...
	 */
	(function safemap() {
		return {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#39;'
		};
	}()),

	/*
	 * (UNSAFE) regular expression to figure out some basic
	 * entities that should be escaped in HTML attributes.
	 */
	/[&<>'"]/g

));



/*
 * Register module.
 */
gui.module('edbml@wunderbyte.com', {

	/*
	 * Mixin properties and method.
	 */
	mixin: {

		/**
		 * TODO: support accessor and implement as property
		 * @param {String|function} script
		 */
		src: function(script) {
			if (gui.Type.isString(script)) {
				var func = gui.Object.lookup(script);
				if (func) {
					script = func;
				} else {
					throw new Error(this + ' could not locate "' + script + '"');
				}
			}
			if (gui.Type.isFunction(script)) {
				this.script.load(script);
			} else {
				throw new TypeError(this + ' could not load script');
			}
		},

		/**
		 * Called whenever the EDBML script was evaluated.
		 * @param {TODOTHING} summary
		 */
		onrender: function(summary) {},

		/**
		 * Handle changes.
		 * @param {Array<edb.ObjectChange|edb.ArrayChange>}
		 */
		onchange: function(changes) {},

		/**
		 * Handle input.
		 * @param {edb.Input} input
		 */
		oninput: function(input) {},

		/**
		 * Handle directed input. Setup to require
		 * the input listener be to be added first.
		 * @see {edb.InputPlugin}
		 * TODO: when to destruct the type?
		 */
		$oninput: function(input) {
			this.script.input.match(input);
		}
	},

	/*
	 * Register plugins for all spirits.
	 */
	plugin: {
		script: edbml.ScriptPlugin
	},

	/*
	 * Channeling spirits to CSS selectors.
	 */
	channel: [
		['.gui-script', 'edbml.ScriptSpirit']
	],

	/**
	 * Setup environment.
	 */
	oncontextinitialize: function() {
		/*
		 * Automatically load spirit scripts by naming convention?
		 * ns.MySpirit would automatically load ns.MySpirit.edbml
		 */
		var edbmlscript, basespirit = gui.Spirit.prototype;
		gui.Function.decorateAfter(basespirit, 'onconfigure', function() {
			if (edbml.bootload && !this.script.loaded) {
				edbmlscript = gui.Object.lookup(this.$classname + '.edbml');
				if (gui.Type.isFunction(edbmlscript)) {
					this.script.load(edbmlscript);
				}
			}
		});

		/*
		 * Nasty hack to circumvent that we hardcode "event" into inline poke
		 * events, this creates an undesired global variable, but fixes an
		 * exception in the console, at least I think this was the problem.
		 */
		if (!window.event) {
			try {
				window.event = null;
			} catch (ieexception) {}
		}
	}

});



}(self));
(function(window) {

"use strict";


/**
 * It's not Greenfield no more: API calls
 * shall render GUI inside the app iframe.
 */
ts.ui.greenfield = false;



/**
 * Corporate base plugin.
 * @extends {gui.Plugin}
 */
ts.ui.Plugin = gui.Plugin.extend();



/**
 * Add support for special events.
 * @extends {gui.EventPlugin} and notably not the {ts.ui.Plugin}
 */
ts.ui.EventPlugin = gui.EventPlugin.extend({

	/**
	 * Handle event.
	 * @param {Event} e
	 */
	handleEvent: function(e) {
		gui.EventPlugin.prototype.handleEvent.call(this, e);
		var fake, time, spirit = this.spirit;
		switch (e.type) {
			case 'mouseenter':
				if (this._hoverintent) {
					fake = this._getfakeevent(e, 'hoverintent');
					time = ts.ui.EventPlugin.HOVER_INTENT_TIME;
					this._hovercountdown = gui.Tick.time(function() {
						spirit.onevent(fake);
					}, time);
				}
				break;
			case 'mouseleave':
				if (this._hoverintent) {
					gui.Tick.cancelTime(this._hovercountdown);
				}
		}
	},

	// Private ...................................................................

	/**
	 * Tracking hoverintent?
	 * @type {boolean}
	 */
	_hoverintent: false,

	/**
	 * Hoverintent timeout index.
	 * @type {number}
	 */
	_hovercountdown: -1,

	/**
	 * Support mysterious 'hoverintent', though maybe that's not needed no more.
	 * @overrides {gui.EventPlugin._shiftEventListener}
	 * @param {boolean} add
	 * @param {Node} target
	 * @param {string} type
	 * @param {object} handler
	 * @param {boolean} capture
	 */
	_shiftEventListener: function(add, target, type, handler, capture) {
		switch (type) {
			case 'hoverintent':
				this._shiftHoverListener(add, target, type, handler, capture);
				break;
			default:
				gui.EventPlugin.prototype._shiftEventListener.call(this, add,target,type,handler,capture);
				break;
		}
	},

	/*
	 * TODO(jmo@): Account for `this._mouseenter` and `this._mouseleave`
	 * pending investigation of whether or not Safari supports this stuff.
	 * @param {boolean} add
	 * @param {Node} target
	 * @param {string} type
	 * @param {object} handler
	 * @param {boolean} capture
	 */
	_shiftHoverListener: function(add, target, type, handler, capture) {
		this._hoverintent = add;
		target = this._getelementtarget(target);
		if (target === this.spirit.element) {
			if (add) { // note that we never remove the listener (we use boolean flags)
				['mouseenter', 'mouseleave'].forEach(function(t) {
					target.addEventListener(t, this);
				}, this);
			}
		} else {
			throw new Error('Not supported just yet');
		}
	}

}, {}, { //	Static ............................................................

	/**
	 * Timeout in milliseconds before we assume
	 * that the user intends to hover something.
	 * @type {number}
	 */
	HOVER_INTENT_TIME: 123

});



/**
 * Reports busy and done while optionally showing and
 * hiding the big transparent DIV that covers it all.
 * TODO (jmo@): isBusy(string) to check the status of stuff.
 * @param {gui.Arguments.confirmed} confirmed
 */
ts.ui.StatusPlugin = (function using(confirmed) {
	var BUSY1 = ts.ui.BROADCAST_GLOBAL_STATUS_BUSY;
	var DONE1 = ts.ui.BROADCAST_GLOBAL_STATUS_DONE;
	var BUSY2 = ts.ui.BROADCAST_GLOBAL_STATUS_BUSY_BLOCKING;
	var DONE2 = ts.ui.BROADCAST_GLOBAL_STATUS_DONE_BLOCKING;

	return ts.ui.Plugin.extend({

		/**
		 * Tracking busy things.
		 */
		onconstruct: function() {
			ts.ui.Plugin.prototype.onconstruct.call(this);
			this._bookmarks = {};
		},

		/**
		 * Release busy stuff when destructed.
		 */
		ondestruct: function() {
			ts.ui.Plugin.prototype.ondestruct.call(this);
			var exit = {};
			if (this.isBusy()) {
				exit[BUSY1] = DONE1;
				exit[BUSY2] = DONE2;
				Object.keys(this._bookmarks).forEach(function(key) {
					var cuts = key.split(this._SEPARATOR);
					this._done(exit[cuts[0]], cuts[1]);
				}, this);
			}
		},

		/**
		 * Is busy?
		 * @param @optional {string} doingwhat
		 * @type {boolean}
		 */
		isBusy: function(doingwhat) {
			if (arguments.length) {
				return Object.keys(this._bookmarks).some(function(activity) {
					return activity.includes(doingwhat);
				});
			} else {
				return Object.keys(this._bookmarks).length > 0;
			}
		},

		/**
		 * Report busy.
		 * @param {String} message
		 */
		busy: function(message) {
			this._busy(BUSY1, message);
		},

		/**
		 * Report done.
		 * @param {String} message
		 */
		done: function(message) {
			this._done(DONE1, message);
		},

		/**
		 * Block while busy.
		 * @param {String} message
		 */
		busyBlocking: function(message) {
			this._busy(BUSY2, message);
		},

		/**
		 * Unblock when done.
		 * @param {String} message
		 */
		doneBlocking: function(message) {
			this._done(DONE2, message);
		},

		// Private .................................................................

		/**
		 * Separates the broadcast from the message in a bookmark key.
		 * @type {string}
		 */
		_SEPARATOR: ':::',

		/**
		 * Tracking busy status.
		 * @type {Map<string,boolean>}
		 */
		_bookmarks: null,

		/**
		 * Non-anonymize the message.
		 * @param {String} message
		 * @return {String}
		 */
		_stamp: function(message) {
			return '[' + this.spirit.constructor.$classname + '] ' + message;
		},

		/**
		 * Go busy.
		 * @param {String} broadcast
		 * @param {String} message
		 */
		_busy: confirmed('string')(function(broadcast, message) {
			this._bookmarks[broadcast + this._SEPARATOR + message] = true;
			message = this._stamp(message);
			this.spirit.life.dispatch(ts.ui.LIFE_STATUS_BUSY, message);
			gui.Broadcast.dispatchGlobal(broadcast, message);
		}),

		/**
		 * Now done.
		 * @param {String} broadcast
		 * @param {String} message
		 */
		_done: confirmed('string')(function(broadcast, message) {
			delete this._bookmarks[broadcast + this._SEPARATOR + message];
			message = this._stamp(message);
			gui.Tick.next(function() {
				gui.Broadcast.dispatchGlobal(broadcast, message);
				if (this.spirit) { // TODO (jmo@): better angle on destructed spirit!
					this.spirit.life.dispatch(
							ts.ui.LIFE_STATUS_DONE,
							this._stamp(message)
					);
				}
			}, this);
		})

	}, { // Static ........................................................

		/**
		 * Report busy.
		 * @param {String} message
		 */
		busy: confirmed('string')(function(message) {
			gui.Broadcast.dispatchGlobal(BUSY1, message);
		}),

		/**
		 * Report done.
		 * @param {String} message
		 */
		done: confirmed('string')(function(message) {
			gui.Tick.next(function() {
				gui.Broadcast.dispatchGlobal(DONE1, message);
			});
		}),

		/**
		 * Report busy blocking.
		 * @param {String} message
		 */
		busyBlocking: confirmed('string')(function(message) {
			gui.Broadcast.dispatchGlobal(BUSY2, message);
		}),

		/**
		 * Report done blocking.
		 * @param {String} message
		 */
		doneBlocking: confirmed('string')(function(message) {
			gui.Tick.next(function() {
				gui.Broadcast.dispatchGlobal(DONE2, message);
			});
		})

	});
}(gui.Arguments.confirmed));



/**
 * All sorts of layout relatedness.
 * @using {gui.Array} GuiArray
 * @using {gui.DOMPlugin} DOMPlugin
 * @using {gui.CSSPlugin} CSSPlugin
 * @using {gui.Combo#chained} chained
 */
ts.ui.LayoutPlugin = (function using(GuiArray, DOMPlugin, CSSPlugin, chained) {
	return ts.ui.Plugin.extend({

		/**
		 * Spirit is positioned before or after Main (not inside)?
		 * TODO(jmo@): could not use classname `ts-main` because of
		 * timing	conflicts in tests, must investigate performance
		 * of the selector used instead.
		 * @returns {boolean}
		 */
		outsideMain: function() {
			return !this.spirit.css.matches('[data-ts=Main] *');
		},

		/**
		 * Spirit is positoned before Main (and not inside an Aside)?
		 * @returns {boolean}
		 */
		beforeMain: function() {
			var is = false, elm = this.spirit.element;
			if (!this._isinaside() && !this._isinmain()) {
				while ((!is && (elm = elm.nextElementSibling))) {
					is = CSSPlugin.contains(elm, 'ts-main');
				}
			}
			return is;
		},

		/**
		 * Spirit is positoned after Main (and not inside an Aside)?
		 * @returns {boolean}
		 */
		afterMain: function() {
			var is = false, elm = this.spirit.element;
			if (!this._isinaside() && !this._isinmain()) {
				while ((!is && (elm = elm.previousElementSibling))) {
					is = CSSPlugin.contains(elm, 'ts-main');
				}
			}
			return is;
		},

		/**
		 * Add or remove classname(s) on the HTML element.
		 * @param {truthy} on
		 * @param {string|Array<string>} cnames
		 * @returns {ts.ui.LayoutPlugin}
		 */
		shiftGlobal: chained(function(on, cnames) {
			this.spirit.action.dispatch(ts.ui.ACTION_ROOT_CLASSNAMES, {
				classes: GuiArray.make(cnames),
				enabled: !!on
			});
		}),

		/**
		 * Flex everything (because of JavaScript based layout).
		 * @returns {ts.ui.LayoutPlugin}
		 */
		flexGlobal: chained(function() {
			ts.ui.get(document.documentElement).reflex();
		}),

		/**
		 * Apply classname based on the current height of some
		 * descendant StatusBarSpirit. This is known to affect
		 * TableSpirit, PanelSpirit and DocumentSpirit (and it
		 * also runs on the StatusBarSpirit itself).
		 * @param {number} level
		 */
		gotoLevel: function(level) {
			var css = this.spirit.css;
			[1, 1.5, 2, 2.5, 3].forEach(function(number) {
				var string = String(number).replace('.', '-');
				css.shift(number === level, 'ts-level-' + string);
			});
		},

		// Private .................................................................

		/**
		 * Spirit is inside some kind of Aside?
		 * @returns {boolean}
		 */
		_isinaside: function() {
			return this.spirit.css.matches('.ts-sideshow *');
		},

		/**
		 * Spirit is inside Main?
		 * @returns {boolean}
		 */
		_isinmain: function() {
			return this.spirit.css.matches('.ts-main *');
		}

	}, { // Static ...............................................................

		/**
		 * @deprecated
		 * @param {truthy} on
		 * @param {string|Array<string>} cnames
		 * @returns {constructor}
		 */
		shift: chained(function(on, cnames) {
			console.error('Deprecated API is deprecated: LayoutPlugin.shift');
		}),

		/**
		 * HTML element has given classname?
		 * TODO: Move to prototype and rename `containsGlobal`
		 * @returns {boolean}
		 */
		contains: function(cname) {
			if (gui.debug) {
				console.log('TODO: this must be synced to root panels setup');
			}
			return ts.ui.get(document.documentElement).css.contains(cname);
		}

	});
}(
	gui.Array,
	gui.DOMPlugin,
	gui.CSSPlugin,
	gui.Combo.chained
));



/**
 * Keyboard TAB attention trapping.
 * This is all *disabled* on mobile.
 * @using {gui.Array} GuiArray
 * @using {gui.Combo#chained} chained
 * @using {function} notontouch Setup to ignore focus stuff on touch device
 */
ts.ui.AttentionPlugin = (function using(GuiArray, chained, notontouch) {
	return ts.ui.Plugin.extend({

		/**
		 * Trapping the focus already?
		 * @type {Boolean}
		 */
		trapping: false,

		/**
		 * Cleanup on exit.
		 * TODO (jmo@): automate this step in Spiritual
		 */
		ondestruct: function() {
			ts.ui.Plugin.prototype.ondestruct.call(this);
			if (this.trapping) {
				ts.ui.LayoutModel.output.get().attention.removeObserver(this);
				gui.Tick.cancelTime(this._timeout);
				this._listen(false);
			}
		},

		/**
		 * Trap attention inside the spiriti (or inside given target).
		 * @param @optional {Element|gui.Spirit} opt_elm
		 * @returns {ts.ui.AttentionPlugin}
		 */
		trap: chained(notontouch(function(opt_elm) {
			var elm = this._getelement(opt_elm);
			if (!this.trapping) {
				this.trapping = true;
				this._listen(true);
				this._trap(elm);
			}
		})),

		/**
		 * Forcibly focus the first focusable thing.
		 * We assume that forms are most important.
		 * @param @optional {Element} elm
		 * @returns {boolean} True when something was focused
		 */
		enter: notontouch(function(opt_elm) {
			var hit = null;
			var elm = this._getelement(opt_elm);
			var all = GuiArray.from(elm.getElementsByTagName('*'));
			var that = this;
			function find(informs) {
				return all.reduce(function(result, next) {
					if (!result && that._isfocus(next, informs)) {
						result = next;
					}
					return result;
				}, null);
			}
			if ((hit = find(true) || find(false))) {
				hit.focus();
			}
			return (hit !== null);
		}),

		/**
		 * Forcibly exit the attention zone. Might move focus to another zone.
		 * @param @optional {Element|gui.Spirit} opt_elm
		 * @returns {ts.ui.AttentionPlugin}
		 */
		exit: function(opt_elm) {
			if (this._entered) {
				var elm = this._getelement(opt_elm);
				var dom = gui.DOMPlugin;
				var act = document.activeElement;
				var def = act === document.body;
				if (act && !act.nodeType) {
					act = null; // IE11 may miserably report activeElement as an array :/
				}
				if (def && act) {
					act.blur();
				} else if (act) {
					if (act === elm || dom.contains(elm, act)) {
						act.blur();
					}
				}
				this._attention('exit');
			}
		},

		/**
		 * Something was focused or blurred.
		 * @param {Event} e
		 */
		handleEvent: function(e) {
			var elm = e.target;
			if (this._isfocus(elm)) {
				switch (e.type) {
					case 'focus':
						this._onfocus(elm);
						break;
					case 'blur':
						this._onblur(elm);
						break;
				}
			}
		},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			if (b.type === ts.ui.BROADCAST_ATTENTION_MOVE) {
				if (b.data === this.spirit.$instanceid) {
					this.enter();
				}
			}
		},

		/**
		 * An `$instanceid` was popped from the attention queue. If we're now the
		 * last entry, we'll attempt to restore the focus to whatever had it.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			var list = ts.ui.LayoutModel.output.get().attention;
			var inst = this.spirit.$instanceid;
			var last = this._latest;
			if (last) {
				changes.forEach(function(change) {
					if (change.object === list) {
						if (change.removed.length) {
							if (list[list.length - 1] === inst) {
								this._restorefocus(last);
							}
						}
					}
				}, this);
			}
		},

		// Private .................................................................

		/**
		 * Timeout index.
		 * @type {number}
		 */
		_timeout: -1,

		/**
		 * Attention zone entered?
		 * @type {boolean}
		 */
		_entered: false,

		/**
		 * Hard reference to last focused element.
		 * @type {HTMLElement}
		 */
		_latest: null,

		/**
		 * Get element for argument, default to spirit element.
		 * @param @optional {element|ts.ui.Spirit} elm
		 */
		_getelement: function(elm) {
			elm = elm || this.spirit.element;
			return elm.nodeType ? elm : elm.element;
		},

		/**
		 * Insert focusable KBD before and after element. Whenever the
		 * KBDs receive the focus, we'll relocate focus another element.
		 * TODO (jmo@): What if someone moves the element to elsewhere?
		 * @param {HTMLElement} elm
		 */
		_trap: function(elm) {
			[true, false].map(function(before) {
				return elm.parentNode.insertBefore(
					document.createElement('kbd'),
					before ? elm : elm.nextElementSibling
				);
			}).forEach(function(kbd, last) {
				kbd.tabIndex = 0;
				kbd.onfocus = function() {
					this._tryfocus(elm, !last);
				}.bind(this);
			}, this);
		},

		/**
		 * @param {Element} elm
		 * @param {boolean} last
		 * @returns {boolean} True when something was focused
		 */
		_tryfocus: function(elm, reverse) {
			var did = false,
				elms = elm.getElementsByTagName('*');
			if ((elms = GuiArray.from(elms)).length) {
				elms = reverse ? elms.reverse() : elms;
				did = this._didfocus(elms.filter(function(elem) {
					return elem.tabIndex > -1 && !elem.disabled;
				}));
			}
			return did;
		},

		/**
		 * Focus the first focusbable thing in that list.
		 * @param {Array<HTMLElement>} elms
		 */
		_didfocus: function(elms) {
			return elms.every(function(elm) {
				if (this._isfocus(elm)) {
					return !this._dofocus(elm);
				}
				return true;
			}, this);
		},

		/**
		 * Attempt to focus that element and report any sucess (this is
		 * cheaper than computing all `display` and `visiblity` up front).
		 * @returns {boolean} True on succesfully focused
		 */
		_dofocus: function(elm) {
			elm.focus(); // TODO(jmo@): could this break IE when focus fails?
			return document.activeElement === elm;
		},

		/**
		 * Element is focusable form control or link? Note that form
		 * elements can be given a higher priority than other elements.
		 * @param {Element} elm
		 * @param {boolan} forms Looking for form fields only?
		 * @returns {boolean}
		 */
		_isfocus: function(elm, forms) {
			if (forms || arguments.length === 1) {
				switch (elm.localName) {
					case 'input':
					case 'textarea':
					case 'select':
						return elm.type !== 'hidden' && !elm.readonly && !elm.disabled;
				}
			}
			if (!forms) {
				switch (elm.localName) {
					case 'button':
					case 'a':
						return !elm.disabled;
				}
				if (elm.tabIndex > -1) {
					// in IE9/IE10 it appears *everything* has tabIndex zero ...
					if (elm.hasAttribute('tabindex')) { // so we'll make extra sure!
						return true;
					}
				}
			}
			return false;
		},

		/**
		 * Listen and unlisten for all sorts of stuff going on.
		 * @TODO use focusin and focusout for IE/Opera?
		 * @param {boolean} listen
		 */
		_listen: function(listen) {
			var element = this.spirit.element;
			var action1 = listen ? 'addEventListener' : 'removeEventListener';
			var action2 = listen ? 'addGlobal' : 'removeGlobal';
			element[action1]('focus', this, true);
			element[action1]('blur', this, true);
			gui.Broadcast[action2](ts.ui.BROADCAST_ATTENTION_MOVE, this);
		},

		/**
		 * Something was focused.
		 * @param {Element} elm
		 */
		_onfocus: function(elm) {
			clearTimeout(this._timeout);
			this._focused = true;
			this._latest = elm;
			if (!this._entered) { // trap just entered?
				this._entered = true;
				this._attention('enter');
			}
		},

		/**
		 * Something was blurred. If nothing new gets focused soon, we determine
		 * that an exit was performed. Not that this doesn't move to focus back
		 * to any previous zone, you must invoke a manual 'exit()' for this
		 */
		_onblur: function() {
			this._focused = false;
			this._timeout = gui.Tick.time(function() {
				if (!this._focused) {
					this._entered = false;
				}
			}, 0, this);
		},

		/**
		 * @param {Element} last
		 */
		_restorefocus: function(last) {
			gui.Tick.time(function() {
				var act = document.activeElement;
				if (act === document.body || act.tabIndex === -1) {
					if (gui.DOMPlugin.embedded(last)) {
						last.focus();
					}
				}
			});
		},

		/**
		 * Update attention list.
		 * @param {String} scenario
		 * In order to fix the bug: it doesn't focus the right button when multiple asides were closed
		 * So disable the code if (last === inst)
		 */
		_attention: function(scenario) {
			var inst = this.spirit.$instanceid;
			var modl = ts.ui.LayoutModel.output.get();
			var list = modl.attention;
			var last = list[list.length - 1];
			switch (scenario) {
				case 'enter':
					if (last !== inst) {
						list.push(inst);
						list.addObserver(this);
					}
					break;
				case 'exit':
					if (list.length) {
						// if (last === inst) {
						list.removeObserver(this);
						list.pop();
						// }
					}
					break;
			}
		}
	});
}(gui.Array, gui.Combo.chained, function notontouch(base) {
	return function() {
		if (!gui.Client.isTouchDevice) {
			return base.apply(this, arguments);
		}
	};
}));



/**
 * Manage the {ts.ui.LayoutModel}. We've rigged this up so that the
 * model is always output when the app is running standalone (without
 * the chrome). If and when the chrome transmits a global model, the
 * {ts.ui.DocumentSpirit} will output that in replacement of ours.
 * @see {ts.ui.DocumentSpirit#_outputmodels}
 */
ts.ui.DocumentLayoutPlugin = ts.ui.Plugin.extend({

	/**
	 * The window width is currently zero in Frankenstein
	 * so we will have to go about it in a delicate way.
	 */
	managelayout: function() {
		this._points = this._computepoints();
		new ts.ui.LayoutModel(this._computelayout()).output();
		new ts.ui.DeviceModel(this._computedevice()).output();
		this._updateBreakpoints();
		gui.Broadcast.add(gui.BROADCAST_RESIZE_END, this);
	},

	/**
	 * If in top frame (or in Frankenstein), update
	 * the global layoutmodel on breakpoint change.
	 * @param {gui.Broadcast} b
	 */
	onbroadcast: function(b) {
		switch (b.type) {
			case gui.BROADCAST_RESIZE_END:
				this._updateBreakpoints();
				break;
		}
	},

	// Private ...................................................................

	/**
	 * Listing breakpoints ascending.
	 * @see {ts.ui.LayoutModel#BREAKPOINTS}
	 * @type {Array<number>}
	 */
	_points: null,

	/**
	 * Frankenstein resize timeout index.
	 * TODO(jmo@): Move this hack to (as yet nonexistent) {ts.ui.Document}
	 * or figure out why the original broadcast isn't propagated in from above.
	 * @type {number}
	 */
	_timeout: -1,

	/**
	 * Compute breakpoints array.
	 */
	_computepoints: function() {
		var points = ts.ui.LayoutModel.BREAKPOINTS;
		return Object.keys(points).map(function(point) {
			return parseInt(point, 10);
		}).sort(function(a, b) {
			return a - b;
		});
	},

	/**
	 * Compute layout.
	 * @returns {object} or null if window size could not be determined...
	 */
	_computelayout: function() {
		var point,
			next,
			points = [],
			width = window.innerWidth || 0,
			presets = ts.ui.LayoutModel.BREAKPOINTS;
		this._points.every(function(p) {
			if ((next = p <= width)) {
				point = presets[p];
				points.push(point);
			}
			return next;
		});
		return {
			breakpoints: points,
			breakpoint: point
		};
	},

	/**
	 * Some kind of device model with
	 * capabilities and what not.
	 * TODO (jmo@): This sort of thing
	 */
	_computedevice: function() {
		return {};
	},

	/**
	 * Update breakpoints. On startup, our window has no width when running
	 * inside the Frankenstein chrome. But that's the least of our worries.
	 */
	_updateBreakpoints: function() {
		var layout = this._computelayout();
		var model = ts.ui.LayoutModel.output.get();
		model.breakpoint = layout.breakpoint;
		model.breakpoints = layout.breakpoints;
	}

});



/**
 * Tracking dialogs to manage the cover.
 * Syncing with the top dialog plugin.
 * @see {ts.top.DocumentDialogPlugin}
 */
ts.ui.DocumentDialogPlugin = (function() {
	// local broadcasts *from* dialogs in this context
	var willopen = ts.ui.BROADCAST_DIALOG_WILL_OPEN,
		goopen = ts.ui.BROADCAST_DIALOG_GO_OPEN,
		willclose = ts.ui.BROADCAST_DIALOG_WILL_CLOSE,
		didclose = ts.ui.BROADCAST_DIALOG_DID_CLOSE,
		modal_willopen = ts.ui.BROADCAST_MODAL_WILL_OPEN,
		modal_willclose = ts.ui.BROADCAST_MODAL_WILL_CLOSE;

	// global broadcasts *for* the top frame dialog plugin
	var globalon = ts.ui.BROADCAST_GLOBAL_DIALOGS_WILL_ON,
		globaloff = ts.ui.BROADCAST_GLOBAL_DIALOGS_DID_OFF,
		globalblock = ts.ui.BROADCAST_GLOBAL_DIALOGS_WILL_BLOCK,
		globalunblock = ts.ui.BROADCAST_GLOBAL_DIALOGS_DID_UNBLOCK;

	// broadcast global
	function announce(msg) {
		gui.Broadcast.dispatchGlobal(msg);
	}

	return ts.ui.Plugin.extend({

		/**
		 * Manage the flow of dialogs.
		 */
		managedialogs: function() {
			this._dialogs = [];
			gui.Broadcast.add([
				willopen,
				goopen,
				goopen,
				willclose,
				didclose,
				modal_willopen,
				modal_willclose
			], this);
		},

		/**
		 * Suspend new dialogs if a dialog is currently shown.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			var queue = this._dialogs;
			var dialog = b.target;
			switch (b.type) {
				case willopen:
					if (queue.length) {
						dialog.suspend();
					} else {
						announce(globalon);
					}
					queue.push(dialog);
					break;
				case goopen:
					if (dialog) {
						this._updateblocking(dialog.blocking);
					}
					break;
				case didclose:
					queue.shift();
					if (queue.length) {
						queue[0].unsuspend();
					} else {
						this._updateblocking(false);
						announce(globaloff);
					}
					break;
				case modal_willopen:
					this._updateblocking(true);
					break;
				case modal_willclose:
					this._updateblocking(false);
					break;
			}
		},

		// Private .................................................................

		/**
		 * Current dialog blocks?
		 * @type {number}
		 */
		_blocking: false,

		/**
		 * Tracking open dialogs.
		 * TODO(jmo@): This should in reality by done	in the {ts.ui.LayoutModel}
		 * so that we can account for dialogs going on in the chrome and such.
		 * @type {Array<ts.ui.DialogSpirit}
		 */
		_dialogs: null,

		/**
		 * ID (and classname) of the aside cover.
		 * @type {string}
		 */
		_coverid: 'ts-dialogcover',

		/**
		 * Update blocking status.
		 * @param {boolean} blocking
		 */
		_updateblocking: function(blocking) {
			if (blocking) {
				if (!this._blocking) {
					announce(globalblock);
					this._cover().fadeIn();
					this._blocking = true;
				}
			} else {
				if (this._blocking) {
					announce(globalunblock);
					this._cover().fadeOut();
					this._blocking = false;
				}
			}
		},

		/**
		 * Get-create CoverSpirit for dialog things. First
		 * run creates the spirit and appends it to BODY.
		 * @returns {ts.ui.CoverSpirit}
		 */
		_cover: function() {
			return ts.ui.CoverSpirit.getCover(this._coverid);
		}

	});
}());



/**
 * Tracking asides to manage the cover.
 * Syncing with the top aside plugin.
 * @see {ts.top.DocumentAsidePlugin}
 * @using {gui.Tick} Tick
 */
ts.ui.DocumentAsidePlugin = (function using(Tick) {
	// local actions *from* asides in this context
	var willopen = ts.ui.ACTION_ASIDE_WILL_OPEN,
		didopen = ts.ui.ACTION_ASIDE_DID_OPEN,
		willclose = ts.ui.ACTION_ASIDE_WILL_CLOSE,
		didclose = ts.ui.ACTION_ASIDE_DID_CLOSE,
		willflip = 'FLIP';

	// global broadcasts *for* the top frame aside plugin
	var globaltouchcover = ts.ui.BROADCAST_GLOBAL_COVER_TOUCH,
		globalwillon = ts.ui.BROADCAST_GLOBAL_ASIDES_WILL_ON,
		globaldidon = ts.ui.BROADCAST_GLOBAL_ASIDES_DID_ON,
		globalwilloff = ts.ui.BROADCAST_GLOBAL_ASIDES_WILL_OFF,
		globaldidoff = ts.ui.BROADCAST_GLOBAL_ASIDES_DID_OFF,
		globaldoclose = ts.ui.BROADCAST_GLOBAL_ASIDES_DO_CLOSE;

	// broadcast global
	function announce(msg) {
		gui.Broadcast.dispatchGlobal(msg);
	}

	/**
	 * Flip the spirits.
	 * @param {Array<ts.ui.SideShowSpirit} first
	 * @param {Array<ts.ui.SideShowSpirit} last
	 */
	function flip(first, last) {
		if (first.length) {
			first.slice().forEach(function(spirit, index) {
				spirit.$flip().then(function() {
					gui.Array.remove(first, index);
					if (!first.length && last) {
						flip(last);
					}
				});
			});
		}
	}

	return ts.ui.Plugin.extend({

		/**
		 * Start managing asides.
		 */
		manageasides: function() {
			this._flipins = [];
			this._flipout = [];
			this.spirit.action.add([ // TODO(jmo@): gui.Action.add() doesn't work :/
				willopen,
				didopen,
				willclose,
				didclose,
				willflip
			], this);
			gui.Broadcast.addGlobal([
				globaltouchcover
			], this);
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			var spirit = a.target;
			switch (a.type) {
				case willopen:
					if (++this._asides === 1) {
						announce(globalwillon);
						this._cover().fadeIn();
					}
					break;
				case didopen:
					if (this._asides === 1) {
						announce(globaldidon);
					}
					break;
				case willclose:
					if (--this._asides === 0) {
						announce(globalwilloff);
						this._cover().fadeOut();
					}
					break;
				case didclose:
					if (this._asides === 0) {
						announce(globaldidoff);
					}
					break;
				case willflip:
					(a.data ? this._flipins : this._flipout).push(spirit);
					Tick.add('xxx', this).dispatch('xxx', 4);
					break;
			}
		},

		/**
		 * Upgrade local broadcast to global broadcasts but
		 * only when switching between zero and one aside/dialog.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			switch (b.type) {
				case globaltouchcover:
					if (b.data === this._coverid) {
						gui.Broadcast.dispatchGlobal(globaldoclose);
					}
					break;
			}
		},

		/**
		 * Handle tick.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			var out = this._flipout;
			var ins = this._flipins;
			if (t.type === 'xxx') {
				if (out.length) {
					flip(out, ins);
				} else {
					flip(ins);
				}
			}
		},

		// Private .................................................................

		/**
		 * Counting asides opened.
		 * @type {number}
		 */
		_asides: 0,

		/**
		 * ID (and classname) of the aside cover.
		 * @type {string}
		 */
		_coverid: 'ts-asidecover',

		/**
		 * Get-create CoverSpirit for ASIDE things. First
		 * run creates the spirit and appends it to BODY.
		 * @returns {ts.ui.CoverSpirit}
		 */
		_cover: function() {
			return ts.ui.CoverSpirit.getCover(this._coverid);
		}

	});
}(gui.Tick));



/**
 * Manage root level Panel components that may generate TopBar tabs.
 * @using {gui.MapList} MapList
 * @using {gui.Array} GuiArray
 */
ts.ui.DocumentPanelPlugin = (function using(MapList, GuiArray) {
	/**
	 * Has root level panels?
	 * @type {boolean}
	 */
	var haspanels = false;

	/**
	 * Currently shown root panel (if any).
	 * @type {ts.ui.PanelSpirit}
	 */
	var shownpanel = null;

	/**
	 * Mapping class names to root panels by `$instanceid`
	 * (or if no such panels, to the root DocumentSpirit).
	 * @type {MapList<string, Array<string>}
	 */
	var classnames = new MapList();

	/*
	 * Use dramatic pause between tab shift so that the menu animation
	 * is nice and smooth? This is not enabled upon initial rendering.
	 * @type {boolean}
	 */
	var pausetabs = false;

	/**
	 * Toggle selected panel. In mobile breakpoint,
	 * we will allow the tabs menu to close first.
	 * @param {ts.ui.PanelSpirit} panel
	 * @param {ts.ui.DocumentSpirit} root
	 */
	function toggle(panel, root) {
		if (pausetabs && ts.ui.isMobilePoint()) {
			gui.Tick.time(function tabsclosed() {
				update(panel, shownpanel, root);
			}, ts.ui.TRANSITION_FAST);
		} else {
			update(panel, shownpanel, root);
		}
		pausetabs = true;
	}

	/**
	 * Show that panel, hide other panel.
	 * @param {ts.ui.PanelSpirit} newpanel
	 * @param {ts.ui.PanelSpirit} oldpanel
	 * @param {ts.ui.DocumentSpirit} root
	 */
	function update(newpanel, oldpanel, root) {
		var main = newpanel.dom.q('.ts-main');
		if (oldpanel) {
			oldpanel.hide();
		}
		newpanel.show();
		if (main) {
			main.scrollTop = 0;
			trackbars(newpanel, main, root);
		}
	}

	/**
	 * Instruct the floating bars (that you see in mobile breakpoint)
	 * to track the scrolling of the Main element in selected Panel.
	 * @param {ts.ui.PanelSpirit} panel
	 * @param {HTMLMainElement}	main
	 * @param {ts.ui.DocumentSpirit} root
	 */
	function trackbars(panel, main, root) {
		var topbar = root.dom.qdoc('.ts-topbar', ts.ui.TopBarSpirit);
		var toolbar = panel.dom.q('.ts-toolbar-first', ts.ui.ToolBarSpirit);
		[toolbar, topbar].forEach(function(bar) {
			if (bar) {
				bar.$setmain(main);
			}
		});
	}

	/**
	 * Add or remove classname from while observering the followin guidelines:
	 * 1. Add classname to array and increment a counter for that classname.
	 * 2. Remove classname from array only if counter decrement reaches zero.
	 * ... this will allow many simultaneous components to affect global css.
	 * @param {Array} list
	 * @param {string} c (classname)
	 * @param {boolean} on
	 */
	function updatelist(list, c, on) {
		var mod = on ? 1 : -1;
		if (isNaN(list[c])) {
			list[c] = 0;
		}
		list[c] += mod;
		if (on) {
			if (list[c] === 1) {
				list.push(c);
			}
		} else {
			if (list[c] === 0) {
				GuiArray.remove(list, list.indexOf(c));
			}
		}
	}

	return ts.ui.Plugin.extend({

		/**
		 * Setup panel management. If no root level panels can be
		 * found, we'll treat the root element as a panel (internally).
		 */
		managepanels: function() {
			classnames.set(this.spirit.$instanceid, []);
			this.spirit.action.add([
				ts.ui.ACTION_PANEL_ATTACH,
				ts.ui.ACTION_PANEL_SHOW,
				ts.ui.ACTION_PANEL_HIDE,
				ts.ui.ACTION_ROOT_CLASSNAMES
			], this);
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			var isroot = a.data === true;
			switch (a.type) {
				case ts.ui.ACTION_PANEL_ATTACH:
					if (isroot) {
						this._enterpanel(a.target);
					}
					break;
				case ts.ui.ACTION_PANEL_SHOW:
					if (isroot) {
						this._showpanel(a.target);
					}
					break;
				case ts.ui.ACTION_PANEL_HIDE:
					if (isroot) {
						this._hidepanel(a.target);
					}
					break;
				case ts.ui.ACTION_ROOT_CLASSNAMES:
					var data = a.data;
					this._togglecss(
						data.enabled,
						data.classes,
						data.relatedPanel
					);
					break;
			}
		},

		/**
		 * Has root level panels?
		 * @returns {boolean}
		 */
		haspanels: function() {
			return haspanels;
		},

		// Private .................................................................

		/**
		 * Root level panel entered. If `label` or `icon` was specified,
		 * we'll add some TopBar tabs to toggle the panels visibility.
		 * TODO(jmo@): Make sure that panels can be added asynchronously
		 * because in Angular, everything is always added asynchronously.
		 * @param {ts.ui.PanelSpirit} panel
		 */
		_enterpanel: function(panel) {
			haspanels = true;
			classnames.set(panel.$instanceid, []);
			var index = panel.dom.ordinal();
			var shown = index === 0;
			if (shown) {
				shownpanel = panel;
			} else {
				panel.hide();
			}
			if (panel.label || panel.icon) {
				this._insertab(panel, index, shown);
				this._quickfixlayout();
			}
		},

		/**
		 * Root level panel was shown (probably becuase the associated
		 * Tab was selected) so we'll add the associated classnames.
		 * @param {ts.ui.PanelSpirit} panel
		 */
		_showpanel: function(panel) {
			shownpanel = panel;
			this.spirit.css.add(classnames.get(panel.$instanceid));
		},

		/**
		 * Root level panel was hidden, remove the associated classnames.
		 * @param {ts.ui.PanelSpirit} panel
		 */
		_hidepanel: function(panel) {
			shownpanel = (shownpanel === panel ? null : shownpanel);
			this.spirit.css.remove(classnames.get(panel.$instanceid));
		},

		/**
		 * Add or remove CSS classnames on the HTML element.
		 * @param {boolean} on
		 * @param {Array<string>} classes
		 * @param {ts.ui.PanelSpirit} panel Root level panel (otherwise null)
		 */
		_togglecss: function(on, classes, panel) {
			var root = this.spirit;
			var guid = panel ? panel.$instanceid : root.$instanceid;
			var list = classnames.get(guid);
			var snap = GuiArray.from(list);
			classes.forEach(function(c) {
				updatelist(list, c, on);
			});
			list = on ? list : snap.filter(function(clas) {
				return list.indexOf(clas) === -1;
			});
			if (panel) {
				if (panel === shownpanel) {
					root.css.shift(on, list);
				}
			} else {
				root.css.shift(on, list);
			}
		},

		/**
		 * Add tab at given index to show the given panel.
		 * @param {ts.ui.PanelSpirit} panel
		 * @param {number} index
		 * @param {boolean} selected
		 */
		_insertab: function(panel, index, selected) {
			var tabs = ts.ui.TopBar.tabs();
			var root = this.spirit;
			tabs.splice(index, 0, {
				label: panel.label,
				icon: panel.icon,
				selected: selected,
				$onselect: function() {
					toggle(panel, root);
				}
			});
		},

		/**
		 * Quickly hack classnames so that the layout doesn't jump.
		 * TODO: This trick should be deployed on a deeper level
		 * so that we never jump whenever the TopBar gets shown.
		 */
		_quickfixlayout: function() {
			this.spirit.css.add('ts-has-topbar ts-has-topbar-tabs');
		}

	});
}(gui.MapList, gui.Array));



/**
 * Corporate base spirit.
 * @extends {gui.Spirit}
 * @using {gui.Type} Type
 * @using {gui.Array} GuiArray
 * @using {gui.Arguments#confirmed} confirmed
 */
ts.ui.Spirit = (function using(Type, GuiArray, confirmed) {
	return gui.Spirit.extend({

		/**
		 * Setup.
		 */
		onconstruct: function() {
			gui.Spirit.prototype.onconstruct.call(this);
			this._confirmattributes(gui.debug);
			this._configureclassnames(this.css);
		},

		// Private .................................................................

		/**
		 * The spirit can have a model associated. This usually
		 * implies that the spirit was generated via API calls.
		 * @type {ts.ui.Model}
		 */
		_model: null,

		/**
		 * This spirit was somehow generated via API calls?
		 * In other words, it's not a simple DHTML widget.
		 * @return {boolean}
		 */
		_ismodelled: function() {
			return this._model !== null;
		},

		/**
		 * Validate that the `gui` attribute is not used around here.
		 * For TS spirits, we'll be using the `ts` attribute instead.
		 * @param {boolean} debug
		 */
		_confirmattributes: function(debug) {
			if (debug && this.att.all().some(function(att) {
				return att.name === 'gui' || att.name.startsWith('gui.');
			})) {
				console.warn(
					'The "gui" attribute should not used. Use the "ts" ' +
					'attribute to configure the ' + this.$classname
				);
			}
		},

		/**
		 * If this spirit has explicit channeling, attach list of CSS classnames.
		 * TODO: MVC frameworks might assume control of the classname :/
		 * @param {gui.CSSPlugin} css
		 */
		_configureclassnames: function(css) {
			var cssnames = this.constructor.$cssnames;
			if (cssnames) {
				this.css.add(cssnames);
			}
		},

		/**
		 * Invoke that function with optional arguments *only if* it's defined.
		 * If the `action` argument is a string, we'll compile it to a function.
		 * Note that the `this` keyword will in either case point to this spirit.
		 * TODO: Support multiple args
		 * @param {string|function} action
		 * @returns {boolan} True if the action was called
		 */
		_maybeinvoke: function(action, arg) {
			if (action) {
				var args = [];
				if (arguments.length > 1) {
					args.push(arg);
				}
				if (Type.isString(action)) {
					action = new Function(action);
				}
				action.apply(this, args);
			}
			return !!action;
		},

		// Privileged ..............................................................

		/**
		 * Overwrites the default debugging (in Spiritual core).
		 * 1. Stamp constructor name unto element (for debugging)
		 * @param {boolean} construct
		 * @overwrites {gui.Spirit.$debug}
		 */
		$debug: function(construct) {
			if (construct) {
				this.att.set('data-ts-spirit', this.$classname);
			} else {
				this.att.del('data-ts-spirit');
			}
		}
	}, { // Xstatic ..............................................................

	}, { // Static ...............................................................

		/**
		 * Spirit name as refered to in the documentation
		 * and also as used in the `data-ts` attribute.
		 * This only applies to spirits with a channeling.
		 * @type {string}
		 */
		$nicename: null,

		/**
		 * Spirit CSS classname. This gets autocomputed
		 * on startup over in the file called "ts.ui.js".
		 * This only applies to spirits with a channeling.
		 * @type {string}
		 */
		$cssname: null,

		/**
		 * Inherit CSS classnames via JS class hierarchy
		 * Still only applies to spirits with a channeling.
		 * @type {string}
		 */
		$cssnames: null,

		/**
		 * Create method to get or set the model associated to a spirit,
		 * (just to make sure that the API remains somewhat consistant).
		 * A model is instantiated if the getter is called before setter!
		 * TODO: The (generated) method should be prefixed with a `$` dollar.
		 * @param {constructor|string} Model eg. ts.ui.ToolBarModel
		 * @param {function|string} edbml eg. ts.ui.ToolBarSpirit.edbml
		 * @param @optional {function}
		 * @returns {function} Optionally do something with that model
		 */
		createModelMethod: confirmed('function', 'function|string', '(function)')(
			function(Model, edbml, handle) {
				handle = handle || function(model) {
					return model;
				};
				return function modelmethod(opt_json) {
					var model = opt_json;
					if (model) {
						if (opt_json !== this._model) {
							if (!Model.is(model)) {
								model = new Model(opt_json);
							}
							this._model = model;
							if (!this.script.loaded) {
								this.script.load(edbml);
							}
							this.script.input(model);
						}
					} else {
						model = this._model || modelmethod.call(this, {});
					}
					return handle.call(this, model) || model;
				};
			}
		)

	});
}(gui.Type, gui.Array, gui.Arguments.confirmed));



/**
 * Spirit of the HTML element.
 * @extends {gui.DocumentSpirit} and not {ts.ui.Spirit}
 * @using {gui.Client} Client
 */
ts.ui.DocumentSpirit = (function using(Client) {
	var APP_LOADING = ts.ui.BROADCAST_GLOBAL_APP_LOADING;
	var APP_ABORTED = ts.ui.BROADCAST_GLOBAL_APP_ABORTED;
	var APP_COMPLETE = ts.ui.BROADCAST_GLOBAL_APP_COMPLETE;

	return gui.DocumentSpirit.extend({

		/**
		 * Kickstart the plugins that manage layout, asides and dialogs.
		 * Prepare to parse global models posted from the parent frame.
		 * Setup to change location hash if and when the chrome says to.
		 */
		onconstruct: function() {
			gui.DocumentSpirit.prototype.onconstruct.call(this);
			this.layoutplugin.managelayout();
			this.dialogplugin.managedialogs();
			this.asideplugin.manageasides();
			this.panelplugin.managepanels();
			this.input.connect(ts.ui.LayoutModel);
			this.broadcast.addGlobal([
				APP_LOADING,
				APP_ABORTED,
				APP_COMPLETE
			]);
			this.action.add(ts.ui.ACTION_STATUSBAR_LEVEL).addGlobal([
				ts.ui.ACTION_GLOBAL_MODELS_INITIALIZE,
				ts.ui.ACTION_GLOBAL_LOCATION_CHANGEHASH,
				ts.ui.ACTION_GLOBAL_LOCATION_HASHCHANGE,
				ts.ui.ACTION_GLOBAL_COMPLETED,
				ts.ui.ACTION_GLOBAL_TERMINATE
			]).dispatchGlobal(
				// TODO: this doesn't do nothing; but it should also hook into menu instead...
				ts.ui.ACTION_GLOBAL_DOCUMENT_TITLE, document.title
			);
		},

		/**
		 * Modernizr style classnames on the HTML element.
		 */
		onconfigure: function() {
			gui.DocumentSpirit.prototype.onconfigure.call(this);
			this.css.add('ts-engine-' + Client.agent)
				.shift(gui.hosted, 'ts-iframe-hosted')
				.shift(Client.isExplorer9, 'ts-engine-explorer9')
				.shift(Client.isTouchDevice, 'ts-device-touch')
				.shift(!Client.isTouchDevice, 'ts-device-mouse');
		},

		/**
		 * This classname will show everything. It's all been hidden
		 * until now to avoid the "flash on non-spiritualized content"
		 * (so it's essentially a Runtime equivalent to `ng-cloak`).
		 */
		onready: function() {
			gui.DocumentSpirit.prototype.onready.call(this);
			this.css.add(ts.ui.CLASS_READY);
		},

		/**
		 * Validate structure and stuff. The `touchstart` event has to
		 * do with an iOS bug that most likely is fixed in Safari now.
		 */
		onasync: function() {
			if (ts.ui.appframe) {
				var main = this.dom.qdoc('.ts-main');
				if (main) {
					main.addEventListener('touchstart', function() {});
				} else {
					console.warn('WARNING: This app needs a ts-main');
				}
				/**
				 * @todo dsp move this behind a debug switch
				 */
				// var tbar = this.dom.qdoc('.ts-topbar');
				// if(!tbar) { // TODO: escalate this to an error later on
				// 	console.warn(
				// 		'WARNING: This app needs a ts-topbar (otherwise ' +
				// 		'the main menu cannot be opened on a mobile phone)'
				// 	);
				// }
			}
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			gui.DocumentSpirit.prototype.onaction.call(this, a);
			a.consume();
			switch (a.type) {
				// request to change location hash descending from the hosting frame
				case ts.ui.ACTION_GLOBAL_LOCATION_CHANGEHASH:
					ts.lib.Location.assign(a.data);
					break;
				// information about global models descending from the hosting frame.
				// this is disabled for now - see {ts.ui.FrameSpirit} - but the idea
				// might come in handy at some point in the future, so we'll leave it.
				case ts.ui.ACTION_GLOBAL_MODELS_INITIALIZE:
					this._outputmodels(a.data);
					this.action.remove(a.type);
					break;
				// this app gets shown to the user
				// TODO(jmo@): are we using this?
				case ts.ui.ACTION_GLOBAL_COMPLETED:
					this.broadcast.dispatch(ts.ui.BROADCAST_COMPLETED);
					break;
				// next app started loading, this app soon to be unloaded
				case ts.ui.ACTION_GLOBAL_TERMINATE:
					this.broadcast.dispatch(ts.ui.BROADCAST_TERMINATE);
					break;
				// statusbar changed height on window resize
				case ts.ui.ACTION_STATUSBAR_LEVEL:
					if (a.target.guilayout.outsideMain()) {
						this.guilayout.gotoLevel(a.data);
					}
					break;
			}
		},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			gui.DocumentSpirit.prototype.onbroadcast.call(this, b);
			var cname = ts.ui.CLASS_LOADING;
			switch (b.type) {
				case APP_LOADING:
				case APP_ABORTED:
					this.css.add(cname);
					break;
				case APP_COMPLETE:
					this.css.remove(cname);
					break;
			}
		},

		/**
		 * Handle the {ts.ui.LayoutModel} whether it was
		 *
		 * 1. output by the local {ts.ui.LayoutPlugin} or
		 * 2. posted down from the chrome (global model)
		 * @param {edb.Input} input
		 */
		oninput: function(input) {
			gui.DocumentSpirit.prototype.oninput.call(this, input);
			var model = input.data;
			switch (input.type) {
				case ts.ui.LayoutModel:
					this._breakpoints(model.breakpoints);
					this._breakpoint(model.breakpoint);
					model.addObserver(this);
					break;
			}
		},

		/**
		 * Model changed something.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			gui.DocumentSpirit.prototype.onchange.call(this, changes);
			changes.forEach(function(c) {
				this._onmodelchange(
					c.object,
					c.name,
					c.newValue,
					c.oldValue
				);
			}, this);
		},

		/**
		 * This will crawl the document on window resize and
		 * invoke the `onflex` method on all spirits, but we
		 * make sure that the breakpoints are resolved first.
		 * @overwrites {gui.DocumentSpirit#reflex}
		 */
		reflex: function() {
			this.tick.time(function waitforbreakpoint2resolve() {
				gui.DocumentSpirit.prototype.reflex.call(this);
			});
		},

		/**
		 * @param {boolean} on
		 * @param {string|Array<string>} classnames
		 */
		shiftclassnames: function(on, cnames) {
			this.layoutplugin.shiftclassnames(!!on, gui.Array.make(cnames));
		},

		// Private .................................................................

		/**
		 * Output models in this window scope by recreating
		 * them from JSON posted by the hosting iframespirit.
		 * NOTE: Migrating models have been disabled for now!
		 * @see {ts.ui.FrameSpirit#_mapmodels}
		 * @param {Map.<String|object>} models
		 */
		_outputmodels: function(models) {
			gui.Object.each(models, function(name, json) {
				var Model = gui.Object.lookup(name);
				Model.syncGlobal(json).output();
			}, this);
		},

		/**
		 * Model changed something.
		 * @param {edb.Object} model
		 * @param {string} prop
		 * @param {object} newval
		 * @param {object} oldval
		 */
		_onmodelchange: function(model, prop, newval, oldval) {
			switch (model.constructor) {
				case ts.ui.LayoutModel:
					this._onlayoutchange(prop, newval, oldval);
					break;
			}
		},

		/**
		 * Layout model changed.
		 * @param {string} prop
		 * @param {object} newval
		 * @param {object} oldval
		 */
		_onlayoutchange: function(prop, newval, oldval) {
			switch (prop) {
				case 'breakpoints' :
					this._breakpoints(newval, oldval);
					break;
				case 'breakpoint' :
					this._breakpoint(newval, oldval);
					break;
				case 'menuopen' :
					this.css.shift(newval, 'ts-menu-open');
					break;
			}
		},

		/**
		 * Update classname for current breakpoint, then
		 * dispatch an custom event for anyone to handle.
		 * @param {string} newpoint
		 * @param {string=} opt_oldpoint
		 */
		_breakpoint: function(newpoint, opt_oldpoint) {
			function fix(p) { return 'ts-' + p + '-only'; }
			this.css.remove('ts-mobile-only ts-tablet-only ts-desktop-only');
			this.css.add(fix(newpoint));
			this.event.dispatch('ts-breakpoint', {bubbles: true});
		},

		/**
		 * Update classname for derived breakpoints.
		 * @param {Array.<string>} newpoints
		 * @param {Array.<string>=} opt_oldpoints
		 */
		_breakpoints: function(newpoints, opt_oldpoints) {
			var css = this.css;
			function fix(p) { return 'ts-' + p; }
			(opt_oldpoints || []).forEach(function(val) {
				css.remove(fix(val));
			});
			newpoints.forEach(function(val) {
				css.add(fix(val));
			});
		}

	});
}(gui.Client));



/**
 * Spirit of the main element.
 * @using {gui.Type} Type
 * @using {string} PANEL_ATTACH
 * @using {string} PANEL_DETACH
 */
ts.ui.MainSpirit = (function using(Type, PANEL_ATTACH, PANEL_DETACH) {
	/**
	 * The TopBar and ToolBar and TabBar share inheritance chain,
	 * se we'll need an elaborate setup to distinguish them apart.
	 * @param {ts.ui.MainSpirit} main
	 * @param {Constructor} Bar
	 */
	function preceding(main, Bar) {
		return main.dom.preceding(ts.ui.Spirit).find(function(spirit) {
			return spirit.constructor === Bar;
		});
	}

	/**
	 * @param {ts.ui.MainSpirit} main
	 * @param {Constructor} Bar
	 */
	function following(main, Bar) {
		return main.dom.following(ts.ui.Spirit).find(function(spirit) {
			return spirit.constructor === Bar;
		});
	}

	/**
	 * Setup to insert the bar only when it has any content.
	 * @see {ts.ui.ToolBarModel#_updatehascontent}
	 * @see {ts.ui.ToolBarSpirit#onchange}
	 * @param {ts.ui.BarSpirit} bar
	 * @param {function} action
	 * @param {ts.ui.MainSpirit} thisp
	 * @returns {ts.ui.BarSpirit}
	 */
	function suspended(bar, action, thisp) {
		var type = 'ts-life-toolbar-hascontent';
		bar.life.add(type, {
			onlife: function() {
				bar.life.remove(type, this);
				action.call(thisp, bar);
			}
		});
		return bar;
	}

	return ts.ui.Spirit.extend({

		/**
		 * ts.ui.SpinnerSpirit.
		 */
		spin: null,

		/**
		 * @param {string} busy
		 */
		busy: function(busy) {
			var opts = {
				message: gui.Type.isString(busy) ? busy : ''
			};
			if (!busy || !this._isbusy) {
				this._initspin(busy, opts);
				if (busy) {
					this.guistatus.busy(this.$instanceid);
					this._isbusy = true;
				} else {
					this.guistatus.done(this.$instanceid);
					this._isbusy = false;
				}
			}
		},

		/**
		 * @param {string} busyblocking
		 */
		blocking: function(busyblocking) {
			var opts = {
				message: busyblocking,
				cover: true,
				color: '#fff'
			};
			this._initspin(busyblocking, opts);
			if (busyblocking) {
				this.guistatus.busy(this.$instanceid);
			} else {
				this.guistatus.done(this.$instanceid);
			}
		},

		/**
		 * Configure.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.element.tabIndex = -1;
			this.attention.trap();
			this.action.add([
				PANEL_ATTACH,
				PANEL_DETACH
			]);
		},

		/**
		 * Handle action: Panel added or removed.
		 * TODO: Validate the the Panel is a direct child of Main.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.Spirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case PANEL_ATTACH:
				case PANEL_DETACH:
					var panel = a.target;
					var index = panel.dom.ordinal();
					var added = a.type === PANEL_ATTACH;
					if (panel.label) { // otherwise just ignore
						this._updatetab(panel, index, added);
					}
					a.consume();
					break;
			}
		},

		/**
		 * If the `autofocus` element is not focused by now, we'll do just that.
		 * TODO(jmo@): Perhaps validate that there is only one 'autofocus' arond?
		 */
		onvisible: function() {
			ts.ui.Spirit.prototype.onvisible.call(this);
			var auto = this.dom.q('[autofocus]');
			if (auto && document.activeElement !== auto) {
				auto.focus();
			}
		},

		/**
		 * Get the TabBar (will be created it if it doesn't exist)
		 * while accounting for manually created TabBar and ToolBar.
		 * TODO: Make sure that this gets inserted BEFORE the ordinary ToolBar.
		 * @returns {ts.ui.TabBarSpirit}
		 */
		tabbar: function() {
			var TabBar = ts.ui.TabBarSpirit;
			return this._tabbar || (this._tabbar = preceding(this, TabBar) ||
				suspended(TabBar.summon('header').lite(), function oncontent(tabbar) {
					var toolbar = preceding(this, ts.ui.ToolBarSpirit);
					(toolbar || this).dom.before(tabbar);
				}, this));
		},

		/**
		 * Get the ToolBar (will be created it if it doesn't exist)
		 * while accounting for manually created TabBar and ToolBar.
		 * @returns {ts.ui.TabBarSpirit}
		 */
		toolbar: function() {
			var ToolBar = ts.ui.ToolBarSpirit;
			return this._toolbar || (this._toolbar = preceding(this, ToolBar) || suspended(ToolBar.summon('header'), function oncontent(toolbar) {
				var tabbar = preceding(this, ts.ui.TabBarSpirit);
				if (tabbar) {
					tabbar.dom.after(toolbar);
				} else {
					this.dom.before(toolbar);
				}
			}, this));
		},

		/**
		 * Get the ToolBar (will be created it if it doesn't exist)
		 * while accounting for manually created StatusBar.
		 * @returns {ts.ui.StatusBarSpirit}
		 */
		statusbar: function() {
			var StatusBar = ts.ui.StatusBarSpirit;
			return this._statusbar || (this._statusbar = following(this, StatusBar) ||
			suspended(StatusBar.summon('footer'), function oncontent(statusbar) {
				this.dom.after(statusbar);
			}, this));
		},

		// Private .................................................................

		/**
		 * The Main tabbar.
		 * @type {ts.ui.TabBarSpirit}
		 */
		_tabbar: null,

		/**
		 * The Main toolbar.
		 * @type {ts.ui.ToolBarSpirit}
		 */
		_toolbar: null,

		/**
		 * The Main statusbar.
		 * @type {ts.ui.ToolBarSpirit}
		 */
		_statusbar: null,

		/**
		 * Added or remove tab for Panel at given index.
		 * TODO: Support a `selected` property in the {ts.ui.PanelSpirit}
		 * TODO: When all panels are done, somehow force `tabbar.script.run()` ...
		 * @param {ts.ui.PanelSpirit} panel
		 * @param {number} index
		 */
		_updatetab: function(panel, index, added) {
			var css = '.ts-maincontent > .ts-panel';
			var bar = this.tabbar();
			var elm = this.element;
			var dom = this.dom;
			if (added) {
				if (index < 0) {
					panel.hide();
				}
				bar.tabs().splice(index, 0, {
					label: panel.label,
					selected: panel.selected || index === 0,
					$onselect: function() {
						dom.qall(css, ts.ui.PanelSpirit).forEach(function(p) {
							if (p === panel) {
								p.show();
								elm.scrollTop = 0; // TODO(jmo@): account for topbar position in mobile breakpoint
								p.$onselect();
							} else {
								p.hide();
							}
						});
					}
				});
			} else {
				bar.tabs().splice(index, 1).forEach(function(tab) {
					tab.dispose();
				});
			}
			bar.$hascontent(); // for the tabbar to render instantly
		},

		/**
		 * If you set the attribute ts.busy is true, you will see the spinner in the main
		 * param {string} busy
		 * param {object} opts
		 */
		_initspin: function(busy, opts) {
			if (!this.spin) {
				this.spin = ts.ui.SpinnerSpirit.summon();
			}
			if (busy) {
				this.spin.spin(document.body, opts);
			} else {
				this.spin.stop();
			}
		}

	});
}(gui.Type, ts.ui.ACTION_PANEL_ATTACH, ts.ui.ACTION_PANEL_DETACH));



/**
 * Spirit of the main element.
 */
ts.ui.MainContentSpirit = ts.ui.Spirit.extend({

	/**
	 * Configure.
	 */
	onconfigure: function() {
		ts.ui.Spirit.prototype.onconfigure.call(this);
		this.element.tabIndex = -1;
	},

	/**
	 * Trap focus in the MAIN section so that TAB
	 * won't travel into ASIDE or exit the IFRAME.
	 */
	onready: function() {
		ts.ui.Spirit.prototype.onready.call(this);
		/**
		 * @todo fix the root cause why the class doesn't get added
		 */
		this.css.add('ts-maincontent');
		if (gui.debug) {
			if (this.dom.qdocall('.ts-maincontent').length > 1) {
				console.log('There should be only on .ts-maincontent at any given time :/');
			}
		}
	}
});



/**
 * Spirit of the icon. Convert font icon to svg.
 * @extends {ts.ui.Spirit}
 */
ts.ui.IconSpirit = (function using() {
	var ICON_PREFIX = 'ts-icon-';
	var SVG_LINK = '//d5wfroyti11sa.cloudfront.net/prod/client/svg-icons/';
	var ICON_SUBSTITUTES = {
		todo: 'vote-flag-7',
		warning: 'interface-alert-triangle'
	};

	return ts.ui.Spirit.extend({

		/**
		 * Setup on enter.
		 */
		onenter: function() {
			ts.ui.Spirit.prototype.onenter.call(this);
			this.att.add('class');
		},

		/**
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.Spirit.prototype.onatt.call(this, att);
			if (att.name === 'class') {
				this._loadsvg();
			}
		},

		// Private ......................................................

		/**
		 * load svg by ajax
		 * XDomainRequest and CORS on IE9 http://perrymitchell.net/article/xdomainrequest-cors-ie9/
		 */
		_loadsvg: function() {
			var icon = this.$geticon();
			if (!icon) {
				return;
			}
			var ajax = null;
			var spirit = this;
			if (gui.Client.isExplorer9) {
				ajax = new window.XDomainRequest();
				ajax.open('get', SVG_LINK + encodeURIComponent(icon) + '.svg', true);
				setTimeout(function() { // why need to do like this https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest
					ajax.send();
				}, 0);
			} else {
				ajax = new XMLHttpRequest();
				ajax.open('get', SVG_LINK + encodeURIComponent(icon) + '.svg', true);
				ajax.send();
			}
			ajax.onload = function() {
				if (ajax.responseText) {
					spirit.element.innerHTML = ajax.responseText + '\n\n';
					console.log(icon + '\n' + ajax.responseText);
					gui.Tick.nextFrame(function() {
						spirit.$fixsize.apply(spirit);
					});
				}
			};
			ajax.onerror = function() {
				console.error('Can not get the svg ' + icon);
			};
		},

		/**
		 * Get icon
		 */
		$geticon: function() {
			var result = null;
			var klasses = this.element.className.split(' ');
			if (!klasses.length) {
				return result;
			}
			klasses.map(function(item) {
				if (item.indexOf(ICON_PREFIX) > -1) {
					result = item.substring(8, item.length);
				}
			});
			return this.$substitute(result);
		},

		$substitute: function(icon) {
			if (ICON_SUBSTITUTES[icon]) {
				return ICON_SUBSTITUTES[icon];
			}
			return icon;
		},

		$fixsize: function() {
			var fontSize = parseFloat(this.css.compute('fontSize'));
			var svgElem = this.element.querySelector('svg');
			svgElem.setAttribute('width', fontSize);
			svgElem.setAttribute('height', fontSize);
		}
	});
}());



/**
 * CURRENTLY USED ONLY IN THE DOCS WEBSITE.
 * @using {gui.URL} URL
 * @using {gui.Request} Request
 * @using {gui.Client} Client
 * @using {gui.HTMLParser} parser
 */
ts.ui.NextIconSpirit = (function(URL, Request, Client, Parser) {
	/**
	 * Cache resolved (external) bundles.
	 * @type {Map<string, Document>}
	 */
	var bundles = {};

	/**
	 * Cache resolved icons.
	 * @type {Map<string, Element>}
	 */
	var icons = {};

	/**
	 * @param {Map<string, Array<Function>>}
	 */
	var queues = {};

	return ts.ui.Spirit.extend({

		/**
		 * Monitor the `src` attribute.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.att.add('src');
		},

		/**
		 * Handle attribute changed.
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.Spirit.prototype.onatt.call(this, att);
			if (att.name === 'src') {
				var src = att.value.trim();
				if (!att.value.startsWith('{')) {
					this._geticon(src).then(function(icon) {
						this.dom.empty().append(icon.cloneNode(true));
					}, this);
				}
			}
		},

		// Private .................................................................

		/**
		 * Get the icon.
		 * TODO: Resolve icon from external URL
		 * @param {string} src
		 * @returns {gui.Then}
		 */
		_geticon: function(src) {
			var icon = icons[src];
			var then = new gui.Then();
			if (!icon) {
				if (src.startsWith('#')) {
					if ((icon = document.querySelector(src))) {
						icons[src] = icon;
					} else {
						throw new Error(src + ' not found');
					}
				} else if (src.includes('#')) {
					var gurl = new URL(document, src);
					var path = gurl.pathname;
					var hash = gurl.hash;
					this._getexternal(path, hash, then);
				} else {
					throw new Error('Missing #identifier in ' + src);
				}
			}
			if (icon) {
				then.now(icon);
			}
			return then;
		},

		/**
		 * @param {string} src
		 * @param {gui.Then} then
		 */
		_getexternal: function getexternal(path, hash, then) {
			var exist = bundles[path];
			var loads = exist && (exist instanceof Request);
			if (!exist || loads) {
				this._loadexternal(path, loads, function onload() {
					getexternal(path, hash, then);
				});
			} else if (hash.length > 1) {
				var icon = exist.querySelector(hash);
				if (icon) {
					then.now(icon);
				} else {
					console.log(hash + ' not found');
				}
			} else {
				console.error('Icon #id missing');
			}
		},

		/**
		 * Load SVG from external location (on own domain).
		 * @param {string} path
		 * @param {boolean} loads
		 * @param {Function} callback
		 */
		_loadexternal: function(path, loads, callback) {
			var queue = queues[path] || (queues[path] = []);
			queue.push(callback);
			if (!loads) {
				var request = bundles[path] = new Request(path);
				request.accept('image/svg+xml').get().then(function(status, svg) {
					if (status === 200) {
						bundles[path] = Parser.parseToDocument(svg);
						while (queue.length) {
							queue.shift()();
						}
					} else {
						console.error(path + ' status:' + status);
					}
				}, this);
			}
		}

	});
}(gui.URL, gui.Request, gui.Client, gui.HTMLParser));



/**
 * Spirit of the IFRAME.
 * @extends {gui.IframeSpirit} and not {ts.ui.Spirit}
 */
ts.ui.FrameSpirit = gui.IframeSpirit.extend({

	/**
	 * Setup listeners for navigation going
	 * on inside the hosted iframe and stuff.
	 */
	onenter: function() {
		gui.IframeSpirit.prototype.onenter.call(this);
		this._models = [];
		this.life.add([
			gui.LIFE_IFRAME_DOMCONTENT,
			gui.LIFE_IFRAME_ONLOAD,
			gui.LIFE_IFRAME_ONHASH,
			gui.LIFE_IFRAME_UNLOAD
		]);
		this.input.connect([
			ts.ui.LayoutModel,
			ts.ui.DeviceModel
		]);
	},

	/**
	 * Translate life events (non-bubbling) to actions (bubbling).
	 * Actions are intended for the {ts.top.RootSpirit} to intecept.
	 * @param {gui.Life} l
	 */
	onlife: function(l) {
		gui.IframeSpirit.prototype.onlife.call(this, l);
		switch (l.type) {
			case gui.LIFE_IFRAME_DOMCONTENT:
				this.action.dispatch(
					ts.ui.ACTION_FRAME_ONDOM,
					this.contentLocation.href
				);
				break;
			case gui.LIFE_IFRAME_ONLOAD:
				this.action.dispatch(
					ts.ui.ACTION_FRAME_ONLOAD,
					this.contentLocation.href
				);
				break;
			case gui.LIFE_IFRAME_ONHASH:
				this.action.dispatch(
					ts.ui.ACTION_FRAME_ONHASH,
					this.contentLocation.hash
				);
				break;
			case gui.LIFE_IFRAME_UNLOAD:
				this.action.dispatch(
					ts.ui.ACTION_FRAME_UNLOAD,
					this.contentLocation.href
				);
				break;
		}
	},

	/**
	 * Handle input.
	 * @param {edb.Input} input
	 */
	oninput: function(input) {
		gui.IframeSpirit.prototype.oninput.call(this, input);
		switch (input.type) {
			case ts.ui.LayoutModel:
			case ts.ui.DeviceModel:
				this._models.push(input.data);
				break;
		}
	},

	/**
	 * Load src. If the src starts with a #hash, we'll
	 * try to update the hosted document without reload.
	 * @param {String} url
	 * @return {gui.Then}
	 */
	load: function(src) {
		var then = new gui.Then();
		if (src.startsWith('#')) {
			this._updatehash(src, then);
		} else {
			this._loadnewsrc(src, then);
		}
		return then;
	},

	// Private .............................................

	/**
	 * @type {Array<edb.Object>}
	 */
	_models: null,

	/**
	 * Load new src, nuke existing iframe page.
	 * TODO (jmo@):: The machine would AJAX about now.
	 * @param {String} src
	 * @param {gui.Then} then
	 */
	_loadnewsrc: function(src, then) {
		this.src(src);
		then.now();
	},

	/**
	 * Update hash inside the iframe. We can't do this
	 * reliably from the outside without nuking the
	 * (xorigin) iframe page, but we can transmit the
	 * instruction to the contained document(spirit).
	 * @param {string} hash
	 * @param {gui.Then} then
	 */
	_updatehash: function(hash, then) {
		var action = ts.ui.ACTION_GLOBAL_LOCATION_CHANGEHASH;
		this.action.descendGlobal(action, hash);
		then.now();
	},

	/**
	 * Content document spiritualized. Important: This can be used to relay
	 * models "globally" from the chrome to the content, but we're not using
	 * this kind of (Greenfield) stuff now. Since it might still come in
	 * handy, perhaps we better leave this commented code around for a while...
	 * @override {gui.IframeSpirit#_onspiritualized}
	 *
	_onspiritualized: function() {
		this.super._onspiritualized();
		this.action.descendGlobal(
			ts.ui.ACTION_GLOBAL_MODELS_INITIALIZE,
			this._mapmodels(this._models)
		);
	},
	*/

	/**
	 * Prepare collected models for cross frame posting. Returns
	 * a map indexing the model classname to a serialized model.
	 * @see {ts.ui.DocumentSpirit#_outputmodels}
	 * @param {Array<edb.Object>} models
	 * @return {Map<String,object>}
	 */
	_mapmodels: function(models) {
		var map = Object.create(null);
		this._models.forEach(function(model) {
			map[model.$classname] = model.serializeToString();
		});
		return map;
	}

}, { // Static .................................................................

	/**
	 * Note: We're not just this thing just now.
	 * TODO (jmo@): Eventually *don't* allow same origin!
	 * @type {String}
	 */
	SANDBOX: 'allow-scripts allow-forms allow-same-origin',

	/**
	 * Summon spirit.
	 * @param @optional {string} opt_src
	 * @param @optional {string} opt_box
	 */
	summon: function(opt_src, opt_box) {
		var iframe = document.createElement('iframe');
		var spirit = this.possess(iframe);
		spirit.css.add(ts.ui.CLASS_IFRAME);
		if (opt_box) {
			iframe.sandbox = opt_box;
		}
		if (opt_src) {
			spirit.load(opt_src);
		}
		return spirit;
	}

});



/**
 * Manager of iframes.
 * TODO(jmo@): This file is not used in app iframes, but still needs to be
 * subclassed by both top.js and sub.js, so we're stashing it here for now.
 */
ts.ui.MainFrameSpirit = ts.ui.Spirit.extend({

	/**
	 * True while loading our new app.
	 * Two iframes exist at this point.
	 * @type {boolean}
	 */
	loading: false,

	/**
	 * Configure much.
	 */
	onconfigure: function() {
		ts.ui.Spirit.prototype.onconfigure.call(this);
		this.event.add('message', window);
		this.css.add(ts.ui.CLASS_MAINFRAME);
		this.action.add([
			ts.ui.ACTION_FRAME_ONDOM,
			ts.ui.ACTION_FRAME_ONLOAD,
			ts.ui.ACTION_FRAME_ONHASH,
			ts.ui.ACTION_FRAME_UNLOAD
		]).addGlobal(ts.ui.ACTION_GLOBAL_DOCUMENT_TITLE);

		// we're using the `ts-mainframe` class in the apps window now...
		this.css.remove('ts-mainframe').add('ts-mainframe-renamed');
	},

	/**
	 * Handle actions, making sure that actions from
	 * an unloading app doesn't reach the top window.
	 * @param {gui.Action} a
	 */
	onaction: function(a) {
		var target = a.target, newframe = this._newframe;
		ts.ui.Spirit.prototype.onaction.call(this, a);
		switch (a.type) {
			case ts.ui.ACTION_GLOBAL_DOCUMENT_TITLE:
				if (target !== newframe) {
					a.consume();
				}
				break;
			case ts.ui.ACTION_FRAME_ONDOM:
				if (target === newframe) {
					this._prepareonload();
				} else {
					a.consume();
				}
				break;
			case ts.ui.ACTION_FRAME_ONLOAD:
				a.consume(); // using ONDOM for now...
				break;
			case ts.ui.ACTION_FRAME_ONHASH:
				if (target !== newframe) {
					a.consume();
				}
				break;
			case ts.ui.ACTION_FRAME_UNLOAD:
				if (target === newframe) {
					this._loading(true);
					this._unload();
				} else {
					a.consume();
				}
				break;
		}
	},

	/**
	 * Handle event.
	 * @param {Event} e
	 */
	onevent: function(e) {
		ts.ui.Spirit.prototype.onevent.call(this, e);
		if (e.type === 'message') {
			if (this._newframe && e.source === this._newframe.contentWindow) {
				switch (e.data) {
					case ts.ui.MESSAGE_BUSY:
						console.error('TODO: implement mechanism for delaying _onload()');
						break;
					case ts.ui.MESSAGE_DONE:
						this._prepareonload();
						break;
				}
			}
		}
	},

	/**
	 * Load something.
	 * @param {String} href
	 * @returns {boolean} True when something completely new gets loaded
	 */
	load: function(href) {
		if (href !== this._href) {
			this._href = href;
			this._loading(true);
			return this._load(this._href);
		}
		return false;
	},

	// Private ...................................................................

	/**
	 * Allow the UI to stabilize before we show it.
	 * @type {number} Timeout in milliseconds
	 */
	_COSMETIC_TIMEOUT: 10,

	/**
	 * @type {String}
	 */
	_href: null,

	/**
	 * Currently hosted URL path excluding the hash.
	 * @type {String}
	 */
	_path: null,

	/**
	 * Current or next iframe.
	 * @type {ts.ui.FrameSpirit}
	 */
	_newframe: null,

	/**
	 * Old iframe. Soon dead.
	 * @type {ts.ui.FrameSpirit}
	 */
	_oldframe: null,

	/**
	 * Prepare do declare everything loaded when
	 *
	 * 1. the 'onload' event fires on the iframe
	 * 2. the iframe does postmessage 'ts-ready'
	 */
	_prepareonload: function() {
		var time = this._COSMETIC_TIMEOUT;
		this.tick.time(function() {
			this._onload();
		}, time);
	},

	/**
	 * Create new iframe. We listen for the `DOMContentLoaded`
	 * event to fire before we show the app, perhaps something
	 * more elaborate should be implemented at some point
	 * (like a message dispatched manually from the iframe).
	 * @return {ts.ui.FrameSpirit}
	 */
	_createframe: function() {
		var Frame = this._frameimplementation();
		var frame = Frame.summon();
		return this._showframe(frame, false);
	},

	/**
	 * So that subclass may overwrite it. Eh.
	 * @returns {constructor}
	 */
	_frameimplementation: function() {
		return ts.ui.FrameSpirit;
	},

	/**
	 * Start loading.
	 * @param {String} href
	 * @returns {boolean} True when something completely new gets loaded
	 */
	_load: function(href) {
		var cuts = href.split('#');
		var path = cuts[0];
		if (path !== this._path) {
			this._loadnew(href);
			this._path = path;
			return true;
		} else {
			this._sameold(href);
			return false;
		}
	},

	/**
	 * Load new iframe, prepare to nuke old iframe (if any).
	 * @param {String} href
	 */
	_loadnew: function(href) {
		this._switchframes();
		this._newframe.load(href).then(function onload() {
			this.dom.append(this._newframe);
		}, this);
	},

	/**
	 * Update location hash inside the current iframe (this._newframe).
	 * @param {string} hash
	 */
	_sameold: function(hash) {
		this._newframe.load(hash).then(function() {
			this._loading(false);
		}, this);
	},

	/**
	 * Create new `this._newframe` and mark current frame as oldframe.
	 * The frames will not *visibly* toggle until newframe is loaded.
	 */
	_switchframes: function() {
		var oldframe = this._oldframe = this._newframe;
		this._newframe = this._createframe();
		if (oldframe) {
			oldframe.action.descendGlobal(ts.ui.ACTION_GLOBAL_TERMINATE);
		}
	},

	/**
	 * Content page done loading.
	 */
	_onload: function() {
		this._loading(false);
		this._toggle();
	},

	/**
	 * Content page unloading. If the user is refreshing the
	 * iframe via contextmenu or something, this will look
	 * a lot better if we hide the frame while reloading.
	 */
	_unload: function() {
		this._showframe(this._newframe, false);
	},

	/**
	 * Show new frame and nuke the old.
	 */
	_toggle: function() {
		var oldframe;
		this._showframe(this._newframe, true);
		if ((oldframe = this._oldframe)) {
			this._oldframe = null;
			this._showframe(oldframe, false);
			this._cleanup(oldframe);
		}
		this._newframe.action.descendGlobal(ts.ui.ACTION_GLOBAL_COMPLETED);
	},

	/**
	 * Mark shebang as loading or done.
	 * Cosmetically allow batch loading
	 * to ride along a single busy/done,
	 * prevents cursor-style flickering.
	 * @param {boolean} is
	 */
	_loading: function(is) {
		this.loading = is;
		var status = 'loading ' + this._href;
		var classn = ts.ui.CLASS_READY;
		if (is) {
			this.guistatus.busyBlocking(status);
			this.css.remove(classn);
		} else {
			gui.Tick.time(function() {
				this.guistatus.doneBlocking(status);
				this.css.add(classn);
			}, 100, this);
		}
	},

	/**
	 * Show or hide the frame.
	 * @param {ts.ui.FrameSpirit} frame
	 * @param {boolean} show
	 * @returns {ts.ui.FrameSpirit}
	 */
	_showframe: function(frame, show) {
		if (show) {
			frame.css.visibility = '';
			frame.visibility.on();
		} else {
			frame.css.visibility = 'hidden';
			frame.visibility.off();
		}
		return frame;
	},

	/**
	 * Nuke old frame.
	 * @param {ts.ui.FrameSpirit} oldframe
	 * TODO (jmo@): IE9 goes "attempt to handle destructed
	 * spirit..." on dom.remove();.
	 */
	_cleanup: function(oldframe) {
		if (gui.Client.isExplorer9) {
			(function iehotfix() {
				var iframe = oldframe.element;
				gui.materialize(iframe);
				iframe.parentNode.removeChild(iframe);
			}());
		} else {
			oldframe.dom.remove();
		}
	}

});



/**
 * Base spirit for aside-like components.
 * @see {ts.ui.AsideSpirit}
 * @see {ts.ui.SideBarSpirit}
 * @see @deprecated {ts.ui.DrawerSpirit}
 * @using {gui.Combo.chained}
 * @using {gui.Client} Client
 * @using {gui.HTMLParser} Parser
 * @using {gui.Object} GuiObject
 * @using {ts.ui.BACKGROUND_COLORS} Colors
 * @using {ts.ui.ACTION_PANEL_ATTACH} PANEL_ATTACH
 * @using {ts.ui.ACTION_PANEL_DETACH} PANEL_DETACH
 */
ts.ui.SideShowSpirit = (function using(chained, Client, Parser, GuiObject, Colors, PANEL_ATTACH, PANEL_DETACH) {
	// custom dom events (for public consumption)
	var domevent = {
		WILLOPEN: ts.ui.EVENT_ASIDE_WILL_OPEN,
		DIDOPEN: ts.ui.EVENT_ASIDE_DID_OPEN,
		WILLCLOSE: ts.ui.EVENT_ASIDE_WILL_CLOSE,
		DIDCLOSE: ts.ui.EVENT_ASIDE_DID_CLOSE
	};

	// when synchronizing the colors, make sure to remove all existing colors...
	var BGCOLORS = (function(colors) {
		return Object.keys(colors).map(function(key) {
			return colors[key];
		});
	}(ts.ui.BACKGROUND_COLORS));

	/**
	 * Extract `ts-bg-` classname from spirit.
	 * @param {ts.ui.Spirit} spirit
	 * @returns {string}
	 */
	function getcolor(spirit) {
		return Object.keys(Colors).map(function(key) {
			return Colors[key];
		}).reduce(function(result, color) {
			return result || (spirit.css.contains(color) ? color : null);
		}, null);
	}

	return ts.ui.Spirit.extend({

		/**
		 * Open?
		 * @type {boolean}
		 */
		isOpen: false,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onopen: null,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onopened: null,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onclose: null,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onclosed: null,

		/**
		 *(work in progress)
		 * @type {boolean}
		 */
		flipped: false,

		/**
		 * ts.ui.SpinnerSpirit.
		 */
		spin: null,

		/**
		 * @param {boolean} busy
		 */
		busy: function(busy) {
			this._initspin(busy);
			if (busy) {
				this.guistatus.busy(this.$instanceid);
			} else {
				this.guistatus.done(this.$instanceid);
			}
		},

		/**
		 *
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.action.add([PANEL_ATTACH, PANEL_DETACH]);
		},

		/**
		 * Setup.
		 */
		onenter: function() {
			ts.ui.Spirit.prototype.onenter.call(this);
			if (this.flipped) {
				// this.css.add('ts-flipped'); TODO!
				this.event.add('transitionend');
				this.css.add('ts-flipping ts-flip-init');
				this.tick.time(function transition_ok() {
					this.css.add('ts-flip-out');
				});
			}
		},

		/**
		 * Fix the color scheme.
		 */
		onasync: function() {
			ts.ui.Spirit.prototype.onasync.call(this);
			this._fixappearance();
		},

		/**
		 * Get ready.
		 */
		onready: function() {
			ts.ui.Spirit.prototype.onready.call(this);
			this._confirmpanel();
			this.css.add('ts-sideshow');
			this._initfooter(window.MutationObserver || window.WebKitMutationObserver);
			this._inittabs();
		},

		/**
		 * Reflex also when moved to another position (V4 scenario)
		 */
		onattach: function() {
			ts.ui.Spirit.prototype.onattach.call(this);
			this._reflex();
		},

		/**
		 * Detach hacky mutation observer.
		 */
		ondestruct: function() {
			ts.ui.Spirit.prototype.ondestruct.call(this);
			if (this._observer) {
				this._observer.disconnect();
			}
		},

		/**
		 * On EDBML rendered.
		 */
		onrender: function() {
			ts.ui.Spirit.prototype.onrender.call(this);
			this._confirmpanel(true);
			this._reflex();
		},

		/**
		 * Window resized (probably).
		 */
		onflex: function() {
			ts.ui.Spirit.prototype.onflex.call(this);
			this._reflex();
		},

		/**
		 * Handle tick.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.Spirit.prototype.ontick.call(this, t);
			if (!this.$destructed && t.type === 'ts-sideshow-theme' && this.dom.embedded()) {
				this._theme = this._theme || this._extractcolor('ts-bg-blue');
				this._transfercolor(this._theme, this.constructor.$bgmembers);
				this._themesupport(this.dom);
				this.tick.remove(t.type);
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'DOMSubtreeModified':
					this._reflex(); // reflex on footer update in IE
					break;
				case 'transitionend':
					if (this._flipping) {
						this._ontransitionend(
							ts.ui.get(e.target)
						);
					}
					break;
			}
		},

		/**
		 * We'll need to support that the tabbar auto-updates whenever a panel gets
		 * added or removed (like we do in the Main TabBar) but for now, we'll just
		 * make sure that these actions (dispatched from the Panel) are contained.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.Spirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case PANEL_ATTACH:
				case PANEL_DETACH:
					var panel = a.target;
					var added = a.type === PANEL_ATTACH;
					if (panel.label) { // otherwise just ignore
						this._updatetab(panel, added);
					}
					a.consume(); // don't exit the Aside
					break;
			}
		},

		/**
		 * Observing the tabbar tabs.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.Spirit.prototype.onchange.call(this, changes);
			var splice = edb.ArrayChange.TYPE_SPLICE;
			changes.filter(function(c) {
				return c.type === splice && ts.ui.TabCollection.is(c.object);
			}).forEach(function(c) {
				if (c.object.length === 0) {
					this._removetabbar();
				}
			}, this);
		},

		/**
		 * Set or get header title.
		 * @param {string} title
		 * @return {ts.ui.AsideSpirit|string}
		 */
		title: chained(function(title) {
			var header = this._headerspirit();
			if (arguments.length) {
				this._reflex(function() {
					header.title(title);
				});
			} else {
				return header.title();
			}
		}),

		/**
		 * Get or set the titlebar search model.
		 * @param {Object|ts.ui.SearchModel} search
		 * @returns {ts.ui.SearchModel|ts.ui.SideShowSpirit}
		 */
		search: chained(function(search) {
			var header = this._headerspirit();
			if (arguments.length) {
				header.search(search);
			} else {
				return header.search();
			}
		}),

		/**
		 * Get or set header model. TODO: Should be private, huh?
		 * @param @optional {object} opt_json
		 * @returns {ts.ui.ToolBarModel}
		 */
		header: function(opt_json) {
			return this._headerspirit().model(opt_json);
		},

		/**
		 * Open AND close the aside (setup to support the HTML
		 * attribute: `data-ts.open="true|false"`)
		 * @param @optional {boolean} opt_open Omit to simply open.
		 * @return {ts.ui.AsideSpirit}
		 */
		open: chained(function(opt_open) {
			if (!gui.Type.isBoolean(opt_open)) {
				opt_open = true;
			}
			if (this._shouldtoggle(opt_open)) {
				this.att.set('data-ts.open', opt_open);
				if (opt_open) {
					if (!this.isOpen) {
						this.isOpen = true;
						this._open(this.life.async);
					}
				} else {
					if (this.isOpen) {
						this.isOpen = false;
						this._close(this.life.async);
					}
				}
			}
		}),

		/**
		 * Close the aside.
		 * @return {ts.ui.AsideSpirit}
		 */
		close: chained(function() {
			this.open(false);
		}),

		/**
		 * Toggle the aside.
		 * @return {ts.ui.AsideSpirit}
		 */
		toggle: chained(function() {
			this.open(!this.isOpen);
		}),

		/**
		 * Announce to the {ts.ui.DocumentAsidePlugin} that we intend to flip.
		 */
		flip: function() {
			this.action.dispatch('FLIP', this.flipped);
		},

		/**
		 * Programatically create those tabs (or modify some declarative tabs).
		 * @returns {ts.ui.TabCollection|ts.ui.SideShowSpirit}
		 */
		tabs: chained(function() {
			var tabbar = this._tabbarspirit();
			if (arguments.length) {
				tabbar.tabs.apply(tabbar, arguments);
			} else {
				return tabbar.tabs();
			}
		}),

		// Privileged ..............................................................

		/**
		 * Actually flip the thing.
		 * @returns {gui.Then} Some kind of Promise-like object
		 */
		$flip: function() {
			if (!this._flipping) {
				this._flipping = new gui.Then();
				this.event.add('transitionend');
				this.css.remove('ts-flipped').add('ts-flipping');
				this.tick.time(function transition_ok() {
					this.css.add(this.flipped ? 'ts-flip-in' : 'ts-flip-out');
				});
			}
			return this._flipping;
		},

		// Private .................................................................

		/**
		 * Snapshot the color scheme asigned via model.
		 * @type {string}
		 */
		_theme: null,

		/**
		 * The Main tabbar.
		 * @type {ts.ui.TabBarSpirit}
		 */
		_tabbar: null,

		/**
		 * Monitor footer updates until we can enable CSS layout again.
		 * @type {MutationObserver}
		 */
		_observer: null,

		/**
		 * We can think of this as a Promise (code is old).
		 * @type {gui.Then}
		 */
		flipping: false,

		/**
		 * Configured with the closing "X" button?
		 * @type {boolean}
		 */
		_canclose: false,

		/**
		 * @deprecated
		 * The classname `ts-internal` will make this thing not behave
		 * much like an Aside because that was needed for teams that
		 * didn't want to use Asides. The classname affects both JS
		 * behavior and CSS styling. When we get support for different
		 * versions of UI Components (in V4), we should see if this
		 * can be deprecated in favor of standard UI Components.
		 * @returns {boolean}
		 */
		_isinternal: function() {
			return this.css.contains('ts-internal');
		},

		/**
		 * Using JS instead of CSS flex because Chrome has a nasty public breakdown.
		 * TODO: Setup to only reflex if the height of header or footer has changed.
		 * @param @optional {function} action Optionally flex after executing this.
		 * @returns {object}
		 */
		_reflex: function(action) {
			var panel, avail = this.box.height, height = 0, thing = (action ? action.call(this) : null);
			if (this.isOpen && avail) {
				var asides = [];
				this.dom.children(gui.Spirit).forEach(function(spirit) {
					if (ts.ui.PanelSpirit.is(spirit) && spirit.visible) {
						panel = spirit;
					} else {
						if (ts.ui.AsideSpirit.is(spirit)) {
							asides.push(spirit);
						} else {
							height += spirit.box.height;
						}
					}
				});
				if (panel) {
					panel.css.height = avail - height;
				}
				// TODO: Not this on global reflex!!!!!!!!!
				asides.forEach(function(aside) {
					aside._reflex(); // TODO: not so private after all...
				});
			}
			return thing;
		},

		/**
		 * Confirm and setup the panel.
		 * @param {boolean} insist
		 * @return {ts.ui.Spirit}
		 */
		_confirmpanel: function(insist) {
			if (insist || !this._isinternal()) {
				var panel = this.dom.q('.ts-panel', ts.ui.PanelSpirit);
				if (!panel) {
					throw new Error('Expected a Panel');
				}
				return panel;
			}
		},

		/**
		 * Confirm that we're not nested inside MAIN.
		 * - The {ts.ui.AsideSpirit} does this when it opens
		 * - The {ts.ui.SideShowSpirit} does it after a second
		 * - The {ts.ui.CollaborationSpirit} doesn't do this because of politics.
		 */
		_confirmposition: function() {
			if (!this._isinternal()) {
				if (!this.guilayout.outsideMain()) {
					throw new Error(
						this + ' must be positioned outside Main', this.element
					);
				}
			}
		},

		/**
		 * Runs on open and close. If the state changes:
		 *
		 * 1. Fire custom DOM event
		 * 2. Return whether or not this was preventDefaulted.
		 * @param {boolean} open
		 * @returns {boolean}
		 */
		_shouldtoggle: function(open) {
			if (open !== this.isOpen) {
				return (this.event.dispatch(open ?
					domevent.WILLOPEN : domevent.WILLCLOSE, {
						bubbles: true,
						cancelable: true
					}
				));
			}
			return false;
		},

		/**
		 * Get the header (and create the header if it doesn't already exist).
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		_headerspirit: function() {
			return (
				this.dom.q('this > .ts-header', ts.ui.ToolBarSpirit) ||
				this._reflex(function createheader() {
					var header = ts.ui.ToolBarSpirit.summon('header', 'ts-header');
					this.dom.prepend(header);
					this._fixappearance();
					return header;
				})
			);
		},

		/**
		 * Get the tabbar (and create the tabbar if it doesn't already exist).
		 * @returns {ts.ui.TabBarSpirit}
		 */
		_tabbarspirit: function() {
			return this._tabbar || (this._tabbar = (function createit() {
				var panel = this.dom.q('this > .ts-panel', ts.ui.PanelSpirit);
				this._fixappearance();
				this.css.add('ts-has-panels');
				return this._reflex(function() {
					var tabbar = ts.ui.TabBarSpirit.summon();
					tabbar.tabs().addObserver(this);
					return panel.dom.before(tabbar);
				});
			}.call(this)));
		},

		/**
		 * The footer versus panel layout was originally implemented using
		 * flexbox but there was a problem with this whenever CSS transitions
		 * and transform were added, so we've switched to JS layout. This means
		 * that we have to recalculate the layout whenever content is changed
		 * in the footer, but fortunately that's cost-effective nowadays.
		 * TODO: We should at some point attempt to go back to CSS layout,
		 * but note that the problem (in Chrome only!) is only apparent
		 * in a production/sandbox environment. They are however easy to spot.
		 * @param {constructor} Observer Which is undefined in old IE versions
		 */
		_initfooter: function(Observer) {
			var footer = this.dom.q('.ts-footer');
			if (footer) {
				if (Observer) {
					this._observer = new Observer(function() {
						this._reflex();
					}.bind(this));
					this._observer.observe(footer, {
						attributes: true,
						childList: true,
						characterData: true,
						subtree: true
					});
				} else { // TODO: Perhaps replace this with a timer?
					this.event.add('DOMSubtreeModified', footer, this);
				}
			}
		},

		/**
		 * (work in progress)
		 * @param {ts.ui.Spirit} spirit
		 */
		_ontransitionend: function(spirit) {
			if (ts.ui.PanelSpirit.is(spirit)) {
				this.event.remove('transitionend');
				this.css.remove('ts-flipping ts-flip-in ts-flip-out');
				if (this.css.contains('ts-flip-init')) {
					this.css.remove('ts-flip-init').add('ts-flipped');
				} else {
					this.flipped = !this.flipped;
					this.css.shift(this.flipped, 'ts-flipped');
				}
				this._flipping.now();
				this._flipping = null;
			}
		},

		/**
		 * Add or remove the closing "X" button in the titlebar.
		 * @param @optional {boolean} show
		 */
		_closebutton: function(show) {
			var that = this;
			var tool = this._headerspirit();
			if (show !== false) {
				this._canclose = true;
				tool.showClose(function() {
					that.close();
				});
			} else if (this._canclose) {
				this._canclose = false;
				tool.hideClose();
				// if `autoclose` was changed sometime *after* initialization,
				// we'll need to remove any header that doesn't have a `title`
				// while accounting for the fact that models are updated async.
				this.tick.time(function asyncproblem() {
					if (!tool.life.hascontent) {
						this.reflex(function removeheader() {
							tool.dom.remove();
							this._fixappearance();
						}, this);
					}
				}, 50);
			}
		},

		/**
		 * Opening scene implemented by subclass(es).
		 * Except for the coloring stuff, apparently.
		 * @param {boolean} animated
		 * @returns {boolean}
		 */
		_open: function(animated) {
			return this._execute('onopen') !== false;
		},

		/**
		 * Closing stuff implemented by subclass(es).
		 * @param {boolean} animated
		 * @returns {boolean}
		 */
		_close: function(animated) {
			return this._execute('onclose') !== false;
		},

		/**
		 * If you set the attribute ts.busy is true, you will see the spinner in the main
		 * param {boolean} busy
		 */
		_initspin: function(busy) {
			if (!this.spin) {
				this.spin = ts.ui.SpinnerSpirit.summon();
			}
			if (busy) {
				var opts = {
					message: busy,
					top: '226px'
				};
				this.spin.spin(this.element, opts);
			} else {
				this.spin.stop();
			}
		},

		/**
		 * If more than one panel next to aside, generate the tabbar automaticly
		 */
		_inittabs: function() {
			var panels = this.dom.qall('this > .ts-panel', ts.ui.PanelSpirit);
			if (panels.length > 1) {
				if (panels.every(function(panel) {
					return !!panel.label;
				})) {
					this._setuptabs(panels, this);
				} else {
					console.warn(
						'(Multiple) Panels in Aside must have ' +
						'a label in order to create the TabBar'
					);
				}
			}
		},

		/**
		 * Multiple panels found, setup the tabbar to switch between them.
		 * @param {Array<ts.ui.PanelSpirit>} panels
		 * @param {ts.ui.SideBarSpirit} that
		 */
		_setuptabs: function(panels, that) {
			var tabbar = this._tabbarspirit();
			panels.forEach(function(panel, index) {
				tabbar.tabs().push({
					label: panel.label,
					selected: index === 0,
					$onselect: function() {
						that.dom.qall('this > .ts-panel', ts.ui.PanelSpirit).forEach(function(p) {
							if (p === panel) {
								p.show();
								p.$onselect();
								// TODO: scroll to zero?
							} else {
								p.hide();
							}
						});
						that._reflex();
					}
				});
			});
		},

		/**
		 * Remove the tabbar.
		 */
		_removetabbar: function() {
			var bar = this._tabbar;
			if (bar) {
				this._reflex(function() {
					bar.dom.remove();
					bar.tabs().removeObserver(this);
					this.css.remove('ts-has-panels');
					this._tabbar = null;
				});
			}
		},

		/**
		 * Added or remove tab for Panel at given index.
		 * TODO: Support a `selected` property in the {ts.ui.PanelSpirit}
		 * TODO: When all panels are done, somehow force `tabbar.script.run()` ...
		 * @param {ts.ui.PanelSpirit} panel
		 */
		_updatetab: function(panel, added) {
			var css = 'this > .ts-panel';
			var bar = this._tabbar;
			var dom = this.dom;
			var index = dom.qall(css, ts.ui.PanelSpirit).indexOf(panel);
			if (!bar) {
				return;
			}
			if (added) {
				if (index !== 0) {
					panel.hide();
				}
				bar.tabs().splice(index, 0, {
					label: panel.label,
					selected: index === 0,
					$onselect: function() {
						dom.qall(css, ts.ui.PanelSpirit).forEach(function(p) {
							if (p === panel) {
								p.show();
								p.$onselect();
								// TODO: scroll to zero?
							} else {
								p.hide();
							}
						});
					}
				});
			} else {
				bar.tabs().splice(index, 1).forEach(function(tab) {
					if (tab.selected) {
						var selectedindex = index ? index - 1 : index;
						bar.tabs()[selectedindex].select();
					}
					tab.dispose();
				});
				if (bar.tabs().length === 1) {
					this._removetabbar();
				}
			}
			bar.$hascontent(); // for the tabbar to render instantly
		},

		/**
		 * Manage background colors and dropshadows. The tick mechanism
		 * schedules the operation at the end of the execution stack so
		 * that it only runs *once* even if called multiple times over.
		 * @see {ts.ui.SideShowSpirit#ontick}
		 */
		_fixappearance: function fix() {
			var tick = 'ts-sideshow-theme';
			this.tick.add(tick).dispatch(tick);
		},

		/**
		 * If spirit was created via a model, return the model color.
		 * Otherwise return any bg-color classname found in the HTML
		 * and also *remove it* (it will soon be applied elsewhere)
		 * so that (in a future project) we can flip the Aside nicely.
		 * @param {string} color Fallback color!
		 * @returns {string}
		 */
		_extractcolor: function(color) {
			function fixweirdlooking(c) {
				return c.match(/ts-bg-lite|ts-bg-white/) ? 'ts-bg-blue' : c;
			}
			if (this._ismodelled() && this._model.color) {
				color = fixweirdlooking(this._model.color);
			} else {
				GuiObject.each(Colors, function(key, value) {
					if (this.css.contains(value)) {
						this.css.remove((color = value));
					}
				}, this);
			}
			return color;
		},

		/**
		 * Transform background color to members (unless it
		 * already has a background color classname given).
		 * @param {string} color
		 * @param {Array<string>} selectors
		 */
		_transfercolor: function(color, selectors) {
			var dom = this.dom;
			selectors.forEach(function(selector) {
				dom.qall(selector, ts.ui.Spirit).filter(function() {
					return true;
				}).forEach(function(spirit) {
					switch (selector) {
						case '.ts-header':
						case '.ts-tabbar':
							spirit.css.remove(BGCOLORS).add(color);
							if (spirit._ismodelled()) {
								spirit._model.color = color;
							}
							break;
						default:
							var classname = spirit.css.name();
							if (!classname.includes('ts-bg')) {
								spirit.css.add(color);
							}
							break;
					}
				});
			});
		},

		/**
		 * Apply color theme extras. The dropshadows are done with DIVs (instead
		 * of using CSS box-shadow) to keep them under control without using any
		 * kind of z-index, since this would mess up the general page layout.
		 * @param {gui.DOMPlugin} dom
		 */
		_themesupport: function(dom) {
			var shade = Parser.parseToNode('<div class="ts-shadow"></div>');
			var panel = dom.q('this > .ts-panel', ts.ui.PanelSpirit);
			var headr = dom.q('this > .ts-header', ts.ui.ToolBarSpirit);
			var footr = dom.q('this > .ts-footer', ts.ui.FooterSpirit);
			var tabbs = dom.q('this > .ts-tabbar', ts.ui.TabBarSpirit);
			var color = getcolor(panel) || 'ts-bg-white';
			dom.qall('.ts-shadow').forEach(function dontduplicate(shadow) {
				shadow.parentNode.removeChild(shadow);
			});
			if (tabbs && getcolor(tabbs) !== color) {
				tabbs.white();
			} else if ([tabbs, headr].every(function(thing) {
				return thing && getcolor(thing) === color;
			})) {
				panel.dom.before(shade.cloneNode());
				headr.css.add('ts-inset');
			} else if (headr && getcolor(headr) === color) {
				panel.dom.before(shade.cloneNode());
			}
			if (footr && getcolor(footr) === color) {
				footr.dom.before(shade.cloneNode());
			}
		},

		/**
		 * Execute callback configured via HTML attribute or via JS property.
		 * The 'this' keyword points to the element or the spirit respectively.
		 * TODO (jmo@): convert potential string to function sometimes sooner...
		 * @type {String|function}
		 * @returns {boolean}
		 */
		_execute: function(callback) {
			if ((callback = this[callback])) {
				switch (gui.Type.of(callback)) {
					case 'string':
						return new Function(callback).call(this);
					case 'function':
						return callback.call(this);
				}
			}
			return true;
		}

	}, { // Xstatic ..............................................................

		/**
		 * List of members that should inherit any assigned background color.
		 * @type {Array<string>}
		 */
		$bgmembers: ['.ts-header']

	});
}(
	gui.Combo.chained,
	gui.Client,
	gui.HTMLParser,
	gui.Object,
	ts.ui.BACKGROUND_COLORS,
	ts.ui.ACTION_PANEL_ATTACH,
	ts.ui.ACTION_PANEL_DETACH
));



/**
 * Spirit of the aside.
 * @extends {ts.ui.SideShowSpirit}
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} confirmed
 * @using {gui.Client} Client
 * @using {function} notontouch Setup to ignore focus stuff on touch device
 * @using {ts.ui.LayoutModel} LayoutModel
 */
ts.ui.AsideSpirit = (function using(chained, confirmed, Client, LayoutModel, notontouch) {
	// custom dom events (for public implementation)
	var domevent = {
		WILLOPEN: ts.ui.EVENT_ASIDE_WILL_OPEN,
		DIDOPEN: ts.ui.EVENT_ASIDE_DID_OPEN,
		WILLCLOSE: ts.ui.EVENT_ASIDE_WILL_CLOSE,
		DIDCLOSE: ts.ui.EVENT_ASIDE_DID_CLOSE
	};

	// actions and broadcasts (for behind-the-scenes implementation)
	var willopen = ts.ui.ACTION_ASIDE_WILL_OPEN,
		didopen = ts.ui.ACTION_ASIDE_DID_OPEN,
		willclose = ts.ui.ACTION_ASIDE_WILL_CLOSE,
		didclose = ts.ui.ACTION_ASIDE_DID_CLOSE,
		doclose = ts.ui.BROADCAST_GLOBAL_ASIDES_DO_CLOSE,
		synctomenu = ts.ui.BROADCAST_PANEL_SYNC_MENU;

	// classnames
	var classopening = ts.ui.CLASS_OPENING,
		classopen = ts.ui.CLASS_OPEN,
		classclosing = ts.ui.CLASS_CLOSING,
		classclosed = ts.ui.CLASS_CLOSED;

	// selector to detect Asides nested inside SideBars
	var SIDEBAR_ASIDE_SELECTOR = '.ts-sidebar .ts-aside';

	return ts.ui.SideShowSpirit.extend({

		/**
		 * Attempt to focus something when the thing opens?
		 * TODO: Consider how Drawers should act in static (non-mobile) layout...
		 * @type {boolean}
		 */
		autofocus: true,

		/**
		 * Configure classnames and optional model.
		 */
		onconfigure: function() {
			ts.ui.SideShowSpirit.prototype.onconfigure.call(this);
			if (this._ismodelled()) {
				this._model.addObserver(this);
				this.broadcast.add(synctomenu);
				this.autofocus = this._model.autofocus;
				this.script.load(ts.ui.AsideSpirit.edbml);
				this.script.input(this._model);
				// this should happen on EDBML render, but it doesn't :/
				this.dom.q('.ts-panel', ts.ui.PanelSpirit).exorcise();
			}
			this._position(100);
			this.dom.hide();
		},

		/**
		 * Check for the footer only once, knowing
		 * that Angular might well insert it later.
		 */
		onready: function() {
			ts.ui.SideShowSpirit.prototype.onready.call(this);
			if (this.dom.q('this > .ts-footer')) {
				this.css.add('ts-hasfooter');
			}
		},

		/**
		 * Reflex Aside members when we open the Aside.
		 * TODO: If and when we deprecate the {gui.VisibilityPlugin}
		 * we should probably move `this.reflex()` to method `_open`.
		 */
		onvisible: function() {
			ts.ui.SideShowSpirit.prototype.onvisible.call(this);
			this.reflex();
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.SideShowSpirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case ts.ui.ACTION_CLOSE:
					if (this.isOpen) {
						this.open(false);
					}
					a.consume();
					break;
			}
		},

		/**
		 * Handle broadcast.
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			ts.ui.SideShowSpirit.prototype.onbroadcast.call(this, b);
			switch (b.type) {
				case synctomenu:
					this._maybesynctomenu(
						b.data.menuid,
						b.data.offset
					);
					break;
				case doclose:
					if (!this._isSideBarAside()) {
						this.close();
					}
					break;
			}
		},

		/**
		 * Some MenuModel has requested a panel scroll operation.
		 * If our AsideModel contains that menu, we can do that.
		 * @param {ts.ui.Collection} items
		 * @param {string} instanceid
		 */
		_maybesynctomenu: function(menuid, offset) {
			if (this._model.items.some(function(item) {
				return item.$instanceid === menuid;
			})) {
				this.dom.q('.ts-panel').scrollTop = offset;
			}
		},

		/**
		 * Handle key.
		 * TODO (jmo@): move elsewhere and broadcast
		 * doclose
		 */
		onkey: function(k) {
			ts.ui.SideShowSpirit.prototype.onkey.call(this, k);
			/*
			 * TODO(jmo@): Consider whether or not this is
			 * applicable to asides nested in drawers...
			 */
			if (k.down && k.type === 'Esc') {
				this.open(false);
			}
		},

		/**
		 * Handle (observed model) changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.SideShowSpirit.prototype.onchange.call(this, changes);
			if (!this.$destructed) {
				var layout = LayoutModel.output.get();
				var asides = layout.asides;
				var id = this.$instanceid;
				changes.forEach(function(c) {
					switch (c.object) {
						case asides:
							var klass = ts.ui.CLASS_SECONDARY;
							var stacked = this.css.contains(klass);
							this._index = asides.indexOf(id);
							var x = asides.length - this._index - 1;
							if (x > 0) {
								if (!stacked) {
									this._stack(true);
								}
							} else {
								if (stacked) {
									this._stack(false);
								}
							}
							this.css.shift(x > 0, klass);
							break;
						case this._model:
							this._onmodelchange(c.name, c.newValue);
							break;
					}
				}, this);
			}
		},

		/**
		 * Confirm closed state on detach.
		 */
		ondetach: function() {
			ts.ui.SideShowSpirit.prototype.ondetach.call(this);
			this._confirmstate(this._isreallyopen);
			if (this._ismodelled()) {
				this._model.removeObserver(this);
			}
		},

		/**
		 * Confirm closed state on destruct.
		 */
		ondestruct: function() {
			ts.ui.SideShowSpirit.prototype.ondestruct.call(this);
			this._confirmstate(this._isreallyopen);
			if (this._ismodelled()) { // TODO: automate this step
				this._model.removeObserver(this);
			}
		},

		/**
		 * Focus something.
		 */
		focus: notontouch(function() {
			this._focusbest();
		}),

		// Private .................................................................

		/**
		 * Optional model.
		 * @type {ts.ui.AsideModel}
		 */
		_model: null,

		/**
		 * Z stack index.
		 * @type {number}
		 */
		_index: -1,

		/**
		 * Z stack offset.
		 * @type {number}
		 */
		_offset: 0,

		/**
		 * Offset width.
		 * @type {number}
		 */
		_width: 0,

		/**
		 * A boolean that remains flipped until the
		 * Aside is fully closed (and done animating).
		 * @type {boolean}
		 */
		_isreallyopen: false,

		/**
		 * Postponing 'onopen' until some event has occured? This setup
		 * relates to a performance optimization of the SELECT menus.
		 * @type {boolean}
		 */
		_suspendopen: false,

		/**
		 * This is just a hack for now to delay initialization of the DOM until
		 * after angular is done with the aside. This depends on being called
		 * inside of a user event handler. Because implicitly, angular is done
		 * with the element at that point in time. This is very fragile.
		 * TODO: This should be replaced with a proper Angular integration, that
		 * allows us to initialize elements after Angular has completed compilation
		 * and linking all other directives. Note that this requires us to figure
		 * out *when exactly that happens* and it is not clear, if that's possible.
		 * @type {boolean}
		 */
		_hackInitialized: false,

		/**
		 * Is this Aside within a SideBar?
		 * @returns {boolean}
		 */
		_isSideBarAside: function() {
			return !!this.css.matches(SIDEBAR_ASIDE_SELECTOR);
		},

		/**
		 * All attempts to animate the Aside with ordinary CSS transitions
		 * would result in fatal rendering glitches that only occurs in a
		 * production environment, of course. Using the brute force method.
		 * UPDATE: This was caused by Track.js versus `handleEvent` so we
		 * can go ahead and use CSS transitions now :)
		 * @param {boolean} open
		 * @param @optional {boolean} callback
		 * @returns {gui.Then}
		 */
		_slideopen: function(open, callback) {
			var then = new gui.Then();
			var tick = this.tick;
			var end = ts.ui.TRANSITION_FAST;
			var deg, off;
			function getoffset(now) {
				deg = now / (end / 90);
				deg = deg * Math.PI / 180;
				off = open ? Math.sin(deg) : Math.cos(deg);
				return off * 100;
			}
			tick.time(function() {
				var time = 0;
				tick.nextFrame(function paint(stamp) {
					if (!this.$destructed) {
						if (!time) {
							time = stamp;
							tick.nextFrame(paint);
						} else {
							var now = stamp - time;
							var pct = getoffset(now);
							if (now < end) {
								this._position(100 - pct);
								tick.nextFrame(paint);
							} else {
								this._position(open ? 0 : 100);
								then.now();
							}
						}
					}
				});
			}, ts.ui.TRANSITION_DELAY);
			return then;
		},

		/**
		 * Stack the Aside.
		 * @param {boolean} stack
		 */
		_stack: function(stack) {
			this._slideopen(!stack);
		},

		/**
		 * Update position.
		 * @param {number} pct
		 */
		_position: function(pct) {
			if (Client.isExplorer) {
				this._width = (this._width || this.box.width);
				this.css.set('right', ((pct / -100) * this._width) + 'px');
			} else {
				this.css.set('-beta-transform', 'translate3d(' + pct + '%,0,0)');
			}
		},

		/**
		 * Aside header (Toolbar) is now fixed height, so we can
		 * harcode the panel height in CSS and save some layout
		 * calculations *except* when there's a Footer present.
		 * @overwrites {ts.ui.SideShowSpirit#_reflex}
		 * @param @optional {function} action
		 * @returns {object}
		 */
		_reflex: function(action) {
			var thing;
			if (this.css.contains('ts-hasfooter')) {
				thing = ts.ui.SideShowSpirit.prototype._reflex.call(this, action);
			} else if (action) {
				thing = action.call(this);
			}
			return thing;
		},

		/**
		 * Fix an occasional collision with the Angular compiler.
		 */
		_delayedAngularInitialization: function() {
			if (!this._hackInitialized) {
				this._hackInitialized = true;
				this._closebutton();
			}
		},

		/**
		 * Open.
		 * TODO: Validate that we are not opening inside .ts-main
		 * @param {boolean} animated (not supported just yet)
		 */
		_open: function(animated) {
			if (ts.ui.SideShowSpirit.prototype._open.call(this, animated)) {
				ts.ui.SideShowSpirit.prototype._open.call(this, animated);
				this._delayedAngularInitialization();
				this._trapattention();
				this._willopen();
				this._slideopen(true).then(function done() {
					this._ontransitionend();
				}.bind(this));
			}
		},

		/**
		 * Close.
		 * @param {boolean} animated (not supported)
		 */
		_close: function(animated) {
			if (ts.ui.SideShowSpirit.prototype._close.call(this, animated)) {
				this._willclose();
				this._slideopen(false).then(function done() {
					this._ontransitionend();
				}.bind(this));
			}
		},

		/**
		 * The {ts.ui.AsideModel} changed something.
		 * @param {string} name
		 * @param {object} value
		 */
		_onmodelchange: function(name, value) {
			switch (name) {
				case 'gofocused':
					this.focus();
					break;
				case 'suspendopen':
					if (this._suspendopen && value === false) {
						this._suspendopen = false;
						this._didopen();
					}
					break;
			}
		},

		/**
		 * CSS transition ended.
		 */
		_ontransitionend: function() {
			if (this.isOpen) {
				this.css.remove(classopening).add(classopen);
				this._didopen();
			} else {
				this.css.remove(classclosing).add(classclosed);
				this._didclose();
			}
		},

		/**
		 * Setup to cycle TAB navigation inside the panel.
		 */
		_trapattention: function() {
			if (!this.attention.trapping) {
				this.attention.trap(
					this.dom.q('.ts-panel')
				);
			}
		},

		/**
		 * About to open.
		 */
		_willopen: function() {
			var index = 0;
			this._confirmposition();
			this._isreallyopen = true;
			this.dom.show();
			this.guistatus.busy('opening aside');
			this._updateworld(willopen);
			this._register(true);
			if (this._isSideBarAside()) {
				this._themesupport(this.dom);
			}
			if ((index = this._zindex())) {
				this.css.zIndex = index;
			}
			if (this._ismodelled()) {
				this._model.status = 'onopen';
			}
		},

		/**
		 * Fully opened.
		 */
		_didopen: function() {
			/*
			 * The model (if exists) is able to halt the execution of 'onopen'
			 * because it may need to run a performance optimization hack for
			 * SELECT menus: Only the visible items are shown while sliding
			 * the aside, the rest is rendered at this exact point in time.
			 * Integration tests should then wait for 'onopened' to finish before
			 * they attempt to select items in the aside (since they don't exist).
			 */
			if (this._ismodelled()) {
				var model = this._model;
				if (model.status === 'onopen') {
					if (model.suspendopen) {
						model.status = 'onbeforeopened';
						this._suspendopen = true;
						return; // exit here
					}
				}
			}

			/*
			 * ... otherwise go ahead with the 'onopen' procedure, noting that
			 * integration tests can safely work with the aside from now on.
			 */
			this._updateworld(didopen);
			this.action.add(ts.ui.ACTION_CLOSE);
			this.broadcast.addGlobal(doclose);
			this.key.addGlobal('Esc');
			this.css.add(ts.ui.CLASS_OPEN);
			this.guistatus.done('opening aside');
			this._execute('onopened');
			this.event.dispatch(domevent.DIDOPEN, {
				bubbles: true
			});

			/**
			 * It would be nice to do this before the Aside opens,
			 * but we can assume that any MVC template has rendered
			 * (actually we can't assume that even when fully open).
			 * Also, assigning focus *while* animating will glitch
			 * the browser, or at least it will mess with Firefox.
			 */
			if (this.autofocus) {
				this.focus();
			}

			/**
			 * Exucute some action whenever new Asides open.
			 * This relates to styling of secondary Asides.
			 */
			var layout = LayoutModel.output.get();
			layout.asides.addObserver(this);

			/**
			 * Finally update the model.
			 */
			if (this._ismodelled()) {
				this._model.status = 'onopened';
			}
		},

		/**
		 * About to close.
		 */
		_willclose: function() {
			this.guistatus.busy('closing aside');
			this._updateworld(willclose);
			this.action.remove(ts.ui.ACTION_CLOSE);
			this.broadcast.removeGlobal(doclose);
			this.key.removeGlobal('Esc');
			this._register(false);
			if (this._ismodelled()) {
				this._model.status = 'onclose';
			}
		},

		/**
		 * Fully closed.
		 */
		_didclose: function() {
			var panel = this.dom.q('.ts-panel');
			this._isreallyopen = false;
			this._offset = 0;
			this.dom.hide();
			this._updateworld(didclose);
			this.guistatus.done('closing aside');
			this.att.del('data-ts-offset');
			this.attention.exit(panel);
			this._execute('onclosed');
			this.css.remove(ts.ui.CLASS_SECONDARY);
			this.event.dispatch(domevent.DIDCLOSE, {
				bubbles: true
			});
			if (this._ismodelled()) {
				this._model.status = 'onclosed';
			}
		},

		/**
		 * Register opened status in global model.
		 * @param {boolean} open
		 * @returns {ts.ui.AsideSpirit}
		 */
		_register: chained(function(open) {
			var layout = LayoutModel.output.get();
			var asides = layout.asides;
			var id = this.$instanceid;
			if (open) {
				asides.push(id);
			} else {
				gui.Array.remove(asides, asides.indexOf(id));
				asides.removeObserver(this);
			}
			this._index = asides.indexOf(id);
		}),

		/**
		 * Dispatch local actions to control that semi-transparent cover.
		 * @see {ts.ui.DocumentAsidePlugin}
		 * @see {ts.ui.DrawerSpirit}
		 * @param {string} type
		 */
		_updateworld: function(type) {
			this.action.dispatch(type);
		},

		/**
		 * Focus the best possible focusable thing.
		 * TODO: This obviously needs an overhaul.
		 */
		_focusbest: notontouch(function() {
			var elm, best = ['[autofocus]', '.ts-checked button'];
			if (!best.some(function(selector) {
				if ((elm = this.dom.q(selector))) {
					elm.focus();
				}
				return !!elm;
			}, this)) {
				var panel = this.dom.q('.ts-panel');
				if (!this.attention.enter(panel)) {
					panel.tabIndex = 0;
					panel.focus();
				}
			}
		}),

		/**
		 * Compute the z-index.
		 * TODO(jmo@): Read base index from CSS.
		 * @returns {number}
		 */
		_zindex: function() {
			return this._index + (this._isSideBarAside() ? 0 : ts.ui.ZINDEX_ASIDE);
		},

		/**
		 * Confirm position.
		 * @overrides {ts.ui.SideShowSpirit#_confirmposition}
		 */
		_confirmposition: function() {
			if (this._isSideBarAside()) {
				var panel = this.dom.parent(ts.ui.PanelSpirit);
				if (panel && this.dom.containedBy(panel)) {
					throw new Error(
						'In the SideBar, Aside must be positioned outside the ts-panel',
						this.element
					);
				}
			} else {
				ts.ui.SideShowSpirit.prototype._confirmposition.call(this);
			}
		},

		/**
		 * Throw and/or error if someone nukes
		 * the Aside without closing it first.
		 * @param {boolean} stillopen
		 */
		_confirmstate: function(stillopen) {
			if (stillopen) {
				this._updateworld(willclose);
				this._updateworld(didclose); // nuke the cover
				this._confirmstate = function norepeat() {};
				var cry = this + ' should not be removed from the document while open.';
				if (gui.debug) {
					throw new Error(cry); // so that we can write a test for it :)
				} else {
					console.error(cry);
				}
			}
		}

	}, { // Static ...............................................................

		/**
		 * Stacking offset in percent of the width of the aside.
		 * @type {number}
		 */
		OFFSET_AMOUNT: 3,

		/**
		 * Importantly create the aside with a `.ts-panel` child element.
		 * @param @optional {ts.ui.AsideModel} opt_model
		 * @return {ts.ui.AsideSpirit}
		 */
		summon: confirmed('(object)')(function(opt_model) {
			var html = ts.ui.aside.edbml(opt_model);
			var elem = gui.HTMLParser.parse(html);
			var spirit = this.possess(elem);
			return spirit;
		})

	});
}(
	gui.Combo.chained,
	gui.Arguments.confirmed,
	gui.Client,
	ts.ui.LayoutModel,
	function notontouch(base) {
		return function() {
			if (!gui.Client.isTouchDevice) {
				base.apply(this, arguments);
			}
		};
	}
));



/**
 * Spirit of the SideBar (formerly known as the "Drawer").
 * @see @deprecated {ts.ui.DrawerSpirit}
 * @extends {ts.ui.SideShowSpirit}
 * @using {gui.Combo.chained} chained
 * @using {gui.Type} Type
 * @using {gui.Client} Client
 * @using {gui.Object} GuiObject
 * @using {ts.ui.BACKGROUND_COLORS} Colors
 */
ts.ui.SideBarSpirit = (function using(chained, Type, Client, GuiObject, Colors) {
	// consuming all actions from nested asides
	var willopen = ts.ui.ACTION_ASIDE_WILL_OPEN,
		didopen = ts.ui.ACTION_ASIDE_DID_OPEN,
		willclose = ts.ui.ACTION_ASIDE_WILL_CLOSE,
		didclose = ts.ui.ACTION_ASIDE_DID_CLOSE;

	return ts.ui.SideShowSpirit.extend({

		/**
		 * Open by default.
		 * @type {boolean}
		 */
		isOpen: true,

		/**
		 * Automatically close the SideBar in mobile breakpoint?
		 * Note that the SideBar must then be *manually* opened.
		 * @type {boolean}
		 */
		autoclose: {
			getter: function() {
				return this._autoclose;
			},
			setter: function(autoclose) {
				if (Type.isBoolean(Type.cast(autoclose))) { // no weird moustache syntax
					this.css.shift(autoclose, 'ts-autoclose');
					this._autoclose = !!autoclose;
					if (this.life.ready) { // changed post init
						if (this._autoclose) {
							if (ts.ui.isMobilePoint()) {
								this._breakpoint();
							}
						} else {
							this._closebutton(false);
							this.isOpen = true;
							this.reflex();
						}
					}
				}
			}
		},

		/**
		 * Setup to consume actions from nested Asides.
		 */
		onconfigure: function() {
			ts.ui.SideShowSpirit.prototype.onconfigure.call(this);
			this.action.add([
				willopen,
				didopen,
				willclose,
				didclose
			]);
		},

		/**
		 * Add assistant classnames and fix the layout.
		 */
		onattach: function() {
			ts.ui.SideShowSpirit.prototype.onattach.call(this);
			this.action.dispatch('ts-action-attach');
			this._layoutmain(true);
			if (ts.ui.isMobilePoint()) {
				this._breakpoint();
			} else {
				this._reflex();
			}
		},

		/**
		 * Setup the stuff.
		 */
		onenter: function() {
			ts.ui.SideShowSpirit.prototype.onenter.call(this);
			this._breakpointwatch();
			this.css.shift(this._autoclose, 'ts-autoclose');
		},

		/**
		 * Remove assistant classnames.
		 */
		ondetach: function() {
			ts.ui.SideShowSpirit.prototype.ondetach.call(this);
			this._layoutmain(false);
		},

		/**
		 * Give'm a second to move the SideBar into it's designated
		 * position (immediately before or after the '.ts-main' element)
		 * if for some reason the portal server didn't place it there.
		 */
		onready: function() {
			ts.ui.SideShowSpirit.prototype.onready.call(this);
			this.input.connect(ts.ui.TopBarModel);
			this.tick.time(function() {
				this._confirmposition();
			}, 1000);
		},

		/**
		 * Handle input. Watching that TopBar.
		 * @param {gui.Input} input
		 */
		oninput: function(i) {
			ts.ui.SideShowSpirit.prototype.oninput.call(this, i);
			if (i.type === ts.ui.TopBarModel) {
				i.data.addObserver(this);
			}
		},

		/**
		 * Handle changes. Reflex the layout when TopBar toggles
		 * and hope this fixes the height measurement in Safari.
		 * UPDATE: It worked - now do this with a simple broadcast!!!!!!!!!!!!!!!!!!
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.SideShowSpirit.prototype.onchange.call(this, changes);
			changes.forEach(function(change) {
				if (ts.ui.TopBarModel.is(change.object)) {
					if (change.name === 'hascontent') {
						this._reflex();
					}
				}
			}, this);
		},

		/**
		 * Consume all nested aside actions
		 * so as not to trigger the cover.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.SideShowSpirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case willopen:
					this._fitaside(a.target, this.dom.qall(
						'.ts-footer', ts.ui.FooterSpirit
					));
					a.consume();
					break;
				case didopen:
				case willclose:
				case didclose:
					a.consume();
					break;
			}
		},

		/**
		 * Cleanup (using a temporary API that should be refactored).
		 */
		ondestruct: function() {
			ts.ui.SideShowSpirit.prototype.ondestruct.call(this);
			ts.ui.removeBreakPointListener(this);
		},

		// Private .................................................................

		/**
		 * Automatically close the SideBar in mobile breakpoint?
		 * @type {boolean}
		 */
		_autoclose: true,

		/**
		 * This classname has to do with flipping, it's a future project.
		 */
		_fixappearance: function() {
			ts.ui.SideShowSpirit.prototype._fixappearance.call(this);
			var has3D = gui.Client.has3D;
			this.css.shift(has3D, 'ts-3d').shift(!has3D, 'ts-2d');
		},

		/**
		 * Add/remove classnames on the HTML element so we can style the MAIN.
		 * TODO: This should probably all be maintained somewhat more modelled...
		 * @param {boolean} attaching This is `false' when SideBar gets removed.
		 */
		_layoutmain: function(attaching) {
			var layout = this.guilayout;
			if (layout.outsideMain()) {
				var local1 = 'ts-sidebar-first',
					local2 = 'ts-sidebar-last',
					global2 = 'ts-has-sidebar-first',
					global3 = 'ts-has-sidebar-last';
				if (layout.beforeMain()) {
					this.css.shift(attaching, local1);
					layout.shiftGlobal(attaching, global2);
				} else {
					this.css.shift(attaching, local2);
					layout.shiftGlobal(attaching, global3);
				}
			}
		},

		/**
		 * Watch for breakpoint changes (using some
		 * temporary API that should be refactored).
		 */
		_breakpointwatch: function() {
			ts.ui.addBreakPointListener(function() {
				this._breakpoint();
			}.bind(this));
		},

		/**
		 * Collapse the SideBar on mobile breakpoint.
		 * Setup to avoid CSS transition on collapse.
		 * @param {boolean} go
		 */
		_breakpoint: function() {
			var go = ts.ui.isMobilePoint();
			if (this._autoclose) {
				this._closebutton(go);
				if (go) {
					if (this.isOpen) {
						this.close();
						this.isOpen = false;
					}
				} else {
					if (!this.isOpen) {
						this.isOpen = true;
						this.guilayout.flexGlobal();
					}
				}
			}
		},

		/**
		 * Show the SideBar (now that it's hidden in mobile view).
		 */
		_open: function() {
			if (ts.ui.SideShowSpirit.prototype._open.call(this)) {
				this.css.add('ts-will-open');
				this._reflex();
				this.tick.time(function slide() {
					this.css.add(ts.ui.CLASS_OPEN);
				});
			}
		},

		/**
		 * Don't show the SideBar.
		 */
		_close: function() {
			if (ts.ui.SideShowSpirit.prototype._close.call(this)) {
				this.css.remove(ts.ui.CLASS_OPEN);
				this.tick.time(function undisplay() {
					this.css.remove('ts-will-open');
				}, ts.ui.TRANSITION_FAST);
			}
		},

		/**
		 * Fit nested aside inside the panel (footer scenario).
		 * @param {ts.ui.AsideSpirit} aside
		 * @param {Array<ts.ui.FooterSpirit>} footers List of bonus footers
		 */
		_fitaside: function(aside, footers) {
			if (footers.length) {
				aside.css.bottom = footers.reduce(function(totalheight, footer) {
					return totalheight + footer.box.height;
				}, 0);
			}
		}

	}, { // Xstatic ..............................................................

		/**
		 * List of members that should inherit any assigned background color.
		 * In the SideBar, all members get the same color (unless explicitly
		 * given a bg-color classname in the HTML).
		 * @type {Array<string>}
		 */
		$bgmembers: ['.ts-header', '.ts-tabbar', '.ts-panel', '.ts-footer']

	});
}(
	gui.Combo.chained,
	gui.Type,
	gui.Client,
	gui.Object,
	ts.ui.BACKGROUND_COLORS
));



/**
 * Something that scrolls with a scrollbar.
 * @using {string} ACTION_ATTACH
 * @using {string} ACTION_DETACH
 * @using {string} ACTION_SHOW
 * @using {string} ACTION_HIDE
 */
ts.ui.PanelSpirit = (function using(ACTION_ATTACH, ACTION_DETACH, ACTION_SHOW, ACTION_HIDE, ACTION_CLASS) {
	return ts.ui.Spirit.extend({

		/**
		 * For when the panel is used to generate tabs.
		 * @type {string}
		 */
		label: null,

		/**
		 * For when the panel is used to generate tabs.
		 * @type {boolean}
		 */
		selected: false,

		/**
		 * For when the panel is used to generate tabs.
		 * @type {string} label
		 */
		icon: null,

		/**
		 * Panel is visible? (please use methods `hide` and `show`).
		 * @type {boolean} visible
		 */
		visible: true,

		/**
		 * Open for implementation.
		 * @type {function}
		 */
		onselect: null,

		/**
		 * Setup.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.action.add([
				ACTION_ATTACH,
				ACTION_SHOW,
				ACTION_HIDE,
				ACTION_CLASS
			]);
		},

		/**
		 * Attach.
		 */
		onattach: function() {
			ts.ui.Spirit.prototype.onattach.call(this);
			this.action.dispatch(ACTION_ATTACH, this._isroot());
		},

		/**
		 * Detach.
		 */
		ondetach: function() {
			ts.ui.Spirit.prototype.ondetach.call(this);
			this.action.dispatch(ACTION_DETACH, this._isroot());
		},

		/**
		 * Consume nested panel actions. When a request for root CSS
		 * update is found, we'll stamp the action with a pointer to
		 * this panel (so that root CSS always matches selected panel).
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			switch (a.type) {
				case ACTION_ATTACH:
				case ACTION_SHOW:
				case ACTION_HIDE:
					a.consume();
					break;
				case ACTION_CLASS:
					if (this._isroot()) {
						a.data.relatedPanel = this;
					}
					break;
				case ts.ui.ACTION_STATUSBAR_LEVEL:
					if (a.target.guilayout.outsideMain()) { // TODO: CSS FOR THIS!
						this.guilayout.gotolevel(a.data);
					}
					break;
			}
		},

		/*
		 * Show the panel.
		 */
		show: function() {
			this.visible = true;
			this.dom.show();
			this.reflex();
			this.action.dispatch(ACTION_SHOW, this._isroot());
		},

		/*
		 * Hide the panel.
		 */
		hide: function() {
			this.dom.hide();
			this.visible = false;
			this.action.dispatch(ACTION_HIDE, this._isroot());
		},

		/**
		 * How high should the Panel be in order to *not* show the scrollbar?
		 * @returns {number}
		 */
		naturalHeight: function() {
			return this.element.scrollHeight;
		},

		/**
		 * Panel shows a scrollbar (assumeing `overflow` is `scroll` or `auto`)?
		 * @returns {boolean}
		 */
		hasOverflow: function() {
			return this.naturalHeight() > this.element.offsetHeight;
		},

		// Privileged ..............................................................

		/**
		 *
		 */
		$onselect: function() {
			switch (gui.Type.of(this.onselect)) {
				case 'function':
					this.onselect();
					break;
				case 'string':
					new Function(this.onselect).call(this);
					break;
			}
		},

		// Private .................................................................

		/**
		 * Is root level panel?
		 * @returns {boolean}
		 */
		_isroot: function() {
			return this.dom.parent() === document.body;
		}

	});
}(
	ts.ui.ACTION_PANEL_ATTACH,
	ts.ui.ACTION_PANEL_DETACH,
	ts.ui.ACTION_PANEL_SHOW,
	ts.ui.ACTION_PANEL_HIDE,
	ts.ui.ACTION_ROOT_CLASSNAMES
));



/**
 * Spirit of the footer.
 * @extends {ts.ui.Spirit}
 */
ts.ui.FooterSpirit = ts.ui.Spirit.extend();



/**
 * Spirit of the button AND link.
 *
 * TODO: ALWAYS APPLY `ts-active` ON TOUCH DEVICE!
 *
 * @extends {ts.ui.Spirit}
 * @using {gui.Combo#chained} chained
 * @using {gui.Client} Client
 * @using {gui.Type} Type
 * @using {gui.CSSPlugin} CSSPlugin
 * @using {boolean} ie9
 */
ts.ui.ButtonSpirit = (function using(chained, Client, Type, CSSPlugin, ie9) {
	// classnames reserved for button color scheme
	var classnames = [
		ts.ui.CLASS_PRIMARY,
		ts.ui.CLASS_SECONDARY,
		ts.ui.CLASS_TERTIARY,
		ts.ui.CLASS_DANGER
	];

	// some other classnames
	var CLASS_READY = ts.ui.CLASS_READY;
	var CLASS_LOADING = ts.ui.CLASS_IS_LOADING;
	var CLASS_LOADING_MESSAGE = 'ts-loading-message';

	return ts.ui.Spirit.extend({

		/**
		 * Action type. This may be set in the markup:
		 * <button data-ts.type="myactiontype"></button>
		 * If not set, we fallback to default action.
		 * @type {String}
		 */
		type: null,

		/**
		 * Action data. This may be set in the markup:
		 * <button data-ts.data="myactiondata"></button>
		 * If not set, we fallback to default data.
		 * @type {objectg}
		 */
		data: null,

		/**
		 * Mark as busy or done, use `false` or empty string when done.
		 * (API looks like this so we can control it via HTML attribute)
		 * TODO(jmo@): Perhaps something more fancy for IE9, but for now
		 * we'll just call it "progressive enhancement"...
		 * @param @optional {string|boolean} busy
		 * @returns {ts.ui.ButtonSpirit}
		 */
		busy: chained(function(busy) {
			busy = arguments.length ? busy : true;
			var css = this.css;
			if (Type.isString(busy) && busy.trim().startsWith('{')) {
				return; // about weird Moustache syntax (Angular scenario)
			}
			if (ie9) {
				this.element.disabled = !!busy;
			} else {
				if (busy) {
					this._busymessage(busy);
					css.remove(CLASS_READY).add(CLASS_LOADING);
				} else if (css.contains(CLASS_LOADING)) {
					css.remove(CLASS_LOADING);
					this._nomorebusy(function bypasstransitions() {
						css.shift(!css.contains(CLASS_LOADING), CLASS_READY);
					});
				}
			}
		}),

		/**
		 * Mark as done.
		 * @returns {ts.ui.ButtonSpirit}
		 */
		done: chained(function() {
			this.busy(false);
		}),

		/**
		 * By setting the `href` property with JavaScript
		 * instead of HTML, Neal says we are more secure.
		 * See also https://dev.to/ben/the-targetblank-vulnerability-by-example
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.att.add('tabindex');
			this.event.add('click dragstart');
			if (!Client.isTouchDevice) {
				this.event.add('mousedown focus blur');
			}
			if (this.type === ts.ui.ACTION_SAFE_LINK && this.data) {
				if (/^http(s?):\/\//.test(this.data)) {
					this.element.target = '_blank';
					this.element.rel = 'noopener';
					this.element.href = this.data;
				}
			}
		},

		/**
		 * Setup on enter.
		 */
		onenter: function() {
			ts.ui.Spirit.prototype.onenter.call(this);
			var elm = this.element;
			this._keyboardclass();
			this._defaultclass(this.element.parentNode.parentNode);
			this._defaulttype(elm.localName, this.att.get('type'), this.att.get('href'));
		},

		/**
		 * Add the classname to transition colors *after* a very short break
		 * so that the colors don't transition strangely on initial page load.
		 * There should probably be (or there is?) a CSS strategy for this.
		 */
		onasync: function() {
			ts.ui.Spirit.prototype.onasync.call(this);
			this.css.add(CLASS_READY);
		},

		/**
		 * Handle attribute.
		 * @param {gui.Att} a
		 */
		onatt: function(a) {
			ts.ui.Spirit.prototype.onatt.call(this, a);
			if (a.name === 'tabindex') {
				this._keyboardclass(a.value);
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			var busy = this.css.contains(CLASS_LOADING);
			switch (e.type) {
				case 'mousedown':
					if (!busy) {
						this._depressing = true;
						this.tick.time(function() {
							this._depressing = false;
						});
					}
					break;
				case 'focus':
					this._focusclass(true, !this._depressing);
					break;
				case 'blur':
					this._focusclass(false);
					break;
				case 'click':
					if (!busy) {
						this._depressing = false;
						this._dispatchaction();
						this._focusclass(true, true);
					}
					break;
				case 'dragstart':
					e.preventDefault();
					break;
			}
		},

		/**
		 * Set icon.
		 * TODO (jmo@): Use "add" but remove existing
		 * icon-class: gui.CSSPlugin.add ( i, classname);
		 * @param {String} classname
		 * @return {ts.ui.ButtonSpirit}
		 */
		icon: chained(function(classname) {
			var i = this.dom.q('i') ||
					this.dom.append(document.createElement('i'));
			i.className = classname;
		}),

		/**
		 * Set ot get text.
		 * @param @optional {string} classname
		 * @return {string|ts.ui.ButtonSpirit}
		 */
		text: chained(function(text) {
			var span = this.dom.q('span');
			if (arguments.length) {
				span = span || this.dom.append(document.createElement('span'));
				span.textContent = text;
			} else {
				return span ? span.textContent : null;
			}
		}),

		/**
		 * Disable the button.
		 * @returns {ts.ui.ButtonSpirit}
		 */
		disable: chained(function() {
			this.element.disabled = true;
		}),

		/**
		 * Enable the button.
		 * @returns {ts.ui.ButtonSpirit}
		 */
		enable: chained(function() {
			this.element.disabled = false;
		}),

		// Private .................................................................

		/**
		 * Used to track button handling in order to support the following:
		 * First time the button is clicked, we flash the :focus appearance.
		 * Next time the button is clicked, we flash the :active appearance.
		 * (it flashed a bit too much when we applied both at the same time).
		 * @type {boolean}
		 */
		_depressing: false,

		/**
		 * When showing a temporary busy-message,
		 * snapshot the original label text here.
		 * @type {string}
		 */
		_donelabel: null,

		/**
		 * Default button type to "button" so that
		 * it won't accidentally submit forms.
		 * @param {string} name
		 * @param {string} type
		 */
		_defaulttype: function(name, type, href) {
			if (name === 'button' && !type) {
				this.element.type = 'button';
			} else if (name === 'a' && !href) {
				this.element.href = ts.ui.ButtonSpirit.HREF_DEFAULT;
			}
		},

		/**
		 * Default to "ts-tertiary" buttons inside Buttons (menu). Doing this
		 * in CSS would make the rules hard to read (and overwrite in apps).
		 * @param {Element} ancestor
		 */
		_defaultclass: function(ancestor) {
			if (ancestor && CSSPlugin.contains(ancestor, 'ts-buttons')) {
				if (!classnames.some(function(name) {
					return this.css.contains(name);
				}, this)) {
					this.css.add(ts.ui.CLASS_TERTIARY);
				}
			}
		},

		/**
		 * Buttons with a negative tabindex should not get focus styling
		 * and we enforce this by switching *direct* to the active styling.
		 * We could in theory do this in CSS using a `:not([tabindex=-1]`
		 * qualifier, but that would perhaps not look quite right. Note
		 * that touch devices will go directly to the active styling and
		 * so will *desktop Safari* because keyboard navigation via TAB
		 * is now disabled by default in Safari, probably this was done
		 * by the same loser who removed the scrollbars.
		 * @param {number} i This buttons tabindex
		 */
		_keyboardclass: function() {
			var ok = ts.ui.ButtonSpirit.hasfocusstyling && this._isfocusable();
			this.css.shift(!ok, 'ts-active').shift(!ok, 'ts-nofocus');
		},

		/**
		 * Can be focused with the keyboard? Note that buttons in the
		 * TopBar cannot be used with keyboard until we can find the
		 * proper time to open that particular can of worms.
		 * @returns {boolean}
		 */
		_isfocusable: function() {
			return this.element.tabIndex >= 0;
		},

		/**
		 * Spirit attached to a LINK that leads to somewhere?
		 * TODO (jmo@): Mount in gui.URL and test for outbound href.
		 * @return {boolean}
		 */
		_isnavigatable: function() {
			var elm = this.element, href = elm.href;
			return href &&
				!href.startsWith('javascript:') &&
				!elm.download;
		},

		/**
		 * When first clicked, the button will get the focus-styling. When
		 * clicked again, we'll deploy the active-styling. Too much stuff
		 * seemed to happen when we applied both styles at the same time.
		 * @param {boolean} is Focused? Otherwise blurred.
		 * @param @optional {boolean} keyboard Is most likely focused via keyboard?
		 */
		_focusclass: function(is, keyboard) {
			var css = 'ts-active';
			if (this._isfocusable()) {
				if (is) {
					if (keyboard) {
						this.css.add(css);
					}
				} else {
					this.css.remove(css);
				}
			}
		},

		/**
		 * Dispatch configured or default action.
		 */
		_dispatchaction: function() {
			this.action.dispatch(this.type || ts.ui.ACTION_CLICK, this.data);
		},

		/**
		 * Perhaps show a status message when busy?
		 * @param @optional {string|boolean} message
		 */
		_busymessage: function(message) {
			if (Type.isString(message)) {
				this.css.add(CLASS_LOADING_MESSAGE);
				this._donelabel = this.text();
				this.text(message);
			}
		},

		/**
		 * Restore original label and revert to normal
		 * button without any strange CSS transitions.
		 * @param {function} done
		 */
		_nomorebusy: function(cb) {
			if (this._donelabel) {
				this.css.remove(CLASS_LOADING_MESSAGE);
				this.text(this._donelabel);
				this._donelabel = null;
			}
			this.tick.time(function nocolortransition() {
				if (!this.$destructed) {
					cb.call(this);
				}
			}, 50);
		}

	}, { // Static ...............................................................

		/**
		 * Focused-styling not working out alright for links without a href.
		 * @type {string}
		 */
		HREF_DEFAULT: 'javascript:void(false);',

		/**
		 * Summon spirit.
		 * @param {Document} doc TODO deprecate this arg...
		 * @param {Map<String,object>} config
		 */
		summon: function(doc, config) {
			var spirit = this.possess(doc.createElement('button'));
			if (config) {
				gui.Object.each(config, function(key, value) {
					switch (key) {
						case 'type' :
							spirit.type = value;
							break;
						case 'data' :
							spirit.data = value;
							break;
						case 'icon' :
							spirit.icon(value);
							break;
					}
				});
			}
			return spirit;
		},

		/**
		 * If a button or something inside a button was clicked,
		 * return that button. When IE9 dies, we should make
		 * everything inside buttons `pointer-events:none`.
		 * Note that, confusingly, Firefox does this by default.
		 * @param {Element} elm
		 * @param @optional (Element) stop
		 * @returns {HTMLButtonElement}
		 */
		getButton: function(elm, stop) {
			while (elm.localName !== 'button' && (elm = elm.parentNode)) {
				if (stop && elm === stop) {
					return null;
				}
			}
			return elm;
		},

		/**
		 * See notes above.
		 * @param {Element} elm
		 * @param @optional (Element) stop
		 * @returns {Spirit}
		 */
		getSpirit: function(elm, stop) {
			elm = this.getbutton(elm, stop);
			return elm ? ts.ui.get(elm) : null;
		}

	}, { // Static ...............................................................

		/**
		 * Buttons should show the focus styling on first click
		 * and then show active styling on subsequenct clicking?
		 * This assuming the the buttons are focusable, of course.
		 * @type {boolean}
		 */
		hasfocusstyling: (!Client.isSafari && !Client.isTouchDevice)

	});
}(gui.Combo.chained, gui.Client, gui.Type, gui.CSSPlugin, gui.Client.isExplorer9));



/**
 * Spirit of the ButtonMenu (for semantics only).
 * @extends {ts.ui.Spirit}
 */
ts.ui.ButtonMenuSpirit = ts.ui.Spirit.extend({

	/**
	 * Channel spirits for complex selectors as soon as the
	 * first `Buttons` component is encountered on the page
	 * (because these selectors come with a performance hit).
	 */
	onconstruct: function() {
		ts.ui.Spirit.prototype.onconstruct.call(this);
		ts.ui.CoreModule.channelComplexSelectors(
			!this.css.contains(ts.ui.CLASS_OPTIMIZED)
		);
	}

});



/**
 * @deprecated
 * @extends {ts.ui.ButtonSpirit}
 */
ts.ui.LinkSpirit = ts.ui.ButtonSpirit.extend({

	/*
	 * Fail miserably for at
	 * least one release cycle.
	 */
	onconstruct: function() {
		ts.ui.ButtonSpirit.prototype.onconstruct.call(this);
		console.error('Deprecated spirit is deprecated: ' + this, this);
	}
});



/**
 * Spirit of the cover. Use it to cover stuff up. Note that the cover should
 * be fitted with a background-color in CSS in order to actually cover stuff.
 * @extends {ts.ui.Spirit}
 * @using {gui.Combo#chained} chained
 */
ts.ui.CoverSpirit = (function using(chained, Client) {
	var MOUSE_EVENTS = Client.isTouchDevice ? 'touchstart mouseenter' : 'mousedown mouseenter';

	return ts.ui.Spirit.extend({

		/**
		 * Pending a current glitch in Chrome where multiple simultaneous
		 * transitions freak out, we have disabled cover fades in WebKit.
		 * UPDATE: We're pushing our luck with WebKit again...
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.css.add(ts.ui.CLASS_COVER);
		},

		/**
		 * Show the cover.
		 * @return {ts.ui.CoverSpirit}
		 */
		show: chained(function() {
			this.event.add(MOUSE_EVENTS);
			this.dom.show();
		}),

		/**
		 * Hide the cover.
		 * @return {ts.ui.CoverSpirit}
		 */
		hide: chained(function() {
			this.event.remove(MOUSE_EVENTS);
			this.dom.hide();
		}),

		/**
		 * Show or hide the cover.
		 * @param {boolean} show
		 * @return {ts.ui.CoverSpirit}
		 */
		shift: chained(function(show) {
			if (show) {
				this.show();
			} else {
				this.hide();
			}
		}),

		/**
		 * Position the cover.
		 * @param {gui.Geometry|object} geo
		 * @return {ts.ui.CoverSpirit}
		 */
		position: chained(function(geo) {
			this.css.style({
				top: geo.y,
				left: geo.x,
				width: geo.w,
				height: geo.h
			});
		}),

		/**
		 * Show and fade to no opacity.
		 */
		fadeIn: function() {
			this.show();
			this._shouldbevisible = true;
			if (this._usetransitions) {
				this.css.add(ts.ui.CLASS_TRANSITION);
				this.event.add('transitionend');
				this.tick.time(function browserfix() {
					this.css.add(ts.ui.CLASS_VISIBLE);
				}, ts.ui.TRANSITION_DELAY);
			}
		},

		/**
		 * Fade to full opacity and hide.
		 */
		fadeOut: function() {
			this._shouldbevisible = false;
			if (this._usetransitions) {
				this.event.add('transitionend');
				this.tick.time(function browserfix() {
					this.css.remove(ts.ui.CLASS_VISIBLE);
				}, ts.ui.TRANSITION_DELAY);
			} else {
				this.hide();
			}
		},

		/**
		 * Closeing all ASIDEs when cover is clicked.
		 * Also maintaining ASIDE class and display.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			var id = this.element.id;
			switch (e.type) {
				case 'mousedown' :
				case 'touchstart' :
					if (id) {
						this.broadcast.dispatchGlobal(
							ts.ui.BROADCAST_GLOBAL_COVER_TOUCH, id
						);
					}
					break;
				case 'mouseenter': // probably related to the Client-Docs chrome...
					if (id) {
						this.broadcast.dispatchGlobal(
							ts.ui.BROADCAST_GLOBAL_COVER_HOVER, id
						);
					}
					break;
				case 'transitionend' :
					if (e.target === this.element) {
						this.event.remove(e.type);
						if (!this._shouldbevisible) {
							this.hide();
						}
					}
					break;
			}
		},

		// Private .................................................................

		/**
		 * Fade around with CSS transitions?
		 * @type {boolean}
		 */
		_usetransitions: ts.ui.usetransitions,

		/**
		 * Tracking a transitional state.
		 * @type {boolean}
		 */
		_shouldbevisible: false

	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @param @optional {gui.Geometry|object} opt_geo
		 * @returns {gui.CoverSpirit}
		 */
		summon: function(opt_geo) {
			var spirit = this.possess(document.createElement('div'));
			spirit.css.add(ts.ui.CLASS_COVER);
			if (opt_geo) {
				spirit.position(opt_geo);
			}
			return spirit;
		},

		/**
		 * Get-create CoverSpirit with ID and classname. First
		 * run creates the spirit and appends it to the BODY.
		 * @param {string} token For both ID and classname
		 * @param @optional {Element} target Where to append the cover
		 * @returns {ts.ui.CoverSpirit}
		 */
		getCover: function(token, target) {
			return gui.DOMPlugin.qdoc('.' + token, this) || (function() {
				var spirit = ts.ui.CoverSpirit.summon();
				spirit.dom.appendTo(target || document.body);
				spirit.css.add(token);
				spirit.dom.id(token);
				return spirit;
			}());
		}
	});
}(gui.Combo.chained, gui.Client));



/**
 * Spirit of the dialog.
 * @extends {ts.ui.Spirit}
 * @using {ts.ui.Dialog} Dialog
 * @using {gui.Client} Client
 * @using {gui.Combo#chained} chained
 * @using {gui.Type} Type
 */
ts.ui.DialogSpirit = (function using(Dialog, Client, chained, Type) {
	var willopen = ts.ui.BROADCAST_DIALOG_WILL_OPEN,
		goopen = ts.ui.BROADCAST_DIALOG_GO_OPEN,
		didopen = ts.ui.BROADCAST_DIALOG_DID_OPEN,
		willclose = ts.ui.BROADCAST_DIALOG_WILL_CLOSE,
		didclose = ts.ui.BROADCAST_DIALOG_DID_CLOSE;

	return ts.ui.Spirit.extend({

		/**
		 * Is open?
		 * @type {boolean}
		 */
		isOpen: false,

		/**
		 * If (and only if) there's no dialog buttons,
		 * automatically fade away at specified time.
		 * @type {number} in milliseconds
		 */
		time: Dialog.DEFAULT_TIME,

		/**
		 * Big icon goes here.
		 * @see `ts-icons.less`
		 * @type {string}
		 */
		icon: null,

		/**
		 * Should block modal stylee?
		 * @type {boolean}
		 */
		blocking: {
			getter: function() {
				return !!this._buttons();
			}
		},

		/**
		 * Classname the dialog. Hide on startup.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.css.add(ts.ui.CLASS_DIALOG);
			if (this._transition) {
				this.css.add(ts.ui.CLASS_TRANSITION);
			}
			this.dom.hide();
		},

		/**
		 * Sync the {ts.ui.DocumentDialogPlugin}
		 */
		ondestruct: function() {
			ts.ui.Spirit.prototype.ondestruct.call(this);
			if (this.isOpen) {
				this.broadcast.dispatch(didclose);
			}
		},

		/**
		 * Forcefully open the dialog in case `isOpen`
		 * was transferred here from a model property.
		 */
		onready: function() {
			ts.ui.Spirit.prototype.onready.call(this);
			if (this._ismodelled()) {
				this._setupmodel();
			}
			if (this.isOpen) {
				this.open(true, true);
			}
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.Spirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case ts.ui.ACTION_SAFE_LINK:
					if (this._ismodelled()) {
						// TODO(jmo@): Wait for animation to finish - close() should promise
						// TODO(jmo@): Rig this up for xframe setup
						if (Type.isFunction(this._model.onlink)) {
							this._model.onlink(a.data);
						}
					}
					break;
			}
		},

		/**
		 * Open AND close the dialog. Setup to support the HTML
		 * attribute: gui.open="true|false".
		 * @param @optional {boolean} opt_open Omit to simply open.
		 * @param @optional {boolean} opt_force Force dialog open.
		 * @return {ts.ui.AsideSpirit}
		 */
		open: chained(function(opt_open, opt_force) {
			if (!Type.isBoolean(opt_open) || opt_force) {
				opt_open = true;
			}
			this.att.set('gui.open', opt_open);
			if (opt_open) {
				if (!this.isOpen || opt_force) {
					this.isOpen = true;
					this._open(this.life.async);
				}
			} else {
				if (this.isOpen) {
					this.isOpen = false;
					this._close(this.life.async);
				}
			}
		}),

		/**
		 * Close that dialog.
		 * @returns {ts.ui.DialogSpirit}
		 */
		close: chained(function() {
			this.open(false);
		}),

		/**
		 * Cancel that dialog. Defaults
		 * to simply closing the dialog.
		 */
		cancel: chained(function() {
			var model = this._model;
			if (model && model.oncancel) {
				model.oncancel.call(model);
			} else {
				this.close();
			}
		}),

		/**
		 * The {ts.ui.Dialog} will now synchronize
		 * the click event across iframes, if needed.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'transitionend':
					if (e.target === this.element) {
						this.event.remove(e.type);
						this._ontransitionend();
						e.stopPropagation();
					}
					break;
				case 'click':
					if (!this.blocking) {
						this.event.remove(e.type);
						if (this._ismodelled()) {
							this._model.accept();
						} else {
							this.accept();
						}
					}
					break;
			}
		},

		/**
		 * Called by the {ts.ui.DocumentDialogPlugin}
		 * if other dialogs are currently in progress.
		 */
		suspend: function() {
			this._suspended = true;
		},

		/**
		 * Called by the {ts.ui.DocumentDialogPlugin}
		 * when no other dialogs are in progress no more.
		 */
		unsuspend: function() {
			this._suspended = false;
			this._goopen();
		},

		/**
		 * Handle key.
		 * @param {gui.Key} k
		 */
		onkey: function(k) {
			ts.ui.Spirit.prototype.onkey.call(this, k);
			if (k.down && k.type === 'Esc') {
				if (this._ismodelled()) {
					var model = this._model;
					var buttons = model.buttons;
					var cancel = buttons.get('cancel');
					if (buttons.length && cancel) {
						model.cancel();
					} else {
						model.accept();
					}
				}
			}
		},

		// Private .................................................................

		/**
		 * Potential model going on.
		 * @type {ts.ui.DialogModel}
		 */
		_model: null,

		/**
		 * Timeout ID for autofadeout scenario.
		 * @type {number}
		 */
		_timeout: -1,

		/**
		 * Waiting for other dialogs to close?
		 * @type {boolean}
		 */
		_suspended: false,

		/**
		 * Use fancy transitions?
		 * @type {boolean}
		 */
		_transition: gui.Client.hasTransitions,

		/**
		 * Do something with the model.
		 * TODO (jmo@): Perhaps support injection of new model.
		 */
		_setupmodel: function() {
			// copy matching properties from model onto spirit
			// TODO(jmo@): just manually stamp relevant properties
			this.action.add(ts.ui.ACTION_SAFE_LINK);
			gui.Object.nonmethods(this._ismodelled()).forEach(function(key) {
				if (this[key] !== undefined) {
					this[key] = this._model[key];
				}
			}, this);
			this.script.load(
				ts.ui.DialogSpirit.edbml
			).input(this._model);
		},

		/**
		 * Open it.
		 * @param {boolean} animated (TODO)
		 */
		_open: chained(function(animated) {
			var oldie = Client.isExplorer9 || Client.isExplorer10;
			if (!this.blocking) {
				this.css.add(ts.ui.CLASS_NONBLOCKING);
			}
			if (this._ismodelled()) {
				this._model.$finalize(); // thus will trigger re-render...
			}
			this.tick.time(function wait_for_finalize() { // wait for re-render
				this._willopen();
			}, oldie ? 100 : 10);
		}),

		/**
		 * Close it.
		 * @param {boolean} animated (TODO)
		 */
		_close: chained(function(animated) {
			this._willclose();
		}),

		/**
		 * About to open.
		 */
		_willopen: function() {
			this._trapattention();
			if (this._ismodelled()) {
				switch (this._model.type) {
					case Dialog.INFO:
					case Dialog.CONFIRM:
						this.css.add('ts-bg-darkened');
						break;
					case Dialog.SUCCESS:
						this.css.add('ts-bg-green');
						break;
					case Dialog.WARNING:
						this.css.add('ts-bg-yellow');
						break;
					case Dialog.ERROR:
					case Dialog.DANGER:
						this.css.add('ts-bg-red');
						break;
				}
			}
			this.broadcast.dispatch(willopen);
			if (!this._suspended) {
				this._goopen();
			}
		},

		/**
		 * Let's open it.
		 */
		_goopen: function() {
			var model = this._model;
			this.broadcast.dispatch(goopen);
			this.dom.show();
			if (this._transition) {
				this.tick.time(function() {
					this.event.add('transitionend');
					this.css.add(ts.ui.CLASS_OPENING);
				}, ts.ui.TRANSITION_NOW);
			} else {
				this._didopen();
			}
			if (this._ismodelled()) {
				model.state = 'onopen';
				this._doclassnames(this._model);
				this._focusdefault(this._buttons());
			}
		},

		/**
		 * It managed to open. If there's no buttons, setup to
		 * automatically close after a timeout; and also to
		 * close when the dialog is clicked.
		 */
		_didopen: function() {
			this.css.remove(ts.ui.CLASS_OPENING).add(ts.ui.CLASS_OPEN);
			this.broadcast.dispatch(didopen);
			this.key.addGlobal('Esc');
			if (!this.blocking) {
				this.event.add('click');
				var time = this._ismodelled() ? this._model.time : this.time;
				this._timeout = this.tick.time(function() {
					this.close();
				}, time);
			}
			if (this._ismodelled()) {
				this._model.state = 'onopened';
			}
		},

		/**
		 * About to close.
		 */
		_willclose: function() {
			this.tick.cancelTime(this._timeout);
			this.broadcast.dispatch(willclose);
			this.event.remove('click');
			this.key.removeGlobal('Esc');
			if (this._transition) {
				this.event.add('transitionend');
				this.css.remove(ts.ui.CLASS_OPEN).add(ts.ui.CLASS_CLOSING);
			} else {
				this._didclose();
			}
			if (this._ismodelled()) {
				this._model.state = 'onclose';
			}
		},

		/**
		 * It really did close. Remove and dispose
		 * so that it's not possible to reuse this.
		 */
		_didclose: function() {
			this.broadcast.dispatch(didclose);
			this.css.remove([
				ts.ui.CLASS_OPEN,
				ts.ui.CLASS_CLOSING
			]);
			this.attention.exit();
			this.dom.remove();
			if (this._ismodelled()) {
				var model = this._model;
				model.state = 'onclosed';
				this.tick.time(function terminate() {
					model.dispose();
				});
			}
		},

		/**
		 * Transition has ended. No more fun.
		 */
		_ontransitionend: function() {
			if (this.isOpen) {
				this._didopen();
			} else {
				this._didclose();
			}
		},

		/**
		 * Setup bonus classnames to make the LESS more manageable.
		 * @param {string} type
		 * @param {string} icon
		 * @param {ts.ui.ButtonCollection} buttons
		 */
		_doclassnames: function(model) {
			var count = model.buttons.length;
			this.css
				.add(model.type)
				.shift(model.icon, 'ts-hasicon')
				.shift(count, 'ts-hasbuttons')
				.shift(count > 1, 'ts-hasmorebuttons');
		},

		/**
		 * Lock the keyboard navigation to the buttons area.
		 */
		_trapattention: function() {
			var buttons = this._buttons();
			if (buttons && !this.attention.trapping) {
				this.attention.trap(buttons);
			}
		},

		/**
		 * Autofocus the default button.
		 * @param {HTMLMenuElement} buttons
		 */
		_focusdefault: function(buttons) {
			var button;
			if (buttons && (button = buttons.querySelector('[autofocus]'))) {
				button.focus();
			}
		},

		/**
		 * Lookup buttons menu OR button at given index.
		 * @param @optional {number} index
		 * @returns {HTMLMenuElement|HTMLButtonElement}
		 */
		_buttons: function(index) {
			var result = this.dom.q('.ts-dialog-buttons .ts-buttons');
			if (result && arguments.length) {
				result = result.querySelectorAll('.ts-button')[index];
			}
			return result;
		}

	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @param @optional {ts.ui.DialogModel} opt_model
		 * @return {ts.ui.DialogSpirit}
		 */
		summon: function(opt_model) {
			var spirit = this.possess(document.createElement('div'));
			spirit._model = (opt_model || null);
			return spirit;
		}

	});
}(ts.ui.Dialog, gui.Client, gui.Combo.chained, gui.Type));




/**
 * Spirit of the menu.
 * @using {gui.Type} Type
 */
ts.ui.MenuSpirit = (function using(Type) {
	return ts.ui.Spirit.extend({

		/**
		 * Get ready.
		 */
		onready: function() {
			ts.ui.Spirit.prototype.onready.call(this);
			if (!gui.Client.isTouchDevice) {
				this.event.add('focus blur', this, this, true);
			}
			if (this._ismodelled()) {
				this.event.add('click');
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'focus':
					this.event.add('keydown', document);
					break;
				case 'blur':
					this.event.remove('keydown', document);
					break;
				case 'keydown':
					this._onkey(e);
					break;
				case 'click':
					if (this._ismodelled()) {
						this._onclick(e.target);
					}
					break;
			}
		},

		// Private ...................................................................

		/**
		 * Optional MenuModel.
		 * @type {ts.ui.MenuModel}
		 */
		_model: null,

		/**
		 * @param {KeyEvent} e
		 */
		_onkey: function(e) {
			var button = document.activeElement;
			switch (e.keyCode) {
				case 38:
				case 40:
					var item = button.parentNode;
					this._movefocus(item, e.keyCode === 40);
					e.preventDefault(); // don't scroll!
					break;
				case 13:
					if (this._ismodelled()) {
						this._onclick(button);
					}
					break;
			}
		},

		/**
		 * Menu was clicked. If it was generated by a model,
		 * it's up to us to handle the toggling of items.
		 * @param {Element} elm
		 */
		_onclick: function(elm) {
			var button = ts.ui.ButtonSpirit.getButton(elm);
			if (button && button.disabled) {
				return;
			}
			if (this._ismodelled()) {
				var item = elm, model = this._model;
				while (item && item.localName !== 'li') {
					item = item.parentNode;
				}
				if (item) {
					this._toggle(model, this._indexOf(item));
				}
			}
		},

		/**
		 * Unknown to many, the item index can be extracted from the ID attribute.
		 * This is only the case for menus that are rendered via models, of course.
		 * We could of course count the ordinal index of the element, but we might
		 * like to hide items that are not visible, so this is more solid.
		 * @param {HTMLLiElement} item
		 * @returns {number}
		 */
		_indexOf: function(item) {
			var index = item.id.split('-')[1];
			if (Type.isDefined(index)) {
				return Type.cast(index);
			} else {
				console.error('That ID was used for something');
			}
		},

		/**
		 * Toggle selected index in model.
		 * @param {ts.ui.MenuModel} model
		 * @param {number} index
		 */
		_toggle: function(model, index) {
			var current, idx;
			switch (model.select) {
				case 'one':
					model.selectedIndex = index;
					break;
				case 'many':
					current = model.selectedIndexes;
					if ((idx = current.indexOf(index)) > -1) {
						gui.Array.remove(current, idx);
					} else {
						current.push(index);
						current.sort(function(a, b) {
							return a - b;
						});
					}
					break;
			}
		},

		/**
		 * Move the focus inside the menu (use regular TAB to navigate out).
		 * @param {Element} source
		 * @param {boolean} down
		 */
		_movefocus: function(source, down) {
			var target, button, elm = this.element;
			if (source && source.localName === 'li') {
				if (down) {
					target = source.nextElementSibling ||
						elm.querySelector('li:first-child');
				} else {
					target = source.previousElementSibling ||
						elm.querySelector('li:last-child');
				}
				if (target && (button = target.querySelector('button, a'))) {
					button.focus();
				}
			}
		}

	}, { // Privileged static ......................................................

		/**
		 * Compute max items to fit on screen (or optionally inside the
		 * given container) for some kind of performance optimization.
		 * @param @optional {Element} opt_elm Container element
		 * @returns {number} Returns the number of items to show
		 */
		$maxItemsCount: function(opt_elm) {
			var itemh = 44; // HARDCODE ALERT
			var total = opt_elm ? opt_elm.offsetHeight : window.innerHeight;
			var avail = total / itemh;
			return Math.ceil(avail);
		}

	});
}(gui.Type));



/**
 * Spirit of the image. Note that all this fallback image functionality should
 * probably be moved serverside (on an open accesss point) at some point.
 * TODO: Read https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa#Unicode_Strings
 * @using {string} css (this is the Base64 encoded "'Open Sans" in weight 400)
 */
ts.ui.ImageSpirit = (function using(fontcss) {
	/**
	 * Generate URL from Blob stylesheet. The stylesheet
	 * contains the font so that we can use that in SVG.
	 * It turns out that Chrome doesn't do `@import` in
	 * SVG files, so we should probably convert this to
	 * something that works more optimized.
	 * @type {string}
	 */
	var fontsheet = (function generatesheet() {
		return gui.Client.hasBlob ? URL.createObjectURL(
			new Blob([fontcss], {type: 'text/css'})
		) : null;
	}());

	/**
	 * With our current setup, only Firefox can handle the font in
	 * a really optimized way because Chrome can't use `@import` in
	 * SVG files. If that becomes a problem, we must fix it. But
	 * the fast workaround is to return `null` which will then
	 * fallback the font to Arial in that browser. Note that this
	 * should only be a problem if there are hundreds of generated
	 * images being rendered at the exact same time.
	 * @param {string} agent
	 * @returns string;
	 */
	function getfontsheet(agent) {
		switch (agent) {
			case 'gecko':
			case 'webkit':
				return fontsheet;
			default:
				return null;
		}
	}

	/**
	 * Get computed image source (caching this to optimize repeated requests).
	 * TODO: Use Blob URL instead of base64 in browsers that support it.
	 * @param {string}
	 * @param @optional {number} width
	 * @param @optional {number} height
	 */
	var getsource = gui.Combo.memoized(function(name, width, height) {
		return 'data:image/svg+xml;base64,' + window.btoa(
			ts.ui.svgname.edbml(
					getinitials(name),
					getcolorval(name, 50),
					getcolorval(name, -180),
					width || height || ts.ui.UNIT_DOUBLE,
					getfontsheet(gui.Client.agent),
					fontcss
			)
		);
	});

	/**
	 * Get initials for name.
	 * @param {string} name
	 * @returns {string}
	 */
	function getinitials(name) {
		var names = name.split(/\s+/);
		var first = names.shift();
		var last = names.pop() || '';
		return (first[0] + (last[0] || '')).toUpperCase();
	}

	/**
	 * Compute consistantly pleasent color for given string.
	 * @param {string} str
	 * @param @optional {number} mod Darken or ligthen mod
	 */
	function getcolorval(name, mod) {
		var base = [245, 245, 245]; // TODO: optimize for diff backgrounds
		var r = base[0];
		var g = base[1];
		var b = base[2];
		var red = color(name, 3);
		var green = color(name, 5);
		var blue = color(name, 7);
		red = (red + r) / 2;
		green = (green + g) / 2;
		blue = (blue + b) / 2;
		var col = [red, green, blue].map(Math.floor);
		return 'rgb(' + darken(col, mod || 0).join(',') + ')';
	}

	/**
	 * Obscurely darken or lighten a color.
	 * https://gist.github.com/p01/1005192
	 */
	function darken(c, n) {
		return c.map(function(d) {
			return (d += n) < 0 ? 0 : d > 255 ? 255 : d | 0;
		});
	}

	/**
	 * Get integer hashcode.
	 * @param {string} word
	 * @param {number} n
	 * @returns {number}
	 */
	function hash(word, n) {
		var h = 0;
		for (var i = 0; i < word.length; i++) {
			h = word.charCodeAt(i) + ((h << n) - h);
		}
		return Math.abs(h);
	}

	/**
	 * Get computed color value.
	 * @param {string} word
	 * @param {number} n
	 * @returns {number}
	 */
	function color(word, n) {
		return Math.floor(parseFloat('0.' + hash(word, n)) * 256);
	}

	return ts.ui.Spirit.extend({

		/**
		 * Setup load handler (dependant on cache status).
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			var src = this.att.get('src');
			var alt = this.att.get('alt');
			var tit = this.att.get('title');
			if (src) {
				if (this.element.naturalWidth) {
					this._onload();
				} else {
					this.event.add('load').add('error');
				}
				if (alt && !tit) {
					this.att.set('title', alt);
				}
			} else {
				this.event.add('load');
				this.att.add('alt');
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'load':
					this.event.remove('load');
					this._onload();
					break;
				case 'error':
					this.event.remove('error');
					this.att.add('alt');
					break;
			}
		},

		/**
		 * The ALT attribute will be used to generate a fallback
		 * image: We generate an SVG which we then Base64 encode.
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.Spirit.prototype.onatt.call(this, att);
			if (att.name === 'alt') {
				if (!att.value.includes('{')) { // no weird handlebars syntax
					if (!this.att.has('title')) {
						this.att.set('title', att.value);
					}
					if (window.btoa) {
						this.element.src = this._computesource(att.value);
					} else {
						// We'll need to polyfill some Base64 stuff for Exploder :/
						console.warn('TODO: Image fallback for IE9');
					}
				}
			}
		},

		// Private .................................................................

		/**
		 * We've set the `opacity` to `0` while loading the image just
		 * in case the browser flashes some kind of strange symbol. But
		 * this is perhaps not needed nowadays, must check slow connection.
		 */
		_onload: function() {
			this.css.add('ts-loaded');
			this.action.dispatch(ts.ui.ACTION_DID_LOAD);
		},

		/**
		 * Compute fallback image source. Note that we don't read `offsetWidth`
		 * because that will force the browser the repaint mid-rendering, we'll
		 * suggest that the `width` attribute is specified (for best quality).
		 * @param {string} name
		 * @returns {string}
		 */
		_computesource: function(name) {
			var w = this.att.get('width');
			var h = this.att.get('height');
			if ((w || h) && w !== h) {
				console.error('Height of the ' + this + ' must match the width');
			}
			return getsource(name, w, h);
		}

	}, { // Static ...............................................................

		/**
		 * Compute consistantly pleasent color for given string.
		 * Exposing this in case the color needs to be replicated.
		 * @param {string} str
		 * @returns {string}
		 */
		getColorForString: function(str) {
			return getcolorval(str);
		}

	});
}([
	'@font-face {',
	'	font-family: "Open Sans";',
	' font-style: normal;',
	' font-weight: 300;',
	'	src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAFiAABAAAAAAk7gAAQABAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABbAAAABwAAAAcXLlcaU9TLzIAAAGIAAAAXQAAAGCg1LufY21hcAAAAegAAAFoAAABsozo3JljdnQgAAADUAAAAF0AAACqEusTqWZwZ20AAAOwAAAEqQAAB7R+YbYRZ2FzcAAACFwAAAAQAAAAEAAeACNnbHlmAAAIbAAAOCIAAFWgflHLXGhlYWQAAECQAAAAMwAAADb5cRTIaGhlYQAAQMQAAAAfAAAAJA7yBThobXR4AABA5AAAAgoAAANYeaRbNGtlcm4AAELwAAAOFAAAIwQMlg8JbG9jYQAAUQQAAAGuAAABruqP1mxtYXhwAABStAAAACAAAAAgAoQBVW5hbWUAAFLUAAADFwAABrEB9k2JcG9zdAAAVewAAAF4AAAB8oJ46dVwcmVwAABXZAAAARwAAAE63o6iXQAAAAEAAAAAyYlvMQAAAADJQhTbAAAAAMnt2Fx4nGNgZtFg1GFgZeBgncVqzMDAKA+hmS8ypDG+4WBi4mZmY2ZlYWJiecDA9N6BQSGagYFBA4gZDB2DnYGUgsIaNvl/IgwtHL1MEQoMjPNBciz2rNtAcgyMAHPDDcQAAAB4nGNgYGBmgGAZBkYGEFgD5DGC+SwME4C0AhCyAOk6hv+MhozBTMeYbjHdURBRkFKQU1BSsFJwUShRWPP/P1jlAqCKIKgKYQUJBRmgCkuYiv+P/x/6P/F/4d//f9/8ff1g64NNDzY+WPdgxoP+BwkPNKG24wWMbAxwZYxMQIIJXQHQKyysbOwcnFzcPLx8/AKCQsIiomLiEpJS0jKycvIKikrKKqpq6hqaWto6unr6BoZGxiamZuYWllbWNrZ29g6OTs4urm7uHp5e3j6+fv4BgUHBIaFh4RGRUdExsXHxCYkMbe2d3ZNnzFu8aMmypctXrl61Zu36dRs2bt66ZduO7Xt2793HUJSSmnmhYmFBNkNZFkPHLIZiBob0crDrcmoYVuxqTM4DsXNrGZKaWqcfPnLi5Nlzp07vZDjIcPnqxUtAmcoz5xlaepp7u/onTOybOo1hypy5sw8dPV7IwHCsCigNAKdLe454nGMTYRBn8GPdBiRLgaQkAwpgsWcQZZjFwPD/DYiHIP+J/P/EwABS/2fK/93/+v8/+Lfy/xuWeKApZAEOCBXFEMcQzhAEJBMZohkiGRKA7DCGI0AyiKEAADDbHaMAAAB4nHVVz1PbRhTeFQYMGCJTyjDVIatu7MJgl3SStkApbG3J2HXTYgwzK+hBIiZjeuKUQ6ad8a2MSP+XJ3IxOeXaQ/+HHNpbOSbX9L2VTSAz1Qhr3/d+7vfeLmr78CDQ+3vt3dbOTz8++qH5faO+XfO9auU7tbX57cY362urX3/15Rf3Vz4vlxY/KxbuyU/duwtzefvOzPTU5ER2fGw0M2JxVhLAQx9GCiJfi6Qvo3q5JPyFrlcu+bIWgogE4CdTlPW6gWQEIhRQxE90Aw5BoeWTDyxVaqmuLbktNtgGpZAC/vKk6PODlsb1H54MBFyZ9SOzzhSNMI2C66KHqYqqFT7UnnZjP8QaeTI1WZXV48lyiSWTU7icwhUsytOEL25ys7AW/fXEYtlpSos79aMO7LS07zmuG5RLDZiRnlGxqgkJY1UYNyHFCZXOzkVSehU/79vsKFzOdWQn+lnDSIS+8Ygfx79DfhmWpAdLz/5ewJ0fQ0l6PixT1ObudZ7m+5QcRgu2FPEbhtuRV//eRqIBMlaw3zBaglUFvqtdepwach3HNSlqcRhH/Xe9IylsGSe5XHzqI91sR2OI/ruX5w7Ungdgh12+Hgy2XtttwketQw1WoSa6ESL4bkl31XHz1zY7/6dmSAuSgwy7LtFw3lfsCAXotXQqC3bkXDC1shyAFZLm1VDz8T5pekPNtXsosbfNto4hU2h0pI+Mn0fQO8Lp+oUaI22Yeeu4Mp7Ni7WVwNgKrKrROREwWkSS0OumA84NucS2EWbepp8rBxMU87NiTWIYiuNLPxy8T7sLGEAg0fXldBD2NCgPFyoadMxP7q+gRxRiw04800xYkacwJyvX3aWy/JO2Ni4DN5irAgsfD7xgxTfnSvhx6KUlUCzZ0pfswbvXyUPhvHjAHrLAI+P5Kk5Z0Y915wncDZ0OnrsnQjsuqAA7HEh9HNDYIUNLrx0zHIGZlT3dbMtm60CvDgpJFRQuU/A/CCO1k4bBAYRsISu05YwEaGgjIGq4kJUN/IXxQhb/bCTcoDS4lQ2hucOG1lgGLAn/2BvYkXwr6CiNU7U+jDZGIsap1h03cNOnXLJQLQaJ0SNLpNaHKrymUJHF+azWDURcLtDQCy2PZSC7AtSOpr0RPYblARmG80Gv9m5JN8hCmpiL6qFAZEJt2blJLmwb+Vqsf6BuDNUizspmO6bgchCQYeUNYDTCajXvmLuADrTEu1fYeKTNgY4Tpegwd9cpiGx0YtnWG8Ya75PfnGeUa5Y1eXOvUi7h1VZJJD9rJYqftQ/0pc2YONvTFxa3qmElSO6hTl8KxpRBLUIJJEGQQJF2Ucgae+dSMdYz2owBjPy4z5nBskOMs8d9K8XsNFHRJFLMQk0m1aihdQaxbIr1DGaehBFlanJUZdWEylnTlpNwgi4QeckZm+DsRY5PcydBr10D93kvmVBOatFDC5VWeLb/PvX+gX6RY+hmfjFRhR4cl4UuNhv/rfiiQ4Pya9CNw4AOG5vH1uDLgctNbJPcxELGcjApjyswJSuEbxG+leJjhI/jiPJ5ju497P0OcJqAQ+3ikRSf/OnE9hV1KsBLJbb/Kf8HKfchKQAAAAABAAMACAAKABYAB///AA94nJV8CUBU1RrwWe4y+9w7KzOswwiIqCAjEhowmhEiAiIRQ+ICiuaGWq5ZWmalZmqpLZqZmZWpmZmZmUumVmbW8/l6rWZ7L1+vVz1LZY7/d++dgYHs7/+zmTvM/eac8+3L+c5FBG26fA6X8LsRRUaUGbTrKEcJMZswNhBqEIaGDHZUnIXiim0F2bINF8iBgBzolYP9NEB7B3KdDn8qdhQmzlpWVV1dhedwhRcfbmxsRAQtoptJhTquiJKDZpFDMLJeJxCRUlQcOJGrjAbDqaNRP/XBC3O+Qh9+C9743eGfiKS8EIyVjxD3K4wVj5LRk8GRuuQEJ+fQyyaT3ma1GDmD3e5wJSaJnODmMPJwcTwvOASDj3rdNM4Ql+LTcSazqTqUgM3JSJKl6pDHKRebK83zzSfNXLFcKS+XqVk2y7zbTg08yg4UB2wFBdnZDQ2AbpaMFJwjV3XRbriqa7e5C9SX+ik3V7sq+PicgI9dfeX51FeAqi8nhj/psXKczQ7W1texh2vratnXOKucfYDza28M4cl1tXU4sfUNPLGCraYb2PRKVogPK69KfH8VPsr6Kq8qNh3fjxBQd9PlxfSMYEMpKAP1RLcGM8zOuKS0LIHjeB/qakO8weblc7K7WJKysiwVoTQzFQTzkJCw5/LBF12eUuUadJul0u6JzsQhoTinWchyOrMEM+fm3Sg7G/DJhv9kFf2sLOVd+6zgilXU4Z+GtUMQnf68njgjLwkH5J4kr3ef/LyA0+UW0zPkJCz2hksRxg6XW7Zgeubo80OHfxgc/H5o5X3B1zYMPfKob9kLpzdMuX3x3GXhPdNvnzUH71n0jOvcdyQzaVyXXNzavW527bxnHQf364vriwzMO2Dd3OtburJM8zxyoHZKOj4izUY8mnb5e4HjjyMDcgFNuqMcNDiYkdOjZ3aCz53BG5FslH0ZPbKF3F5J3brlUIslO0fIjtM5RG8XD8gl/FNEPSArr3YEtX+9ckDQArly73R/qsA7BH9qOuAYyHVh9Wup07d67Men6kcdahoxqh5/umbZoodW3Lf0YTwLvjqkfLNq2b1rHly6+GHW2np6FM3iyN5X8Yw9r7yy54sf/vvJmX/9t/WTV17B0/G0l/d+8cMvH5397ieacbEM1EDl+62Xz/H38CcAxyzQj6HBHp44hzPX3F3MREgEGeALrnJ75S6cIy2bSpzD4LEZ8spDBi7JVx5Kiui0ptfuAlWMO+AKmALzMnpiDRMnsBYX4fwAXPwZFgIo8rl98rGFOB0uCgwtAkCFKLc++NbgAcEDT6x96b6X8RuFtSmjih/AhnsODV/x3OT3/4OPLTg9jiXeOyd/b9eqqY/Pmzdh+kJ885LXJ1Vfd2/Z8mc2Lr/p+Yksv3TLLed3sV+P1A/r/u4tN4zDX5eOnVm5fCNXXXn3xOtXjRwx4xaEsGJfMKfaF8fLiFKeI4pdOaHZKM2kqOZEsyQKzTCqZvvwT/AbE1gki4gMikXSI4vZoPw0u023FewlGyBLZAn700n12gemrVqPc1oefJT0wnr87vbdLHAZsUQ2aQs+CuMWwrgfR8elehhXQByMy+nbxw3AyLAsiYh+JEskI+Cy4Y/XPtCCc9avmqYMzC6wvs/gVfhLjPGJl55nvbQ1jycbaavgQBYUH7QCmlg0G/RGvVXSWRAqfkPlm4Jumpu3i0acYU/L5ymZlYZXO9mM3+Yd2HXbz2yuHa/MEBxs4viFGWzrdfhWtug6XJOxcDxerc7Rgi5yfm47eICrgn49AtPBm01U1InVIWTVZeuKdSN183XLdc/rDujO6PQ6lN2g2QCV2GAKYQFg8WS/DJZODpBpeCerqGZVeEc1adWueCfMM5D9jgPoRyQg+SUO68AngIVRydMrJ80NlLHl4wzT4Kb+Q3w/Otlv/8T2L9X1DSeI5JNq4LUzCCQFIqBhIYyysyK/tef5nMPxxwRVV6vwG8GnDUQ7wPPEBY0wieJ2hoYEReqj8pEfcV4bFb9Vobgs+J0HnM1GVaYSgiaKMCEwF6XEhoqLY9yVotdkY/jMeJLC79Y0kqCbL5/jkkEfjciNugYdNmQSBOSJ0zuHhPQitQ4JUU9E6WIdnwSqBFJmC+TasPouq99wyT/8+PWP35779ufWgztfem3bttde20LOsPnsfnwbnolvx1PZQracbWWv4io8CA/EVWwHrP8YLGQLLMeAUoIWYBPGJqOox3GcXlBMm60g4sFhZp9f7p1vwXwGDpAtjSZrCvu4AC+r5TJXrrMmfH0dzlToMQ0psnAcxaHcoFe0uSEwsMVxXg9xY6thSMgqYndFCMe14YXazUivnEych4uIahbEDM2IEBE7fRzXOhkv2nRX0dbFLz/d5+UzBz5+8DBbTC11eM2WXZvqF25adO2j77y4kv33GJvPaTowAmiLYB1dwc5lce4EZBf9JiSa3Fy3TOqOi4NVWOOwkcbFGdLTk4eE0kWDNCRk8MQsLC575IiGjktUJDfitZKw08H5UlXHldsH1pyF87QPYNPEjCL41kVPPbdixx72Pbt4ZnPN+8M//ezLT9Zv2H16232Td03tdf1Pt779CTfi3r1ewbXr4RNnhzV1z33xyZXrRm1bNffBwrJrrht2AGQkC+g5g98P/LGhYNBn1IsctgkCRtRhF7Ce2njeNiTE8yKNs1itosI0WWGbIugoxkarHMR+Vd/A0wZ8spTvB9PMzWgdEZbI6TmtbLNF5xgXbsUz2FI84xpOaDXjjbjnibSHwskaTZcDTSWQlQTUN5gs0XgX1bs8XFIisg8JISS43d6KkFsLFTrSMSuGxziXA8KBN2innMJtuxL+9CGef2Ez++785DcGTHpm5MHvvnj9zvuv7ksOhtf3WEdbvjh69mJW13H5Wce3Pbk3I4M8Nircmgg0Wgjr8oMexaF0VBHslmD3m0zg0ey0a4ZZcknJlSGrNF8iBipJLo7TV4Y40eUZEnL9JbNVo94lkOt2whoRDahMBZmEP/jIyi0gBkl44Vqc+NaIikHjfmP/ls3lb0w+8e0v737GLuMzm3bvWtv8/PimZ0kLTsSL9rnr4tk6trVxzL/e/ZyF8bBL7x54Zl/96oqWE7NVGk8GficDjQWUFXQKCPOI8FQHVokHZ0UqQlRAkQUXxxDVh8GKOjGuIPWtR+jO8Ca+dtSgiw+CVZoDtHHwJ4E2XVAvdEMwO1mfTbs6PVaqtzpTuwuBXMFmS+3ePRWI1B30oXt3IF0a8FM0JQwJmf6ERB3jHIWpqr9XdCISy+QrcUARpkqUo1Aqw4JxqqDQSnP8pGTvl8vWH1wXPv3puc3bn7hrwoGfX31m05uPfb7nUTx22XPFs+578v5n+ZP7N07dOqhy390v/fPtQwuPlpQ/O/Omx2svPbLk4SeWzFt7/XVb6dKlc0om3tC3+OGJs+9TbGoL4GsCWfCC5oMspJnNKMmBRAftlmlxy7KvMoTkqTLIgixzbnf8kJBb5AwgEf8PsgCWF+RWE1tk91uwiilYYHDLCmqAqYJaT8yZHmJnToyvy5qT8huOk0yD3p5y/MsLx1b8cwbzr9+3fePY58c1PE3L2Ods3l5vrcWKx+LaUeM+f/cTLD3EPsFNp1/Zvqt+9ZAZ79ys6B3RfBPXA3yTjAqCqSYdB0bObjNYh4ashmxDpaHFMN+w3CBYIPuKOi0URaLN3Ubdl6xeFTapjqyqOtuf2lNxZ/RMY2Nez57anOXgd6NzZgcTTDrM6ajdBsSCWUfCfI8bDhhOGs4YBAO4dmW67AixIn65jy2fts2EsxUXnTjAGqdNp7rq0ThzEvm0bU6IKbABYopDIPspQZnHCHOK5FtpMR1JIdzKbjjaNoUePIVTjzl/aznd1foWzccGvKEQfzSSTWSPqXKAP+X89JiaSxYHMzkRckm9juOrQ/+BUICTOKKnHIb4LmTF2bgFP48P4DMY7KqKjHQUiNeQFYmUlFgBw6sFpoLp6IzqajY+Ejd0WDPmCS/AmoUrrtmuLhq30HxYMIyEJ+AmvHokSy9ko1SaF1w+Rx3gs5IhL+sf9OmcXVLA8lqdKVxmV87rtSGUbrMZq0I2Lj11aCjd3kFkbR21EsQVtLAYR6PsiEdyOixEtJBE3JaJpw0ee2Np0dP3Vi6pSpuyuvLlv3XpP/yq4LXJN2vZedqt60KVhbMr5q/xZ1TlpBzZOrD5hqHZfUKNoy3stBoDEcif+gmb+a0oDwVRTbCHF11t6yc4+phTeyKzzdG1pzCgv2gokqQsd0EBzTEEDQsM1GDITctKylXy+myQT4gOlWUXKJ9jsIiiopjc9IwYlXNTZ8SykC7+VI44JeSD7MIp+FMgVFZsNmdTMqyUeKxgL2x+aW2oRc9lbZy0auN/X1+yylUydNzC9ezjfd+wJ17DFTjQcODe46fYk2zuh3jZxQ/w4BcvnZoyC122SZXTV+8gp79i5yY1jBl7aPvbGGeynKTxN33/6uu4y2PH2KpzbD97okvvpiq8EhQZ4Ue+2MleYo8vX4HrsT/+BNAH/uNO8PtAEi3o6mAKx5tEAay5Cev0SBAlq4lyOlwe0imFFJHatLgru7MBUujgo34cgFDSR9MzBJEuD29/Zxop70+CN4d1xHjM449PIVy4ld93cSAZRaxFU0ZVgAachPlXgk+xghdIVuKhRKPk9VodnJGzilyKT+eRJE85OEmw/5JkRVYv/GFDceUh+PFfmEVVsH0pqvnXYiK/z+7TnKPPg30psuQ7CZSxsrWrn3+K/XqeBZvxgHdfPfU++xBD/MZq+N179s5/Nk7wPvvQ2x/RrMUPPHBXeEZ4MS7DPUC/7gB7vgd0woXSgw5qcegsEL3ZUDkogVEoCxnblSCiZVgRABCGiCz0Vv23mE6L2b/ZG7gbdu55dOWH7B22/llc+Ld/PJu5gW9hG9i77BjbnF0fwPfjsWdwzStVw6s0Owi049OAdjokKTG6hYNcB8k23lwe4ilnKQ9xtivF6CgTy74URNUPgRQ+jd3OlrCNeCkegSe3sEPsOPvlZ7KcfM9WsHv43ewB9hjuiwsvMsWmwJz0R5jTiK4NpgkGAwZzr8PUbBL0ZSGrAFyCAJAQvixEKDaUhbDtClyKsQTKWiDVUl/0x9azNDl8HXkgPIW8wu8eEf5gRHiZZn+VeZVcVw9S6hPgG07E1GDUZi0WSId5lQTnShOqeUJkOpzXTH3ha8mq8CRlplUjtXmAp3ym6qMhjrSLcZAjeEUuPgF5B0McyRmNUnnIyHEuIK79z+NInyz4Yhjsj/IdcLSQ+L+z39hmtvxlfP2n/9mfuf8ddoZtwwPwVW8vY0PI2fDYenwPbj6DQ/vqhtextex9tpu9WEBIlA7czyr984MJ4Gx5PTgKHpnMOloWytZhnY43CBTzqqaqxqud+e0kgFA7AO8B7udxrVuam2ntOHIy3IvfHZ5FFrfRG+epuaO8G3E8piiaNfbKUQY62azkiirs5VK2XIU1qvUCgygqq0HACpSqkSiSp/XKoRCigGn0QJQv+Yb3q7ju52a2PL7OgXX8wYtlbHnb3Nxmtf6QF0zAyGBU8OSRkZh4i9mkI5TrgKO7s877/FhUMcwHg8Rtvi188nBz80ZSeGf4WcptDT8DeOo2ktrwmhh55tW1w8SQd1BEgdm29rWryqsM7nOebFYk8+KWUdpvBQ/81o6Kgkl2SMt5XjBaLGazXqAOpw0iOSIYRWpBgrJSrQorBzrX4dQQ2e9yKiuG9QZkJZX1Y1odPqPTNa4ngkCER8eZdOFP+ZJ5d17aA7Nf5IWLZVzNLfMu7ovS67xqQ3sGnRiiSr0giBAcSdQoWnQUi1FhKPiDKLRPnJ4H4nB+XOt6namxmY4W9E287buZreUw3U+7NtK9YG8U3VjXXhMwAVoCivPonYNDeo5aB4eo/Yr2xqeJfwqK/cyvY5vAtJ1km/BIDEE6rr9Ug+MgytFht5KVskvsa/IpwEzEq8EwNeCVbDL4wKPsWVyDC/HVeCjbqtlArli1CzbUO+i1IAMwQUAOu4ErDxkMQAdbeUikQoxJiFUIxX9zPjX1TGnLlbliCH9//6IZNxND6/m3fvvkvY9+5mx//wJSl92t7MmXn31Ss793sE0qPSTIOguCSTxHBTeSjSBDRsg8LWAxLBzldTpHWUinUUY6GijO6pyfSEQEtyn6r0yl1jN4yGb2jS/5L0n1EZvfB0DKyP+FYFG/wT0INDOD56oO9jSYTUabCDkQIaLRzMW5DRALgJe1JFuKLZXgVajFQk3ERsHo0YjTVSyLalpRZ3EGhFRqcmqR1Y/TfBGqgsHFw7GEubXr8bK57B62GrtfeefNL34mt4UX8rvfevvBt7uHm8ltdU898fTDWvwKMed58K9dgLPxiTYjQm4bz6WlGxOp0wlxgBNi8LJYoUMFsRUb4Kw/RbU3fZTMR63+RuxxJNtLIvQ8++UM+3X5+v/tOlWy/pHPn8P47XdfStu9eePBfnc/+dzWSjzn5X/0a77mqbuHTa7vPeTF1ZtOVtSVr7lj6Phhffu1RHyTAeiZAfQUUVrQhjCmAtXrsE2EkGlwiFMoBmRqy4k1Cwwhu4+Uj2NpXCJLg4xYsSf7Qb8IjCPDOLKEwZBiu02GyMvc7m0CsaolO5AvFSnWVAs4ZZ6wT0Aa2Jfj/vWP978Baa1oZV/hRHSZbm+tOPXDtyfoPphHifnWq3W1bhC3EB1k8pySQpmMYLY5qkR5xZ1iXZhMie0C2OXuk89lt4Q/rQ+fmYyn1iQ6+mlFw9bEs9MGr1fpEQC7+JO6vzUwmIqRWydKDjvnjTfoOb3kjucTEzi9W5J0XrueYp1mnAJqjtApvo5YRz9WU3Rl+iTq7hOvLqMI4wA/vIYd6OqQ+rGPa9mUiRiiQ6csxlVcnIbTAi5zJk4Zx41fGrrhi0v/hgVWF4y+vrLrvdhJZ7UKOyaVbuS6a/xT6FGh+i/V3+gNokA5RDhe0IHvMZuIjgOLjrlYM9rR3+gx/B/QK+6mYgarYqXT8DnW/2YIqVZOZv3IlnAtuUj2he8n08Ml7XMWqLFb96ATUQrBi04kEDcb9IjHIuX/yASlvKdMAeqFAyQZb53CPDcx9wyyhqa0zg8fJz3oYm1fAMYuU23iVcFEKuoI4UQ9ZzSI4EW5wRAbEh3GusFabKbVa65U7VTLNj6urFVH61pP0r2tm+m0ct4wqvzieQ2H7WwfqVflPjlo5kQBi1ivEyDR1DKnWEmNRHikntXgrWw3LmP7hIsjLhxGf6hTEwzUwFeqU9tBAuYT/7jwZ9EytSJrbB8+E10DFih4JL0OKarXeQ1un1rO9wVg8t2wiJqvhcIRFwQYo470Al4oeXJG0EaUuSHApEppi0ecgsyJ3E7KYFe0QQ85wvsD8Ttj2Aw2nfSiK1qnUnfr91pM1MrO04rLpZEaP084goeFiFLjxxGK5PloRet2Ws3OV4PNWMx9SHWCD3gWF9QLHIeMBmEBZPzeE20BCPYre5EBsFtUd+2oV3z3e1eWcB9WvpIt5+wrV+x6I9jLB7lqoGcXyKS6Y1NioidVp/PYaXoaQU5T0qCQ1ZRsgljZZHIip1MqDTkl3lsS4l2xG2hXSqUUKW/LcbsU49g6uJyW26cQi0q10UXLPLrqbTM37MT6Sydvv++hjWkvPv/iCyxj+1v7vz5829abbti08vEdvFC6dn1Nbc3eI+EeJcdemKgzzlnQPE3zTbshpyoXHMiJfBBVJadQg8dqNZmoP9VgE8BjwcJdJSEkCYmlISFm2cVybHgTKfxp2w+QnItKNOiw4kARdqcKiVgzlxK546tvf/nklr199AlFTZDfFj0/5+DmbS/v3MXVsLPsHPsv+2hU3SbBwebUlV3fOLz+k7B8/h8XvsEfaPI/C+i9iKuBtUL+Z6FUZ6dul2AsCQkSkmGRrs75H5+quPV2FwSrgFSQjP+e/Y5tPy67I37Z+DffffeVVfPHO3A6aJMF9+hVl/3bd59cyBse0OgzS6khAn3skC0DfYyJgqB3y7IeHK7JAlpgcCKHQh+LpzRk+VP6aBY91+VWwz7Zn+EXtI0boI5T8in87J1OBs7cOlAQGvt7dPO+O/vjubM7X8Tj9mx9lqupHX/7HHzPhXOb90IYYsJe3K3+4o8s9x/n5dZPtTXSH4EuDvAA1wUzPPo4o5FSvUwTE+KMpSFrXHIcUXY3kCA4SxViWToQ64p5YpR0tkTsU2vz+U4LpqmC6IOFTv43+w2jDw9+1vpfcuJAw7JJw9fd+th+iWzY5MBdgI4cLmC/flP1+TlvVn3XRE46efi108C/RCDoaSEZ+FcYTDY7HCIBZQe9d7uo0wjKYVQsscOBS0MOq+bE5UBcNClwa7XLiHWDCDIvX91c1ngLqyRll1HT228/+HR9vbuq8pbRYNe+b3XT7/um1bz5anytZ/GjY8E69GAOTgBaZYLXLEYLgteZkvtyvbv0tHfzYM7uSe4i9A9yGWJCrtWnF8X8QSEkjhJXiNRMRdGVac29LmS1ujIzCgeFMqRMMiiUaXV1HxRyxbdzvj3qbSOs2vlRINv+uE2OnaJLLYtmqOrcTy2ec772snl+ZA/djR2+FFmJ61Ls0To64M0JZ+vf31GW1K+osmH/C/sgOmUnzi6d1avf0pETTu6Y2C98Dg/BW+9es5OdHvbIgntXrr77ztVc8bWWqXc/dlhIrsnunbP8vq2vrl82dVW8c0ju5GEZT0968ojzkv5zLDfWkVduX7pk4dKlq4F3YP05C+iBAwWCHuSAtFCnd+hdTrNelrmSkCxBUKZ3Kg67zbfFmAaf1vOgpj6yqOydpHgw3bpk5eGXmpp4sXDvEjydHNq0+sin4WdA/eWljXXs5nAByPYzoPhKfYCCLYJoT6m4YGy1jDJhk8ARK4Ypi4tPNMT0FkG0p/YWaXTFnqamacXJfn9yMVeMe47K7dmjN4jh5fXMoY5rAkWAPMZmMCuJdJwbObGVOoNWTmdFPKhJhLHF3hPAyej+p+odtdRaUWeHYG+bL60q/9qrH2qab9HmZA5PrWMHn3Lxx3seEEOR2ZFGT3oG6GmGmAEyGUwUgkKmLeh5q4UKZpHTYwPCVj5CVPmPabcaAUVTb4rdJGs2ePv3Z7GmnU1NIv6UNLKc8EqStpHdJjhaf2WnI/NiD8xLkSuoB1LyHEEqEaM72wr5FKIBTAReaAZ9SUWlwS5enR6lAt8lSdbLqbSLP94hx9msSC87OVOcqSSUFCfBarXwGxJwuXPsJisxVYwwSFGhcKsy4Y7sqskCN2/B0xvGtj63rqnaKfTYPAbjQVzei9N37iRvPf7AniPhheRbbD/2cfgZrnj10NChhjH7T4K4ROUU1mtDvYJxCk2RTW+zO0x6qxXE1CoZrFcW085S6g708bXLaI1dmICt7TIKs25RBbTNRxTAnCYUp+TpZtEOjsHjNYDjNEhUKglR1xXzdHCVJE8xsgjHqnQB5BPLP7oFk7Ofo8utm4/s2nXk2K5dh4mPnWenl2DyLDbgTHaKXfz80qXPz/7+m+bHwa6VwxoUP9U/6Es0CmCwdG5ZJ6f4qBFZLJ6SkEXSW3XxyFHaZv2L27O4NkcVUK1/ht/tihJC6yvIUDy4T/Pm5J5LN0PMp9Bl6vlPvv3l70+/zDbv3/mcY19NWR1rFLLW7mBnwKH/yj6s+/0MPvP+uZTLH2m0gnWaVP6o/tSlN5tNidREfSl6GQkGqzle8KoO3d6+yj/xp3yk9cEdyI8UcQRYo6xREYwpKfjHuXOfnJsh2GoaBWHmhaPPbtm74+UXHTgBfKgd99j+yIXTeP3c2/fXfYSx6X8f/f7T199HZZ6chzVKSq5g1usNBmKTzQZktIK3V4yChNrWFMvRaJwRFWjSeG2lfeCgpTubagziNQ9zNZaR8rldivS8MXs0zFMDfrsO5vEr+bYRJdoQb3NzaV20fLsEgkWq6yA8nfNtxW/kRTdV1Ya5mFhHybbrPnvnowWbdj/x9KKHn7zrmhN7dqxP27B40bo5Ox68+xoc/8Bj10ysnhiqntqn3/UTh8y9f0D9gLqK65uL866fpOUJl8+ROXwJ+Ot+wSSryW7XEZ1B5twui8Vk1dusNogtrDwqbY9nVZcdiMtu99e9ctLU8jt4NHDZxTigJiYOFz49oqR0xIrFTzyRG8DF7FDdQKkq7tGnyP6+Pc6zC7Xhqtu0PfAtoFuEKwZ5yQm6TaJowLJscNjNRp3NanSqOh2V5YCtozrjaJauBVyKOmPTkpWvv9xYYxMmQLC5jCsOBzetfuNTUnfp0JoteBk5Gs0V6VaY0wjabIegRG8gYCgN1GzSg0EGchTnFgc6Betqjhzoo1RA8SY2vBl7rkoQMrOwp5kNh2kS759w73Ry9tIhZfxkhPgtMH48KodozWvQ22QuHjl1ooXTW5xeyNcpx4FvtVCzWeeR9Vakc7Yl7W4la4/O3pa2q+aLQuRtxcq2kF1di127Kvk7F/+ju4vg7PFzI3trwvZCu9Av/vP606WSoCvdPIZ9SD4oW162MpwFK13yryn/GkIeCk/8obw/jidTlSXDmvOBJkdUmgSCXh1ktgQbjAjzgmgUgC7UyGGrzuj8k4xdS9bVrN2PD7FF0/FA3H8yW4pX3My2sGcmk2wisT747fBP4ffx1yw+krMzh8oHpX/Io9NjFGfggRsy5/VwcTpktdjBpkUcdCA7hibKlHLAbosgrzQcqnpSRPKbv7kpQeg28ptm5ulXNbG8oKTvNYGK4mEmwHw9+7bxDozI8Evyo5P6OGulnLEf+yL5Pa2HdVwxvwfpt6r5fWlI8aN/md/T+tbfyaLwFvJBeBZZWkyfqSturdPwLYT8fink1okoP+j1GmzUZUGQWosGmpzkMRiMRplyNrltm7S9WmGLmiAe1N6pqFrvjLwinCdLaRC1O+XIfhxeNGv54ae+mTsJj18yr65xdCi+eSy9cc06PPQEV0Uam/AInCXU8xPGs5N3LnDqHPNvVdeFW5lA6gSPFjMQpVkSCJIQEzMoRXTcOny44Pnt34BHKeCxBvBIUvCgDmO8VZeU5Ha442lKMudw2O2meK/R9H/DAyutvxD5gkPOyFMCAgUvQUHEr+CFK0KjR4duXbp97+Q53zx1eNkcnHHrfIfOsWAh7jVuIl+/dg3bOGY0qeJOsOfXPnQjGTtOq2+S8ZyfFoICdw/GWZS0w2Yx2hagFmG+8LhAhaDeXCqg7KyGgPdE7hvSG5H2QAxZT56SebtdkTwIxCkdV/SaedWk2wonjb19xFUTi3KmDbrl0Xnk+8J+I6bEd+9bGBzVK1gaiQ82s8W4FOy8EsMqPfJEaTa1Am8FSKiMQxVvd4UeedBef3vXxAeFibMcWsMEOXbpdf6mmF6JU+BHTvDHQW5GBvvpxIQEcKjuRC45SW8dEhKQfof+oP49PWejen2iiOIh0g9J8SnxOfF0VPzU+AXxND4+URQTPUjtXW6YplWZteQlkNXBlkPA0tumdGV3TqqzsNNP6veeOLG32rJwRfLd4149/tauhfdOecxUvT8Jp/7wHc7ybd+cXxP437mzF/oOv+odWHcFxGq9+LdATiqD3ThdghUhE68zmZ1JQkoyMlvMlaEEi0W02+OGhOyijhNFriIkxnVUsrjsQExVPJohKiIPjkZVAn9eQI7xjOCA8LqSCprZmjjl1lOn3nj5+bX+x5YsW4zXkk2X0S0bckbVOHfeg0k1znzns4G1AzZuZaeqVT7OxwZO4taD3c5ANcH4ZJRmQYTXmyyS3e01ZHaNswVNjlKbkzMoXfFx8Nlgl9xek54nugQxtcW53HnGSZ1K++vfc90FR7NyJXh18OiiW8xQvLqYkQ8pYH5GvltZeL5bdOFofKhUfc7UL+23eMqaRyYu6be0Hj4vGffY2psWw2d2092v7V909/7XyKmHblp29f0NDfdfvWzCmgdbop9bWNqBxfe+/vq99x5UZUfpKRwDuupCTcG+SJSo0WhScbI5IRsSbHZbZQhRqz3ZTvQUNNdpsFgtlSFxvnW59XErtVpN2CmY4rTiaVtfb0R2OnDGHSmnAlucbd2+yj8cIGVKcbUKx7PtuJptv4k9j4fCy8WqZ5BHaULrueoT1ewk7gUX6lB1KsYmieClbZSAKeb0OkpFjhPBaqrmCfQpqlJal3FAzZVUW6VYqzAX/jrMaXtLl1vpPTBeDipCVcEeefHdkq7yXE1tQi+wdYLRE5+UpgsWX02dNC++B/Xp9dZBIT3yZQwK+Zzt8Zm74A+t8NFm+GgeL/bEbdshkPK39cl12DjJj/bGwV8WvHJsXW3F8e3PP+G/8Z4hdy8PzF5wcMXe2tovjg5fX7t7zcYtufPnv7libPGqHdV1wUc2DG2iPYYtTc+eMnTGomBVqjc0uM+1RVnBxc3bxnabVH3PyqS0kRVNN+b3H9Bz0OJp/StKizOnB4uqynLdUxW6VvFuWs4fRjoko6SgSW/hkQXZbSYqiSi707EbBR+lbygt+gFXJacEg8X4NvXCT+7Ztba2VnnTzhyMuXxOGAh2yonSUB6qCGZTS8+kdJfOYncl8fl9YEZZkj+Xf5I5wWg1Jhv/Y7xs5GSjbEzN9XLdUu3R4CI7u0EONHRucWq3RdETFKDwuLfW/+N0KP16XUi+w8YFcrvYor1C9I77n1j9QM305gmvHv9s76xJaY2t97yJR7ytvF5nG987yTYebngB5+zcibN3PsdOvLSDndzJDXxty96dWXU9vvnnexd6D+vBHlJ/wja+fYRtfu8krj+6k72/U/nVdtxzzwvsHZCvCuojA/ljoGc+pZPAgBMTXW5BkF3Un5pkMNi9QCCJEmqxJwOaf294Q/WMnbaEMiKoxdaDnXKaGuaqFWGCPDUzR07d8MTI8oE3TPbNmP4VG1NSWH9T3S1zaY/Smsb6MeN0XNaQwb0GXfUBK9zVp2jM8CAvFML6qtFttAd9Bik13x5BFxUMZsIZ9XrOLHAWK5jlkRgrDXGBN3I7xXZ27KZ2Eadpl2qcV8RYETuOx+M+hYwVsrdJMl6cxVazNVn4nvj2j9E+PwtnIa2Ih7gyhWAOC6KiytUhK5/NF/Mj+fn8cv55/gB/htfzkYa8N9pL9KoV4SzVrS+SVmbD66rR5cvRfn+bgJSDG1yb3IkRyWsK9jFaOJ3ZhCRJViXQZJFdSUJ+H6MVfJDNLFvlZJmINmSTbES2ybY/EUCVRX8856OFRIoyZ2EeHBH4cWXHWzno8xfiSI5MvXH8kSl47ZDSf8/52zNjTy1f38r9pTySjxtCW5+unJPKZuHx7GE6dR57468kUtkzuSg4OEFo1vZMEI+vtGfCCZd+VQrg1SAjS+kMchboqPQj+IOSTTAh5YyCtViP9U7KAXXeaIg1EPbo4R+Q2vyYCsfSbbffvm3b7Xc+Wz/3htpbZ4fqZ3Eb7nr66bvuenrzohtvn9cw/LYFqk1uQVg9V0IRcCVfjZ7bT4m00F2sov2gCK6uJpdizorkkTIyA9bqVqqGoGaEmGQ354nTW5KJC6do/SEdWojy8os6bLM4LAT7yIzwwZ9vG9EwZNLkXrMemneft88w9j98gJRV/HvOiiHXDavuP25+S3bNDQ2sVZPnTFJA7oB5/ag4mCbxHmRMdlDEC2ldqMNR6RzpbHFSozPeSZxOXYIv2azztTUONcRuP2onCyK14WiOH3OsQFskGV83aO8Lj6+Yfe+dN8+aNWvhPTdNGFG1YGb2nU/OX8mdq5jo6rH5zuVX1xU13jCsouaGIdcMrSgZoebVHfe/KKekM9wCfcf9L+XEFkS7oh8vHrTcu6zLtvEl3PeVr+TIvbfeoNZJmIOzqPlZcTBZzc1dLrfb4PXY40xmyNDjIEN3x0uQo0tt9ab2fefYxpiOqbq67ZWhlp+wZ8kKLWHPfXNG0+IA39QhZx/SkF8wvEIpOKnnTVgrVy04QFp6BJ0YcZAsGqksYV6ns/AWWhaygGwjpT02W+7Ae0U7/bJqXKU+AR9XPearMcHqfx7/6DuSzFqFvRdKaMB28RLmGFLsy0bSggfSgKT0QyOyUIujmAMru8GysqdpRJIZCWZqt5klyaqj8VaUXdzRoHcq32TkByDEW3zPnIHepKKK6kMNowY8wz4dM9ZYZ7iq94j47TPSYI5yiJP2qvvMSUEzQRSyboOOpggQQBfnFkdpGsnH5N75gpiBRwxvNHlPZvO7W1cRf9Pd7rlDtJykBPzRevBHRsUmBm0SMglIcEPCqXohuz75D9qMY44m8lL0GCNZv2H58kfXrbz/MUbef3/M5MljuBlPvLj1mY07tm9iv2Pdwvnz1flKwb/4I/4lM+g06jlAQCQGvWCxQvZsGsljXnUv2bEBsR5n2Gk+5rUL9bPjinPBeewhdlxxLjiPCGxWFp6AJ2axOfHtH1U+9UOIn8rvltLRrf9BUgY6RYqBQSL6OzkTfhnpX6REBtHNy1NgjQB7qwZ7QIXFv6qwt1ABYMWdxKqAInXcTID9gD8OsDOQNu4H2ri0JDJuljYu4F3GZtA0yP2SUFfQkhR/MkrSOa3OpGSuWybn8SQl2Xy+9KEhn6Q2c/s7bMr9oYsbrIEVqxtFgdxi7I5sD4OaFpFC3J4rkoLK0fWDijYtvW1SMK1ldcWe97sOWRS8Nik7mj+m3fb49ZWFsyrnPdwzvjIn5eiWkkmjWvJuHD3airOieSXgqfYqizfb0lEXFb9rLr+Jq5HuRSLx6Sgr74owM8GjqzBxfw5zBCVqMAmdYeLbYI4hToPxdIZxtsFMQMkAY9hFSbIKlNcGk9gGcxQlo0dVniTRCE8ugxbzv6v9e3Y0OdhPsNtl2WCxYB1S2h6xSbLxTofBXBayGrCRGgxYkGh5SJKwwNv0dsFeFhIotsT22mrtRgXZnXdTA9FOkrYykKy0bbd14Co7mfzv4QBL+7KFLKOTw4+QYPggGXfpDrxzjNq9HWnKJYT8rtLgDrC5e/jjgF86yJ6I5hJB/V7tq1Rp3DXCqxdU+mFzO/06w8xEJRqM889hjiBJg/F0hnG2wUxANpUPBCdE+XBZKXQG1XG6a+thV2nj8O3jHABmFMXAzLzcp/OaL38OMOkxMEfYSxqM3D4OryQu6no0mAkqjLIeh7Ye0MPsSO+2skdzY7CPGdl0LheHOAiBvB6nIAplIZtVLBZHii3icvFx8YAoGqkocnq9XB4CB+nq0N2N2oojf6g8qF3eSsmhreVb4XR72/eGDR0av/EaNqGt+ZtsHkF2Rvu/w8+MCO+K0ps7r+pGr4huzNBo4G2ngdorqtIpV6M3mvwH/ekMMxOCdhXG9+cwR9AhDSatM0x8G8wxtEGDSe0M42yDmaCOo+hq1whPMJqFCRfPbQLbmxSUEeEEnUEwm0bq5+vP6KkeebIbIodu9NitxyI4Az3OJ6X4kb5sPF7Tl93EJhTg1eymAmrCDyt/ji/AD6tv+KG+EDVq/bPnQMvjIR67PtjL5Qa760hwoAQD4nUGqw3CMvjKxfk8VpuO56hkFqjZNzhk5qgntr1W2daIPqyhzSJrTy2QkE8r16gd52qphkoZ2BVQGkvdWOlF11pvzz1eW1a/T+ko/W7DpNKWAy1Lw95FJ5Se0kuHl5IvF73V3oE7e3a/+W/iaUpP6ZyHr37kJFuN+z136ZcJSmMpe/M5ztDMtgKN1f5FlVdXRXheoMmFvZ0PnWFmop80mPg/hzmCVmowyZ1hnG0wE1QYRcdSO9jeAnWcqyNzZWrj2CLjxPQPG5FDOcMKcYdebSB2OfUOUDS9IJq48lC2CZtMQqSNONJU37GVuEMvceBK3cTNGLW3E1PD379gW/nd7Pe2hmKs9j4NFJJRb9Q/mMqnpCOvuUdPZE7p6eD75HnTpdyeztzM0lAuktylbSGs1o7yhx0O7BC145/uJBIt6ETPtGrPQYimF+r+oBpF0UNLh/ZLLOs/4cYeO9aPfDy7/9PXTp9TMWX+qP5lZf3vu2vlxqaTr+07zHNLW4KDMrrnDOgxuGniNeueS0uamJ4zecKwuYNvmF179Zi+BaP7NoxZMv/SAG73tn0rgQ9qX5rgAz4MjPiCmYAv6Ge63MbPjjACmpmoQvRUIa5w/8h76v3cDvf5t9ruH9um3s/ueP9w2/0JbyNV+/NkTfvb17CwDebo3zSYrlEY0GGAEZR9bcX25aM7g4PyEonJncT17p2VrdPZE/1ZypMqCO80ZcV02/HO3kmlIWvv5N7wZ+/evDNXUrrvPDanlJLBZ5SEkLJl2daoEFu07HS8qZ3PtkhPWQqNxF2xZZgUpU6r9EpJPm2LIKZHD6dQX+907mP2YfPANx9et/Vi61u3Ll71WNq2bZgPtpzbcyqch4dff+fk4Q+0zn/29Vc/3jeXzmNfJZHhax0YLbr1qRWP7tRFOvhOnWa/fF3Fesf1qM9MqG9r5aO72ZR9/1BpOos5lB45oGmJFh/gMu17pUdM5WepSutrnlL5lRjlV+f7M/up99P+7P6R39T7mR3uq/zW7k+4pPGyezu/L38GStegjvF6JCa4XpVLzLfL5USA+VcMzEz2hQZjboO5fBQMiSkG5ghbq8HI7TA/wDjfqut5PRITKDBqTCBHY4IZyjMXIF9MgDimMtjNnJiI/JAFyY44vlumzer2cnGS5DRRvT6lBEwTjXMimt6+IR+IBnyK5HRsz4k+mkE7EuzOJyB0+ekZ+S7VP9jE3m1bJ3245N/P/uNS+J+THr+WC55gP/f6tXZajwfHnu319qOP3PT6lld2vbb9xVdJNjvH3sfct19hOqCYYMtrjw15oKhg6LXli2vmPMQmffvAU2+9s/fkeS1uV3tgVN0cqunmZZU6sbzmClT6VWuycFTlpffP7s+coN5P/bP7Rwwx1iV6X51fu3/s3+p9f8f7h9vuTzBospIZo/ctWOL83Bp1z8yNhgcLdZzNBtmphXrinFJ16D1I8J2Ss8q5wsnpqVMwVoeCAhacAlLO8BaDm52Pl0dO8urVwmUgoJ1NBs2e1mFTSz3S25Y8tR+JbqG7wqe1lCmSOG2prsaLm5p69+wZvqVt/40CPp9yBdz4TnFGgiMBOdrjjGT4kvP4eJ3VpsQZZk9JyCwJlPoiAqWaIuX9T+OM6LaQ2tGqyBHvcKsnWvneSrwBoqR0Dm2bWVvaMAeTsy/OHVU2fmrr5gqS3Lhq12Hyc2n47IgVu45ofUSN0/rOfuSC0kk0fl7+4gd/fXMuOVT/2xf7Z4UHVF8CHql9FyqP6zQZeVqVIUeUh53vz2xW7yf82f0jFvV+Sof7qgxo9ydYNO30x/gHdf9fHWO4Nsfn6hiaHEZ7ntSexBSllyiOT7JZrZLEp/oMSEdkJMUTb0mISDpnaUj3F73LfaIPT2lrfJJFHNPxhD3T2Sff/vI3re+pScQ3P/0y23Ro23N0zf5oq5PW/KRDbM5vrduVtqe/XbCpbU9RXFR8NVwm3K3h2y7zkd48rji2N896xd48gNH2rH4SdvLHAP9kNCLY22q3u80oUanjSJwvxWqDBNYKCazyZoR01UixXUla9V71/JgzJsDt2LraqRlYS1yF6KFKd1v2yufmy5GzlsLOsKl8jHpkqgHnVtxEfghPI+PDD5PlrcMn9y+awi6yb7BHwitAMW/Ey2Qtq7XYuJ8l9gJ7kx1h26O6dE5MBn+vPHsrgMYF8yWakeN2Z/Ry+QwGV2IGl9dbooI5ByIya05yDrj3nBzB3KObuVtJyGaWvF2ELuDdhRjv/gfn3jF0U00An6qceGnrx3O5bb6Onc+xDXppWhc0v37dp/n9jj6iteo99GbBFOw7+FlYIEd2qh3RF788smv77r1bdx3mNq7dbiXLNjnuWbhgSbSB776l2K00SX/zjdokTfI+v/S/bz6/8NuF915/7bTWd5HFfUinCT6wgF2DNp3IUYPJbDaI1GoxcAvMOpSt9Cm0P9WlrWbrcjv9yplwP84qWprZOHB7ydymSdNKuO+v2XnN7IPS2AnTG9Q91Ju5j2masFCt56cEzdFnDjn1B61UGfydPy3/xVCDps0ePXq28mLrBxcVDa7oVzSY3zH6lltGj5gxs2HA4MEDgoPLNXziYb7T/FvIg9KDksutN7gN8V6XGZK+BXaEsnNjui6ie3pK7Kw8scCvNoa6NX4ELJiaulQUpRSm9LjaNsgwoSanqltqMLFnkVwuTeA+Tsvzdr32hpb5uakJ3QcNu2Wu2sNDEN3+F8+AqqbD254BBfDiX8KL7fCJ9BA2qeeL3EG9eipYj7joE8W0Rz5k9FEfCiZmmlKasvonXWukhxxTsevGsezNug5jiOoYSvFBx4kwxtH2knzkaRoYqc/QCMr8bgf77Z+jsH862JiB7ILyfCyIdo6jjEtXocALSFSe05eYWKpe7XbtarFoV5NJu+r1pSKSs5T/1JolrIOUqbjIKDUoGWSs43UWmbPbkJ4ztz1+sa2QHUXMF/2Am02pjd0GJA2wsooYZGdjy42N7FRzO9btc4lIUubSS1jkRLPE2WQzJynIB452mCtCAJ9b6EQJvNPcpbGrMmc7TRwL2PkbGnGPZs0GA33INJU+76r0yduJ//8JlKft83xL8kk83aDWLiQBIbNJrzzoYz79j3IUKruh7UlysZtg3w4dNGhodWlpNTkXunFE7fWjRkTOj92Gj6i18YSgmQqEU54bwkc2XN9of2ZIpx3W2H1VdZxSGGdv2zjASeWZKThSWW8fJ1JUx3uvVEOHcdgu+Gmhej7MGzSC7GNC2o6HYdVo5kaeYlbYenoEzWo7Hgb89JAyspLfhwwgOwODftGoJ4TKAhUM1G6zUFGQMc/r1f1VWaZiEk2JZPgB1RbHnpEAy6xuzjj9edpzqvx5yjPHMFl5Rz1rwg+NuuNjnZDMvqP9/vvfq8m14ROf3jXGlM1mqrQog/iijj+BuqE7glVmKqZ6xCTeaItPSukqds8SUnwplSHqUzq+fN4gmKH4ypC52Dvf+7yXzvcu9570/sd72csjr+Qleur1utLS0JBQmuiSrvSsqIZpqpfxxknvZuXG1AQjByqVBjJwmKLTofhOxYZpTWSI+vMC6Xn58G5TvY6YTv3bv8rE5xnhOHyIXZv0w55VS4cuve4r9n23XVs5buueDJzyUd0DgzPu4mdc+k/1+Lj+ruoPf+k/ItWjnAyqTh/cXI0lnJvatRbSMPR/AEBrj2YAAHicY2BkYGBglJyVkCS/JJ7f5iuDPAcDCJx8eyMGRv/b8o+NfR17MZDLwcAEEgUAeDUNxAB4nGNgZGDg6P27Akgy/Nvybyf7OgagCAq4BgCfMgc5AHicbZNBaBNBGIXfzPyzKdqDB0GkBBFPIZQgRUqR3EoJoQQJPXgoPZQgRSkSSgjiQYL0UEREhJ7KHiSUUiTkUJaQg1JClR7KHnJXwUMO9ixSQtc3YyuxdOHjzc7Mv7v/e7Nj+HvJdUATdYym7mPdZjEtb9EMaqjaPTxXG1jXkyiTvKxghWtPVQez+h0W1QDvdRc3ObdGvpAqWSJZ8oa8JKvkma/jfjLvxueYJcykbrDuCLCCWH6jYbepjwnv7SHv9xFrjtVJUhC3NoE4GHDtgJpGQ1pnyn2yyOfexRXWfJQQSN3BlJTY5wzZYh+v0XLfTJ3i+x+aYjKUUG1IHsvSQ2SOUKfWpYK6foS05DApHUQqxo6Kk9B88+ModQ2Rm5e23x+5GpNmfRcLukVPOtg1H9jTIW6ZIabd2LT5/j59XFBDasH1f+b9Nsd9UiIvvH/cI7fZU6geBDuo8JklU0PZ19B7NydITswqXvm5Nu6RjO/lAJHNo+r9biLL+Xn9A3OsL9hj3CdXSYbeF53vlxHUklOXhc9hBC3JPrP4RP1OtbaL3HkOF+F31Z26LEbxWTAz2aVvzvdLCHpY9llU/ocZfKX/T6ifyU/ZRO1fDhdxZ8wpsxjFZeGzpvosc2ikNrkvVFmyRiYEKI8RlUHa0+OZ53lwGGDWaAz0OPMcRwG/TvfosfsPin8AQyLe0gAAeJwl2btvJGd2BfDeQEk5mG3AgWObIk0BSwKtBqgpko40Ei0BjRlSLYls2v+D4836adq7SaNfaD6KmKfEhwKCpAbUgyRGwW5V13TgQP/ERg4cevbr3wY8KHyse8+pc6tu162vUCj8plD4p4Dv/c8/FApR9L+F9wpz7/4j4EphMeBDGMO1wt8H/PjddwE/edcK+CncgJ+9exPwMXwCN61vOf7CcdXxl/BrWMfVgE3Ygm3YgQnepzI8w/4cvoAv4Sv4DfzWmSfwFJ7Bc3gJr+A1/B6+hjfwB9p+hD/Bn+Ev4b8RfyL+RPyJ+BPxJ+JPxJ+IPxF/Iv5E/In4E/En4k/En4g/EX8i/kT8ifgT8SfiT8SfiD8RfyL+RPyJ+BPxJ+JPxJ+IPxF/Iv5E/In4E/En4k/En4g/EX8i/kT8ifgT8SfiT8SfiD9/V/hd4XXhQWH+3TjgB7AEy3AlaH5Q+OjdrwEfhvMfFGK4Bvec04N9OIBDOIJjuC/DATyERzCR500457eB67tCkZIiJUVKipQUKSlSUqSkSEmRkiIlRUqKlBQpKVJSpKRISZGSIiVFSoqUFCkpUjJXeC9wzRUiOB/+Oxf0zPB3vwn3U1A1Oy7DFec8DMrngp4ZzvTMBT2z//ZgHw7gEI7gGCbOf+M4k+1twPcLD0K29wtFOBf++37gehPw4bu/BIzhqvU1x+uwbqUBm7AF27ADE2dOZJ4GnHeN865x3tXNu7p5VzHvKuZdxbyrmHcV865i3lXM079A8wLNCzQv0LxA8wLNCzQv0LxA8wLNCzQv0LxA8wLNCzQv0LxA8wLN/xzu29+H5/hBcG8xMM7wH8PfIt5FORflXJRzUc5FORflXAzZZlHTgEscWOLAEgeWOLDEgSUOLHFgiQNLHFjiwBIHljiwHO6c3YARnLfyASzBMlyBH4UrWg7OzI5juBa8Wsa4jHEZ4zLGZYzLGJcxLoc7eZbhAB7CI5jI8zc9GSVvA5ZUp6Q6JS6VVKekOiXVKalOSXVKqlPiZImTJU6WOFniZImTJdUpqU5JdT4sPPj//wtYhHPhmfpQ5g/l/DDknK00YBO2YBt24ETsNGCZ8jLlZcrLlJcpL1Nelr9MeRlLmfIy5WXKy5SXKS9TXqa8THmZ8hV31Erht46Ljmf31YrfkRU1XVHTFTVdUdMVvy8r4ddkN+AnzvwUbsDP4ONwXSvh12SGm1a2HH/huOr4S4xfO96WeQfW4C78N9rqohqwCVuwDTtwz/k92IcDOIQjOIZPnf+M/ufwBXwJX8Fv4LfOPIGn8Ayew0t4Ba/h9/A1vIE/uLof4U/wZ3hLyRv4izP/5Er/DCecmT2tH4Ua/RqwCOdCBT8KbsywAZuwBduwAyfOnwZ8GDKMAxbhrL4PQ57vAs6HMx+G+s6wBMvwY1GfwE/hBvzMfx/DJ3DT+pbjLxxXHX8Jv4Z1XA3YhC3Yhh2458we7MMBHMIRHMOnWJ7B5/AFfAlfwW/gt/AEnsIzeA4v4RW8ht/D1/AG/oDxR/gT/Bm+gb84Z8LVacCYzzGfYz7HfI75HPM55nPM55jPMZ9jPsd8jvkc8znmc8znmM8xn2M+x3yO+RzzOeZzzOeYzzGfYz7HfI75HPM55nPM55jPMZ9jPsd8jvkc8znmc8znmM8xn2M+x3yO+RzzOeZzzOeYzzGfYz7HfI75HPM55nPM55jPMZ9jPsd8XtWXVvWlVX1pVV9a1QFWdYBVHWBVB1jVAVZ1gFUdYNVzt6b7rel7a+q1Fuo1O5733w9gCZbhx4F9LdRrhp/CDfiZ/87en9e8P6+Fes3Wtxx/4bjq+MtQhTXvz2uhs82i6hgbsAlbsA07cM+ZPdiHAziEIziGT3E9g8/hC/gSvoLfwG/hCTyFZ/AcXsIreA2/h6/hDfzBVfwIf4I/w795+4tzJvTP+ti6p2DdU7DuKVj3FKy7J9fdk+vuyXX35Lp7ct09ue6eXHc//It3+I/Du8dfAkYwg28DPrL+yPojvymP/KY88pvyyG/Ko+D87L+3jjPHs9hPwhS1GDCCGXwbcEPODTk35NyQc0PODTk35NyQc0PODTn/NeT8fcAIZvBtwM/l/FzOz53/ufMrukFFN6joBhXPfsVTX/FUVjxxFU9cxRNX8cRVPHEVT1zFE1fxxFU8cRVPXMUTV/FMPabhMQ2PaXhMwxPrT6w/sf7E+qb1TeubfNjkwyYfNvmwyYdNPmyK3RS7JXZL7JbYLbFbYrfEbondErsldktsdTavB4zgrGdWuVTlUpVLVT2zyqsqr6q8qupgVR2sqoNVdbCqDlbVwar8rPKzys8qP6v8rPKzys8qP6v8rPKzys8qP6uhvjOFbwN+5V76yr30lXvpK/fStmvZdi3b3vS2velt6z/bMmx7Q9uWZ9t72o6oHVE7onZE7YjaEbUjakfUjqgal2pcqnGpxp8af2r8qbn2mmuvufaaa6+59pprr7n2mmuvufaaa6+59ppr36Vwl8JdCncp3KVwl8JdCncp3KXw3z3LdRNo3QRa13vrem/dBFrXges6cN0EWjeB1k2gdRNoXYes65B1HbKuQ9Z1yLoOWdch6ybQuh5VN4HWTaANGho0NGho0NCgoUFDg4YGDQ0aGjQ0aGjQ0KChQUODhgYNDRoaNDRoaNDQoKFBQ5OGJg1NGpo0NGlo0tCkoUlDk4YmDU0amjQ0aWjS0KShSUOThiYNTRqaNDRpaNLQoqFFQ4uGFg0tGlo0tGho0dCioUVDi4YWDS0aWjS0aGjR0KKhRUOLhhYNLRpaNLRpaNPQpqFNQ5uGNg1tGto0tGlo09CmoU1Dm4Y2DW0a2jS0aWjT0KahTUObhjYNHRo6NHRo6NDQoaFDQ4eGDg0dGjo0dGjo0NChoUNDh4YODR0aOjR0aOjQ0KGhQ8N/mvr3sO9h38O7h3dP/j359+Tfk39P/j359+Tfk/m/ZPtv+Af4R9j1tHY9rV3zZte82TVvds2bXfNm17zZNW92zZtd82bXvNk1b3bNm13zZte82fXUdz3vPVw9XD1cPVw9XD1cPVw9XD1cPVw9XD1cPVw9XD1cPVw9XD1cfVx9XH1cfVx9XH1cfVx9XH1cfVx9XH1cfVx9XH1cfVx9XH1cA1wDXANcA1wDXANcA1wDXANcA1wDXANcA1wDXANcA1wDXANcQ1xDXENcQ1xDXENcQ1xDXENcQ1xDXENcQ1xDXENcQ1xDXENcI1wjXCNcI1wjXCNcI1wjXCNcI1wjXCNcI1wjXCNcI1wjXCNcY1xjXGNcY1xjXGNcY1xjXGNcY1xjXGNcY1xjXGNcY1xjXGNc+2bqfTP1vpl630y9b6beN1Pvm6n3zdT7Zup9M/W+mfpAhgMZDmQ4kOFAhgMZDmQ4kOFAhgMZDmQ4lOFQhkMZDmU4lOFQhkMZDmU4lOFQhkMZjmQ4kuFIhiMZjmQ4kuFIhiMZjmQ4kuFIhsQElJiAEr/UiQko0XMSPSfRcxI9JzEBJSagxASUmIASE1BiAkpMQIkJKDEBJSagxASUmIASE1BiAkpMQIkJKDEBJSagxASUmIASvS7R6xK9LtHrEr0u0esSvS4xASUmoMQElJiAEhNQYgJKTECJCSgxASUmoMQElJiAEhNQYgJKTECJCSgxASUmoMQElJiAEhNQYgJK9NvEBJSYgBIT0LHvhMe+Ex77Tnjsfj52Jx/7TnjsO+Gx74THvhMe+0547Dvhse+Ex74TPvVG/dQb9VNvy0+9LT+z/sz6M+vPrD+3/tz6c+vPrb+w/sL6C+svrL+0/tL6S+svrb+y/sr6K+uvrJ9YP7F+4g3/xBv+iTf8E2/4J97wT7zhn4g9EXsq9lTsqdhTsadiT8Weij0Veyr2VOyZ2DOxZ2LPxJ6JPRN7JvZM7JnYM7HnYs/Fnos9F3su9lzsudhzsediz8VeiL0QeyH2QuyF2AuxF2IvxF6IvRB7KfZS7KXYS7GXYi/FXoq9FHsp9lLsldgrsVdir8Reib0SeyX2SuyV2Cux12KvxV6LvRZ7LfZa7LXYa7HXYq/Fvg6xvwaMYAbfBryR80bOGzlv5LyR80bOGzlv5LyR80bOW1PDranhVv+/1f9v9aJbU8Otvn1rarjVve8w3mG8w3iH8Q7jHcY7jHcY7zDeYbzHeI/xHuM9xnuM9xjvMd5jvMf4xpvSn+zZ/RmmvpCnvoSndlpTO62pndbUTmtqpzW105raaU3ttKb6ZKpPpnZaU30ytdOa6pOpndZUn0x9/U59/U59/U59/U59/U59/U7ttKZ2WlM7ramd1tROa2qnNbXTmtppTe20pnZaUzutqZ3W1E5raqc1tdOa2mlN7bSmdlpTO62p7pfqfqnul+p+qZ3WjD8ZfzL+ZPzJ+JPxJ+NPxp+MPxl/Mv5k/Mn4k/En40/Gn4w/GX8y/mT8yfiT8SfjT8afjD8ZfzL+ZPzJ+JPxJ+NPxp+MPxl/Mv5k/Mn4k/En40/Gn4w/GX8y/mT8yfiT8SfjT8afiZ3fiZ3fiZ3fiZ3fiWliYud3Yud3Yud3YqaY2Pmd2Pmd2Pmd2Pmd2Pmd2Pmd2Pmd2Pmd2Pmd2Pmd2PmdmDUmdn5zNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI1yNcrVKFejXI2majRVo6kaTdVoqkZTNZqq0VSNpmo0VaOpGk3VaKpGUzWaqtFUjaZqNFWjqRpN1WiqRtNZjf4KjUi9gAAAAAAAAAAAAAAALABSAOABaAHcAlwCdgKiAtADAgM2A1IDagOGA6QD5gQOBFIEtgT8BUgFrgXWBk4GuAbyBywHUgeGB6wICAiYCNgJNgl2CbAJ7AogCnAKpAq6CuILGAs2C3oLrgv4DDYMkgzmDToNXg2SDcIOGg5UDoIOtg7aDvgPGg9ED1wPfg/gEDYQcBDCERYRWBH0EjASXBKcEtgS8BNIE4ITxBQYFGoUnhTuFTAVahWaFfQWLhZyFqYW8hcKF1YXkheSF8IYHhh2GOAZPBlkGegaFhqUGuQbIBtKG1Ib3hv2HC4cTByIHNwc/h1GHXodhB22HdweFB5OHmQeeh6QHu4fAB8SHyQfNh9IH1ofuB/EH9Yf6B/6IAwgHiAwIEIgVCCyIMQg1iDoIPohDCEeIU4hviHQIeIh9CIGIhgiXiLKItwi7CL8IwwjHiMwI8gj1CPkI/QkBCQWJCgkOiRMJF4kyiTaJOok+iUKJRolLCWCJewl/CYMJhwmLiY+JpQmpia+JygnrifeKBYoVChsKIQopijGKOopIClWKXwpoinGKeoqCCpMKtAAAAABAAAA1gBBAAUAPwAEAAIAEAAvAFwAAAE1AKMAAwABeJydlLtuE0EUhv+NbZKQO1BQRNEgIYFQvLZTQSQkclOIZCVSgtKQZrI7WU9i71qzYwWnp0ZC4g1o0sAL8AyUFBQUVNBQUnNmfJI4FyKBrZn9dnzmn7P/OWsAM0GKAL3PE1jmABP4zDyAQfxiLuB+8Iy5iIngNXMJo8FH5hsYD74yD2Jz4A3zEO4URplHMF14yTyKsPCFeQxhMWIex6PiD+ZJDJceME+hVHpKmQTFYbozPivHAWbwgXmAdn9jLuA5fjMX6XkVcwl3g3fMNzAdfGIexPvgJ/MQHg58Zx7B48I95lHsFF4xj2GnWGIex4viW+ZJ3CrdZp7CzVINy9BIaFgaR1CIIWhIupdEETK00aUnclENWhU4pjGHKmo0ykw1zNLqKkVnFNckHYElYkO73Sy9foYUIbCsE231kYpFLK0UUdbuGp00rDgWc9VatUxTbVasZlnSVGIpM+3MSKuzlLZukJ4iFYEt0kyRE9VPc8NGW6ViS6a5qDtBYJOiE3QoI+mqsqmSTlMSLNDOyCvFNBtSKdO4Xl1gkZQ0aTmP3NNXSSiPVBorI8riwuFisaObsahVq/+e9rZPKmfL3GGhPxDbyuTkhKiFtT7ZE9HyRVGnWWbNq3LQfnaFtr5IzoyWt+qA1jLsXSqq9JYJH9Wl665fNd5mp2Z95r020v60yK+4durd75OJxsfGNEenjZG71jhzQudCCmtkrFrSHIhs76QhZBqLluyKXSWMSnRulaFO0qmIlLGSrvsdo/NYR65l8vCqWl/dmWe17Os5eDMtBc+jQt9D/w1p23nRiCVDTy2KRMPa9nylcnh4GEpWjkg4jLJW5f9lLdne9gYr3yAJxfaaJfSaLSrUtUfbblvFKtdJSr0UNmyL4uu+EspXoVe7Tp9dloRdlRfoYElxvbvze9zrf7Fr5ygl6tK6pgxyqlHHm2sbSiy0ZUQX/mVWnLT1XFj9uzNnh4felYR+bZ5LIqeVOtaovitYpzZf8f9PPol+R/zhYWaSSrOXQF6pry2trG+tlH0Cl9+Us75E/yvWe7P+AKTJTdoAeJxt0MdvzQEAwPHPa19Vqb333qv2HqW1996rXqnRV7/n1V6xCSESTsS6EHtHjANir9gHznbsK42zT/L9B74S/PMnW7b/eVFQSIJEYUkKSVZYiiKKSlVMcSWUVEppZZRVTnkVVFRJZVVUVU11NdRUS2111FVPfQ001EhjTTTVTHMtpGmpldbaaKud9jroqJPOuuiqm+56SNdTLxky9dZHX/30N8BAgww2xFDDDDfCSKOMNsZY44w3wUSTTDbFVNMcddBa61yxyzvrbbPFHocdCiXYHEq0xk7f/bDVbhtd99Y3ex3xy0+/HXDMHbccN12W7Wa4J+K2ux6574GH3hfce+qxJ06Y6asdBd+eeW6Wjz7bZLYcc8wzV659oubLE4iJWyDfQh8sssRiSy23zEX7rbTCKqt98sUlL510yitvvHbaGeddcMNZ59y0wVXXXA6FQ0nJ8dyctLT0jJRofiSIZUWDSGp2NB7E4nmRICcahDPjQfQvuKxrVHicbUy9TsJQGL0fF0qIw4caCQbxAxUcuhjuYOIiYbhWKgItX1IgYXJnKCZuGI0JC+rg7iNwu5G4+AY+io9Qy+4ZTs7J+Wl+5wa6Sr4Xk6cD6ulnqjoVroBkciQfypi6nYBuOx51dJ9OVZ3r2KCaOuF9VeSskmwlnZt2l9z2A7X1Be2qHc4k+3SSkQSUl3IlpXWd3Dv6ia70B23pkk6df2k4Vkd8oEpcUHu8Dch5hYzYxRThHD/xB9OIbxijtFIgGJTgqZiLlfgV6byAxwJkYA3v0cC3bXedjT3X5HpjAwtT8zfc7I+MtTCCR+MgAngdviyXolV2TcMPzFl56Jq7RFTKUUG0hmFo25Nwdm9vMJskbmPt/1Gc/AGZGE4y) format(\'woff\');',
	'}'
].join('\n')));



/**
 * Spirit of the calendar.
 * @see	https://github.com/Tradeshift/Apps/pull/707
 * @extends {ts.ui.Spirit}
 * @using {Object} locale (ad-hoc localization config)
 */
ts.ui.CalendarSpirit = (function() {
	/**
	 *
	 */
	function getRelativeYear(year, diff) {
		return parseInt(year, 10) + diff;
	}

	function getLocale() {
		return ts.ui.DatePicker.localize();
	}

	/**
	 *
	 */
	function getRelativeMonth(year, month, diff) {
		month = parseInt(month, 10) + diff;
		year = parseInt(year, 10);
		if (month < 0) {
			year = getRelativeYear(year, -1);
			month = 11;
		} else if (month > 11) {
			year = getRelativeYear(year, 1);
			month = 0;
		}
		return {
			year: year,
			month: month
		};
	}

	/**
	 * Exposed for easier unit testing.
	 */
	ts.ui.__generateDays = function(year, month, currentYear, currentMonth, currentDay) {
		year = parseInt(year, 10);
		month = parseInt(month, 10);
		currentDay = parseInt(currentDay, 10);
		currentYear = parseInt(currentYear, 10);
		currentMonth = parseInt(currentMonth, 10);

		var numDays = ts.lib.Date.getDaysInMonth(year, month);
		var startDay = (ts.lib.Date.getFirstDayInMonth(year, month) -
			getLocale().firstDay + 7) % 7;

		return actuallyGenerateDays(
			year,
			month,
			currentDay,
			numDays,
			ts.lib.Date.getDaysInMonth(year, month - 1),
			startDay,
			Math.ceil((numDays + startDay) / 7), (year === currentYear &&
				month === currentMonth), (year === ts.lib.Date.getCurrentFullYear() &&
				month === ts.lib.Date.getCurrentMonth())
		);
	};

	/**
	 *
	 */
	function actuallyGenerateDays(
		year,
		month,
		currentDay,
		numDays,
		numDaysInPrevMonth,
		startDay,
		numRows,
		selectedIsVisible,
		todayIsVisible
	) {
		var row, col, cells = [];
		for (row = 0; row < numRows; ++row) {
			for (col = 0; col < 7; ++col) {
				var i = (row * 7) + col,
					day = i - startDay + 1,
					tempRow = null,
					newDate;
				if (col === 0) {
					cells[row] = [];
				}
				if (day > 0 && day <= numDays) {
					tempRow = cells[row];
					tempRow[col] = new Cell({
						today: todayIsVisible && day === ts.lib.Date.getCurrentDay(),
						selected: selectedIsVisible && day === currentDay,
						year: year,
						month: month,
						day: day
					});
				} else if (day <= 0) { // cells from the previous month
					newDate = getRelativeMonth(year, month, -1);
					tempRow = cells[row];
					tempRow[col] = new Cell({
						year: newDate.year,
						month: newDate.month,
						day: numDaysInPrevMonth + day,
						prev: true
					});
				} else if (day > numDays) { // cells from the next month
					newDate = getRelativeMonth(year, month, 1);
					tempRow = cells[row];
					tempRow[col] = new Cell({
						year: newDate.year,
						month: newDate.month,
						day: day - numDays,
						next: true
					});
				}
			}
		}
		return cells;
	}

	/**
	 * TODO (jmo@): This is a temporary hack to emulate translation.
	 * @param {string} term
	 * @return {string}
	 */
	function t(term) { // eslint-disable-line no-unused-vars
		return term;
	}

	/**
	 * One of these things for each day in the calendars "view".
	 * The view may contain cells for previous and next month.
	 * @param {Map} data
	 */
	function Cell(data) {
		gui.Object.extend(this, data);
	}
	Cell.prototype = {
		year: -1,
		month: -1,
		day: -1,
		today: false,
		selected: false,
		next: false,
		prev: false,
		stringify: function() {
			return JSON.stringify(this);
		}
	};
	Cell.parse = function(string) {
		return new Cell(JSON.parse(string));
	};

	return ts.ui.Spirit.extend({

		/**
		 * Selected date in the form of YYYY-MM-DD (as defined in RFC3339.)
		 * @type {string}
		 */
		value: null,

		/**
		 * Min date in YYYY-MM-DD.
		 * @type {string}
		 */
		min: null,

		/**
		 * Max date in YYYY-MM-DD.
		 * @type {string}
		 */
		max: null,

		/**
		 * @type {function}
		 */
		onselect: null,

		/**
		 * Load default template and
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.event.add('click');

			// if supplied, import settings from the {ts.ui.DatePickerModel}
			if (this._ismodelled()) {
				['min', 'max', 'value'].forEach(function(key) {
					this[key] = this._model[key];
				}, this);
			}

			// compute the setup
			if (ts.lib.Date) {
				this._labels = this._generateLabels();
				this._today = ts.lib.Date.getCurrentDay();
				this._current = ts.lib.Date.dateStringToObject(this.value || 'today');
				this._year = this._current.year;
				this._month = this._current.month;
				if (this.min) {
					this._min = ts.lib.Date.dateStringToObject(this.min);
				}
				if (this.max) {
					this._max = ts.lib.Date.dateStringToObject(this.max);
				}
			} else {
				throw new Error('Dysfunction');
			}

			// load EDBML and render
			if (!this.script.loaded) {
				this.script.load(ts.ui.CalendarSpirit.edbml);
				this._render();
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			var node = e.target;
			if (e.type === 'click') {
				if (this._doaction(node.parentNode, node)) {
					e.stopPropagation();
					e.preventDefault();
				}
			}
		},

		// Private .................................................................

		/**
		 * Optional model.
		 * @type {ts.ui.DatePickerModel}
		 */
		_model: null,

		/**
		 * Tracking the zero-based month.
		 * @type {number}
		 */
		_month: -1,

		/**
		 * Tracking the year.
		 * @type {number}
		 */
		_year: -1,

		/**
		 * Short weekday names.
		 * @type {Array<string>}
		 */
		_labels: null,

		/**
		 * Today is the day (as an object).
		 * @type {Map}
		 */
		_today: null,

		/**
		 * @type {Map}
		 */
		_current: null,

		/**
		 * @type {Map}
		 */
		_min: null,

		/**
		 * @type {Map}
		 */
		_max: null,

		/**
		 * Perhaps execute action for something that was clickped upon.
		 * @param {Element} parent
		 * @param {Element} child
		 */
		_doaction: function(parent, child) {
			var testnode = (parent.localName === 'button' ? parent : child);
			switch (testnode.name) {
				case 'accept':
					this._select(
						Cell.parse(testnode.value)
					);
					break;
				case 'nextMonth':
					this._nextMonth();
					break;
				case 'prevMonth':
					this._prevMonth();
					break;
				case 'prevYear':
					this._prevYear();
					break;
				case 'nextYear':
					this._nextYear();
					break;
				default:
					return false;
			}
			return true;
		},

		/**
		 * Select cell. Called fromt the EDBML template.
		 * @param {Cell} cell
		 */
		_select: function(cell) {
			var month = cell.month + 1;
			var day = cell.day;
			if (month < 10) {
				month = '0' + month;
			}
			if (day < 10) {
				day = '0' + day;
			}
			// TODO (jmo@): support preventDefault and return false for this callback
			this.value = cell.year + '-' + month + '-' + day;
			this._current = ts.lib.Date.dateStringToObject(this.value);
			if (cell.prev) {
				this._prevMonth();
			} else if (cell.next) {
				this._nextMonth();
			} else {
				this._render();
			}
			if (this.onselect) {
				new Function(['value'], this.onselect).call(this, this.value);
			}
			if (this._ismodelled()) {
				this._model.value = this.value;
			}
		},

		/**
		 * View previous month.
		 */
		_prevMonth: function() {
			var newDate = getRelativeMonth(this._year, this._month, -1);
			this._month = newDate.month;
			this._year = newDate.year;
			this._render();
		},

		/**
		 * View next month.
		 */
		_nextMonth: function() {
			var newDate = getRelativeMonth(this._year, this._month, 1);
			this._month = newDate.month;
			this._year = newDate.year;
			this._render();
		},

		/**
		 * View previous year.
		 */
		_prevYear: function() {
			this._year = getRelativeYear(this._year, -1);
			this._render();
		},

		/**
		 * View next year.
		 */
		_nextYear: function() {
			this._year = getRelativeYear(this._year, 1);
			this._render();
		},

		/**
		 * Generate short weekday names starting from locale first.
		 * TODO (jmo@): Move to static variable since it's always the same.
		 * @return {Array<string>}
		 */
		_generateLabels: function() {
			var labels = [],
				i;
			for (i = 0; i < 7; ++i) {
				labels.push(
					getLocale().dayNamesMin[
						(i + getLocale().firstDay) % 7
					]
				);
			}
			return labels;
		},

		/**
		 * @return {Array<Cell>}
		 */
		_generateDays: function(year, month) {
			return ts.ui.__generateDays(
				year,
				month,
				this._current.year,
				this._current.month,
				this._current.day
			);
		},

		/**
		 * Compute minimum day.
		 * @param {object} min
		 * @param {number} year
		 * @param {number} month
		 */
		_minDay: function(min, year, month) {
			var day = 0;
			if (min && year === min.year) {
				if (month === min.month) {
					day = min.day;
				} else {
					if (month < min.month) {
						day = Number.MAX_VALUE;
					}
				}
			}
			return day;
		},

		/**
		 * Compute maximum day.
		 * @param {object} max
		 * @param {number} year
		 * @param {number} month
		 */
		_maxDay: function(max, year, month) {
			var day = 0;
			if (max && year === max.year) {
				if (month === max.month) {
					day = max.day;
				} else {
					if (month > max.month) {
						day = 1 - Number.MAX_VALUE;
					}
				}
			}
			return day;
		},

		/**
		 * Run EDBML with computed arguments.
		 */
		_render: function() {
			var names = getLocale().monthNamesShort,
				year = this._year,
				month = this._month,
				mname = names[month],
				labels = this._labels,
				min = this._min,
				max = this._max,
				view = this._generateDays(year, month);

			var prevYear = (!min || year > min.year) ? 'prevYear' : '';
			var nextYear = (!max || year < max.year) ? 'nextYear' : '';
			var prevMonth = min && year === min.year && month <= min.month ? '' : 'prevMonth';
			var nextMonth = max && year === max.year && month >= max.month ? '' : 'nextMonth';
			var minDay = this._minDay(min, year, month);
			var maxDay = this._maxDay(max, year, month);

			this.script.run(
				labels,
				mname,
				year,
				view,
				prevYear,
				nextYear,
				prevMonth,
				nextMonth,
				minDay,
				maxDay
			);
		}

	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @param {ts.ui.DatePickerModel} opt_model
		 */
		summon: function(opt_model) {
			var html = ts.ui.datepicker.edbml(opt_model);
			var elem = gui.HTMLParser.parse(html);
			return this.possess(elem);
		}

	});
}());



/**
 * Spirit of the pager.
 * @extends {gui.Spirit}
 * @using {gui.Type} Type
 * @using {ts.ui.ButtonSpirit} ButtonSpirit
 * @using {gui.CSSPlugin} CSSPlugin
 */
ts.ui.PagerSpirit = (function using(Type, ButtonSpirit, CSSPlugin) {
	return ts.ui.Spirit.extend({

		/**
		 * Create the (default) model first so that it's
		 * ready to be configured via HTML attributes.
		 */
		onconstruct: function() {
			ts.ui.Spirit.prototype.onconstruct.call(this);
			this._model = new ts.ui.PagerModel();
		},

		/**
		 * Cleanup observers when destructed.
		 * TODO(jmo@): This should happen automatically!
		 */
		ondestruct: function() {
			ts.ui.Spirit.prototype.ondestruct.call(this);
			this._model.removeObserver(this);
		},

		/**
		 * Evaluate HTML attributes and load the script.
		 * Note that a NEW model may be assigned via the
		 * HTML atttributes (like in "ts.ui.pager.edbml").
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this._model.addObserver(this);
			this.script.load(ts.ui.PagerSpirit.edbml);
			this.script.input(this._model);
			this.event.add('click');
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			if (e.type === 'click') {
				var element = e.target;
				var button = ButtonSpirit.getButton(element);
				var model = this._model;
				if (button && !button.disabled) {
					this._update(button);
					this.tick.time(function unfreeze() {
						this._navigate(button, model);
					}, 30);
				}
			}
		},

		/**
		 * Total page count.
		 * @type {number}
		 */
		pages: {
			getter: function() {
				return this._model.pages;
			},
			setter: function(n) {
				this._model.pages = n;
			}
		},

		/**
		 * Current page.
		 * @type {number}
		 */
		page: {
			getter: function() {
				return this._model.page;
			},
			setter: function(n) {
				this._model.page = n;
			}
		},

		/**
		 * Open for implementation. Called whenever the model `page` changes.
		 * TODO: Rename this `onchange` when that method name refactoring is done.
		 * @type {function}
		 */
		onselect: null,

		/**
		 * Handle changes. Note that the model also has an `onselect`
		 * method, this evaluates the *spirits* `onselect` method.
		 * The timeout allows for the pager to update the selection
		 * before whatever big operation might happen happens after.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			var model = this._model;
			changes.forEach(function(change) {
				if (change.object === model && change.name === 'page') {
					this._onchange(change.newValue);
				}
			}, this);
		},

		// Private .................................................................

		/**
		 * The pager model itself.
		 * @type {ts.ui.PagerModel}
		 */
		_model: null,

		/**
		 * Update the button with DHTML for instant feedback before we change
		 * properties in the model (since we don't know what big operation might
		 * happen then). After the EDBML repaint, the result will look the same.
		 * @param {HTMLButtonElement} button
		 */
		_update: function(button) {
			if (button.getAttribute('data-page')) {
				this.dom.qall('button').forEach(function(b) {
					CSSPlugin.shift(b, b === button, 'ts-selected');
				});
			}
		},

		/**
		 * @param {number} index
		 */
		_onchange: function(index) {
			var callb = this.onselect;
			this.page = index;
			this.action.dispatch(ts.ui.ACTION_PAGER_SELECT, index);
			if (callb) {
				if (Type.isString(callb)) { // assigned via HTML attribute?
					callb = new Function(['index'], callb);
				}
				callb.call(this, this.page);
			}
		},

		/**
		 * @param {HTMLButtonElement} button
		 * @param {ts.ui.PagerModel} model
		 */
		_navigate: function(button, model) {
			var page = button.getAttribute('data-page');
			var jump = button.getAttribute('data-jump');
			if (page) {
				model.page = Type.cast(page);
			} else if (jump) {
				model[jump]();
			}
		}

	});
}(gui.Type, ts.ui.ButtonSpirit, gui.CSSPlugin));




/**
 * Spirit of the time.
 * @extends {ts.ui.Spirit}
 * @using {gui.Combo.chained}
 */
ts.ui.TimeSpirit = (function using(chained) {
	var mytick = 'mytick';
	var time = 1000;
	var issame = false;
	var firsttime = null;

	return ts.ui.Spirit.extend({

		/**
		 * Setup on enter.
		 */
		onenter: function() {
			ts.ui.Spirit.prototype.onenter.call(this);
			ts.ui.moment.suppressDeprecationWarnings = true;
			this.tick.add(mytick).start(mytick, time);
			this.att.add('datetime');
		},

		/**
		 * @param {gui.Tick} tick
		 */
		ontick: function(tick) {
			ts.ui.Spirit.prototype.ontick.call(this, tick);
			if (tick.type === mytick) {
				this._setText();
			}
		},

		/**
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.Spirit.prototype.onatt.call(this, att);
			if (att.name === 'datetime') {
				this._setText();
			}
		},

		// Private ......................................................

		/**
		 * Set the time to the element text
		 * Just show the datetime if it is an invalid time
		 */
		_setText: function() {
			var datetime = this.att.get('datetime');
			var realtime = this.att.get('realtime');
			if (!datetime) {
				return;
			}
			if (realtime && !issame) {
				this.element.textContent = this._getTime(datetime, realtime);
				this.element.title = ts.ui.moment(datetime).format('MMM Do YYYY, h:mm:ss a');
				return;
			}
			if (ts.ui.moment(datetime).isValid()) {
				this.element.textContent = ts.ui.moment(datetime).fromNow();
				this.element.title = ts.ui.moment(datetime).format('MMM Do YYYY, h:mm:ss a');
			} else {
				if (parseInt(datetime, 10) && ts.ui.moment(parseInt(datetime, 10)).isValid()) {
					datetime = parseInt(datetime, 10);
					this.element.textContent = ts.ui.moment(datetime).fromNow();
					this.element.title = ts.ui.moment(datetime).format('MMM Do YYYY, h:mm:ss a');
				} else {
					this.element.textContent = datetime;
					this.element.title = datetime;
				}
			}
		},

		/**
		 * Get the time base on the real time
		 * @param {string} datetime
		 * @param {string} realtime
		 */
		_getTime: function(datetime, realtime) {
			var newdatetime = null;
			var timespan = null;
			if (!ts.ui.moment(datetime).isValid()) {
				if (parseInt(datetime, 10)) {
					datetime = parseInt(datetime, 10);
				} else {
					return datetime;
				}
			}
			if (!ts.ui.moment(realtime).isValid()) {
				if (parseInt(realtime, 10)) {
					realtime = parseInt(realtime, 10);
				} else {
					return ts.ui.moment(datetime).fromNow();
				}
			}
			issame = ts.ui.moment().isSame(realtime, 'minute');
			if (issame) {
				return ts.ui.moment(datetime).fromNow();
			}
			if (!firsttime) {
				firsttime = ts.ui.moment();
				timespan = firsttime.diff(realtime);
				newdatetime = ts.ui.moment(datetime).add(timespan);
				return ts.ui.moment(newdatetime).fromNow();
			}
			var duration = ts.ui.moment().diff(firsttime);
			timespan = ts.ui.moment().diff(realtime);
			newdatetime = ts.ui.moment(datetime).add(timespan).subtract(duration);
			return ts.ui.moment(newdatetime).fromNow();
		}

	});
}(gui.Combo.chained));



/**
 * Spirit of the spin.
 * @extends {ts.ui.Spirit}
 */
ts.ui.SpinnerSpirit = (function using() {
	return ts.ui.Spirit.extend({

		/**
		 * Support `data-ts.spinning="boolean"` attribute.
		 */
		spinning: function(is) {
			if (is) {
				var opt = ts.ui.SpinnerSpirit.topbar();
				var top = this.css.contains('ts-topbarspinner');
				this.spin(this.element, top ? opt : null);
			} else {
				this.stop();
			}
		},
		/**

		 * Start spinning.
		 * @param @optional {element} element
		 * @param @optional {object} options
		 */
		spin: function(element, options) {
			element = element || this.element;
			var opts = ts.ui.SpinnerSpirit.defaults(options);
			if (this._spinner) {
				this.stop();
			}
			this._spinner = new ts.ui.Spinner(opts).spin();
			element.appendChild(this._spinner.el);
			if (opts.message) {
				this._textelement = document.createElement('div');
				this._textelement.className = 'ts-spinner-text';
				this._textelement.style.top = opts.top;
				this._textelement.style.color = opts.color;
				this._textelement.innerHTML = opts.message;
				element.appendChild(this._textelement);
			}
			if (opts.cover) {
				this._updateblocking(true);
			}
		},

		/**
		 * Stop spinning.
		 */
		stop: function() {
			this._updateblocking(false);
			if (this._spinner) {
				this._spinner.stop();
				this._spinner = null;
			}
			if (this._textelement) {
				this._textelement.parentNode.removeChild(this._textelement);
				this._textelement = null;
			}
		},

		// Private .................................................................

		/**
		 * ts.ui.Spinner
		 */
		_spinner: null,

		/**
		 * html element
		 */
		_textelement: null,

		/**
		 * ID (and classname) of the spinner cover.
		 * @type {string}
		 */
		_coverid: 'ts-spinnercover',

		/**
		 * Current dialog blocks?
		 * @type {number}
		 */
		_blocking: false,

		/**
		 * Update blocking status.
		 * @param {boolean} blocking
		 */
		_updateblocking: function(blocking) {
			if (blocking) {
				if (!this._blocking) {
					this._cover().fadeIn();
					this._blocking = true;
				}
			} else {
				if (this._blocking) {
					this._cover().fadeOut();
					this._blocking = false;
				}
			}
		},

		/**
		 * Get-create CoverSpirit for dialog things. First
		 * run creates the spirit and appends it to BODY.
		 * @returns {ts.ui.CoverSpirit}
		 */
		_cover: function() {
			return ts.ui.CoverSpirit.getCover(this._coverid);
		}

	}, { // Static ...............................................................

		/**
		 * Default or modified configuration.
		 * @param @optional {object} options
		 */
		defaults: function(options) {
			var opts = {
				lines: 12, // The number of lines to draw
				length: 22, // The length of each line
				width: 6, // The line thickness
				radius: 22, // The radius of the inner circle
				scale: 1, // Scales overall size of the spinner
				corners: 1, // Corner roundness (0..1)
				color: '#555', // #rgb or #rrggbb or array of colors
				opacity: 0.5, // Opacity of the lines
				rotate: 0, // The rotation offset
				direction: 1, // 1: clockwise, -1: counterclockwise
				speed: 1, // Rounds per second
				trail: 60, // Afterglow percentage
				fps: 12, // Frames per second when using setTimeout() as a fallback for CSS
				zIndex: 40000, // The z-index (defaults to 4000)
				className: 'spinner', // The CSS class to assign to the spinner
				top: '50%', // Top position relative to parent
				left: '50%', // Left position relative to parent
				shadow: false, // Whether to render a shadow
				hwaccel: true, // Whether to use hardware acceleration
				position: 'fixed', // Element positioning
				message: '', // Text under the spinner
				cover: false // Has a cover
			};
			if (options) {
				gui.Object.extend(opts, options);
			}
			return opts;
		},

		/**
		 * TopBar spinner modifications.
		 * @returns {object}
		 */
		topbar: function() {
			return {
				radius: 5,
				length: 5,
				width: 2,
				position: 'absolute',
				color: 'rgb(255,255,255)'
			};
		}

	});
}());



/**
 * @todo
 * - use css for icon shit instead of crappy JS
 */

/**
 * Spirit of the dialog.
 * @extends {ts.ui.Spirit}
 * @using {ts.ui.Note} Note
 * @using {gui.Type} Type
 * @using {gui.Client} Client
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} confirmed
 */
ts.ui.NoteSpirit = (function using(Note, Type, Client, chained, confirmed) {
	var CLASS_CLOSING = ts.ui.CLASS_CLOSING;
	var CLASS_CLOSED = ts.ui.CLASS_CLOSED;
	var CLASS_HAS_CLOSE = 'ts-has-close';
	var CLASS_YELLOW_BG = ts.ui.CLASS_BG_YELLOW;
	var CLASS_CLOSE_ICON = 'ts-icon-close';
	var CLASS_CLOSE_BUTTON = 'ts-note-close';
	var CLASS_HIDDEN = ts.ui.CLASS_HIDDEN;

	return ts.ui.Spirit.extend({
		/**
		 * Is the Note closing?
		 * @type {gui.Then|null}
		 */
		_closing: null,
		/**
		 * The previous visibility state
		 * @type {boolean|null}
		 */
		_prevIsVisible: null,

		/**
		 * Load edbml if we have a model.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			if (this._ismodelled()) {
				this.action.add(ts.ui.ACTION_SAFE_LINK);
				this.script.load(ts.ui.NoteSpirit.edbml);
				this.script.input(this._model);
				this._model.addObserver(this);
			}
		},

		/**
		 * Make background yellow & adjust container height if page-level Note.
		 */
		onready: function() {
			ts.ui.Spirit.prototype.onready.call(this);
			this.css.add(CLASS_YELLOW_BG);
			this._adjustVisible();
		},

		/**
		 * Adjust container height if page-level Note if values change.
		 */
		onrender: function() {
			ts.ui.Spirit.prototype.onrender.call(this);
			this._adjustVisible();
		},

		/**
		 * Handle closing transition event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'transitionend':
					if (this._closing) {
						this._closing.now();
						this._closing = null;
					}
					break;
				case 'click':
					this.$close();
					gui.Tick.time(function() {
						this.css.add(CLASS_HIDDEN);
					}, 50, this);

					break;
			}
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.Spirit.prototype.onaction.call(this, a);
			if (a.type === ts.ui.ACTION_SAFE_LINK && this._ismodelled()) {
				if (Type.isFunction(this._model.onlink)) {
					this._model.onlink.call(this._model, a.data);
				}
				a.consume();
			}
		},

		/**
		 * Handle (model) changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.Spirit.prototype.onchange.call(this, changes);
			changes.forEach(function(c) {
				if (c.object === this._model && c.name === 'open' && !c.newValue) {
					this.close();
				}
			}, this);
		},

		/**
		 * Make it closeable.
		 * @param {boolean} closeable
		 */
		closeable: function(closeable) {
			if (closeable) {
				var button = this.dom.prepend(ts.ui.ButtonSpirit.summon(document, {icon: CLASS_CLOSE_ICON}));
				this.css.add(CLASS_HAS_CLOSE);
				button.css.add(CLASS_CLOSE_BUTTON);
				button.event.add('click', button, this);
			}
		},

		/**
		 * Support alternative spelling (since none is more correct).
		 * @alias {ts.ui.NoteSpirit#closable}
		 */
		closable: function() {
			return this.closeable.apply(arguments);
		},

		/**
		 * Set icon.
		 * icon-class: gui.CSSPlugin.add(i, classname);
		 * @param {String} classname
		 */
		icon: chained(function(classname) {
			var i = this.dom.q('i') || this.dom.prepend(document.createElement('i'));
			i.className = classname;
			this._adjustVisible();
		}),

		/**
		 * Set text.
		 * @param {String} text
		 */
		text: chained(function(text) {
			var p = this.dom.q('p') || this.dom.append(document.createElement('p'));
			p.textContent = text;
			this._adjustVisible();
		}),

		/**
		 * Close Note.
		 * @returns {ts.ui.NoteSpirit}
		 */
		close: chained(function() {
			this.$close().then(function() {
				if (gui.Type.isFunction(this._model.onclose)) {
					this._model.onclose();
				}
				this._adjustPage(true);
				this._model.removeObserver(this);
				this._model.dispose();
				if (this._model === ts.ui.Note._model) {
					ts.ui.Note._model = null;
				}
				this._model = null;
				this.dom.remove();
			}, this);
		}),

		/**
		 * Get or set the buttons.
		 * @param @optional {Array<object>} opt_json
		 * @returns {ts.ui.ButtonCollection|ts.ui.ToolBarSpirit}
		 */
		buttons: confirmed('(array)')(
			chained(function(opt_json) {
				var buttons = this.model().buttons;
				if (arguments.length) {
					buttons.clear(); // reusing the collection to preserve observers
					opt_json.forEach(function(json) {
						buttons.push(json);
					});
				} else {
					return buttons;
				}
			})
		),

		// Private .................................................................

		/**
		 * Adjust Note visibility.
		 * @private
		 */
		_adjustVisible: function() {
			if (this._ismodelled() && this._model.onclose) {
				this.css.add(CLASS_HAS_CLOSE);
			} else {
				this.css.remove(CLASS_HAS_CLOSE);
			}
			if (
				(!!this.dom.q('p') && !!this.dom.q('p').textContent) ||
				(!!this.dom.q('i') && !!this.dom.q('i').className) ||
				(!!this.dom.q('.ts-note-buttons'))
			) {
				this.dom.show();
				if (!this._prevIsVisible) {
					this._adjustPage();
				}
				this._prevIsVisible = true;
				this._adjustContentPadding();
			} else {
				if (this._prevIsVisible) {
					this._adjustPage(true);
				}
				this._prevIsVisible = false;
				this.dom.hide();
			}
		},

		/**
		 * adjust the <p> padding right when the note has buttons.
		 * @private
		 */
		_adjustContentPadding: function() {
			var buttons = this.dom.q('.ts-note-buttons');
			var para = this.dom.q('p');
			if (buttons && para) {
				para.style.paddingRight = buttons.offsetWidth + 'px';
			}
		},

		/**
		 * Add mainContent margin and adjust scrolling.
		 * @param {boolean=} isRemove
		 * @private
		 */
		_adjustPage: function(isRemove) {
			if (this._ismodelled() && this._model.$isTopNote) {
				var height = isRemove ? 0 : this.box.height;
				var mainContentElement = document.querySelector('.ts-maincontent');
				mainContentElement.spirit.css.marginTop = height;
				ts.ui.get(document.documentElement).reflex();
			}
		},

		// Privileged .................................................................

		/**
		 * Start closing transition.
		 * @returns {gui.Then|null}
		 */
		$close: function() {
			if (!this._closing) {
				this._closing = new gui.Then();
				this.event.add('transitionend');
				this.css.add(CLASS_CLOSING);
				gui.Tick.time(function() {
					this.css.add(CLASS_CLOSED);
				}, 0, this);
			}
			return this._closing;
		}
	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @param {ts.ui.NoteModel=} opt_model
		 * @return {ts.ui.NoteSpirit}
		 */
		summon: function(opt_model) {
			var spirit = this.possess(document.createElement('div'));
			spirit._model = (opt_model || null);
			return spirit;
		}

	});
}(
	ts.ui.Note,
	gui.Type,
	gui.Client,
	gui.Combo.chained,
	gui.Arguments.confirmed
));



/**
 * Spirit of the Modal.
 * @using {ts.ui.ts.ui.ToolBarSpirit} ToolBarSpirit
 * @using {gui.Client} Client
 * @using {boolean} transition
 * @using {function} gui.Combo.chained
 */
ts.ui.ModalSpirit = (function using(ToolBarSpirit, Client, transition, chained) {
	var willopen = ts.ui.BROADCAST_MODAL_WILL_OPEN,
		didopen = ts.ui.BROADCAST_MODAL_DID_OPEN,
		willclose = ts.ui.BROADCAST_MODAL_WILL_CLOSE,
		didclose = ts.ui.BROADCAST_MODAL_DID_CLOSE;

	return ts.ui.Spirit.extend({

		/**
		 * Modal is open?
		 * @type {boolean}
		 */
		isOpen: false,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onopen: null,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onopened: null,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onclose: null,

		/**
		 * Open for implementation.
		 * @type {string|function}
		 */
		onclosed: null,

		/**
		 * Get ready.
		 */
		onready: function() {
			ts.ui.Spirit.prototype.onready.call(this);
			this.dom.hide();
			this._setup(this._panel());
			this.css.shift(transition, 'ts-transition');
		},

		/**
		 * Open AND close the Modal (setup to support the
		 * HTML attribute: `data-ts.open="true|false"`)
		 * @param @optional {boolean} opt_open Omit to simply open
		 */
		open: function(opt_open) {
			var then = this._then = new gui.Then();
			opt_open = arguments.length ? opt_open : true;
			if (opt_open !== this.isOpen) {
				if (opt_open) {
					if (this._execute('onopen') && this._confirmposition()) {
						this.isOpen = true;
						this._fadeIn();
					}
				} else {
					if (this._execute('onclose')) {
						this.isOpen = false;
						this._fadeOut();
					}
				}
			}
			return then;
		},

		/**
		 * Close the Modal.
		 * @returns {gui.Then}
		 */
		close: function() {
			return this.open(false);
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			if (e.type === 'transitionend' && e.target === this.element) {
				this.event.remove(e.type);
				if (this.isOpen) {
					this._fadeIn(true);
				} else {
					this._fadeOut(true);
				}
			}
		},

		/**
		 * Handle key.
		 * @param {gui.Key} key
		 */
		onkey: function(key) {
			ts.ui.Spirit.prototype.onkey.call(this, key);
			if (key.type === 'Esc') {
				this.close();
			}
		},

		/**
		 * Get or set the title.
		 * @param @optional {string} title
		 */
		title: chained(function(title) {
			var header = this._header();
			if (arguments.length) {
				header.title(title);
			} else {
				return header.title();
			}
		}),

		/**
		 * Get or set the buttons.
		 * @param @optional {Array<Object>} json
		 * @returns {ts.ui.ButtonsCollection|ts.ui.ModalSpirit}
		 */
		buttons: chained(function(json) {
			var footer = this._footer();
			if (arguments.length) {
				footer.buttons(json);
			} else {
				return footer.buttons();
			}
		}),

		/**
		 * Resize and reposition on startup and on `window.resize`.
		 * @overwrites {gui.Spirit#onflex}
		 * @param @optional {Function} callback
		 * @param @optional {Object} thisp
		 */
		onflex: function(callback, thisp) {
			var avail = window.innerHeight;
			this._autosize(avail).then(function(height, breaks) {
				this._position(height, avail, breaks);
				if (callback) {
					callback.call(thisp);
				}
			}, this);
		},

		// Private .................................................................

		/**
		 * Promise-like object for intercepting fadeIn/fadeOut setup.
		 * @type {gui.Then}
		 */
		_then: null,

		/**
		 * Fade in (start and done).
		 * @param @optional {boolean} done Animation finished?
		 */
		_fadeIn: function(done) {
			if (done) {
				this.key.add('Esc');
				this.css.remove('ts-opening').add('ts-open');
				this._execute('onopened');
				this.broadcast.dispatch(didopen);
				this._then.now();
				this._focus();
			} else {
				this.dom.show();
				this._cloak(true);
				this.broadcast.dispatch(willopen);
				this.onflex(function() {
					this._cloak(false);
					if (transition) {
						this.css.add('ts-opening');
						this.event.add('transitionend');
					} else {
						this._fadeIn(true);
					}
				}, this);
			}
		},

		/**
		 * Fade out (start and done).
		 * @param @optional {boolean} done Animation finished?
		 */
		_fadeOut: function(done) {
			if (done) {
				this.dom.hide();
				this.css.remove('ts-closing');
				this._execute('onclosed');
				this.broadcast.dispatch(didclose);
				this._then.now();
			} else {
				this.key.remove('Esc');
				this.broadcast.dispatch(willclose);
				this.css.add('ts-closing').remove('ts-open');
				if (transition) {
					this.event.add('transitionend');
				} else {
					this._fadeOut(true);
				}
			}
		},

		/**
		 * On Modal opened, focus the first focusable thing
		 * (having allowed the dev to focus something first)
		 */
		_focus: function() {
			var focused = document.activeElement;
			if (!focused || !this.dom.contains(focused)) {
				this.attention.enter();
			}
		},

		/**
		 * @param {boolean} hidden
		 */
		_cloak: function(hidden) {
			this.css.visibility = hidden ? 'hidden' : 'visible';
		},

		/**
		 * @returns {gui.Then}
		 */
		_autosize: function(avail) {
			this.css.remove('ts-overflow');
			var then = new gui.Then();
			var height = this._panel().naturalHeight() +
				(this.css.contains('ts-hasheader') ? 66 : 0) +
				(this.css.contains('ts-hasheader') ? 66 : 0);
			var breaks = height > avail;
			height = breaks ? avail : height;
			this.css.height = height;
			this.css.shift(breaks, 'ts-overflow');
			this.tick.time(function unflicker() {
				then.now(height, breaks);
			}, Client.isWebKit ? 100 : 200);
			return then;
		},

		/**
		 * Position Modal in the center of the screen.
		 * TODO: Position in golden ratio (and account for exit via screen top).
		 * @param {number} height
		 * @param {number} avail
		 * @param {boolean} breaks
		 */
		_position: function(height, avail, breaks) {
			this.css.top = breaks ? 0 : 0.5 * (avail - height);
		},

		/**
		 * Confirm panel, setup the header.
		 * @param {ts.ui.PanelSpirit} panel
		 * @throws {Error}
		 */
		_setup: function(panel) {
			var that = this;
			if (panel) {
				this.attention.trap(panel);
				this._header().buttons([{
					icon: 'ts-icon-close',
					onclick: function() {
						that.open(false);
					}
				}]);
			} else {
				throw new Error('Expected a ts-panel');
			}
		},

		/**
		 * Get spirit of the panel.
		 * @returns {ts.ui.PanelSpirit}
		 */
		_panel: function() {
			return this.dom.q('.ts-panel', ts.ui.PanelSpirit);
		},

		/**
		 * Get spirit of the header.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		_header: function() {
			var theToolBarSpirit = ts.ui.ToolBarSpirit; // TODO: Load this after!
			this.css.add('ts-hasheader');
			return this.dom.q('header.ts-toolbar', theToolBarSpirit) ||
				this.dom.prepend(theToolBarSpirit.summon('header', 'ts-bg-blue'));
		},

		/**
		 * Get spirit of the footer.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		_footer: function() {
			this.css.add('ts-hasfooter');
			var theToolBarSpirit = ts.ui.ToolBarSpirit; // TODO: Load this after!
			return this.dom.q('footer.ts-toolbar', theToolBarSpirit) ||
				this.dom.append(theToolBarSpirit.summon('footer'));
		},

		/**
		 * Confirm that we're not nested inside Main.
		 * @returns {boolean}
		 * @throws {Error}
		 */
		_confirmposition: function() {
			if (this.guilayout.outsideMain()) {
				return true;
			} else {
				throw new Error(
					this + ' must be positioned outside Main', this.element
				);
			}
		},

		/**
		 * Execute callback configured via HTML attribute or via JS property.
		 * The 'this' keyword points to the element or the spirit respectively.
		 * TODO (jmo@): convert potential string to function sometimes sooner...
		 * @type {String|function}
		 * @returns {boolean}
		 */
		_execute: function(callback) {
			if ((callback = this[callback])) {
				switch (gui.Type.of(callback)) {
					case 'string':
						return new Function(callback).call(this);
					case 'function':
						return callback.call(this);
				}
			}
			return true;
		}

	});
}(ts.ui.ToolBarSpirit, gui.Client, gui.Client.hasTransitions, gui.Combo.chained));



/**
 * Core GUI module.
 */
ts.ui.CoreModule = gui.module('core-gui@tradeshift.com', {

	/**
	 * Channeling spirits to CSS selectors.
	 */
	channel: [

		// stuff that the framework uses
		['html', ts.ui.DocumentSpirit],

		// stuff that developers use
		['[data-ts=Main]', ts.ui.MainSpirit],
		['[data-ts=MainContent]', ts.ui.MainContentSpirit],
		['[data-ts=Frame]', ts.ui.FrameSpirit],
		['[data-ts=Aside]', ts.ui.AsideSpirit],
		['[data-ts=SideBar]', ts.ui.SideBarSpirit],
		['[data-ts=Footer]', ts.ui.FooterSpirit],
		['[data-ts=Panel]', ts.ui.PanelSpirit],
		['[data-ts=Menu]', ts.ui.MenuSpirit],
		['[data-ts=Button]', ts.ui.ButtonSpirit],
		['[data-ts=Buttons]', ts.ui.ButtonMenuSpirit],
		['[data-ts=Link]', ts.ui.LinkSpirit],
		['[data-ts=Pager]', ts.ui.PagerSpirit],
		['[data-ts=Time]', ts.ui.TimeSpirit],
		['[data-ts=Note]', ts.ui.NoteSpirit],
		['[data-ts=Icon]', ts.ui.NextIconSpirit],
		['[data-ts=Spinner]', ts.ui.SpinnerSpirit],
		['[data-ts=Modal]', ts.ui.ModalSpirit],
		['[data-ts=Spirit]', ts.ui.Spirit]
	],

	/**
	 * This type of selector (as used a lot in forms) will slow the stuff down,
	 * but it does make the markup easy to author. We'll at least make sure that
	 * the channelings are not introduced before they needed.
	 * @see {ts.ui.ButtonMenuSpirit#onconstruct}
	 */
	channelComplexSelectors: function(enabled) {
		if (enabled && !this._channeled) {
			this._channeled = true;
			gui.channel([
				['.ts-buttons button, .ts-buttons a', ts.ui.ButtonSpirit]
			]);
		}
	},

	/**
	 * Setup plugins (for all spirits).
	 */
	plugin: {
		guistatus: ts.ui.StatusPlugin,
		guilayout: ts.ui.LayoutPlugin,
		attention: ts.ui.AttentionPlugin
	},

	/**
	 * 1. Setup special plugins for special spirits.
	 * 2. Use 'ts' instead of 'gui' for config attributes.
	 * 3. Support PolymerGestures in {gui.EventPlugin}
	 */
	oncontextinitialize: function() {
		this._commonplugins();
		this._documentplugins();
		this._guiattributes();
		this._defaultcolors();
	},

	/**
	 * Let the spirit know what attribute value we use to channel it
	 * so that it may add that attribute value as a CSS classname.
	 * TODO(jmo@): Split this up into something more readable :)
	 */
	onbeforespiritualize: function() {
		var ATTRIBUTE = /^\[data-ts=[a-zA-Z]+\]$/;

		function allcssnames(constructor) {
			return gui.Class.ancestorsAndSelf(constructor).map(function(c) {
				return c.$cssname || undefined;
			}).filter(function(cssname) {
				return !!cssname;
			}).join(' ');
		}

		gui.getChannels().map(function(channel) {
			var cssselector = channel[0];
			var constructor = channel[1];
			if (cssselector.trim().match(ATTRIBUTE)) {
				if (constructor.$cssname) {
					throw new Error(constructor + ' appears to be channeled twice? ' + constructor.$cssname);
				} else {
					var attval = cssselector.replace('data-ts=', '').slice(1, -1);
					var fixval = 'ts-' + attval.toLowerCase();
					constructor.$nicename = attval;
					constructor.$cssname = fixval;
				}
				return constructor;
			}
		}).filter(function(constructor) {
			return !!constructor;
		}).forEach(function(constructor) {
			constructor.$cssnames = allcssnames(constructor);
		});
	},

	// Private ...................................................................

	/**
	 * Complex selectors have been channeled?
	 * @type {boolean}
	 */
	_channeled: false,

	/**
	 * Override the {gui.EventPlugin} to add support
	 * for PolymerGestures and other special events.
	 */
	_commonplugins: function() {
		var override = true;
		ts.ui.Spirit.plugin('event', ts.ui.EventPlugin, override);
	},

	/**
	 * Special plugins for the {ts.ui.DocumentSpirit}
	 * to manage the layout model, dialogs and asides
	 * and root level panels (that create TopBar tabs).
	 */
	_documentplugins: function() {
		ts.ui.DocumentSpirit
			.plugin('layoutplugin', ts.ui.DocumentLayoutPlugin)
			.plugin('dialogplugin', ts.ui.DocumentDialogPlugin)
			.plugin('asideplugin', ts.ui.DocumentAsidePlugin)
			.plugin('panelplugin', ts.ui.DocumentPanelPlugin);
	},

	/**
	 * Use `data-ts` instead of `gui` for magic configuration attributes.
	 * TODO: Remove the deprecated 'ts' after a few iterations (perform boost!)
	 * @see wunderbyte.github.io/spiritual-gui/plugin-config.html
	 */
	_guiattributes: function() {
		gui.attributes = ['ts', 'data-ts'];
	},

	/**
	 * Assign a default "colorspace". This will cause
	 * reflow, so it's wise to hardcode it in the HMTL.
	 */
	_defaultcolors: function() {
		var cssp = gui.CSSPlugin;
		var html = document.documentElement;
		if (!html.className.includes('ts-bg')) {
			cssp.add(html, 'ts-bg-lite');
		}
	}

});



/**
 * Performs just-in-time channeling of spirits for complex selectors. These
 * selectors come with a performance hit, but they make forms easy to author.
 * Note: In V4, sometimes `ts-form` class is found on `fieldset` and random
 * elements, that's why we can't rely on the FormSpirit to do this thing.
 * @see {ts.ui.FormSpirit}
 * @see {ts.ui.FieldSetSpirit}
 * @see {ts.ui.LabelSpirit}
 */
ts.ui.FormSupportSpirit = (function() {
	return ts.ui.Spirit.extend({
		onconstruct: function() {
			ts.ui.Spirit.prototype.onconstruct.call(this);
			var module = ts.ui.FormsModule;
			var enable = !this.css.contains(ts.ui.CLASS_OPTIMIZED);
			module.channelComplexSelectors(enable);
		}
	});
}());



/**
 * Spirit of the form element (textarea, checkbox, input, select).
 * @extends {ts.ui.Spirit}
 * @using {gui.Combo.chained} chained
 */
ts.ui.FieldSpirit = (function using(chained) {
	return ts.ui.Spirit.extend({

		/**
		 * Shortcut `this.element.value` with an automated
		 * management of special classname for empty fields.
		 * Also fixes the (browser-inherrent) dysfunction
		 * where changing the value will move the caret to
		 * the end of the field.
		 * TODO: Global fix via https://github.com/wunderbyte/spiritual-edbml/issues/17
		 * TODO: Move this to {ts.ui.InputSpirit} please...
		 * @type {string}
		 */
		value: {
			getter: function() {
				return this.element.value;
			},
			setter: function(value) {
				value = this._evaluated(value);
				var idx = -1;
				var elm = this.element;
				var foc = document.activeElement;
				if (foc && foc === elm) {
					idx = elm.value.slice(0, elm.selectionStart).length;
				}
				elm.value = value;
				if (idx > -1) {
					elm.setSelectionRange(idx, idx);
				}
				if (!this.$destructed) {
					this._label(function(label) {
						label.$empty(!value);
					});
				}
			}
		},

		/**
		 * Attach to the DOM.
		 */
		onattach: function() {
			ts.ui.Spirit.prototype.onattach.call(this);
			this.tick.addStart(ts.ui.FieldSpirit.TICK_SYNC, ts.ui.FieldSpirit.TICK_TIME, this);
			this.event.add('focus blur');
			this.css.add(ts.ui.CLASS_FIELD);
			this.$updatestyling();
		},

		/**
		 * Account for strange Angular quantum effects.
		 */
		onasync: function() {
			ts.ui.Spirit.prototype.onasync.call(this);
			this.$updatestyling();
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			var model = this._model;
			switch (e.type) {
				case 'focus':
					if (model) {
						model.focused = true;
					}
					break;
				case 'blur':
					if (model) {
						model.focused = false;
					}
					break;
			}
		},

		/**
		 * Handle tick.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.Spirit.prototype.ontick.call(this, t);
			if (t.type === ts.ui.FieldSpirit.TICK_SYNC) {
				this.$updatestyling();
			}
		},

		// Privileged ..............................................................

		/**
		 * Style the form.
		 * @see {ts.ui.LabelSpirit#ontick}
		 */
		$updatestyling: function() {
			var required = this.att.has('required');
			var disabled = this.att.has('disabled');
			var readonly = this.att.has('readonly');
			this._label(function(label) {
				label.$fieldlabel();
				label.$required(required);
				label.$disabled(disabled);
				if (!this.css.contains(ts.ui.CLASS_FAKE)) {
					if (!this.css.contains(ts.ui.CLASS_NOLOCK)) {
						label.$readonly(readonly);
					}
				}
			});
		},

		/**
		 * Focus the field.
		 * @returns {ts.ui.FieldSpirit}
		 */
		focus: chained(function() {
			this.element.focus();
		}),

		/**
		 * Blur the field.
		 * @returns {ts.ui.FieldSpirit}
		 */
		blur: chained(function() {
			this.element.blur();
		}),

		// Private .................................................................

		/**
		 * Potential model going on.
		 * @type {ts.ui.Model}
		 */
		_model: null,

		/**
		 * Invoked when 'value' property gets updated on the spirit (not the element!)
		 * This method can be used for validation and type-coercion in sub-types.
		 * @param {string} value
		 * @returns {string}
		 */
		_evaluated: function(value) {
			return String(value);
		},

		/**
		 * Has containing LABEL? If so, run the optional callback action.
		 * @param @optional {function} Takes the {ts.ui.LabelSpirit} as argument.
		 */
		_label: function(action) {
			var label, result;
			if (this.dom.embedded()) {
				if ((label = this.dom.parent(ts.ui.LabelSpirit))) {
					if (action) {
						result = action.call(this, label);
					}
				}
			}
			return result;
		},

		/**
		 * Has containing fieldset? If so, run the optional callback action.
		 * @param @optional {function} Takes the {ts.ui.FieldSetSpirit} as argument.
		 */
		_fieldset: function(action) {
			var fieldset, result;
			this._label(function(label) {
				if ((fieldset = label.dom.parent(ts.ui.FieldSetSpirit))) {
					if (action) {
						result = action.call(this, fieldset);
					}
				}
			});
			return result;
		}

	}, { // Static .................................................................

		/**
		 * The `value` property of form fields cannot be observed for changes,
		 * so we start a periodic tick to perform this kind of syncrhonization.
		 * We do it in a way so that there's only a single setInterval involved.
		 * We also code it so that any delay is only visual (formdata remains sync).
		 * TODO(jmo@): Hook into Page Visibility API if the browser doesn't already.
		 */
		TICK_SYNC: 'ts-tick-forms-sync',
		TICK_TIME: (gui.Client.isTouchDevice ? 1000 : 500)

	});
}(gui.Combo.chained));



/**
 * Spirit of the textinput and textarea.
 * @extends {ts.ui.FieldSpirit}
 * @using {gui.Combo#chained}
 * @using {gui.Type} Type
 * @using {gui.Client} Client
 */
ts.ui.InputSpirit = (function using(chained, Type, Client) {
	return ts.ui.FieldSpirit.extend({

		/**
		 * @type {ts.ui.ValidityModel}
		 */
		validity: null,

		/**
		 * Icon to use, overriding the default (date, select, disabled, etc.)
		 * @type {String|function}
		 */
		icon: null,

		/**
		 * Function to execute on idle (pause).
		 * @type {string|function}
		 */
		onidle: null,

		/**
		 * Time before user is considered idle.
		 * @type {number} Timeout in milliseconds
		 */
		idletime: (Client.isTouchDevice ? 750 : 500),

		/**
		 * Function to execute on ENTER key.
		 * @type {string|function}
		 */
		onenterkey: null,

		/**
		 * Shortcut to 'this.element.disabled'.
		 * @type {boolean}
		 */
		disabled: {
			getter: function() {
				return this.att.has('disabled');
			},
			setter: function(is) {
				this.att.set('disabled', is);
			}
		},

		/**
		 * Shortcut to 'this.element.readonly'.
		 * @type {boolean}
		 */
		readonly: {
			getter: function() {
				return this.att.has('readonly');
			},
			setter: function(is) {
				this.att.set('readonly', is);
			}
		},

		/**
		 * Observe that model.
		 */
		onconfigure: function() {
			ts.ui.FieldSpirit.prototype.onconfigure.call(this);
			if (this._ismodelled()) {
				this._setupmodel(this._model, true);
			}
		},

		/**
		 * Release the validity checker.
		 */
		ondestruct: function() {
			ts.ui.FieldSpirit.prototype.ondestruct.call(this);
			this._discount();
			if (this._ismodelled()) {
				this._setupmodel(this._model, false);
			}
		},

		/**
		 * Attach to the DOM.
		 */
		onattach: function() {
			ts.ui.FieldSpirit.prototype.onattach.call(this);
			this.element.spellcheck = false;
			this.element.autocomplete = 'off';
			this.disabled = this.att.has('disabled');
			this.att.add('onidle idletime disabled');
			this.event.add('input change invalid');
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.FieldSpirit.prototype.onevent.call(this, e);
			var model = this._model;
			switch (e.type) {
				case 'keydown':
					if (e.keyCode === 13) {
						this._onenterkey(e);
					}
					break;
				case 'input' :
				case 'change' :
					var value = this.value;
					if (value !== this._snapshot) {
						this._snapshot = value;
						this._oninput(value);
					}
					break;
				case 'focus':
					this.event.add('keydown');
					if (model) {
						model.focused = true;
					}
					break;
				case 'blur':
					this.event.remove('keydown');
					this._oncount();
					if (model) {
						model.focused = false;
					}
					break;
			}
		},

		/**
		 * Handle model changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.FieldSpirit.prototype.onchange.call(this, changes);
			changes.forEach(function(c) {
				this._onmodelchange(c.object, c.name, c.newValue, c.oldValue);
			}, this);
		},

		/**
		 * Handle attribute change (or listener added).
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.FieldSpirit.prototype.onatt.call(this, att);
			switch (att.name) {
				case 'disabled' :
					this.disabled = this.att.has('disabled');
					break;
			}
		},

		/**
		 * Sugar not disabled.
		 * @returns {ts.ui.InputSpirit}
		 */
		enable: chained(function() {
			this.disabled = false;
		}),

		/**
		 * Sugar disabled.
		 * @returns {ts.ui.InputSpirit}
		 */
		disable: chained(function() {
			this.disabled = true;
		}),

		/**
		 * Clear the input.
		 * @returns {ts.ui.SearchSpirit}
		 */
		clear: chained(function() {
			this.value = '';
		}),

		/**
		 * Set or get the model.
		 * TODO: Move all this to ancestor spirit (ts.ui.Spirit)?
		 * @param {ts.ui.InputModel} model
		 * @returns {ts.ui.InputSpirit|ts.ui.InputModel}
		 */
		model: chained(function(model) {
			if (arguments.length) {
				if (ts.ui.InputModel.is(model)) {
					if (model !== this._model) { // TODO(jmo@): edbml.$get should fix this: https://github.com/wunderbyte/spiritual-edbml/issues/14
						if (this._model) {
							this._setupmodel(this._model, false);
						}
						this._model = model;
						this._setupmodel(model, true);
					}
				} else {
					throw new TypeError('InputModel expected');
				}
			} else {
				return this._model;
			}
		}),

		// Privileged ..............................................................

		/**
		 * Style the form.
		 */
		$updatestyling: function() {
			ts.ui.FieldSpirit.prototype.$updatestyling.call(this);
			this._label(function(label) {
				label.$empty(!this.value);
				label.$customicon(this.icon, this.att.has('data-ts.icon'));
			});
		},

		// private .................................................................

		/**
		 * Optional model thing.
		 * @type {ts.ui.InputModel}
		 */
		_model: null,

		/**
		 * Tracking the value to detect actual value-changes (ex. arrow keys etc).
		 * @type {string}
		 */
		_snapshot: null,

		/**
		 * Timeout key.
		 * @type {number}
		 */
		_timeout: -1,

		/**
		 * Temporarily suspending evaluation of `onenterkey` (if assigned)?
		 * @see {ts.ui.TextAreaSpirit} Can be setup to require SHIFT+ENTER.
		 * @type {boolean}
		 */
		_suspendenterkey: false,

		/**
		 * Setup the model (and unsetup any potential old model).
		 * @param {ts.ui.InputModel} model
		 * @param {boolean} setup Setup or unsetup?
		 */
		_setupmodel: function(model, setup) {
			if (setup) {
				model.addObserver(this);
			} else {
				model.removeObserver(this);
			}
			this.onidle = setup ? function() {
				model.idle = true;
			} : null;
			this.onenterkey = setup ? function() {
				model.enterkey = true;
			} : null;
			if (setup) {
				if (model.value) {
					this.value = model.value;
				}
				if (model.focused) {
					this.element.focus();
				}
			}
		},

		/**
		 * Countdown on idle.
		 */
		_countdown: function() {
			this._discount();
			this._timeout = this.tick.time(function() {
				this._oncount();
			}, this.idletime);
		},

		/**
		 * Compile and invoke idle function.
		 */
		_oncount: function() {
			this._discount();
			this._maybeinvoke(this.onidle, this.value);
		},

		/**
		 * Clear the idle timeout.
		 */
		_discount: function() {
			clearTimeout(this._timeout);
			this._timeout = -1;
		},

		/**
		 * Input value changed.
		 * @param {string} value
		 */
		_oninput: function(value) {
			this._label(function(label) {
				label.$empty(!value);
			});
			if (this.onidle) {
				this._countdown();
			}
			if (this._ismodelled()) {
				this._model.value = value;
			}
		},

		/**
		 * Handle model change. Some of this can be moved to EDBML pending
		 * https://github.com/wunderbyte/spiritual-edbml/issues/4 (NOW FIXED!).
		 * @param {ts.ui.Model} model
		 * @param {string} name
		 * @param {object} value
		 * @param {object} oldvalue
		 */
		_onmodelchange: function(model, name, value, oldvalue) {
			if (model === this._model) {
				switch (name) {
					case 'value':
						this.value = value;
						if (!value) {
							this._label(function(label) {
								label.$empty(true);
							});
						}
						break;
					case 'focused':
						if (value) {
							this.element.focus();
						} else {
							this.element.blur();
						}
						break;
				}
			}
		},

		/**
		 * Note that a 'preventDefault()' will prevent IE10 from clearing
		 * the value of the input for reasons that remain a mystery. This
		 * will however prevent buttons in forms from submittin, so let's
		 * think about this some more.
		 * @param {KeyEvent} e
		 */
		_onenterkey: function(e) {
			if (!this._suspendenterkey) {
				if (this._maybeinvoke(this.onenterkey, this.value)) {
					this._discount();
				}
			}
			if (this.element.localName !== 'textarea') {
				// e.preventDefault(); // see comment above...
			}
		}

	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @return {ts.ui.InputSpirit}
		 */
		summon: function() {
			return this.possess(document.createElement('input'));
		}

	});
}(gui.Combo.chained, gui.Type, gui.Client));



/**
 * Spirit of the input type=text and textarea.
 * @extends {ts.ui.InputSpirit}
 */
ts.ui.TextInputSpirit = ts.ui.InputSpirit.extend({

	/**
	 * Attach to the DOM.
	 */
	onattach: function() {
		ts.ui.InputSpirit.prototype.onattach.call(this);
		this.css.add(ts.ui.CLASS_TEXT);
	},

	// Privileged ................................................................

	/**
	 * Style the form.
	 */
	$updatestyling: function() {
		ts.ui.InputSpirit.prototype.$updatestyling.call(this);
		this._label(function(label) {
			label.$textlabel();
		});
	}

});



/**
 * The date-input and the select will hide themselves
 * and present this fake input to the outside world.
 * @see {ts.ui.FakeDateInputSpirit}
 * @see {ts.ui.FakeSelectInputSpirit}
 */
ts.ui.FakeInputSpirit = (function() {
	var KEY_ENTER = 13;
	var KEY_SPACE = 32;

	return ts.ui.TextInputSpirit.extend({

		onconfigure: function() {
			ts.ui.TextInputSpirit.prototype.onconfigure.call(this);
			this.css.add(ts.ui.CLASS_FAKE);
			this.element.tabIndex = -1;
			this.element.type = 'text';
			this.element.name = '';
			this.att.set('readonly', true);
		},

		/**
		 * Set it up so that we are prepared to work
		 * even if not embedded into a Form component.
		 */
		onattach: function() {
			ts.ui.TextInputSpirit.prototype.onattach.call(this);
			var label = this.dom.parent(ts.ui.LabelSpirit);
			if (label) {
				label.event.add('click', label, this);
			} else {
				this.event.add('click');
			}
		},

		/**
		 * At least attempt to flush some listeners.
		 */
		ondetach: function() {
			ts.ui.TextInputSpirit.prototype.ondetach.call(this);
			this._label(function(label) {
				label.event.remove('click', label, this);
			});
		},

		/**
		 * @param {Element} element
		 */
		proxy: function(element) {
			this._proxyelement = element;
			this._proxyspirit = ts.ui.get(element);
			this.event.add('keydown keypress keyup', element, this);
		},

		/**
		 * Handle event. Notice that we don't call super.
		 * We should probably refactor something some day.
		 * @param {Event} e
		 */
		onevent: function(e) {
			switch (e.type) {
				/*
				 * Try not to focus this, focus the real
				 * element for better keyboard handling.
				 * TODO: This makes text not selectable
				 * in fake select (when readonly).
				 */
				case 'focus':
					if (e.target === this.element) {
						if (!this._inactive()) {
							this._proxyelement.focus();
						}
					}
					break;
				case 'click':
					if (!this._inactive()) {
						this._maybeopen();
					}
					break;
				case 'keydown':

				/*
				 * All attempts to open the aside would fail :/
				 * Keyboard handling simply disabled for the time
				 * being, but we also need to `preventDefault` the
				 * ENTER key to stop Chrome from showing native
				 * select dropdowns and date pickers at this point.
				 */
					switch (e.keyCode) {
						case KEY_ENTER:
						case KEY_SPACE:
							e.preventDefault();
							if (!this._inactive()) {
								this._maybeopen();
							}
							break;
					}
					break;
			}
		},

		// Privileged ..............................................................

		/**
		 * Style the form.
		 */
		$updatestyling: function() {
			ts.ui.TextInputSpirit.prototype.$updatestyling.call(this);
			this._label(function(label) {
				label.$fakelabel();
			});
		},

		// Private .................................................................

		/**
		 * The proxied element is disabled or readonly? We double check `readonly`
		 * to support readonly on SELECT fields, who according to spec cannot be
		 * readonly (only disabled).
		 * @returns {boolean}
		 */
		_inactive: function() {
			var elm = this._proxyelement;
			return !!(elm.disabled || elm.readOnly || elm.hasAttribute('readonly'));
		},

		/**
		 * TODO: Click might be triggered twice, is it because of FastClick.js??
		 * TODO: Ouch! https://bugzilla.mozilla.org/show_bug.cgi?id=392863
		 */
		_maybeopen: function() {
			if (!this._isopen) {
				this._isopen = true;
				this._label(function(label) {
					label.css.add(ts.ui.CLASS_FOCUS_ON);
				});
				this._openaside(function onclosed() {
					this._isopen = false;
					this._proxyelement.focus();
					this._label(function(label) {
						label.css.remove(ts.ui.CLASS_FOCUS_ON);
					});
				});
			}
		},

		/**
		 * TODO: Use `ts.ui.get(this._proxyelement).event.trigger('change')
		 * but make sure that we cover this with some kind of test first...
		 */
		_triggerchange: function() {
			var evt = document.createEvent('HTMLEvents');
			evt.initEvent('change', false, true);
			this._proxyelement.dispatchEvent(evt);
		},

		/**
		 * Restore focus (when Aside is closed).
		 */
		_restorefocus: function() {
			this._proxyelement.focus();
		}

	});
}());



/**
	* Appears in the place of <input type="date"/>.
	* The original type="date" has too much browser-specific baggage, so we
	* replace it with a text input. This is that text input. The original date
	* input stays in the DOM, but is	hidden. That allows most bindings that
	* the user have used to keep working.
	* @extends {ts.ui.FakeInputSpirit}
	* @using {string} tick
	* @using {number} time
 */
ts.ui.FakeDateInputSpirit = (function using(chained, tick, time) {
	return ts.ui.FakeInputSpirit.extend({

		/**
		 * Attached the DOM.
		 */
		onattach: function() {
			ts.ui.FakeInputSpirit.prototype.onattach.call(this);
			this.css.add(ts.ui.CLASS_DATE);
		},

		/**
		 * Handle tick.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.FakeInputSpirit.prototype.ontick.call(this, t);
			if (!this._proxyspirit.$destructed) {
				if (t.type === tick) {
					this._syncfake();
				}
			}
		},

		/**
		 * Proxy spirit of the dateinput.
		 * @param {HTMLInputElement} input
		 */
		proxy: chained(function(input) {
			ts.ui.FakeInputSpirit.prototype.proxy.call(this, input);
			this.disabled = input.disabled;
			this._initialupdate();
		}),

		// Privileged ..............................................................

		/**
		 * Style the form.
		 */
		$updatestyling: function() {
			ts.ui.FakeInputSpirit.prototype.$updatestyling.call(this);
			this._label(function(label) {
				label.$datelabel();
			});
		},

		// Private .................................................................

		/**
		 * Spirit of the real <input type="date">.
		 * @type {ts.ui.DateInputSpirit}
		 */
		_proxyspirit: null,

		/**
		 * Initial update going on. When Angular is running somewhere on the page,
		 * it appears that Firefox needs a short break here for some weird reason.
		 * @param {HTMLSelectElement} select
		 */
		_initialupdate: function(select, again) {
			this._syncfake();
			this.tick.add(tick).start(tick, time);
		},

		/**
		 * Open that date picker.
		 * @param {function} onclosed
		 * TODO(jmo@): First update fake, then wait for animation, then update real.
		 */
		_openaside: function(onclosed) {
			var spirit = this, real = this._proxyspirit;
			var title = this._label(function(label) {
				return label.text();
			});
			ts.ui.DatePicker({
				title: title || ts.ui.String.LABEL_DATEPICK,
				value: real.value,
				min: real.min,
				max: real.max,
				onselect: function(value) {
					spirit._syncreal(value);
					spirit._syncfake();
					this.close();
				},
				onclosed: function() {
					onclosed.call(spirit);
					this.dispose();
				}
			}).open();
		},

		/**
		 * Assign value to the real input
		 * and dispatch a 'change' event.
		 */
		_syncreal: function(value) {
			var realspirit = this._proxyspirit;
			if (realspirit.value !== value) {
				realspirit.value = value;
				this._triggerchange();
			}
		},

		/**
		 * Sync the fake input to the real input. Note that
		 * Copy the real date input placeholder to the fake one.
		 * this method is runs periodically on a {gui.Tick}.
		 * TODO(jmo@): Validate ISO format around here...
		 */
		_syncfake: function() {
			var realspirit = this._proxyspirit;
			if (realspirit.value !== this.value) {
				this.value = realspirit.value;
			}
			if (realspirit.element.placeholder !== this.element.placeholder) {
				this.element.placeholder = realspirit.element.placeholder;
			}
		}

	});
}(
	gui.Combo.chained,
	ts.ui.FieldSpirit.TICK_SYNC,
	ts.ui.FieldSpirit.TICK_TIME
));



/**
 * Spirit of the input type="date".
 * TODO(jmo@): Destruct fake input when this gets destructed.
 * TODO(jmo@): Move fake input when this gets moved?
 * @extends {ts.ui.InputSpirit}
 * @see http://stackoverflow.com/questions/7372038/
 *		 is-there-any-way-to-change-input-type-date-format
 */
ts.ui.DateInputSpirit = (function(tick, time) {
	var EMPTYVALUE = ''; // invalid dates will not be displayed

	return ts.ui.InputSpirit.extend({

		/**
		 * Min date.
		 * @type {string}
		 */
		min: null,

		/**
		 * Max date.
		 * @type {string}
		 */
		max: null,

		/**
		 * Configure much.
		 */
		onconfigure: function() {
			ts.ui.InputSpirit.prototype.onconfigure.call(this);
			this.att.add('min max');
		},

		/**
		 * Show the fake input. This (real) input is hidden via CSS in a
		 * way so that it can still be focused (so not via `display:none`).
		 */
		onready: function() {
			ts.ui.InputSpirit.prototype.onready.call(this);
			this.tick.add(tick).start(tick, time);
			this._createfake(
				ts.ui.FakeDateInputSpirit
			).proxy(this.element);
		},

		/**
		 * Handle tick.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.InputSpirit.prototype.ontick.call(this, t);
			if (t.type === tick) {
				this._revaluate(this.element.value);
			}
		},

		/**
		 * Handle attribute update.
		 * TODO(jmo@): Validate min versus max versus (current) value
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.InputSpirit.prototype.onatt.call(this, att);
			var value = att.value;
			switch (att.name) {
				case 'min':
					this.min = this._evaluated(value);
					break;
				case 'max':
					this.max = this._evaluated(value);
					break;
			}
		},

		// Private .................................................................

		/**
		 * Remember the good old value.
		 * @type {string}
		 */
		_snapshot: null,

		/**
		 * Now this is tricky: If this spirit happened to attach to an Angular
		 * template before Angular parsed the template, the temple will now
		 * contain the initialized markup including the {ts.ui.FakeDateInputSpirit}.
		 * In that case, we'll need to remove the old fake input first.
		 * @param {constructor} SelectInput
		 * @returns {ts.ui.FakeDateInputSpirit}
		 */
		_createfake: function(FakeInput) {
			var existing = this.dom.next(ts.ui.TextInputSpirit); // huh?
			if (existing) {
				existing.dom.remove();
			}
			return this.dom.after(FakeInput.summon());
		},

		/**
		 * There's no callback when input.value changes, so we'll check on a tick.
		 *
		 */
		_revaluate: function(newval) {
			var oldval = this._snapshot;
			if (newval !== EMPTYVALUE && newval !== oldval) {
				this._snapshot = newval;
				this.value = newval;
				// the value will be _evaluated() in method below
				// because {ts.ui.FieldSpirit#value} has a setter
			}
		},

		/**
		 * Evaluate that value. If bad value, warn user and return empty string.
		 * This emulates the behavior that occurs in browsers where native date
		 * inputs are supported (WebKit, but not Firefox) and in which this code,
		 * by the way, doesn't even get evaluated if the format is indeed invalid.
		 * @overwrites {ts.ui.FieldSpirit#_evaluated}
		 * @param {string} value
		 * @returns {string}
		 */
		_evaluated: function(value) {
			if (isNaN(new Date(value).getTime())) {
				console.warn(
					"The specified value '" + value + "' does not " +
					"conform to the required format, 'yyyy-MM-dd'."
				);
				return EMPTYVALUE;
			}
			return value;
		}

	});
}(
	ts.ui.FieldSpirit.TICK_SYNC,
	ts.ui.FieldSpirit.TICK_TIME
));



/**
 * Spirit of the textarea.
 *
 * TODO: If the textarea or container for some reason is display:none,
 * then it will look strange once it gets shown, perhaps we can work
 * around this by creating a mirror-textarea (in the root of BODY)
 * and then do measurements here?
 *
 * @extends {ts.ui.TextInputSpirit}
 * @using {gui.Type} Type
 * @using {gui.Client} Client
 * @using {number} unit
 * @using {string} tick
 * @using {number} time
 */
ts.ui.TextAreaSpirit = (function using(Type, Client, unit, tick, time) {
	return ts.ui.TextInputSpirit.extend({

		/**
		 * When false, ENTER will make the textarea grow (to a certain limit).
		 * When true, only SHIFT+ENTER will do that (chat comment style) and
		 * the ENTER key can be freed up to other purposes (eg. submit comment).
		 * In HTML, this can also be adjusted by setting the `type` to `submit`.
		 * TODO: It's not really possible to hold SHIFT while pressing ENTER in iOS.
		 * @type {boolean}
		 */
		entershift: false,

		/**
		 * Setup on enter.
		 */
		onenter: function() {
			ts.ui.TextInputSpirit.prototype.onenter.call(this);
			this.css.add(ts.ui.CLASS_TEXTAREA);
			this.event.add('input keydown');
			this._snapshot = this.element.value;
			this.tick.add(tick).start(tick, time);
			this.att.add('rows');
			this._autosize();
		},

		/**
		 * Form in ASIDE scenario.
		 * TODO: remove all visibility stuff since nobody knows how to use it :/
		 */
		onvisible: function() {
			ts.ui.TextInputSpirit.prototype.onvisible.call(this);
			if (this.css.get('height') === 'auto') {
				this._autosize();
			}
		},

		/**
		 * Handle attribute (change). In Angular, attributes change chaotically.
		 * @param {gui.Att} att
		 */
		onatt: function(att) {
			ts.ui.TextInputSpirit.prototype.onatt.call(this, att);
			if (att.name === 'rows') {
				var val = att.value;
				if (Type.isNumber(val)) { // no weird Moustache template
					this.css.minHeight = unit * val;
					if (val >= 10) {
						this.css.maxHeight = unit * val;
					}
				}
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			var was = this._suspendenterkey;
			switch (e.type) {
				case 'input':
					ts.ui.TextInputSpirit.prototype.onevent.call(this, e);
					this._autosize();
					break;
				case 'keydown':
					if (e.keyCode === 13) {
						if (this.entershift || this.att.get('type') === 'submit') {
							if (e.shiftKey) {
								this._suspendenterkey = true;
							} else {
								e.preventDefault();
								var elm = this.element;
								if (elm.form) {
									elm.form.submit();
								}
								this.tick.next(function donteatevent() {
									if (document.activeElement === elm) {
										elm.blur();
									}
								});
							}
						}
					}
					ts.ui.TextInputSpirit.prototype.onevent.call(this, e);
					this._suspendenterkey = was;
					break;
			}
		},

		/**
		 * Autosize whenever `textarea.value` was changed programatically.
		 * TODO: Account for scenario where textarea is in a `display:none`
		 * part of the screen...
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.TextInputSpirit.prototype.ontick.call(this, t);
			if (t.type === tick) {
				if (this.element.value !== this._snapshot) {
					this._snapshot = this.element.value;
					this._autosize();
				} else if (this.css.get('height') === 'auto') {
					/*
					 * Hotfix for TODO (in top of file): This is expensive, but there
					 * is no way for us to know if we started hidden and now we are
					 * shown (spirits have an API to manage this, but nobody knows).
					 * Perhaps some kind of transitioned property can be caught with
					 * `transitionend` so that we can get away with something nicer?
					 */
					this._autosize();
				}
			}
		},

		// Private .................................................................

		/**
		 * Setup the model (and unsetup any potential old model).
		 * @param {ts.ui.InputModel} model
		 * @param {boolean} setup Setup or unsetup?
		 */
		_setupmodel: function(model, setup) {
			ts.ui.TextInputSpirit.prototype._setupmodel.call(this, model,setup);
			this.entershift = setup ? model.entershift : false;
		},

		/**
		 * Adjust height. Snap to line height. Abort in case we are display:none.
		 * If the height changed, dispatch action to any containing layout managers.
		 */
		_autosize: function() {
			var target, padding = unit * 0.5;
			var current = this.css.height || this.box.height;
			this.css.height = 'auto';
			if ((target = Math.floor(this.element.scrollHeight / unit) * unit) > 0) {
				this.css.height = target + padding;
				if (current !== target) {
					this._hotfixchrome(this.element);
					this.action.dispatch(ts.ui.ACTION_CHANGED, {
						oldheight: current,
						newheight: target
					});
				}
			}
		},

		/**
		 * Force repaint to fix a rendering dysfunction in newer versions
		 * of Google Chrome (appears not needed when the scrollbar is shown).
		 * @param {Element} elm
		 */
		_hotfixchrome: function(elm) {
			if (Client.isChrome && elm.scrollHeight <= elm.offsetHeight) {
				this.tick.nextFrame(function() {
					this.css.display = 'none';
					this.css.display = '';
				});
			}
		}

	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @returns {ts.ui.TextAreaSpirit}
		 */
		summon: function() {
			return this.possess(document.createElement('textarea'));
		}

	});
}(
	gui.Type,
	gui.Client,
	ts.ui.UNIT,
	ts.ui.FieldSpirit.TICK_SYNC,
	ts.ui.FieldSpirit.TICK_TIME
));



/**
 * Spirit of the input type=checkbox|radio.
 * @extends {ts.ui.FieldSpirit}
 */
ts.ui.OptionSpirit = ts.ui.FieldSpirit.extend({

	/**
	 * Validate much.
	 */
	onconfigure: function() {
		ts.ui.FieldSpirit.prototype.onconfigure.call(this);
		this._confirmbasic(this.element.localName, this.element.type);
	},

	/**
	 * Attach to the DOM.
	 */
	onattach: function() {
		ts.ui.FieldSpirit.prototype.onattach.call(this);
		this.css.add(ts.ui.CLASS_OPTION);
	},

	// Privileged ................................................................

	/**
	 * Style the form.
	 */
	$updatestyling: function() {
		ts.ui.FieldSpirit.prototype.$updatestyling.call(this);
		var type = this.element.type;
		this._label(function(label) {
			label.$option(type);
		});
		this._fieldset(function(fieldset) {
			fieldset.$options(type);
			if (type === 'radio') {
				fieldset.$disabled(this.att.has('disabled'));
			}
		});
	},

	// Private ...................................................................

	/**
	 * Confirm that you're not doing it wrong.
	 * TODO: handle this via some advanced superclass boilerplate.
	 * @param {string} name
	 * @param {string} type
	 */
	_confirmbasic: function(name, type) {
		if (gui.debug) {
			if (name !== 'input') {
				throw new Error(this + ' must attach to an input field', this.element);
			} else if (type !== 'checkbox' && type !== 'radio') {
				throw new Error(this + ' must attach to a checkbox or radio', this.element);
			}
		}
	}

});



/**
 * Spirit of the switch.
 * TODO (jmo@): Support swipe gestures on that switch!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * @extends {ts.ui.FieldSpirit}
 * @using {string} tick
 * @using {string} time
 */
ts.ui.SwitchSpirit = (function using(tick, time) {
	return ts.ui.FieldSpirit.extend({

		/**
		 * Setup the stuff.
		 */
		onenter: function() {
			ts.ui.FieldSpirit.prototype.onenter.call(this);
			this._confirmbasic(
				this.element.localName,
				this.element.type
			);
		},

		/**
		 * Attach to the DOM.
		 */
		onattach: function() {
			ts.ui.FieldSpirit.prototype.onattach.call(this);
			this.event.add('change');
			this.css.add([ // TODO: update these classnames what with the new stylee!
				ts.ui.CLASS_SWITCHBOX,
				ts.ui.CLASS_ENGINE
			]);
			this._switch = this._createswitch();
			this._synchronize(true);
		},

		/**
		 * Syncrhonize on an interval so that we don't have to anticipate
		 * all the strange stuff that Angular might do with our elements.
		 */
		onready: function() {
			ts.ui.FieldSpirit.prototype.onready.call(this);
			this.tick.add(tick).start(tick, time);
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.FieldSpirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'change':
					this._synchronize();
					break;
			}
		},

		/**
		 * Handle tick.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.FieldSpirit.prototype.ontick.call(this, t);
			if (t.type === tick) {
				this._synchronize();
			}
		},

		// Privileged ..............................................................

		/**
		 * Style the containing form elements.
		 */
		$updatestyling: function() {
			ts.ui.FieldSpirit.prototype.$updatestyling.call(this);
			this._label(function(label) {
				label.$switch();
			});
			this._fieldset(function(fieldset) {
				fieldset.$options();
			});
		},

		// Private .................................................................

		/**
		 * The switch DHTML thing.
		 * @type {HTMLDivElement}
		 */
		_switch: null,

		/**
		 * Snapshot checked status so that we know when it changes.
		 * @type {boolean|null}
		 */
		_snapshot: null,

		/**
		 * Inject the switch while accounting for strange Angular quantum effects.
		 * @returns {ts.ui.Spirit}
		 */
		_createswitch: function() {
			var oldswitch = this.dom.following(ts.ui.Spirit)[0];
			if (oldswitch && oldswitch.css.contains('ts-switcher')) {
				oldswitch.dom.remove();
			}
			return ts.ui.get(this.dom.after(
				this.dom.parseToNode(
					ts.ui.switchonly.edbml()
				)
			));
		},

		/**
		 * Match switch to checkbox. Note that we do
		 * this on an interval just to make sure...
		 * @param @optional {boolean} init Don't dispatch action on init
		 */
		_synchronize: function(init) {
			var checked = this.element.checked;
			if (init || checked !== this._snapshot) {
				this._switch.css.shift(checked, ts.ui.CLASS_CHECKED);
				this._snapshot = checked;
				if (!init) {
					this.action.dispatch(ts.ui.ACTION_SWITCH, checked);
				}
			}
		},

		/**
		 * Confirm that you're not doing it wrong.
		 * TODO: handle this via some advanced superclass boilerplate.
		 */
		_confirmbasic: function(name, type) {
			var elm = this.element;
			if (gui.debug) {
				if (name !== 'input') {
					throw new Error(this + ' must attach to an input field', elm);
				} else if (type !== 'checkbox' && type !== 'radio') {
					throw new Error(this + ' must attach to a checkbox or radio', elm);
				}
			}
		}

	});
}(ts.ui.FieldSpirit.TICK_SYNC, ts.ui.FieldSpirit.TICK_TIME));



/**
 * Spirit of the label.
 * @extends {ts.ui.FormSupportSpirit}
 * @using {gui.Client} Client
 * @using {ts.ui.FieldSpirit} FieldSpirit
 * @using {gui.Combo.chained}
 * @using {string} tick
 * @using {number} time
 * @using {number} controlclass
 */
ts.ui.LabelSpirit = (function using(Client, FieldSpirit, chained, tick, time, controlclass) {
	var class_switchlabel = ts.ui.CLASS_SWITCHLABEL,
		class_fieldlabel = ts.ui.CLASS_FIELDLABEL,
		class_textlabel = ts.ui.CLASS_TEXTLABEL,
		class_datelabel = ts.ui.CLASS_DATELABEL,
		class_fakelabel = ts.ui.CLASS_FAKELABEL,
		class_customiconlabel = ts.ui.CLASS_CUSTOMICONLABEL,
		class_haslabel = ts.ui.CLASS_HASLABEL,
		class_disabled = ts.ui.CLASS_DISABLED,
		class_readonly = ts.ui.CLASS_READONLY,
		class_required = ts.ui.CLASS_REQUIRED,
		class_option = ts.ui.CLASS_OPTION,
		class_error = ts.ui.CLASS_ERROR,
		class_focus = ts.ui.CLASS_FOCUS,
		class_empty = ts.ui.CLASS_EMPTY;

	/**
	 * Under mysterious circumstances, the label will loose it's styling
	 * when running inside Angular templates. The only known workaround
	 * is to periodically check for missing classnames and reapply them.
	 * @param {ts.ui.FieldSpirit} field
	 */
	function updatestyling(field) {
		field.$updatestyling();
	}

	return ts.ui.FormSupportSpirit.extend({

		/**
		 * Setup for hotfix.
		 */
		onconstruct: function() {
			ts.ui.FormSupportSpirit.prototype.onconstruct.call(this);
			this._persisted = [];
		},

		/**
		 * Attach to the DOM.
		 */
		onattach: function() {
			ts.ui.FormSupportSpirit.prototype.onattach.call(this);
			this.event.add('mousedown');
			this.event.add('focus blur', this, this, true);
			this.tick.add(tick).start(tick, time);
			this.css.add('ts-engine-' + Client.agent);
		},

		/**
		 * If the control class has not been applied, we'll ask all fields to
		 * refresh the styling. Fixes a (rare) glitch in Angular integration.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.FormSupportSpirit.prototype.ontick.call(this, t);
			if (t.type === tick) {
				this._refreshstyling();
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.FormSupportSpirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'focus' :
				case 'blur' :
					switch (e.target.type) {
						case 'radio' :
							break;
						default :
							this._focus(e.type === 'focus');
							break;
					}
					break;
				case 'mousedown' :
					var boxes = this.dom.qall('input[type=checkbox]');
					if (boxes.length) {
						boxes[0].focus();
						e.preventDefault();
					}
					break;
			}
		},

		/**
		 * Get the label text (what the user sees).
		 * @returns {string}
		 */
		text: function() {
			var span = this.dom.q('this > span');
			return span ? span.textContent.trim() : '';
		},

		// Private .................................................................

		/**
		 * @type {boolean}
		 */
		_disabled: false,

		/**
		 * Layout as options?
		 * @type {boolean}
		 */
		_option: false,

		/**
		 * Layout as focused?
		 * @param {boolean} is
		 */
		_focus: function(is) {
			this.css.shift(is, class_focus);
		},

		/**
		 * If the "control class" is lost, we'll assume that the
		 * (rare) Angular glitch has occured and reapply styling.
		 */
		_refreshstyling: function() {
			if (!this.css.contains(controlclass)) {
				this.dom.descendants(FieldSpirit).forEach(updatestyling);
			}
		},

		// Priveleged ..............................................................

		/**
		 * This is like a "control class" that all fields
		 * will attach. If we don't see this class, it's
		 * because Angular has done something terrible
		 * and we must react in a strong way.
		 */
		$fieldlabel: chained(function() {
			this.css.add(class_fieldlabel);
		}),

		/**
		 * Layout as invalid.
		 * @param {boolean} is
		 */
		$invalid: chained(function(is) {
			this.css.shift(is, class_error);
		}),

		/**
		 * Layout as text input label.
		 */
		$textlabel: chained(function() {
			this.css.add(class_textlabel);
		}),

		/**
		 * Layout as labeled field (versus unlabeled field).
		 */
		$haslabel: chained(function(has) {
			this.css.shift(has, class_haslabel);
		}),

		/**
		 * Layout as date input label.
		 */
		$datelabel: chained(function() {
			this.css.add(class_datelabel);
		}),

		/**
		 * Layout as (fake) selector label.
		 */
		$fakelabel: chained(function() {
			this.css.add(class_fakelabel);
		}),

		/**
		 * Is this a fake input's label?
		 */
		$isFakelabel: function() {
			return this.css.contains(class_fakelabel);
		},

		/**
		 * Use a custom icon instead of the automatically generated one
		 */
		$customicon: chained(function(customicon, hasCustomicon) {
			if (hasCustomicon) {
				var character = ts.ui.ICONS[customicon] || '';
				this.css.add(class_customiconlabel);
				this.att.set('data-ts-icon', character);
			} else {
				this.css.remove(class_customiconlabel);
				this.att.remove('data-ts-icon');
			}
		}),

		/**
		 * Layout as radio or checkbox label.
		 * @param {string} type 'radio' or 'checkbox'
		 */
		$option: chained(function(type) {
			this.css.add(class_option);
			this.css.add('ts-' + type);
		}),

		/**
		 * Layout as switch label.
		 */
		$switch: chained(function() {
			this.css.add(class_switchlabel);
		}),

		/**
		 * Field disabled? (also called when not disabled).
		 * @param {boolean} disabled
		 */
		$disabled: chained(function(disabled) {
			var change = this.css.contains(class_disabled) ? !disabled : disabled;
			if (change) {
				this.css.shift(disabled, class_disabled);
			}
		}),

		/**
		 * Field read only? (also called when not read only).
		 * @param {boolean} readonly
		 */
		$readonly: chained(function(readonly) {
			/*
			if (this.$isFakelabel()) { // fakelabel is always NOT readonly
				this.css.remove(class_readonly);
				return;
			}
			*/
			var change = this.css.contains(class_readonly) ? !readonly : readonly;
			if (change) {
				this.css.shift(readonly, class_readonly);
			}
		}),

		/**
		 * Field required? (also called when not required).
		 * @param {boolean} readonly
		 */
		$required: chained(function(required) {
			var change = this.css.contains(class_required) ? !required : required;
			if (change) {
				this.css.shift(required, class_required);
			}
		}),

		/**
		 * Field empty.
		 * @param {boolean} empty
		 */
		$empty: chained(function(empty) {
			this.css.shift(empty, class_empty);
		})

	});
}(
	gui.Client,
	ts.ui.FieldSpirit,
	gui.Combo.chained,
	ts.ui.FieldSpirit.TICK_SYNC,
	ts.ui.FieldSpirit.TICK_TIME,
	ts.ui.CLASS_FIELDLABEL
));



/**
 * Spirit of the `SPAN` that contains the label text. If this label text is
 * enclosed in a conditional, Angular might insert this `SPAN` at a random
 * point in time, so the applied CSS classname is best managed by this spirit.
 * (it would be even better to deprecate the need for a special classname,
 * but that fixes some cross-browser problems with `text-overflow: ellipsis`).
 * @extends {ts.ui.Spirit}
 */
ts.ui.LabelTextSpirit = (function() {
	/**
	 * Attempt to apply the classname to the containing label and if not found,
	 * attempt to apply the class the containing fieldset (for option groups).
	 * @param {ts.ui.Spirit} spirit
	 * @param {boolean} on
	 */
	function classname(spirit, on) {
		var label, fieldset;
		if ((label = spirit.dom.parent(ts.ui.LabelSpirit))) {
			label.$haslabel(on);
		} else if ((fieldset = spirit.dom.parent(ts.ui.FieldSetSpirit))) {
			fieldset.$haslabel(on);
		}
	}

	return ts.ui.Spirit.extend({
		/**
		 * Attach the special classname.
		 */
		onattach: function() {
			ts.ui.Spirit.prototype.onattach.call(this);
			classname(this, true);
		},

		/**
		 * Detach the special classname.
		 */
		ondetach: function() {
			ts.ui.Spirit.prototype.ondetach.call(this);
			classname(this, false);
		}
	});
}());



/**
 * Spirit of fieldset.
 * @extends {ts.ui.FormSupportSpirit}
 */
ts.ui.FieldSetSpirit = (function() {
	return ts.ui.FormSupportSpirit.extend({

		/**
		 * Attach to the DOM.
		 */
		onattach: function() {
			ts.ui.FormSupportSpirit.prototype.onattach.call(this);
			this.event.add('mousedown');
			this.event.add('focus blur', this.element, this, true);
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.FormSupportSpirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'focusin' :
				case 'focusout' :
				case 'focus' :
				case 'blur' :
					switch (e.target.type) {
						case 'radio' :
							this._focus(e.type === 'focusin' || e.type === 'focus');
							break;
					}
					break;
				case 'mousedown' :
					if (this._focusradio() || this._focusbox()) {
						e.preventDefault();
					}
					break;
			}
		},

		// Privileged ..............................................................

		/**
		 * Layout as options group.
		 * @param {string} type 'radio' or 'checkbox'
		 */
		$options: function(type) {
			this.css.add(ts.ui.CLASS_OPTIONS).add('ts-' + type);
		},

		/**
		 * Mark as disabled (radio group scenario).
		 */
		$disabled: function(disabled) {
			this.css.shift(disabled, 'ts-disabled');
		},

		/**
		 * Layout as labeled fieldset (versus unlabeled fieldset).
		 * @param {boolean} has
		 */
		$haslabel: function(has) {
			this.css.shift(has, ts.ui.CLASS_HASLABEL);
		},

		// Private .................................................................

		/**
		 * Can we focus a radio button?
		 * @return {boolan}
		 */
		_focusradio: function() {
			var radio = this.dom.q('input[type=radio]');
			if (radio) {
				radio.focus();
				return true;
			}
			return false;
		},

		/**
		 * Can we focus a checkbox?
		 * @return {boolan}
		 */
		_focusbox: function() {
			var box = this.dom.q('input[type=checkbox]');
			if (box && !this.dom.q('.' + ts.ui.CLASS_FOCUS)) {
				box.focus();
				return true;
			}
			return false;
		},

		/**
		 * Layout as focused?
		 * @param {boolea} is
		 */
		_focus: function(is) {
			this.css.shift(is, ts.ui.CLASS_FOCUS);
		}

	});
}());



/**
 * Spirit of the SELECT.
 * @extends {gui.Spirit}
 */
ts.ui.SelectSpirit = ts.ui.FieldSpirit.extend({

	/**
	 * Attribute `ts.debugsync` can be toggled to induce random selections.
	 * This will come in handy when we attempt to synchronize everything.
	 * @type {boolean}
	 */
	debugsync: false,

	/**
	 * Get ready.
	 */
	onready: function() {
		ts.ui.FieldSpirit.prototype.onready.call(this);
		this._debugsync(this.debugsync);
		this.css.add(ts.ui.CLASS_SELECT);
		this._createfake(
			ts.ui.FakeSelectInputSpirit
		).proxy(this.element);
	},

	// Private ...................................................................

	/**
	 * Now this is tricky: If this spirit happened to attach to an Angular
	 * template before Angular parsed the template, the temple will now
	 * contain the initialized markup including the fake input. In that case,
	 * we'll need to remove it first. There is unfortunately no way yo figure
	 * out, whether or not a piece of HTML is intended for a template, is the
	 * result of a template, or is not related to templates at all.
	 * TODO(jmo@): Link to Angular GitHub issue when online...
	 * @param {constructor} SelectInput
	 * @returns {ts.ui.FakeSelectInputSpirit}
	 */
	_createfake: function(SelectInput) {
		var oldfake = this.dom.following(ts.ui.TextInputSpirit); // huh?
		if (oldfake[0]) {
			oldfake[0].dom.remove();
		}
		return this.dom.after(SelectInput.summon());
	},

	/**
	 * Debug component synchronization. Change indexes and
	 * append new options. Don't try this in production.
	 * TODO: This in a test instead :)
	 * @param {boolean} enabled
	 */
	_debugsync: function(enabled) {
		var elm = this.element;
		var ops = elm.options;
		if (enabled) {
			setInterval(function updaterandomly() {
				if (elm.multiple) {
					console.log('indexes: ' + gui.Array.from(ops).map(
						function(o, i) {
							o.selected = Math.random() > 0.5;
							return o.selected ? i : null;
						}
					).filter(function(index) {
						return index !== null;
					}));
				} else {
					elm.selectedIndex = Math.floor(Math.random() * ops.length);
					console.log('index: ' + elm.selectedIndex);
				}
				var label = 'Option' + (ops.length + 1);
				elm.add(new Option(label, Math.random()));
			}, 2000);
		}
	}

});



/**
 * Spirit of the input field that acts like a SELECT element.
 * NOTE: All this business logic should be moved into the Menu API so
 * that someone else can create his own implementation of a "fake select"
 * with just a few lines of code. Not now though.
 * @extends {ts.ui.FakeInputSpirit}
 * @using {gui.Combo#chained}
 * @using {gui.Arguments.confirmed} confirmed
 * @using {string} tick
 * @using {number} time
 * @using {gui.Array} guiArray
 */
ts.ui.FakeSelectInputSpirit = (function using(chained, confirmed, tick, time, guiArray) {
	/**
	 * @param {HTMLOptionsCollection} options
	 * @returns {Array<number>}
	 */
	function selectedoptions(options) {
		return guiArray.from(options).map(selectedindexes).filter(selectedonly);
	}

	/**
	 * @param {HTMLOption} option
	 * @param {number} index
	 */
	function selectedindexes(option, index) {
		return option.selected ? index : -1;
	}

	/**
	 * @param {number} index
	 * @returns {boolean}
	 */
	function selectedonly(index) {
		return index > -1;
	}

	return ts.ui.FakeInputSpirit.extend({

		/**
		 * Proxy the actual SELECT element.
		 * @param {HTMLSelectElement} select
		 * @returns {ts.ui.FakeSelectInputSpirit}
		 */
		proxy: chained(function(select) {
			ts.ui.FakeInputSpirit.prototype.proxy.call(this, select);
			this.disabled = select.disabled;
			if (select.multiple) {
				this._selectedIndexes = [];
			}
			this._initialupdate(select);
			if (select.spirit) {
				var spirit = this;
				select.spirit.att.add('disabled', {
					onatt: function(att) { // TODO (jmo@): check that this is "live"
						spirit.disabled = select.disabled;
					}
				});
			}
		}),

		/**
		 * Sync fake select to real select.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.FakeInputSpirit.prototype.ontick.call(this, t);
			if (t.type === tick) {
				if (!this._proxyspirit.$destructed) {
					this._syncfake(
						this._proxyelement,
						this._menumodel
					);
				}
			}
		},

		/**
		 * Get or set the search.
		 * TODO: The search will probably move to the Aside toolbar.
		 * @param @optional {Array<object>} opt_json
		 * @returns {ts.ui.SearchModel|ts.ui.ToolBarSpirit}
		 */
		search: confirmed('(object)')(
			chained(function(opt_json) {
				var Model = ts.ui.SearchModel;
				var model = this._searchmodel;
				if (arguments.length) {
					if (model) {
						model.dispose();
					}
					this._searchmodel = new Model(opt_json);
				} else {
					if (!model) {
						this.search({});
					}
					return this._searchmodel;
				}
			})
		),

		// Private .................................................................

		/**
		 * Aside that opens.
		 * @type {ts.ui.AsideModel}
		 */
		_aside: null,

		/**
		 * Proxied select element.
		 * @type {HTMLSelectElement}
		 */
		_select: null,

		/**
		 * Tracking selected index (select single scenario).
		 * @type {number}
		 */
		_selectedIndex: -1,

		/**
		 * Tracking selected indexes (select multiple scenario).
		 * @type {Array<number>}
		 */
		_selectedIndexes: null,

		/**
		 * SearchModel no less.
		 * @type {ts.ui.SearchModel}
		 */
		_searchmodel: null,

		/**
		 * @type {number}
		 */
		_optionslength: -1,

		/**
		 * Initial update going on.
		 * @param {HTMLSelectElement} select
		 */
		_initialupdate: function(select, again) {
			this._syncfake(select);
			this.tick.add(tick).start(tick, time);
		},

		/**
		 * Match label to selected option.
		 * @param @optional {number} length (nastyhack for multiple selects)
		 */
		_updatestatus: function(length) {
			var multiple = this._proxyelement.multiple;
			var options = this._proxyelement.options;
			this._optionslength = options.length;
			if (multiple) {
				var indexes = this._getindexes(options);
				length = arguments.length ? length : indexes.length;
				this.value = (length + ' selected'); // TODO: Localization needed!!!!!!!!!
				this._selectedIndexes = indexes;
			} else {
				var index = this._proxyelement.selectedIndex;
				this._selectedIndex = index;
				if (options[index]) {
					this.value = options[index].text;
				} else {
					this.value = '';
				}
			}
		},

		/**
		 * Get selected indexes.
		 * @returns {Array<number>}
		 */
		_getindexes: function(options) {
			if (this._proxyelement.multiple) {
				return selectedoptions(options);
			} else {
				return [];
			}
		},

		/**
		 * Change selection index (on the actual SELECT element).
		 * TODO(jmo@): Implement this as a callback on the Menu!
		 * @param {number} index
		 */
		_doselectone: function(index) {
			var select = this._proxyelement;
			if (index !== select.options.selectedIndex) {
				select.options.selectedIndex = index;
				this._triggerchange();
			}
		},

		/**
		 * Change selected options (on the actual SELECT element).
		 * TODO(jmo@): Implement this as a callback on the Menu!
		 * @param {Array<number>} indexes
		 */
		_doselectmany: function(indexes) {
			var options = gui.Array.from(this._proxyelement.options);
			var changed = options.reduce(function(result, option, index) {
				var was = option.selected;
				option.selected = indexes.indexOf(index) > -1;
				return result || (option.selected !== was);
			}, false);
			if (changed) {
				this._triggerchange();
			}
		},

		/**
		 * Compute JSON for the {ts.ui.MenuModel} items collection.
		 * @returns {Array<object>}
		 * @param {HTMLSelectElement} select
		 */
		_computemodelitems: function(select) {
			return Array.map(select.options, function(option) {
				return {
					label: option.text,
					disabled: option.disabled
				};
			});
		},

		_openaside: function(onclosed) {
			this._open(this._proxyelement, this._proxyelement.options, onclosed);
		},

		// Aside ...................................................................

		/**
		 * Open the Aside.
		 * TODO(jmo@): Much too much scoped action going on, externalize this code?
		 * @param {HTMLSelectElement} select
		 * @param {HTMLOptionsCollection} options
		 */
		_open: function(select, options, onclosed) {
			var that = this,
				aside,
				menu,
				observer,
				multiple = select.multiple,
				oldindex = options.selectedIndex;

			// @param {function} action
			// @param {number} wait
			function when(action, wait) {
				gui.Tick.time(action, wait || 0);
			}

			// create the aside (setup to show all items when opened)
			aside = ts.ui.Aside({
				title: this._labeltitle(),
				autofocus: false,
				suspendopen: true,
				onbeforeopened: function() {
					aside.focus();
					when(function focusdone() {
						menu.showallitems();
						when(function edbmldone() {
							aside.unsuspendopen();
						});
					}, 25);
				},
				onclose: function() {
					// TODO: update text now, trigger `change` later
					that._onasideclose(menu, observer);
				},
				onclosed: function() {
					that._onasideclosed(menu, observer);
					onclosed.call(that);
					menu.dispose();
					this.dispose();
				}
			});

			// create the menu (setup to show only some items while opening)
			menu = this._menumodel = ts.ui.Menu({
				select: (multiple ? 'many' : 'one'),
				items: this._computemodelitems(select),
				selectedIndex: (multiple ? -1 : oldindex),
				selectedIndexes: this._getindexes(options),
				maxItemsShown: this._getminimumitemscount(),
				search: function(item, value) { // TODO: will be moved to the Aside?
					var label = item.label.toLowerCase();
					return label.startsWith(value.toLowerCase());
				}
			});

			// custom label for the "Done" button (in multiple selects)?
			if (multiple) {
				var button;
				this._label(function(label) {
					if ((button = label.dom.q('button'))) {
						menu.donebuttonlabel = button.textContent;
					}
				});
			}

			// create menu observer
			// TODO: implement this stuff as an 'onchange' callback (on the Menu)
			observer = {
				onchange: function(changes) {
					changes.forEach(function(change) {
						switch (change.object) {
							case menu:
								if (change.name === 'selectedIndex') {
									var newindex = change.newValue;
									var oldindex_ = that._selectedIndex;
									if (newindex !== oldindex_) {
										gui.Tick.time(function dramaticpause() {
											aside.close();
										}, 150);
									}
								}
								if (change.name === 'donebuttonpressed') {
									if (menu.select === 'many') {
										that._updatestatus(menu.selectedIndexes.length);
										aside.close();
									}
								}
								break;
							case menu.selectedIndexes:
								menu.donebuttonenabled = true;
								break;
						}
					});
				}
			};

			// launch everything
			menu.addObserver(observer);
			menu.selectedIndexes.addObserver(observer);
			aside.items.push(menu);
			aside.open();
		},

		/**
		 * Max items on screen roughly accounting for Aside
		 * title and panel paddeng (will compute better later).
		 */
		_getminimumitemscount: function() {
			return ts.ui.MenuSpirit.$maxItemsCount() - 2;
		},

		/**
		 * Fetch aside title from containing label.
		 * Simultaneously apply "fake focus" class.
		 * @return {string}
		 */
		_labeltitle: function() {
			return this._label(function(label) {
				return label.text();
			}) || '';
		},

		/**
		 * Cleanup when aside is about to close.
		 * @param {ts.ui.MenuModel} menu
		 * @param {strangeobject} observer
		 */
		_onasideclose: function(menu, observer) {
			menu.removeObserver(observer); // TODO: auto when disposed!
			menu.selectedIndexes.removeObserver(observer);
			if (menu.select === 'one') {
				this._instantfeedback(menu.selectedIndex);
			}
		},

		/**
		 * We've set it up so that the `change` event doesn't trigger
		 * until the Aside is fully closed (so that the animation is
		 * not ruined by other activity), but here we hack it so that
		 * there is instant visual feedback when selection changes.
		 * @param {number} index
		 */
		_instantfeedback: function(index) {
			var options = this._proxyelement.options;
			if (options[index]) {
				this.value = options[index].text;
			}
		},

		/**
		 * Update when aside fully is closed.
		 * @param {ts.ui.MenuModel} menu
		 * @param {strangeobject} observer
		 */
		_onasideclosed: function(menu, observer) {
			switch (menu.select) {
				case 'one':
					this._doselectone(menu.selectedIndex); // TODO: check this with the iPad :/
					break;
				case 'many':
					if (menu.donebuttonpressed) {
						this._doselectmany(menu.selectedIndexes);
					}
					break;
			}
			this._menumodel = null;
		},

		// Sync ....................................................................

		/**
		 * Sync the fake select to the real select. Note that
		 * this method is runs periodically on a {gui.Tick}.
		 * The strange cornercase hack is supposed to fix a
		 * mysterious bug somewhere in V4 where a SELECT with
		 * only a single option would simply not update after
		 * an asynchronous operation.
		 * @param {HTMLSelectElement} select The real SELECT element
		 * @param {ts.ui.MenuModel} model Exists only when Aside is open
		 */
		_syncfake: function(select, model) {
			var cornercase = select.options.length && !this.element.value;
			this.element.disabled = !!select.disabled;
			if (cornercase || [
				this._changedlength(select, this._optionslength, model),
				this._changedindex(select, this._selectedIndex, model),
				this._changedindexes(select, this._selectedIndexes, model)
			].some(function something(didchange) {
				return didchange;
			})) {
				this._updatestatus();
			}
		},

		/**
		 * Sync to SELECT: Options added or removed?
		 * @param {HTMLSelectElement} select
		 * @param {number} oldlength
		 * @param {ts.ui.MenuModel} model
		 * @returns {boolean}
		 */
		_changedlength: function(select, oldlength, model) {
			var did = select.options.length !== oldlength;
			if (did && model) {
				model.items = this._computemodelitems(select);
			}
			return did;
		},

		/**
		 * Sync to SELECT single: index changed?
		 * @param {HTMLSelectElement} select
		 * @param {number} oldindex
		 * @param {ts.ui.MenuModel} model
		 * @returns {boolean}
		 */
		_changedindex: function(select, oldindex, model) {
			var did = false, newindex;
			if (!select.multiple) {
				newindex = select.selectedIndex;
				if ((did = (newindex !== oldindex))) {
					if (model) {
						model.selectedIndex = newindex;
					}
				}
			}
			return did;
		},

		/**
		 * Sync to SELECT multiple: indexes changed?
		 * @param {HTMLSelectElement} select
		 * @param {number} oldlength
		 * @param {ts.ui.MenuModel} model
		 * @returns {boolean}
		 */
		_changedindexes: function(select, oldindexes, model) {
			var did = false, newindexes;
			if (select.multiple) {
				newindexes = this._getindexes(select.options);
				if (newindexes.some(function(i, x) {
					return oldindexes[x] !== i;
				})) {
					did = true;
					if (model) {
						// make sure not to reassign the list (this would kill the observer)
						var list = model.selectedIndexes;
						while (list.length) {
							list.pop();
						}
						newindexes.forEach(function(i) {
							list.push(i);
						});
					}
				}
			}
			return did;
		}

	});
}(
	gui.Combo.chained,
	gui.Arguments.confirmed,
	ts.ui.FieldSpirit.TICK_SYNC,
	ts.ui.FieldSpirit.TICK_TIME,
	gui.Array
));



/**
 * Spirit of the search.
 * @using {ts.ui.ButtonSpirit} ButtonSpirit
 * @using {gui.CSSPlugin} CSSPlugin
 * @using {gui.Type} Type
 * @using {gui.Combo.chained} chained
 */
ts.ui.SearchSpirit = (function using(ButtonSpirit, CSSPlugin, Type, chained) {
	/*
	 * We'll make the spirit interface identical to the model interface so
	 * that we can use them interchangeably whenever one makes more sense.
	*/
	var methodnames = ['onsearch', 'onidle', 'onfocus', 'onblur'];

	return ts.ui.Spirit.extend({

		/**
		 * Setup. If no model is assigned via standard configuration
		 * (framework-internal usecase), we'll create the default model.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.event.add('click').add('focus blur', this.element, this, true);
			if (!this._model) {
				this.model(this._defaultmodel());
			}
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'focus':
				case 'blur':
					this._isfocused = e.type === 'focus';
					this._update(this._model);
					break;
				case 'click':
					var button = ButtonSpirit.getButton(e.target);
					if (button && CSSPlugin.contains(button, 'ts-button-clear'))	{
						this.dom.q('.ts-input').blur(); // IE dysfunction
						this.tick.time(function() {
							this._clear(this._model);
						}, 25);
					}
					break;
			}
		},

		/**
		 * Assign or change the model (the API user is not supposed to do this!).
		 * @param {ts.ui.SearchModel} model
		 */
		model: function(model) {
			if (model !== this._model) { // TODO(jmo@): edbml.$get should fix this: https://github.com/wunderbyte/spiritual-edbml/issues/14
				if (this._model) {
					this._model.removeObserver(this);
				}
				this._model = model;
				model.addObserver(this);
				if (!this.script.loaded) {
					this.script.load(ts.ui.SearchSpirit.edbml);
				}
				this.script.input(model);
				this._update(this._model);
			}
		},

		/**
		 * Handle model changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.Spirit.prototype.onchange.call(this, changes);
			var model = this._model;
			changes.forEach(function(c) {
				if (c.object === model) {
					switch (c.name) {
						case 'value':
							this._update(model);
							break;
						case 'flex':
							// perhaps do something here?
							break;
					}
				}
			}, this);
		},

		// API .....................................................................

		/**
		 * @type {string}
		 */
		value: {
			getter: function() {
				return this._model.value;
			},
			setter: function(value) {
				this._model.value = value;
			}
		},

		/**
		 * @type {number}
		 */
		idletime: {
			getter: function() {
				return this._model.idletime;
			},
			setter: function(value) {
				this._model.idletime = value;
			}
		},

		/**
		 * Open for implementation: Called when the user presses ENTER
		 * (noting that this only works for the default-created model).
		 * @param {string} value
		 */
		onsearch: function(value) {},

		/**
		 * Open for implementation: Called when the user pauses typing.
		 * @param {string} value
		 */
		onidle: function(value) {},

		/**
		 * Open for implementation: Called when the search field is focused.
		 */
		onfocus: function() {},

		/**
		 * Open for implementation: Called when the search field gets blurred.
		 */
		onblur: function() {},

		/**
		 * Focus the search field.
		 * @returns {ts.ui.SearchSpirit}
		 */
		focus: chained(function() {
			this._model.focus();
		}),

		/**
		 * Blur the search field.
		 * @returns {ts.ui.SearchSpirit}
		 */
		blur: chained(function() {
			this._model.blur();
		}),

		/**
		 * The `info` string acts as a title (tooltip) when
		 * collapsed and as an input placeholder when expanded.
		 * @param @optional {string} text
		 * @returns {string|ts.ui.SearchSpirit}
		 */
		info: chained(function(text) {
			if (arguments.length) {
				this._model.info = text;
			} else {
				return this._model.info;
			}
		}),

		// Private .................................................................

		/**
		 * The model goes here.
		 * @type {ts.ui.SearchModel}
		 */
		_model: null,

		/**
		 * Create the default model. We'll attempt to make the
		 * spirit interface identical to the model interface.
		 * @returns {ts.ui.SearchModel}
		 */
		_defaultmodel: function() {
			var spirit = this, model = new ts.ui.SearchModel();
			methodnames.forEach(function(method) {
				model[method] = function() {
					if (Type.isFunction(spirit[method])) {
						spirit[method].apply(spirit, arguments);
					}
				};
			});
			return model;
		},

		/**
		 * Generally update things.
		 * @param {ts.ui.SearchModel} model
		 */
		_update: function(model) {
			if (model.flex) {
				this.css.add('ts-searching');
			} else {
				var emptiness = !model.value;
				var searching = model.value || this._isfocused;
				var isalready = this.css.contains('ts-searching');
				this.css.shift(emptiness, 'ts-empty').shift(searching, 'ts-searching');
				if (this.css.contains('ts-searching') !== isalready) {
					this.action.dispatch('ts-action-search', !isalready);
				}
			}
		},

		/**
		 * Clear the search.
		 * @param {ts.ui.SearchModel} model
		 */
		_clear: function(model) {
			if (!model.flex) { // hack for the ToolBar here...
				this.action.dispatch('ts-action-search', false);
				this.css.remove('ts-searching');
			}
			model.removeObserver(this);
			model.clear();
			this.css.add('ts-empty');
			this.tick.time(function reset() {
				model.addObserver(this);
			});
		}

	});
}(ts.ui.ButtonSpirit, gui.CSSPlugin, gui.Type, gui.Combo.chained));



/**
 * Spirit of the form.
 * @extends {ts.ui.FormSupportSpirit}
 * @using {ts.ui.FormsModule} module
 */
ts.ui.FormSpirit = (function() {
	return ts.ui.FormSupportSpirit.extend({

		/**
		 * Add the classname if not already.
		 * TODO: Just-in-time channeling of form spirits whenever the
		 * form is first initialized (but ONLY the complex selectors
		 * that rely on markup structure to channel the spirits).
		 */
		onconstruct: function() {
			ts.ui.FormSupportSpirit.prototype.onconstruct.call(this);
			this.css.add(ts.ui.CLASS_FORM);
			if (!this.element.getAttribute('novalidate')) {
				this.element.setAttribute('novalidate', 'novalidate');
			}
		},

		/**
		 * By default, don't submit to nowhere. This will make it easier
		 * to setup a clientside form (one that is running on AJAX calls).
		 */
		onconfigure: function() {
			ts.ui.FormSupportSpirit.prototype.onconfigure.call(this);
			var elm = this.element, method = (elm.method || '').toLowerCase();
			if (elm.localName === 'form' && !elm.action && method !== 'post') {
				elm.action = ts.ui.FormSpirit.ACTION_DEFAULT;
			}
		},

		/**
		 * TODO: Can this be privatized (or removed)?
		 * Get or set model. TODO: Figure out how this conflicts
		 * with a model assigned via {ts.ui.FormSpirit#summon}.
		 * @param {JSONObject|ts.ui.FormModel} model
		 * @returns {ts.ui.FormModel}
		 */
		model: ts.ui.Spirit.createModelMethod(
			ts.ui.FormModel, 'ts.ui.FormSpirit.edbml'
		),

		// Private .................................................................

		/**
		 * Form model.
		 * @type {ts.ui.FormModel}
		 */
		_model: null

	}, { // XStatic ..............................................................

		/**
		 * Summon spirit.
		 * @param {ts.ui.FormModel=} opt_model
		 * @return {ts.ui.FormSpirit}
		 */
		summon: function(model) {
			var spirit = this.possess(
				gui.HTMLParser.parse(
					ts.ui.form.edbml()
				)
			);
			if (model) {
				spirit.render(model);
			}
			return spirit;
		}

	}, { // Static ...............................................................

		/**
		 * Default form 'action' attribute value so that the form
		 * never accidentally submits to the page it's running on.
		 * If you do need that, you must declare <form action="">.
		 * @type {string}
		 */
		ACTION_DEFAULT: gui.IframeSpirit.SRC_DEFAULT

	});
}());



/**
 * Spirit of the autocomplete.
 */
ts.ui.AutocompleteDropdownSpirit = (function using(Client) {
	var CLASS_RESULTS_ITEM = 'ts-autocomplete-results';
	var CLASS_ITEM_SELECTED = 'ts-autocomplete-selected';

	var KeyCodes = {
		TAB: 9,
		ENTER: 13,
		ESC: 27,
		UP: 38,
		DOWN: 40,

		/**
		 *
		 * @param e {DOMEvent}
		 * @returns {Number}
		 */
		getKeyCode: function(e) {
			return window.event ? event.keyCode : e.keyCode ? e.keyCode : e.which;
		}
	};

	function getLocale() {
		return ts.ui.Autocomplete.localize();
	}

	return ts.ui.Spirit.extend({
		/**
		 * Should we show the dropdown?
		 * @type {Boolean}
		 */
		_isActive: false,

		// Proxying from another input field here ..................................

		/**
		 * Bind to all important events of the original input fields
		 * @param {HTMLElement} element
		 */
		proxy: function(element) {
			this._proxyelement = element;
			this._proxyspirit = ts.ui.get(element);
			['keyup', 'keydown', 'focus', 'input', 'blur', 'change'].forEach(
				function(event) {
					this.event.add(event, element, this);
				}, this
			);
		},

		/**
		 * Load list of all possible items
		 * @type {Array.<{key: String, value: String}>}
		 */
		data: function(d) {
			this._model.autocompleteList = d;
		},

		onfilter: function(f) {
			this._model.onfilter = f;
		},

		onselect: function(f) {
			this._model.onselect = f;
		},

		// Lifecycle ...............................................................

		/**
		 * Create the model.
		 */
		onconstruct: function() {
			ts.ui.Spirit.prototype.onconstruct.call(this);
			this._model = new ts.ui.AutocompleteDropdownModel();
			this._locale = getLocale();
		},

		/**
		 * Render the EDBML
		 */
		onenter: function() {
			ts.ui.Spirit.prototype.onenter.call(this);
			this.script.load(ts.ui.AutocompleteDropdownSpirit.edbml);
			this.script.input(this._model);
		},

		/**
		 * Clean up potential memory leaks
		 */
		ondestuct: function() {
			ts.ui.Spirit.prototype.prototype.call(this);
			delete this._model.autocompleteList;
			delete this._model.filteredAutocompleteList;
			this._model.dispose();
		},

		// Events ..................................................................

		/**
		 * Call the on`eventname` fn's from the spirit
		 * @param e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			var events = ['keyup', 'keydown', 'focus', 'input', 'blur'];

			if (events.indexOf(e.type) > -1) {
				this['on' + e.type](e);
			}
		},

		/**
		 * Handle up/down/enter/tab keys
		 */
		onkeydown: function(e) {
			var autocompleteElem = this._getelem();
			if (!autocompleteElem) {
				return;
			}
			var selectedElem = this._getselected();
			var keyCode = KeyCodes.getKeyCode(e);
			if (
				keyCode === KeyCodes.UP &&
				selectedElem !== autocompleteElem.firstChild
			) {
				this._select('previous');
			} else if (
				keyCode === KeyCodes.DOWN &&
				selectedElem !== autocompleteElem.lastChild
			) {
				this._select('next');
			} else if (keyCode === KeyCodes.ENTER) {
				if (selectedElem.className.indexOf(CLASS_RESULTS_ITEM) === -1) {
					this._selectelem(selectedElem);
					autocompleteElem.scrollTop = 0;
					this._render();
				}
			} else if (keyCode === KeyCodes.TAB || keyCode === KeyCodes.ESC) {
				this.onblur(null, true);
			}

			if (
				keyCode === KeyCodes.UP ||
				keyCode === KeyCodes.DOWN ||
				keyCode === KeyCodes.ENTER
			) {
				e.preventDefault();
			}
		},

		/**
		 * Capture esc/up/down keyup before they get to the input field
		 */
		onkeyup: function(e) {
			if (
				this._getelem() &&
				this._isActive &&
				this._model.filteredAutocompleteList.length
			) {
				var keyCode = KeyCodes.getKeyCode(e);
				if (
					keyCode === KeyCodes.ESC ||
					keyCode === KeyCodes.UP ||
					keyCode === KeyCodes.DOWN
				) {
					e.stopPropagation();
				}
			}
		},

		/**
		 * On focus, activate the field and filter
		 */
		onfocus: function() {
			this._isActive = true;
			this._render();
		},

		/**
		 * When typing, render filter results
		 */
		oninput: function() {
			this.onfocus();
		},

		/**
		 * On blur, hide the field
		 * isNow should be false, when clicking on the field because the focus
		 * would be lost from the input before the click event can capture the
		 * item being clicked.
		 * @param e
		 * @param {boolean} isNow should we hide it now, or in a few milliseconds?
		 */
		onblur: function(e, isNow) {
			var onblurAction = function() {
				this._isActive = false;
				this.script.run();
			}.bind(this);

			if (isNow) {
				onblurAction();
			} else {
				this.tick.time(
					onblurAction,
					Client.isExplorer ? 300 : 100
				);
			}
		},

		// Private .................................................................

		/**
		 * Get the autocomplete dropdown element
		 * @returns {HTMLElement} div
		 * @private
		 */
		_getelem: function() {
			return document.getElementById(this._model.$instanceid + '-list');
		},

		/**
		 * Get selected element
		 * @returns {HTMLElement} li
		 * @private
		 */
		_getselected: function() {
			return this._getelem().querySelector('.' + CLASS_ITEM_SELECTED);
		},

		/**
		 * Scroll the suggestion dropdown so that the elem appears as the first item
		 * @param {HTMLElement} elem
		 */
		_scroll: function(elem) {
			if (elem) {
				var elemRect = elem.getBoundingClientRect();
				var elemHeight = elemRect.bottom - elemRect.top;
				var elemSiblings = elem.parentNode.childNodes;
				for (var elemIdx = 0; elemIdx < elemSiblings.length; elemIdx++) {
					if (elemSiblings[elemIdx] === elem) {
						this._getelem().scrollTop = elemIdx * elemHeight;
						return;
					}
				}
			}
		},

		/**
		 * Select previous or next sibling and scroll the autocomplete to it
		 * @param direction 'previous' or 'next'
		 * @private
		 */
		_select: function(direction) {
			var selectedElem = this._getselected();
			this._unselect();
			selectedElem = selectedElem[direction + 'Sibling'];
			selectedElem.className += ' ' + CLASS_ITEM_SELECTED;
			this._scroll(selectedElem);
		},

		/**
		 * Remove selection from all items
		 * @private
		 */
		_unselect: function() {
			var childrenItems = this._getelem().children;
			if (childrenItems.length > 1) {
				for (var i = 0; i < childrenItems.length; i++) {
					childrenItems[i].className = childrenItems[i].className.replace(CLASS_ITEM_SELECTED, '');
				}
			}
		},

		/**
		 * Select DOM Element and parse the value from it
		 * @param {HTMLElement} elem
		 * @private
		 */
		_selectelem: function(elem) {
			var item = {
				key: '',
				value: ''
			};
			try {
				item = JSON.parse(elem.getAttribute('data-item'));
			} catch (e) {
				console.warn('Invalid JSON item!', e);
			}
			this._onselect(item, false);
		},

		/**
		 * Call the model's onselect and blur the field if necessary
		 * @param {Object} item
		 * @param {boolean} noBlur if true, the field won't blur
		 * @private
		 */
		_onselect: function(item, noBlur) {
			this._proxyelement.value = this._model.onselect(item);
			if (!noBlur) {
				this.onblur(null, true);
			}
		},

		/**
		 * Filter results and render the list
		 * Also select the first item in the list when searching and scroll to it
		 * @TODO @dsp maybe debounce the filtering
		 * @private
		 */
		_render: function() {
			var filter = this._proxyelement.value;

			if (this._model.onfilter) {
				this._model.filteredAutocompleteList = this._model.onfilter(filter);
			} else {
				this._model.filteredAutocompleteList = [];
			}

			this.script.run(
				this._locale.matchString
			);
			var autocompleteElem = this._getelem();
			if (autocompleteElem !== null) {
				var autocompleteListLength = this._model.filteredAutocompleteList.length;

				if (autocompleteListLength > 0) {
					// Always select the first item in the list
					autocompleteElem.firstChild.className += ' ' + CLASS_ITEM_SELECTED;
				}
				this._scroll(autocompleteElem.firstChild);
			}
		}
	}, { // Static ...............................................................
		summon: function() {
			return this.possess(document.createElement('div'));
		}
	});
})(
	gui.Client
);



/**
 * Spirit of the SELECT.
 * @extends {gui.Spirit}
 */
ts.ui.AutocompleteInputSpirit = (function using(chained) {
	return ts.ui.TextInputSpirit.extend({

		/**
		 * Get ready.
		 */
		onready: function() {
			ts.ui.TextInputSpirit.prototype.onready.call(this);
			this._getdropdown().proxy(this.element);

			this._label(function(label) {
				label.css.add('ts-autocompletelabel');
			});
		},

		/**
		 * Load autocomplete items into the model through the spirit
		 * @param {Array.<{key: String, value: String}>} d
		 */
		data: chained(function(d) {
			this._getdropdown().data(d);
		}),

		/**
		 * Load filtering function into the model through the spirit
		 * @param {Function} f
		 */
		onfilter: chained(function(f) {
			this._getdropdown().onfilter(f);
			return this;
		}),

		/**
		 * Load selection function into the model through the spirit
		 * @param {Function} f
		 */
		onselect: chained(function(f) {
			this._getdropdown().onselect(f);
			return this;
		}),

		// Private ...................................................................

		/**
		 * Get or create the dropdown spirit
		 * @returns {ts.ui.AutocompleteDropdownSpirit}
		 */
		_getdropdown: function() {
			var AutocompleteDropdown = ts.ui.AutocompleteDropdownSpirit;
			var dropdown = this.dom.following(AutocompleteDropdown);
			if (dropdown[0]) {
				return dropdown[0];
			} else {
				return this.dom.after(AutocompleteDropdown.summon());
			}
		}
	});
})(
	gui.Combo.chained
);



/**
 * Forms GUI module.
 */
ts.ui.FormsModule = gui.module('forms-gui@tradeshift.com', {

	/**
	 * Channeling spirits to CSS selectors.
	 */
	channel: [

		['[data-ts=Form]', ts.ui.FormSpirit],
		['[data-ts=FieldSet]', ts.ui.FieldSetSpirit],
		['[data-ts=Label]', ts.ui.LabelSpirit],
		['[data-ts=Switch]', ts.ui.SwitchSpirit],
		['[data-ts=Option]', ts.ui.OptionSpirit],
		['[data-ts=Input]', ts.ui.TextInputSpirit],
		['[data-ts=DateInput]', ts.ui.DateInputSpirit],
		['[data-ts=TextArea]', ts.ui.TextAreaSpirit],
		['[data-ts=Select]', ts.ui.SelectSpirit],
		['[data-ts=Search]', ts.ui.SearchSpirit],
		['[data-ts=AutoComplete]', ts.ui.AutocompleteInputSpirit],
		['[data-ts=Calendar]', ts.ui.CalendarSpirit], // does not belong here...

		// needed because of illegal usage in V4 :(
		['fieldset.ts-form', ts.ui.FieldSetSpirit],
		['label.ts-form', ts.ui.LabelSpirit],

		// these are really "private" spirits created by
		// other spirits, but we need to assign them here
		// because otherwise they will not be recognized
		// when Angular (sadly) has parsed them into the
		// templates, which in itself is a tragic problem.
		// @see {ts.ui.DateInputSpirit}
		// @see {ts.ui.SelectSpirit}
		['[data-ts=FakeDateInput]', ts.ui.FakeDateInputSpirit],
		['[data-ts=FakeSelectInput]', ts.ui.FakeSelectInputSpirit]
	],

	/**
	 * Channeling spirits to complex CSS selectors at considerable performance
	 * penalty; this will however make the forms markup much easier to author.
	 * This method is called when the first {ts.ui.FormSpirit} is encountered.
	 * @see {ts.ui.FormSpirit#onconstruct}
	 * @param {boolean} enabled
	 */
	channelComplexSelectors: function(enabled) {
		if (enabled && !this._channeled) {
			this._channeled = true;
			gui.channel([
				['.ts-form fieldset', ts.ui.FieldSetSpirit],
				['.ts-form label', ts.ui.LabelSpirit],
				['.ts-form span', ts.ui.LabelTextSpirit],
				['.ts-form input[type=date]', ts.ui.DateInputSpirit],
				['.ts-form span + input[type=checkbox]', ts.ui.SwitchSpirit],
				['.ts-form input[type=checkbox], .ts-form input[type=radio]', ts.ui.OptionSpirit],
				['.ts-form input', ts.ui.TextInputSpirit],
				['.ts-form textarea', ts.ui.TextAreaSpirit],
				['.ts-form select', ts.ui.SelectSpirit]
			]);
		}
	},

	// Private ...................................................................

	/**
	 * Complex selectors have been channeled?
	 * @type {boolean}
	 */
	_channeled: false

});



/**
 * TradeshiftObject base spirit.
 * @see {ts.ui.CompanyCardSpirit}
 * @extends {ts.ui.Spirit}
 * @using {gui.Type} Type
 * @using {gui.Combo.chained}
 * @using {gui.Arguments.confirmed}
 */
ts.ui.ObjectSpirit = (function using(Type, chained, confirmed) {
	// TODO: automatically quote keys (for inline JSON island)
	// TODO: Perhaps use {gui.ConfigPlugin#jsonify} for this?
	// function escape(json) {
	// 	var regx = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g;
	// 	return json.replace(regx, '$1"$2":');
	// }

	return ts.ui.Spirit.extend({

		/**
		 * Set the GUID (via HTML attribute ts.id="myguid").
		 * @type {string}
		 */
		id: {
			getter: function() {
				return this._guid;
			},
			setter: function(guid) {
				this._guid = guid;
				this._model = null;
				this.input.connect(this.constructor.collection);
			}
		},

		/**
		 * Show details on click (via HTML attribute ts.details="true").
		 * @type {boolean}
		 */
		details: {
			getter: function() {
				return this._details;
			},
			setter: function(enable) {
				if (enable === '') { // TODO: This by default in {gui.AttPlugin}
					enable = true;
				}
				if (Type.isBoolean(enable)) {
					this._toggledetails(enable, this.element);
					this._details = enable;
				}
			}
		},

		/**
		 * Scenario 1: The model is extracted from embedded JSON.
		 * There's no code to support the scenario where JSON is
		 * injected via the `ts.render` attribute because that's
		 * just built into spirits via the {gui.ConfigPlugin}.
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			var script, path = 'script[type="application/json"]';
			this.css.add('ts-object');
			this.script.load(ts.ui.ObjectSpirit.edbml);
			if ((script = this.dom.q(path))) {
				// console.log(encodeURIComponent(script.textContent.trim()));
				this.render(JSON.parse(script.textContent));
			} else {
				this.script.run(this._model);
			}
		},

		/**
		 * If the element wraped by button or a link without a `href`,
		 * The component should detail itself in an Aside when clicked.
		 * TODO: Make sure that ENTER key also works!
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			switch (e.type) {
				case 'click':
					if (this._details) {
						this.open();
					}
					break;
			}
		},

		/**
		 * Scenario 2: The model is injected manually by some guy.
		 * @param {JSONObject|ts.ui.ObjectModel} json
		 * @returns {ts.ui.ObjectSpirit}
		 */
		render: confirmed('object')(chained(function(json) {
			if (this._assignmodel(json)) {
				this._guid = this._model.id;
				this.script.run(this._model);
			}
		})),

		/**
		 * The sub-class should implented the function
		 * May be we implented it here
		 * Open an aside to show some details
		 */
		open: function() {},

		/**
		 * Assign new model from argument, disposing any old model.
		 * @param {JSONObject|ts.ui.CompanyCardModel} data
		 * @returns {boolean} True if a model was assigned
		 */
		_assignmodel: function(data) {
			var Model = this.constructor.model;
			if (data) {
				if (this._model) {
					this._model.dispose();
				}
				this._model = Model.from(data);
			}
			return this._model !== null;
		},

		/**
		 * Scenario 3: The model is retrieved from public output
		 * (The listener is setup when someone changes the `id`).
		 * @param {edb.Input} input
		 */
		oninput: function(input) {
			ts.ui.Spirit.prototype.oninput.call(this, input);
			var Collection = this.constructor.collection;
			if (input.type === Collection) {
				var thismodel = input.data.get(this.id);
				if (thismodel) {
					this.input.disconnect(Collection);
					this._assignmodel(thismodel);
					if (this.script.loaded) {
						this.script.run(thismodel);
					}
				}
			}
		},

		// Private .................................................................

		/**
		 * Model GUID.
		 * @type {string}
		 */
		_guid: null,

		/**
		 * The model itself.
		 * @type {ts.ui.ObjectModel}
		 */
		_model: null,

		/**
		 * Show details view on click?
		 * @type {boolean}
		 */
		_details: false,

		/**
		 * Setup to show details in Aside.
		 * @param {boolean} on
		 * @param {Element} elm
		 */
		_toggledetails: function(on, elm) {
			this.css.shift(on, 'ts-has-details');
			this.event.shift(on, 'click');
			if (!this.dom.tag().match(/button|a/)) {
				elm.tabIndex = on ? this.att.get('tabindex') || 0 : -1;
			}
		}

	}, { // Static ...............................................................

		/**
		 * Scenario 1 and 2: Convert injected JSON to this
		 * kind of model. The subclass should define this.
		 * @type {constructor}
		 */
		model: ts.ui.ObjectModel,

		/**
		 * Scenario 3: Fetch the model from public output of
		 * this collection.	The subclass should define this.
		 * @type {constructor}
		 */
		collection: ts.ui.ObjectCollection

	});
}(gui.Type, gui.Combo.chained, gui.Arguments.confirmed));



/**
 * Spirit of the card.
 * @see {ts.ui.CompanyCardSpirit}
 * @see {ts.ui.UserCardSpirit}
 * @using {ts.ui.Card} card
 */
ts.ui.CardSpirit = (function(Card) {
	/*
	 * If these classes are not found,
	 * we'll add a default classname.
	 */
	var specialclasses = [
		Card.TYPE_COMPACT,
		Card.TYPE_INLINE,
		Card.TYPE_DETAILS
	];

	return ts.ui.ObjectSpirit.extend({

		/**
		 * Stub myself with a potential mock model so that we can
		 * show a default rendering before some real data arrives.
		 * TODO: Perhaps move up to {ts.ui.ObjectSpirit}?
		 */
		onconfigure: function() {
			var mock = this.constructor.MOCK_MODEL;
			if (mock && !this._model) {
				this._model = mock;
			}
			ts.ui.ObjectSpirit.prototype.onconfigure.call(this);
		},

		/**
		 * Setup.
		 */
		onenter: function() {
			ts.ui.ObjectSpirit.prototype.onenter.call(this);
			this._classnames(this.css);
		},

		// Private .................................................................

		/**
		 * Add default classnames (for nicer LESS management).
		 * @param {gui.CSSPlugin} css
		 */
		_classnames: function(css) {
			css.add('ts-card');
			if (!specialclasses.some(function(cname) {
				return css.contains(cname);
			})) {
				css.add(Card.TYPE_DEFAULT);
			}
		}

	});
}(ts.ui.Card));



/**
 * Spirit of the Tradeshift object.
 * @extends {ts.ui.CardSpirit}
 */
ts.ui.CompanyCardSpirit = ts.ui.CardSpirit.extend({

	/**
	 * TODO: Maybe add logic here to hide
	 * the logo until it's fully loaded?
	 */
	onrender: function() {
		ts.ui.CardSpirit.prototype.onrender.call(this);
	},

	/**
	 * @experimental
	 * From the future.
	 */
	open: function() {
		if (this._model) {
			this._openaside(ts.ui.CompanyCardModel.from(this._model));
			console.warn('This is an experimental feature. Please don\'t use it.');
		} else {
			throw new Error(this + ' has no data');
		}
	},

	/**
	 * TODO: This is just mockup stuff, don't use it yet!
	 * @param {ts.ui.CompanyCardModel} model
	 */
	_openaside: function(clone) {
		clone.type = 'ts-details';
		var aside = ts.ui.Aside({
			title: clone.data.name || '',
			items: [
				clone,
				{
					item: 'menu',
					items: [
						'Create Document',
						'Invite',
						'Categorize As',
						'Properties',
						'Remove Company'
					].map(function(label) {
						return {
							label: label
						};
					})
				}
			]
		}).open();

		/*
		 * We need to implement a menu.onchange() callback of some kind
		 * now that the menu items have been refactored to "simple" data.
		 */
		(function tempworkaround(menu) {
			menu.addObserver({
				onchange: function(changes) {
					if (changes[0].name === 'selectedIndex') {
						aside.close();
						aside.onclosed = function() {
							ts.ui.Notification.success('To be continued...');
							menu.removeObserver(this);
							aside.dispose();
						};
					}
				}
			});
		}(aside.items[1]));
	}

}, { // Static .................................................................

	/**
	 * Convert injected JSON to this kind of model.
	 * @see {ts.ui.ObjectSpirit}
	 * @type {constructor}
	 */
	model: ts.ui.CompanyCardModel,

	/**
	 * Fetch the model from this kind of collection.
	 * @see {ts.ui.ObjectSpirit}
	 * @type {constructor}
	 */
	collection: ts.ui.CompanyCardCollection,

	/**
	 * Dummy model used to render a preloader-layout.
	 * No real data in it, so all can share the same.
	 * @type {ts.ui.CompanyCardModel}
	 */
	MOCK_MODEL: new ts.ui.CompanyCardModel({
		id: gui.KeyMaster.generateGUID(),
		mock: true,
		data: {
			name: 'Company Name',
			size: '123',
			location: 'Company Location, Country',
			industry: 'Company Industry'
		}
	})

});



/**
 * Spirit of the user image.
 * @extends {ts.ui.ImageSpirit}
 */
ts.ui.UserImageSpirit = (function using() {
	return ts.ui.ImageSpirit.extend({

	});
}());



/**
 * Spirit of the user.
 * @extends {ts.ui.CardSpirit}
 * @using {ts.ui.CardSpirit} CardSpirit
 */
ts.ui.UserCardSpirit = (function(UserCard) {
	return ts.ui.CardSpirit.extend({

		/**
		 * Show the user details in an aside.
		 */
		open: function() {
			var clone = ts.ui.UserCardModel.from(this._model);
			clone.type = 'ts-details';
			ts.ui.Aside({
				title: UserCard.localize('userDetails'),
				items: [
					clone
				],
				onclosed: function() {
					this.dispose();
				}
			}).open();
		}

	}, { // Static ..............................................................

		/**
		 * Convert injected JSON to this kind of model.
		 * @see {ts.ui.ObjectSpirit}
		 * @type {constructor}
		 */
		model: ts.ui.UserCardModel,

		/**
		 * Fetch the model from this kind of collection.
		 * @see {ts.ui.ObjectSpirit}
		 * @type {constructor}
		 */
		collection: ts.ui.UserCardCollection

	});
}(ts.ui.UserCard));



/**
 * Objects GUI module.
 */
gui.module('objects-gui@tradeshift.com', {

	/**
	 * Channeling spirits to CSS selectors.
	 */
	channel: [

		['[data-ts=CompanyCard]', ts.ui.CompanyCardSpirit],
		['[data-ts=UserImage]', ts.ui.UserImageSpirit],
		['[data-ts=UserCard]', ts.ui.UserCardSpirit]
	]

});



/**
 * Spirit of the bar.
 * @see http://www.amazon.co.uk/Spirit-bar-delivered-students-Lectures/dp/B0008AZ278
 * @see {ts.ui.TopBarSpirit}
 * @see {ts.ui.ToolBarSpirit}
 * @using {ts.ui.TopBar} TopBar
 * @using {gui.Client} Client
 * @using {gui.Combo.chained} chained
 * @using {number} UNIT_DOUBLE
 * @using {number} UNIT_TRIPLE
 */
ts.ui.BarSpirit = (function(TopBar, Client, chained, UNIT_DOUBLE, UNIT_TRIPLE) {
	return ts.ui.Spirit.extend({

		/**
		 * Scroll the bar whenever MAIN is scrolling. This always applies to the
		 * TopBar. It applies to the ToolBar (which is different) only in mobile
		 * breakpoint and only when it's positioned directly before `ts-main`.
		 * TODO: Big time `pointer-events:none` while scrolling!
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			if (e.type === 'scroll') {
				this._slide(e.target.scrollTop);
			}
		},

		/**
		 * TODO
		 */
		hide: function() {
			alert('TODO!');
		},

		/**
		 * TODO
		 */
		show: function() {
			alert('TODO!');
		},

		// Privileged ..............................................................

		/**
		 * Track the scroll position of a different main (top level panel layout).
		 * Note that the scrolling BarSpirit only works in the mobile breakpoint.
		 * @param {HTMLMainElement} main
		 * @returns {ts.ui.BarSpirit}
		 */
		$setmain: chained(function(main) {
			this._main = main;
			this._onbreakpoint();
			this._slide(main.scrollTop);
		}),

		/**
		 * Get specifically assigned Main or just the first Main on the page.
		 * @returns {HTMLMainElement}
		 */
		$getmain: function() {
			return this._main || ((this._main = this.dom.qdoc('.ts-main')));
		},

		// Private .................................................................

		/**
		 * Snapshot scrolling.
		 * @type {number}
		 */
		_scroll: 0,

		/**
		 * Supporting multiple Main elements.
		 * @type {HTMLMainElement}
		 */
		_main: null,

		/**
		 * Setup stuff in mobule breakpoint (the subclass will decide if and when).
		 * Note that the floating bar is not floating in IE9 because of certain
		 * conflicts with JS positioning versus CSS positioning (IE9 must use
		 * `left` and `top` in both cases) but IE9 users are after all not mobile.
		 * TODO: Make sure to also remove the breakpoint listener when we terminate.
		 */
		_initbreakpoint: function(attach) {
			var main = this.$getmain();
			if (main && Client.has3D) {
				this.sprite.y = 0;
				if (attach) {
					this._onbreakpoint();
					this._breakfunction = function(newpoint, oldpoint) {
						this._onbreakpoint();
						if (oldpoint && oldpoint === 'mobile') {
							this.sprite.y = 0;
						}
					}.bind(this);
					ts.ui.addBreakPointListener(this._breakfunction);
				} else if (this._breakfunction) {
					ts.ui.removeBreakPointListener(this._breakfunction);
				}
			}
		},

		/**
		 * Breakpoint changed (or was initialized).
		 * @param @optional {HTMLMainElement} main
		 */
		_onbreakpoint: function() {
			var main = this.$getmain();
			var mobi = ts.ui.isMobilePoint();
			this._scroll = main.scrollTop;
			this.event.shift(mobi, 'scroll', main, this);
		},

		/**
		 * Scroll TopBar when MAIN is scrolled
		 * (this happens in mobile breakpoint).
		 * @param {number} scroll Main scrollTop
		 */
		_slide: function(scroll) {
			if (Client.has3D) {
				var stop = 0 - this._offsetLimit();
				var delt = scroll - this._scroll;
				var down = delt > 0;
				var doit = false;
				var next = 0;
				if (down) {
					doit = this.sprite.y > stop;
				} else {
					doit = this.sprite.y < 0;
				}
				if (doit) {
					next = this.sprite.y - delt;
					next = next < stop ? stop : next;
					next = next > 0 ? 0 : next;
					this.sprite.y = next;
				}
				this._scroll = scroll;
			}
		},

		/**
		 * The bar should stop sliding after this many pixels.
		 * @returns {number}
		 */
		_offsetLimit: function() {
			return UNIT_TRIPLE + (TopBar.tabs().length ? UNIT_DOUBLE : 0);
		}

	});
}(ts.ui.TopBar, gui.Client, gui.Combo.chained, ts.ui.UNIT_DOUBLE, ts.ui.UNIT_TRIPLE));

/**
 * Generate methods `blue` `green` `purple` and so
 * on to change the general color scheme of the Bar.
 * @using {Object} methods
 */
(function generatercode(methods) {
	var proto = ts.ui.BarSpirit.prototype;
	var names = Object.keys(methods).map(function(key) {
		return methods[key];
	});
	gui.Object.each(methods, function(method, classname) {
		proto[method] = function() {
			(this._model || {}).color = classname;
			this.css.remove(names).add(classname);
			return this;
		};
	});
}(ts.ui.BACKGROUND_COLORS));



/**
 * Spirit of the toolbar.
 * @using {gui.Combo.chained} chained
 * @using {gui.Client} Client
 * @using {gui.Type} Type
 * @using {gui.Array} guiArray
 * @using {gui.CSSPlugin} CSSPlugin
 * @using {ts.ui.TextModel} TextModel
 * @using {ts.ui.SearchModel} SearchModel
 * @using {ts.ui.TopBar} TopBar
 * @using {ts.ui.ButtonModel} ButtonModel
 * @using {ts.ui.BACKGROUND_COLORS} bgcolors
 */
ts.ui.ToolBarSpirit = (function using(chained, confirmed, Client, Type, guiArray, CSSPlugin, DOMPlugin, TextModel, SearchModel, TopBar, ButtonModel, bgcolors) {
	/*
	 * When rendering as a statusbar, we'll split into multiple rows
	 * when we hit this breakpoint. Note that this is only used in
	 * the Table component for now, might need an adjustment later.
	 * Breakpoint corresponds to an iPad in vertical orientation.
	 */
	var BREAKPOINT_1 = 768;

	/**
	 * Is flexed item?
	 * @param {HTMLLiElement} li
	 * @returns {boolean}
	 */
	function hasflex(li) {
		return CSSPlugin.contains(li, 'ts-flex');
	}

	/**
	 * Used to filter flexed items.
	 * @param {HTMLLiElement} li
	 * @returns {boolean}
	 */
	function nonflex(li) {
		return !CSSPlugin.contains(li, 'ts-flex');
	}

	/**
	 * Used to compute items total width.
	 * @param {number} sum
	 * @param {HTMLLiElement} li
	 * @returns {number}
	 */
	function sumwidth(sum, li) {
		return sum + li.offsetWidth;
	}

	return ts.ui.BarSpirit.extend({

		/**
		 * Bar is visible?
		 * @type {boolean}
		 */
		visible: true,

		/**
		 * @see https://github.com/wunderbyte/spiritual-gui/issues/109
		 */
		onenter: function() {
			this._validate();
			ts.ui.BarSpirit.prototype.onenter.call(this);
			this.action.add([edbml.ACTION_RENDER, 'ts-action-search']);
			if (!this.css.name().includes('ts-bg')) {
				this.lite();
			}
		},

		/**
		 * Further hotfix for situation explained in previous comment.
		 */
		onattach: function() {
			ts.ui.BarSpirit.prototype.onattach.call(this);
			this._layoutmain(true);
		},

		/**
		 * Remove assistant classnames.
		 */
		ondetach: function() {
			ts.ui.BarSpirit.prototype.ondetach.call(this);
			this._layoutmain(false);
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.BarSpirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case edbml.ACTION_RENDER:
					this._flex();
					break;
				case 'ts-action-search':
					var li = this.dom.q('.ts-toolbar-search');
					CSSPlugin.shift(li, a.data, 'ts-searching');
					this._flex();
					break;
			}
		},

		/**
		 * Handle event. Focus the search when the title is clicked.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.BarSpirit.prototype.onevent.call(this, e);
			var title = this.dom.q('.ts-toolbar-title');
			var search = this.dom.q('.ts-search', ts.ui.SearchSpirit);
			if (title && search && DOMPlugin.contains(title, e.target)) {
				search.focus();
			}
		},

		/**
		 * Handle model changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.BarSpirit.prototype.onchange.call(this, changes);
			changes.forEach(function(c) {
				if (c.name === 'hascontent') {
					this.$hascontent(c.newValue);
				}
			}, this);
		},

		/**
		 * Clean up.
		 * TODO: Again, this should be handled automatically some day.
		 */
		ondestruct: function() {
			ts.ui.BarSpirit.prototype.ondestruct.call(this);
			if (this._ismodelled()) {
				this._model.removeObserver(this);
			}
		},

		/**
		 * Show tabs as menu in aside (this gets invoked by the EDBML template).
		 * @see ts.ui.TopBarSpirit.edbml
		 * @param {Array<ts.ui.TabModel>} tabs
		 * @param {string} color
		 */
		puttabs: function(tabs) {
			var self = this;
			var model = this._model;
			var selecteditem = null;
			var aside = ts.ui.Aside({
				title: TopBar.localize('more'),
				onclosed: function() {
					this.dispose();
					if (selecteditem) { // postponed to transition the Aside elegantly
						self._arraymove(tabs, selecteditem, 1);
					}
				}
			});
			aside.items.push(
				ts.ui.Menu({
					onselect: function(index) {
						var item = this.items[index];
						selecteditem = item.id;
						aside.close();
					},
					items: tabs.filter(function(tab) {
						return !tab.$isontop;
					}).map(function(tab) {
						return {
							label: tab.label,
							id: tab.$instanceid
						};
					}).reverse()
				})
			);
			this._matchcolor(aside, model).open();
		},

		/**
		 * Show buttons as menu in aside (this gets invoked by the EDBML template).
		 * TODO: Button groups now expands to normal buttons (they get ungrouped)!
		 * @see ts.ui.ToolBarSpirit.edbml
		 * @param {Array<ts.ui.ButtonModel>} buttons
		 * @param {string} color Copy from Tobbar. Now useless(@leo)
		 */
		putaside: function(buttons, color) {
			var selected = null, morphed = [];
			buttons.forEach(function transmorph(button) {
				if (ts.ui.Collection.is(button)) { // it's a button group!
					button.forEach(transmorph);
				} else {
					var data = JSON.parse(JSON.stringify(button));
					var clone = new ts.ui.ButtonModel(data);
					clone.onclick = function() {
						selected = button;
						aside.close();
					};
					morphed.push(clone);
				}
			});
			var aside = ts.ui.Aside({
				title: TopBar.localize('options'),
				items: [
					ts.ui.Buttons({
						items: morphed.reverse()
					})
				],
				onclosed: function() {
					this.dispose();
					if (selected && selected.onclick) {
						selected.click();
					}
				}
			});
			this._matchcolor(aside, this._model).open();
		},

		/**
		 * Set the toolbar to macro.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		macro: chained(function() {
			this.css.remove(ts.ui.CLASS_MICRO).add(ts.ui.CLASS_MACRO);
			if (this._outsidemain()) {
				this.guilayout.shiftGlobal(false, 'ts-has-toolbar-first-ts-micro');
				this.guilayout.shiftGlobal(true, 'ts-has-toolbar-first-ts-macro');
				this.guilayout.flexGlobal();
			}
		}),

		/**
		 * Set the toolbar to micro.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		micro: chained(function() {
			this.css.remove(ts.ui.CLASS_MACRO).add(ts.ui.CLASS_MICRO);
			if (this._outsidemain()) {
				this.guilayout.shiftGlobal(false, 'ts-has-toolbar-first-ts-macro');
				this.guilayout.shiftGlobal(true, 'ts-has-toolbar-first-ts-micro');
				this.guilayout.flexGlobal();
			}
		}),

		/**
		 * Get or set the title (aborting weird Moustache syntax).
		 * Support also `null` because of some flaky Jasmine test.
		 * @param @optional {string|null} title
		 * @returns {string|ts.ui.ToolBarSpirit}
		 */
		title: confirmed('(string|null)')(
			chained(function(opt_title) {
				var model = this.model();
				if (arguments.length) {
					opt_title = opt_title || '';
					if (opt_title.trim().indexOf('{') !== 0) {
						this.$hascontent();
						model.title = opt_title;
						this.event.add('click');
						this.$hascontent();
					}
				} else {
					return model.title;
				}
			})
		),

		/**
		 * Get or set the search (getter will *create* the search).
		 * @param @optional {object|ts.ui.SearchModel} opt_json
		 * @returns {ts.ui.SearchModel|ts.ui.ToolBarSpirit}
		 */
		search: confirmed('(object)')(
			chained(function(opt_json) {
				var model = this.model();
				if (arguments.length) {
					this.$hascontent();
					if (model.search) {
						model.search.dispose();
					}
					model.search = SearchModel.from(opt_json);
					model.search.inset = true; // render with border
				} else {
					if (!model.search) {
						this.search({});
					}
					return model.search;
				}
			})
		),

		/**
		 * Get or set the buttons.
		 * @param @optional {Array<object>} opt_json
		 * @returns {ts.ui.ButtonCollection|ts.ui.ToolBarSpirit}
		 */
		buttons: confirmed('(array)')(
			chained(function(opt_json) {
				var buttons = this.model().buttons;
				if (arguments.length) {
					this.$hascontent();
					buttons.clear(); // reusing the collection to preserve observers
					opt_json.forEach(function(json) {
						buttons.push(json);
					});
				} else {
					return buttons;
				}
			})
		),

		/**
		 * Get or set the tabs.
		 * @param @optional {Array<object>} opt_json
		 * @returns {ts.ui.TabCollection|ts.ui.ToolBarSpirit}
		 */
		tabs: confirmed('(array)')(
			chained(function(opt_json) {
				var tabs = this.model().tabs;
				if (arguments.length) {
					this.$hascontent();
					tabs.clear(); // reusing the collection to preserve observers
					opt_json.forEach(function(json) {
						tabs.push(json);
					});
				} else {
					return tabs;
				}
			})
		),

		/**
		 * Attempt to economize space by automatically transferring
		 * any assigned buttons (especially tertiary) into an Aside.
		 * Note that this is `true` by defult (make space for tabs).
		 * @param {boolean} compact
		 * @returns {ts.ui.TableSpirit|boolean}
		 */
		compact: chained(function() {
			this.model().compact = true;
		}),

		/**
		 * Don't attempt to economize space by automatically
		 * moving buttons (especially tertiary) into an Aside.
		 * @returns {ts.ui.TableSpirit|boolean}
		 */
		uncompact: chained(function() {
			this.model().compact = false;
		}),

		/**
		 * TODO: Can this be privatized?
		 * Get or set the model. Not recommended.
		 * @param {object|ts.ui.ToolBarModel} model
		 * @returns {ts.ui.ToolBarModel|ts.ui.ToolBarSpirit}
		 */
		model: ts.ui.Spirit.createModelMethod(
			ts.ui.ToolBarModel,
			'ts.ui.ToolBarSpirit.edbml',
			function observe(model) {
				model.addObserver(this);
			}
		),

		/**
		 * Handle EDBML rendered.
		 * TODO(jmo@): Called twice (on first render)???
		 * @param {TODOType} summary
		 */
		onrender: function(summary) {
			ts.ui.BarSpirit.prototype.onrender.call(this, summary);
			this._layout();
		},

		/**
		 * Window was resized.
		 */
		onflex: function() {
			ts.ui.BarSpirit.prototype.onflex.call(this);
			this._layout();
		},

		/**
		 * Hide the ToolBar.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		hide: chained(function() {
			if (this.visible) {
				this.dom.hide();
				this.visible = false;
				this._layoutmain(false);
			}
		}),

		/**
		 * Show the ToolBar.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		show: chained(function() {
			if (!this.visible) {
				this.dom.show();
				this.visible = true;
				this._layoutmain(true);
			}
		}),

		/**
		 * Clear the ToolBar.
		 * TODO: Do we really want to clear the title?
		 */
		clear: chained(function() {
			var model = this.model();
			model.buttons.clear();
			model.tabs.clear();
			model.search = null;
			model.pager = null;
			model.title = null;
		}),

		/**
		 * Show the close button "X".
		 * @param @optional {Function} onclose
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		showClose: confirmed('(function)')(
			chained(function(onclose) {
				this.model().closebutton = new ts.ui.ButtonModel({
					icon: 'ts-icon-close',
					type: 'ts-tertiary ts-noborder',
					onclick: onclose
				});
			})
		),

		/**
		 * Hide the close button.
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		hideClose: chained(function() {
			this.model().closebutton = null;
		}),

		// Privileged ..............................................................

		/**
		 * EDB model observers are always triggered async and this may cause the
		 * (main) toolbars to flicker into existence on page load. When you know
		 * that an operation will cause the toolbar to have content, please make
		 * sure to call this method manually.
		 * TODO(jmo@): Some kind of synchronous observer setup to mitigate this.
		 * @param @optional {boolean} hascontent
		 * @see {ts.ui.ToolBarModel#hascontent} Defaults to `true`
		 */
		$hascontent: function(has) {
			this.life.hascontent = (has = arguments.length ? has : true);
			this.life.dispatch(
				has ? 'ts-life-toolbar-hascontent' : 'ts-life-toolbar-nocontent'
			);
		},

		// Private .................................................................

		/**
		 * Confirm that we don't have hardcoded HTML content,
		 * because the HTML will just be nuked when we render.
		 * TODO: Upgrade this to a `throw` in future version.
		 */
		_validate: function() {
			if (this.element.childElementCount) {
				console.error(
					'The ' + this.$classname + ' should not have HTML content.'
				);
			}
		},

		/**
		 * Compute flex (relative widths) of all members.
		 * Figure out if all tabs can fit inside the bar.
		 */
		_layout: function() {
			if (this.element.offsetWidth) {
				this._flex();
				if (this._ismodelled()) {
					this._calculate(this._model.tabs);
				}
			}
		},

		/**
		 * Layout the Main section.
		 * @param {boolean} show
		 */
		_layoutmain: function(show) {
			if (this.guilayout.outsideMain()) {
				if (this.guilayout.beforeMain()) {
					this._looknormal(this.css);
					this._layoutbefore(show);
					this._initbreakpoint(show);
				} else if (this.guilayout.afterMain()) {
					this._looknormal(this.css);
					this._layoutafter(show);
				}
			}
		},

		/**
		 * @param {boolean} show
		 */
		_layoutbefore: function(show) {
			this.css.shift(show, 'ts-toolbar-first');
			var micro = this.css.contains(ts.ui.CLASS_MICRO);
			var klass = 'ts-has-toolbar-first-' + (micro ? 'ts-micro' : 'ts-macro');
			this.guilayout.shiftGlobal(show, klass);
		},

		/**
		 * @param {boolean} show
		 */
		_layoutafter: function(show) {
			this.css.shift(show, 'ts-toolbar-last');
			this.guilayout.shiftGlobal(show, 'ts-has-toolbar-last');
		},

		/**
		 * Is positioned outside the Main section? Must be called after init phase.
		 * @returns {boolean}
		 */
		_outsidemain: function() {
			return ['ts-toolbar-first', 'ts-toolbar-last'].some(function(cname) {
				return this.css.contains(cname);
			}, this);
		},

		/**
		 * When fixed to top or bottom, the Toolbar covers the MAIN scrollbar.
		 * Let's offset it some pixels to the left so that it looks OK again.
		 * @param {gui.CSSPlugin} css
		 */
		_looknormal: function(css) {
			var mobile = ts.ui.isMobilePoint();
			if (['ts-toolbar-first', 'ts-toolbar-last'].some(function(klass) {
				return css.contains(klass);
			})) {
				css.right = mobile ? Client.scrollBarSize : '';
			}
		},

		/**
		 * Match spirit color to model color (we use it for the Asides).
		 * @param {ts.ui.Spirit} spirit (implements color scheme methods).
		 * @param {ts.ui.ToolBarModel} model
		 * @returns {ts.ui.Spirit}
		 */
		_matchcolor: function(spirit, model) {
			gui.Object.each(bgcolors, function(methodname, classname) {
				if (classname === model.color) {
					spirit[methodname]();
				}
			});
			return spirit;
		},

		/**
		 * Flex toolbar items (step one).
		 */
		_flex: function() {
			var avail = this.box.width;
			var lefts = this.dom.qall('.ts-left > li');
			var right = this.dom.qall('.ts-right > li');
			var extra = this.dom.qall('.ts-center > li');
			var items = lefts.concat(right);
			var small = avail <= BREAKPOINT_1;
			this._cnames(small, lefts, right, extra);
			if (small && this.css.contains('ts-statusbar')) { // TODO: move to StatusBarSpirit!
				this._flexnone(items.concat(extra));
			} else {
				if (extra.length) {
					avail = (avail - extra.reduce(sumwidth, 0)) * 0.5;
					this._flexnext(avail, lefts);
					this._flexnext(avail, right);
				} else {
					this._flexnext(avail, items);
				}
			}
		},

		/**
		 * Flex toolbar items (step two).
		 * @param {number} avail
		 * @param {Array<HTMLLiElement>} items
		 */
		_flexnext: function(avail, items) {
			var flexitems = items.filter(hasflex);
			var fixtitems = items.filter(nonflex);
			if (flexitems.length) {
				avail = avail - fixtitems.reduce(sumwidth, 0);
				avail = avail / flexitems.length;
				flexitems.forEach(function(li) {
					li.style.width = avail + 'px';
				});
			} else {
				this._flexnone(items);
			}
		},

		/**
		 * Cleanup all existing flexiness.
		 * @param {Array<HTMLLiElement>} items
		 */
		_flexnone: function(items) {
			items.forEach(function(item) {
				item.style.width = '';
			});
		},

		/**
		 * Toggle some classnames. Mostly relevant for
		 * statusbar rendering in the mobile breakpoint.
		 * @param {boolean} small
		 * @param {Array} lefts
		 * @param {Array} right
		 * @param {Array} extra
		 * @returns {Array<Any>}
		 */
		_cnames: function(small, lefts, right, extra) {
			var search = this.dom.q('.ts-toolbar-search');
			this._docss(this.css, small, lefts.length, right.length, extra.length, search);
		},

		/**
		 * General styling hooks.
		 * @param {gui.CSSPlugin} css
		 * @param {boolean} small
		 * @param {truthy} lefts
		 * @param {truthy} right
		 * @param {truthy} extra
		 * @param {truthy} search
		 */
		_docss: function(css, small, lefts, right, extra, search) {
			css.shift(small, 'ts-small')
				.shift(lefts, 'ts-hasleft')
				.shift(right, 'ts-hasright')
				.shift(extra, 'ts-hascenter')
				.shift(search, 'ts-hassearch')
				.shift(!search, 'ts-nosearch');
		},

		/**
		 * Breakpoint changed.
		 */
		_onbreakpoint: function() {
			ts.ui.BarSpirit.prototype._onbreakpoint.call(this);
			this._looknormal(this.css);
		},

		/**
		 * Hide tabs that won't fit (and show the More-tab). Note
		 * that the More-tab is not rendered in mobile breakpoint.
		 * @param {Array<ts.ui.TabCollection>} tabs
		*/
		_calculate: function calculate(tabs) {
			var moretab, gonetab, avail, width, dofit;
			if (tabs && tabs.getLength()) {
				if ((moretab = this.dom.q('.ts-tab-more', ts.ui.Spirit))) {
					moretab.css.display = '';
					avail = this._getavailwidth(22);
					this._setmaxwidth(avail);
					width = 44; // width of the more-tab button
					dofit = this._toggletabs(tabs, width, avail);
					moretab.css.display = dofit ? 'none' : '';
					if (!dofit) { // make sure selected tab is visible
						if ((gonetab = tabs.find(function ishidden(tab) {
							return tab.selected && !tab.$isontop;
						}))) {
							this._arraymove(tabs, gonetab.$instanceid, 1);
						}
					}
				}
			}
		},

		/**
		 * Set the max-width, let the tabbar shows at least two tabs
		 * @param {number} avail
		*/
		_setmaxwidth: function(avail) {
			var maxwidth = (avail - 95) / 2;// 88 means the width of more tab(44), two tabs of padding left and right(2 * 2 * 11) and the buffer(7)
			this.dom.qall('.ts-tab-label').forEach(function(tab) {
				tab.style.maxWidth = maxwidth + 'px';
			});
		},

		/**
		 * move an item whoes id is {id} to {toIndex} and then select it.
		 * @param {Array}
		 * @param {String} id
		 * @param {Number} toIndex
		 */
		_arraymove: function(arr, id, toIndex) {
			var fromIndex = -1;
			var element = arr.find(function(item, index) {
				fromIndex = index;
				return item.$instanceid === id;
			});
			element.selected = true;
			arr.splice(fromIndex, 1);
			arr.splice(toIndex, 0, element);
		},

		/**
		 * Toggle tabs that won't fit in the topbar.
		 * @param {Array<ts.ui.TabModel>} tabs
		 * @param {number} moreoffset Width of the More tab
		 * @param {number} availwidth Width of the tabs area
		 * @returns {boolean} True if all tabs can fit
		 */
		_toggletabs: function(tabs, moreoffset, availwidth) {
			var that = this, tabspirit, taboffset, tabsoffset = 0;
			var oldie = Client.isExplorer9 || Client.isExplorer10;
			var getspirit = function(tabmodel) {
				return that.dom.q('#' + tabmodel.$instanceid, ts.ui.Spirit);
			};
			return tabs.filter(function hotfix(tabmodel) {
				return !!getspirit(tabmodel);
			}).reduce(function(isontop, tabmodel) {
				tabspirit = getspirit(tabmodel);
				if (isontop) {
					tabspirit.css.display = '';
					taboffset = tabspirit.box.width + (oldie ? 1 : 0);
					isontop = tabsoffset + taboffset < availwidth - moreoffset;
				}
				if (isontop) {
					tabsoffset += taboffset;
					tabmodel.$isontop = true;
				} else {
					tabspirit.css.display = 'none';
					tabmodel.$isontop = false;
				}
				return tabmodel.$isontop;
			}, true);
		},

		/**
		 * Get the tab container maximum length (allowing for the buttons).
		 * @returns {number}
		 */
		_getavailwidth: function(buffer) {
			var right = this.dom.q('.ts-right');
			var center = this.dom.q('.ts-center');
			return this.box.width - (right ? right.offsetWidth : 0) - (center ? center.offsetWidth : 0) - (buffer || 0);
		}

	}, { // Static ...............................................................

		/**
		 * Summon spirit.
		 * @param @optional {string} tagname (eg. MENU, HEADER, FOOTER)
		 * @param @optional {string} classname (eg. ts-header, ts-footer)
		 */
		summon: function(tagname, classname) {
			var tag = tagname ? tagname.toLowerCase() : 'menu';
			var elm = document.createElement(tag);
			elm.className = classname || '';
			return this.possess(elm);
		}

	});
}(
	gui.Combo.chained,
	gui.Arguments.confirmed,
	gui.Client,
	gui.Type,
	gui.Array,
	gui.CSSPlugin,
	gui.DOMPlugin,
	ts.ui.TextModel,
	ts.ui.SearchModel,
	ts.ui.TopBar,
	ts.ui.ButtonModel,
	ts.ui.BACKGROUND_COLORS
));



/**
 * Spirit of the TopBar.
 * @using {ts.ui.TopBar} TopBar
 * @using {gui.Client} Client
 * @using {gui.Combo.chained} chained
 * @using {gui.Arguments.confirmed} confirmed
 */
ts.ui.TopBarSpirit = (function(TopBar, Client, chained, confirmed) {
	var HAS_TOPBAR = ts.ui.CLASS_HAS_TOPBAR;
	var HAS_TOPBAR_TABS = ts.ui.CLASS_HAS_TOPBAR_TABS;
	var TOPBAR_READY = ts.ui.BROADCAST_GLOBAL_TOPBAR_READY;
	var CLASS_HIDDEN = ts.ui.CLASS_HIDDEN;

	return ts.ui.ToolBarSpirit.extend({

		/**
		 * Always be using this particular model. The model
		 * may have been configured before this spirit exists.
		 */
		onconstruct: function() {
			ts.ui.ToolBarSpirit.prototype.onconstruct.call(this);
			this.life.hascontent = false;
			this._model = ts.ui.TopBar.$getmodel();
			this._matchcolor(this, this._model);
			this.script.load(ts.ui.ToolBarSpirit.edbml);
			this.script.input(this._model);
			this._model.addObserver(this);
		},

		/**
		 * Cleanup (in case TopBar gets removed).
		 * TODO: this should really be automated!
		 */
		ondestruct: function() {
			ts.ui.ToolBarSpirit.prototype.ondestruct.call(this);
			this.model().removeObserver(this);
		},

		/**
		 * Setup.
		 */
		onconfigure: function() {
			ts.ui.ToolBarSpirit.prototype.onconfigure.call(this);
			this.sprite.y = 0;
			this.css.remove(ts.ui.CLASS_MICRO).add(ts.ui.CLASS_MACRO);
		},

		/**
		 * Change it to dark
		 */
		onenter: function() {
			if (!this.css.name().includes('ts-bg')) {
				this.dark();
			}
			ts.ui.ToolBarSpirit.prototype.onenter.call(this);
		},

		/**
		 * Making sure *not* to call the superclass `onattach` here.
		 * This whole setup could do with a nice refactoring some day.
		 */
		onattach: function() {
			ts.ui.Spirit.prototype.onattach.call(this);
			this._initbreakpoint(true);
		},

		/**
		 * Emergency remove all root classnames if someone removes the TopBar.
		 * Again, making sure *not* to invoke the superclass `ondetach` here.
		 */
		ondetach: function() {
			ts.ui.Spirit.prototype.ondetach.call(this);
			this._initbreakpoint(false);
			var root = ts.ui.get(document.documentElement);
			root.css.remove(HAS_TOPBAR);
			root.css.remove(HAS_TOPBAR_TABS);
			root.reflex();
		},

		/**
		 * When the topbar's ready we tell the Chrome
		 * about it and it will send the defaultTitle
		 */
		onready: function() {
			ts.ui.ToolBarSpirit.prototype.onready.call(this);
			this.broadcast.dispatchGlobal(TOPBAR_READY);
		},

		/**
		 * Update classes on the HTML element as soon as the rendering is done.
		 * If the TopBar element for some reason was added late, we'll need to
		 * reflex the page so that js-based layouts (as in SideBars) can account
		 * for the height of the TopBar.
		 * @param {TODO} summary
		 */
		onrender: function(summary) {
			ts.ui.ToolBarSpirit.prototype.onrender.call(this, summary);
			var tbar = this._model;
			this._setclasses();
			if (this.element.offsetWidth) {
				this._calculate(tbar.tabs);
			}
			if (gui.spiritualized && tbar.hascontent && !this._reflexfixed) {
				var root = document.documentElement;
				ts.ui.get(root).reflex();
				this._reflexfixed = true;
			}
		},

		/**
		 * Handle (model) changes.
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.ToolBarSpirit.prototype.onchange.call(this, changes);
			changes.forEach(function(c) {
				switch (c.name) {
					case 'color':
						this._matchcolor(this, this._model);
						break;
					case 'visible':
						this._setclasses();
						break;
				}
			}, this);
		},

		/**
		 * Get or set the title (aborting weird Moustache syntax).
		 *
		 * TODO: `this._model` is the TopBarModel, so why did we overwrite this?
		 *
		 * @overwrites {ts.ui.ToolBarSpirit#title}
		 * @param @optional {string} title
		 * @returns {string|ts.ui.TopBarSpirit}
		 */
		title: confirmed('(string)')(
			chained(function(opt_string) {
				if (arguments.length) {
					if (opt_string.trim().indexOf('{') !== 0) {
						this.$hascontent();
						ts.ui.TopBar.title(opt_string);
						this.event.add('click');
						this.$hascontent();
					}
				} else {
					return ts.ui.TopBar.title();
				}
			})
		),

		/**
		 * Never be using some other model.
		 * @override {ts.ui.ToolBarSpirit#model}
		 * @returns {ts.ui.TopBarModel}
		 */
		model: function() {
			if (arguments.length) {
				throw new Error('Cannot assign :/');
			}
			return this._model;
		},

		/**
		 * Make sure this goes via the API so that the
		 * business logic with mobile breakpoint works.
		 * @overwrites {ts.ui.ToolBarSpirit#hide}
		 * @throws {Error}
		 */
		hide: function() {
			throw new Error('Please use ts.ui.TopBar.hide()');
		},

		/**
		 * Make sure this goes via the API.
		 * @overwrites {ts.ui.ToolBarSpirit#hide}
		 * @throws {Error}
		 */
		show: function() {
			throw new Error('Please use ts.ui.TopBar.show()');
		},

		// Private .................................................................

		/**
		 * @type boolean
		 */
		_reflexfixed: false,

		/**
		 * Handled elsehow...
		 * @param {boolean} attaching
		 * @overwrites {ts.ui.ToolBarSpirit#_layoutinit}
		 */
		_layoutinit: function(attaching) {},

		/**
		 * In mobile breakpoint, the TopBar is "floating" and that
		 * looks better when we make some room for the scrollbar
		 * (at least on platforms where the scrollbar even exists).
		 * @param {gui.CSSPlugin} css
		 */
		_looknormal: function(css) {
			css.right = ts.ui.isMobilePoint() ? Client.scrollBarSize : '';
		},

		/**
		 * TODO: Fix this elsehow!
		 * The idea here is to allow for more TopBar negative scrolling
		 * when the tabs are open in mobile breakpoint, but it turns out
		 * not to work after all :/
		 * @overrides {ts.ui.BarSpirit#_offsetlimit}
		 * @returns {number}
		 */
		_offsetLimit: function() {
			var stop = ts.ui.ToolBarSpirit.prototype._offsetLimit.call(this);
			if (ts.ui.isMobilePoint()) {
				var tabs = this.dom.q('.ts-toolbar-tabs', ts.ui.TopBarTabsSpirit);
				if (tabs && tabs.isOpen) {
					stop = tabs.$offsetLimit();
				}
			}
			return stop;
		},

		/**
		 * Update classes on myself plus root element.
		 */
		_setclasses: function() {
			var tbar = this._model;
			var show = this._shouldshow(tbar, ts.ui.breakpoint);
			var tabs = this.dom.q('.ts-topbar-tabs');
			var root = ts.ui.get(document.documentElement);
			root.css.shift(show, HAS_TOPBAR);
			root.css.shift(tabs, HAS_TOPBAR_TABS);
			this.css.shift(!show, CLASS_HIDDEN);
		},

		/**
		 * Should always show in mobile, otherwise should only
		 * show if it has content (buttons, tabs, title etc)
		 * or if now empty but used to have some of that stuff.
		 * @param {ts.ui.TopBarModel} tbar
		 * @param {string} breakpoint
		 */
		_shouldshow: function(tbar, breakpoint) {
			if (breakpoint === 'mobile') {
				return true;
			} else {
				return tbar.visible && (
					this.life.hascontent ||
					tbar.hascontent ||
					tbar.hadcontent
				);
			}
		}

	});
}(ts.ui.TopBar, gui.Client, gui.Combo.chained, gui.Arguments.confirmed));



/**
	* Spirit of the topbar tabs.
	*/
ts.ui.TopBarTabsSpirit = ts.ui.Spirit.extend({

	/**
	 * Tabs are open (in mobile breakpoint)?
	 * @type {boolean}
	 */
	isOpen: false,

	/**
	 * Get ready.
	 */
	onready: function() {
		ts.ui.Spirit.prototype.onready.call(this);
		this.input.connect(ts.ui.LayoutModel);
	},

	/**
	 * TODO(jmo@): Automate this step in Spiritual :/
	 */
	ondestruct: function() {
		ts.ui.Spirit.prototype.ondestruct.call(this);
		this.input.disconnect(ts.ui.LayoutModel);
	},

	/**
	 * Handle input.
	 * TODO: removeObserver when we are sure that there's no new model incoming.
	 * @param {edb.Input} input
	 */
	oninput: function(input) {
		ts.ui.Spirit.prototype.oninput.call(this, input);
		if (input.type === ts.ui.LayoutModel) {
			this._onbreakpoint(input.data.isMobilePoint());
			input.data.addObserver(this);
		}
	},

	/**
	 * Model changed something.
	 * @param {Array<edb.Change>} changes
	 */
	onchange: function(changes) {
		ts.ui.Spirit.prototype.onchange.call(this, changes);
		changes.forEach(function(c) {
			if (c.object instanceof ts.ui.LayoutModel) {
				this._onbreakpoint(c.object.isMobilePoint());
			}
		}, this);
	},

	/**
	 * Handle event.
	 * @param {Event} e
	 */
	onevent: function(e) {
		ts.ui.Spirit.prototype.onevent.call(this, e);
		switch (e.type) {
			case 'click':
				this.event.remove('click');
				if (ts.ui.isMobilePoint()) {
					this._toggle();
				}
				break;
		}
	},

	/**
	 * Handle tween.
	 * @param {gui.Tween} t
	 */
	ontween: function(t) {
		ts.ui.Spirit.prototype.ontween.call(this, t);
		if (t.type === 'ts-tween-tabs') {
			this._expand(t.value);
			if (t.done) {
				this.tween.remove(t.type);
				this._ontoggle();
			}
		}
	},

	/**
	 * Handle broadcast.
	 * @param {gui.Broadcast} b
	 */
	onbroadcast: function(b) {
		ts.ui.Spirit.prototype.onbroadcast.call(this, b);
		switch (b.type) {
			case gui.BROADCAST_MOUSECLICK:
				this.broadcast.removeGlobal(b.type);
				this._time = this.tick.time(function pause() {
					if (this.isOpen) {
						this._toggle();
					}
				}, 100);
				break;
		}
	},

	/**
	 * Make sure we collapse the tabs (in mobile breakpoint)
	 * before we load next so that the animation doesn't jerk.
	 */
	onaction: function(a) {
		ts.ui.Spirit.prototype.onaction.call(this, a);
		if (a.type === ts.ui.ACTION_GLOBAL_LOAD) {
			this._loadargs = a.data;
			a.consume();
		}
	},

	// Privileged ................................................................

	/**
	 * When tabs are expanded in mobile breakpoint, the
	 * {ts.ui.TopBarSpirit} will allow bonus scrolling.
	 * @returns {number}
	 */
	$offsetLimit: function() {
		var items = this.dom.qall('li', ts.ui.Spirit);
		var stops = Number.MAX_VALUE;
		if (items.length) {
			var last = items.pop();
			var init = ts.ui.UNIT_TRIPLE;
			var ends = last.sprite.y + last.box.height + init;
			stops = ends - window.innerHeight;
		}
		return stops;
	},

	// Private ...................................................................

	/**
	 * List items.
	 * @type {Array<ts.ui.Spirit>}
	 */
	_items: null,

	/**
	 * Timeout index.
	 * @type {number}
	 */
	_time: -1,

	/**
	 * Scrolling down?
	 * @type {boolean}
	 */
	_down: false,

	/**
	 * Consume the `gui.Action` that instructs the (Docs website!!) chrome
	 * to load something. We'll dispatch the again again after toggle done.
	 * @type {object} See original dispatch in the `ts.ui#load` method.
	 */
	_loadargs: null,

	/**
	 * Toggle menu open (in mobile breakpoint).
	 * @param @optional {boolean} reset
	 */
	_toggle: function(reset) {
		this._items = this.dom.qall('li', ts.ui.Spirit);
		if (this._items.length > 1) {
			this.css.shift((this.isOpen = !this.isOpen), ts.ui.CLASS_OPEN);
		}
		if (reset) {
			this._expand(1);
			this._ontoggle();
		} else {
			this.tick.cancelTime(this._time);
			this.broadcast.removeGlobal(gui.BROADCAST_MOUSECLICK);
			this.tween.addDispatch('ts-tween-tabs', {
				duration: ts.ui.TRANSITION_NOW,
				timing: 'ease-out'
			});
		}
	},

	/**
	 * Toggle animation done.
	 */
	_ontoggle: function() {
		var root = ts.ui.get('html');
		var load = ts.ui.ACTION_GLOBAL_LOAD;
		var args = this._loadargs;
		if (this.isOpen) {
			this.broadcast.addGlobal(gui.BROADCAST_MOUSECLICK);
			root.action.addGlobal(load, this);
		} else {
			root.action.removeGlobal(load, this);
			if (args) {
				root.action.dispatchGlobal(load, args);
				this._loadargs = null;
			}
			this.tick.time(function() {
				this.event.add('click');
			});
		}
	},

	/**
	 * Position list items.
	 * @param {number} value
	 */
	_expand: function(value) {
		value = this.isOpen ? value : 1 - value;
		this._items.forEach(function(spirit, index) {
			if (!spirit.life.destructed) {
				spirit.sprite.y = 44 * value * index;
			}
		});
	},

	/**
	 * Handle breakpoint change. Fit the scrollbar so that it doesn't go
	 * under the tabs. There's no scrollbar on real mobile (and in OSX),
	 * so few people will notice that this really doesn't look right...
	 * @param {boolean} mobile
	 */
	_onbreakpoint: function(mobile) {
		this.event.shift(mobile, 'click');
		if (!mobile && this.isOpen) {
			this._toggle(true);
		}
	}

});



/**
	* Spirit of the tabbar.
	* @extends {ts.ui.ToolBarSpirit}
	* @using {string} CLASS_MACRO
	* @using {string} CLASS_MICRO
	*/
ts.ui.TabBarSpirit = (function(CLASS_MACRO, CLASS_MICRO) {
	return ts.ui.ToolBarSpirit.extend({

		/**
		 * Set `ts-micro` for the default style.
		 */
		onconfigure: function() {
			ts.ui.ToolBarSpirit.prototype.onconfigure.call(this);
			if (!this.css.contains(CLASS_MACRO)) {
				this.css.add(CLASS_MICRO);
			}
		},

		/**
		 * The title would anyway be hidden by the tabs.
		 * @overwrites {ts.ui.ToolBar#title}
		 */
		title: function() {
			console.error('The TabBar doesn\'t support a title :(');
		}

	});
}(ts.ui.CLASS_MACRO, ts.ui.CLASS_MICRO));



/**
 * Spirit of the statusbar.
 * @using {ts.ui.PagerModel} PagerModel
 * @using {gui.Type} Type
 * @using {gui.Combo.chained} chained
 * @using {gui.Arguments.confirmed} confirmed
 */
ts.ui.StatusBarSpirit = (function using(PagerModel, Type, chained, confirmed) {
	return ts.ui.ToolBarSpirit.extend({

		/**
		 * Open for implementation: Called when message link is clicked.
		 * @type {function}
		 */
		onlink: null,

		onlayout: null,

		/**
		 * Set the message.
		 * @alias {ts.ui.StatusBarSpirit#title}
		 * @param @optional {string} text
		 */
		message: confirmed('(string)')(function(text) {
			return this.title.apply(this, arguments);
		}),

		/**
		 * Get or set the pager. Pass `null` to remove the pager (via bad API :/)
		 * @param @optional {object|ts.ui.PagerModel|null} opt_json
		 * @returns {ts.ui.PagerModel|ts.ui.ToolBarSpirit}
		 */
		pager: confirmed('(object|null)')(
			chained(function(opt_json) {
				var model = this.model();
				if (arguments.length) {
					if (model.pager) {
						model.pager.dispose();
					}
					if (opt_json === null) {
						model.pager = null;
					} else {
						model.pager = PagerModel.from(opt_json);
					}
				} else {
					if (!model.pager) {
						this.pager({});
					}
					return model.pager;
				}
			})
		),

		/**
		 * Manually enable support for links in the status message (just to
		 * remind yourself that you may now be enncouraging phishing attacks).
		 * @param @optional {function} onlink
		 * @returns {ts.ui.StatusBarSpirit}
		 */
		linkable: confirmed('(function)')(
			chained(function(onlink) {
				this.model().linkable = true;
				this.action.add(ts.ui.ACTION_SAFE_LINK);
				if (arguments.length) {
					this.onlink = onlink;
				}
			})
		),

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.ToolBarSpirit.prototype.onaction.call(this, a);
			if (a.type === ts.ui.ACTION_SAFE_LINK) {
				if (Type.isFunction(this.onlink)) {
					this.onlink.call(this, a.data);
				}
				a.consume();
			}
		},

		/**
		 * To support tabs, we would at least need to revisit the CSS.
		 * @overwrites {ts.ui.ToolBar#title}
		 */
		tabs: function() {
			throw new Error('The StatusBar doesn\'t support tabs :(');
		},

		/**
		 * TODO: Can this be privatized?
		 * Get or set the model. Not recommended.
		 * @param {object|ts.ui.StatusBarModel} model
		 * @returns {ts.ui.StatusBarModel|ts.ui.StatusBarSpirit}
		 */
		model: ts.ui.Spirit.createModelMethod(
			ts.ui.StatusBarModel,
			'ts.ui.ToolBarSpirit.edbml',
			function observe(model) {
				model.addObserver(this);
			}
		),

		// Private .................................................................

		/**
		 * Add some special styling hooks for mobile breakpoint.
		 * @override {ts.ui.ToolBarSpirit#_docss}
		 * TODO: Also account for statusbar levels in file "ts-main.less"
		 * @param {gui.CSSPlugin} css
		 * @param {boolean} small
		 * @param {truthy} lefts
		 * @param {truthy} right
		 * @param {truthy} extra
		 * @param {truthy} search
		 */
		_docss: function(css, small, lefts, right, extra, search) {
			ts.ui.ToolBarSpirit.prototype._docss.call(this, css,small,lefts,right,extra,search);
			this._gotoLevel(
				small ? this._computelevel(lefts, right, extra, search) : 1
			);
		},

		/**
		 * Update `ts-level-x` classname and dispatch an action if it changed.
		 * This will probably cause an ancestor component to update its classname.
		 * @see {ts.ui.LayoutPlugin#gotoLevel}
		 * @param {number} level
		 */
		_gotoLevel: function(level) {
			var oldname = this.css.name();
			this.guilayout.gotoLevel(level);
			if (this.css.name() !== oldname) {
				this.action.dispatch(ts.ui.ACTION_STATUSBAR_LEVEL, level);
				if (Type.isFunction(this.onlayout)) {
					this.onlayout.call(this);
				}
			}
		},

		/**
		 * @param {truthy} lefts
		 * @param {truthy} right
		 * @param {truthy} extra
		 * @param {truthy} search
		 * @returns {number}
		 */
		_computelevel: function(lefts, right, extra, search) {
			if (lefts && right && !extra) {
				return search ? 2 : 1.5;
			} else if (lefts && extra && !right) {
				return search ? 2 : 1.5;
			} else if (right && extra && !lefts) {
				return 2;
			} else if (lefts && right && extra) {
				return search ? 3 : 2.5;
			}
			return 1;
		}

	});
}(
	ts.ui.PagerModel,
	gui.Type,
	gui.Combo.chained,
	gui.Arguments.confirmed
));



/**
 * @using {gui.DOMPlugin} DOMPlugin
 * @using {ts.ui.MainSpirit} MainSpirit
 */
ts.ui.Bar = (function using(DOMPlugin, MainSpirit) {
	return gui.Class.create(Object, {

		/**
		 * Associate this instance to Main component of given ordinal index.
		 * @param {number} index
		 */
		onconstruct: function(index) {
			this._main = DOMPlugin.qall(document, '.ts-main', MainSpirit)[index];
		},

		/**
		 * Subclass must implement! Get the ToolBarSpirit (via the
		 * Main component that this instance has been associated to).
		 * @returns {ts.ui.ToolBarSpirit}
		 */
		$getbar: function() {}

	}, { // Xstatic ..............................................................

		/**
		 * Get Bar instance by index of associated Main.
		 * This will be created if it doesn't yet exist.
		 * @returns {ts.ui.Bar}
		 */
		get: function(index) {
			var Bar = this, all = this.$bars;
			return all[index] || (all[index] = new Bar(index));
		},

		/**
		 * Apply method to the Bar instance associated to the first Main.
		 * Make sure that chained returns this (constructor, not instance).
		 * @returns {ts.ui.Bar}
		 */
		first: function(method, args) {
			var bar = this.get(0);
			var res = bar[method].apply(bar, args);
			return ts.ui.Bar.is(res) ? this : res;
		}

	}, { // Static ...............................................................

		/**
		 * Listing Bar instances.
		 * @type {Array<ts.ui.Bar>}
		 */
		$bars: [],

		/**
		 * Generate methods to go on the Bar prototype (instance methods).
		 * @param {Array<string>} names
		 * @returns {Object<string, Function>}
		 */
		$protomethods: function(names) {
			var protos = Object.create(null);
			names.forEach(function(name) {
				protos[name] = this.$protomethod(name);
			}, this);
			return protos;
		},

		/**
		 * Generate methods to go on the Bar constructor (static methods).
		 * @param {Array<string>} names
		 * @returns {Object}
		 */
		$staticmethods: function(names) {
			var statix = Object.create(null);
			names.forEach(function(name) {
				statix[name] = this.$staticmethod(name);
			}, this);
			return statix;
		},

		/**
		 * Generate single instance method.
		 * @param {string} name
		 * @returns {Function}
		 */
		$protomethod: function(name) {
			return function() {
				var bar = this.$getbar();
				var res = bar[name].apply(bar, arguments);
				return ts.ui.Spirit.is(res) ? this : res;
			};
		},

		/**
		 * Generate single static method.
		 * @param {string} name
		 * @returns {Function}
		 */
		$staticmethod: function(name) {
			return function() {
				return this.first(name, arguments);
			};
		}

	});
}(gui.DOMPlugin, ts.ui.MainSpirit));



/**
 * Static methods will forward method calls to the instances
 * while the instances will forward method calls to spirits.
 * To make sure we get this right, we'll generate the class.
 * - Proto: These methods are simply the regular instance methods
 * - Static: These methods are only found on this constructor
 * - Xstatic: These methods are copied onto subclass constructors
 * @extends {ts.ui.Bar}
 * @using {Array<string>} methods
 */
ts.ui.ToolBar = (function using(methods) {
	var statics = {$bars: []};
	var xstatics = ts.ui.Bar.$staticmethods(methods);
	var protos = gui.Object.extend(ts.ui.Bar.$protomethods(methods), {
		$getbar: function() {
			return this._main.toolbar();
		}
	});
	return ts.ui.Bar.extend(protos, xstatics, statics);
}([ // these methods are mapped directly to the spirits methods!
	'title',
	'buttons',
	'tabs',
	'search',
	'hide',
	'show',
	'clear',
	'green',
	'blue',
	'purple',
	'dark',
	'lite',
	'showClose',
	'hideClose'
]));



/**
 * See comments in "ts.ui.ToolBar.js"
 * @extends {ts.ui.ToolBar}
 * @using {Array<string>} methods (no special methods here just yet!)
 */
ts.ui.TabBar = (function using(methods) {
	var statics = {$bars: []};
	var xstatics = ts.ui.Bar.$staticmethods(methods);
	var protos = gui.Object.extend(ts.ui.Bar.$protomethods(methods), {
		$getbar: function() {
			return this._main.tabbar();
		}
	});
	return ts.ui.ToolBar.extend(protos, xstatics, statics);
}([]));



/**
 * See comments in "ts.ui.ToolBar.js"
 * @extends {ts.ui.ToolBar}
 * @using {Array<string>} methods
 */
ts.ui.StatusBar = (function using(methods) {
	var statics = {$bars: []};
	var xstatics = ts.ui.Bar.$staticmethods(methods);
	var protos = gui.Object.extend(ts.ui.Bar.$protomethods(methods), {
		$getbar: function() {
			return this._main.statusbar();
		}
	});
	return ts.ui.ToolBar.extend(protos, xstatics, statics);
}(['message', 'linkable', 'pager']));



/**
 * Bars GUI module.
 */
gui.module('bars-gui@tradeshift.com', {

	/**
	 * Channeling spirits to CSS selectors.
	 */
	channel: [

		['[data-ts=TopBar]', ts.ui.TopBarSpirit],
		['[data-ts=TabBar]', ts.ui.TabBarSpirit],
		['[data-ts=ToolBar]', ts.ui.ToolBarSpirit],
		['[data-ts=StatusBar]', ts.ui.StatusBarSpirit]
	]

});



/**
 * TODO: Reset this._scroll.y when sorting (also when searching, but how)?
 * TODO: Reset pager when when sorting (also when searching, but how)?
 * @using {gui.Type} Type
 * @using {gui.Client} Client
 * @uisng {gui.Array} guiArray
 * @using {gui.DOMPlugin} DOMPlugin
 * @using {gui.CSSPlugin} CSSPlugin
 * @using {gui.ConfigPlugin} ConfigPlugin
 * @using {gui.Position} Position
 * @using {gui.Combo#chained} chained
 * @using {gui.Arguments#confirmed} chained
 * @using {ts.ui.TableRowModel} TableRowModel
 * @using {ts.ui.ButtonSpiri	t} ButtonSpirit
 * @using {ts.ui.PagerModel} pager
 */
ts.ui.TableSpirit = (function using(Type, Client, guiArray, DOMPlugin, CSSPlugin, ConfigPlugin, Position, chained, confirmed, TableRowModel, ButtonSpirit, PagerModel) {
	var UNIT = 22;
	var UNIT_DOUBLE = UNIT * 2;
	var ICON_OFF = 'ts-icon-checkbox';
	var CLASS_TEXTAREA = 'ts-table-input';
	var CLASS_CLICKABLE = 'ts-clickable';
	var CLASS_SELECTABLE = 'ts-selectable';
	var CLASS_SELECTBUTTON = 'ts-table-checkbox-button';
	var TABLE_MIN_HEIGHT = 267;

	/**
	 * Is something simple?
	 * @param {object|string|number|boolean} x
	 * @returns {boolean}
	 */
	function primitive(x) {
		switch (Type.of(x)) {
			case 'string':
			case 'number':
			case 'boolean':
				return true;
		}
		return false;
	}

	/**
	 * TODO: Fix that EDB cornercase (and update all the depends on old behavior)
	 * TODO: The TableModel should assign these indexes!!!
	 * TODO: validate object-with-label-property
	 * @param {object|string|number|boolean} x
	 * @returns {object}
	 */
	function colify(x, i) {
		if (primitive(x)) {
			x = {
				label: x
			};
		}
		if (!x.search) { // can't NOT have a search because EDB wrongful convention :/
			x.search = {
				hidden: true
			};
		}
		if (!x.button) { // can't NOT have a button because EDB wrongful convention :/
			x.button = {
				hidden: true
			};
		}
		x.$index = i;
		x.search.$index = i;
		x.button.type = 'ts-default';
		return x;
	}

	/**
	 * Something is selected?
	 * @param {object} x
	 * @returns {boolean}
	 */
	function selected(x) { // eslint-disable-line no-unused-vars
		return !!x.selected;
	}

	/**
	 * Something is visible?
	 * @param {object} x
	 * @returns {boolean}
	 */
	function visible(x) {
		return !!x.visible;
	}

	/**
	 * Map array member to index.
	 * @param {object} x
	 * @param {number} i
	 * @returns {number}
	 */
	function indexes(x, i) {
		return i;
	}

	/**
	 * TODO: Think some more about this....
	 * TODO: More error info goes here...
	 */
	function maxerror() {
		throw new Error([
			'You shouldn\'t set max() rows when the table is maximized.'
		].join(''));
	}

	/**
	 * Support both x number of arguments and one array of x items.
	 * @param {Arguments|Array} args
	 * @returns {Array}
	 */
	function makearray(args) {
		var first = args[0];
		if (first && Array.isArray(first)) {
			return first;
		} else {
			return guiArray.from(args);
		}
	}

	/**
	 * Since we are deliberately not creating models of the rows,
	 * we'll need to *clone* the data so that our state doesn't get
	 * entangled into something that the user might depend upon.
	 * Specifically, we don't want Angular models in our structure.
	 * @param {object|array} thing
	 * @returns {object|array}
	 */
	function deepclone(thing) {
		return JSON.parse(JSON.stringify(thing));
	}

	/**
	 * Clientside sorting is slow. Let's at least announce the fact.
	 * TODO: Measure how well clientside search stacks up to this.
	 * @param {boolean} required (should really be device specific)
	 */
	function perfwarning(required) {
		if (required) {
			console.warn(
				'The client will freeze while we sort this many ' +
				'rows. If you see this warning, please remind ' +
				'us to sort the data in a Worker process.'
			);
		}
	}

	return ts.ui.Spirit.extend({

		/**
		 * @param {string} busy
		 */
		busy: function(busy) {
			var opts = {message: busy, position: 'absolute'};
			var that = this;
			if (this.box.height && this.dom.q('.ts-table-body')) {
				this._initspin(opts);
				if (busy) {
					this.guistatus.busy(this.$instanceid);
				} else {
					this.guistatus.done(this.$instanceid);
				}
			} else { // not rendered, we'll try again when something has changed...
				this.life.add(gui.LIFE_RENDER, {
					onlife: function() {
						that.life.remove(gui.LIFE_RENDER);
						that.busy(busy);
					}
				});
			}
		},

		/**
		 * Open for implementation: Called whenever a cell is clicked.
		 * @type {function}
		 * @param {object} cell
		 * @param {number} rowindex
		 * @param {number} cellindex
		 */
		onclick: null,

		/**
		 * Open for implementation: Called whenever row(s) get toggled.
		 * @type {function}
		 * @param {Array<ts.ui.RowModel>} selected
		 * @param {Array<ts.ui.RowModel>} unselected (but was selected)
		 */
		onselect: null,

		/**
		 * Open for implementation: Called after window resize and when
		 * the Table itself is done resizing and flexing and fixing it.
		 * @type {function}
		 * @param {number} maxrows that can be fitted in a single page.
		 */
		onresize: null,

		/**
		 * Open for implementation: Called when configbutton is clicked.
		 * Carefully named not to conflict with `onconfigure` which will
		 * eventually be renamed to `onconfig` in Spiritual core.
		 * @type {function}
		 */
		onconf: null,

		/**
		 * Open for implementation: Called when a link is clicked somewhere
		 * in the table cells. The links `href` is passed as an argument.
		 * The links, by the way, can be declared with some markdown syntax.
		 * @type {function}
		 */
		onlink: null,

		/**
		 * Open for implementation: Called when a cell value is edited.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @param {string|number} newval
		 * @param {string|number} oldval
		 * @type {function}
		 */
		onedit: null,

		/**
		 * Open for implementation: Called whenever headers are clicked.
		 * @param {number} index
		 * @param {boolean} ascending
		 */
		onsort: function(index, ascending) {
			this.sort(index, ascending);
		},

		/**
		 * Create the model.
		 */
		onconstruct: function() {
			ts.ui.Spirit.prototype.onconstruct.call(this);
			this._model = new ts.ui.TableModel();
			this._model.rows.addObserver(this);
			this._renderqueue = [];
		},

		/**
		 * We'll render the table ourselves because otherwise we'll
		 * run into the old relative position in tabels bug (Gecko).
		 */
		onconfigure: function() {
			ts.ui.Spirit.prototype.onconfigure.call(this);
			this.action.add([
				ts.ui.ACTION_CLICK,
				ts.ui.ACTION_SWITCH
			]);
			this.event.add('click');
			this._rowsadd = [];
			this._rowsoff = [];
			this._scroll = new Position();
			this.action.add([
				ts.ui.ACTION_STATUSBAR_LEVEL,
				ts.ui.ACTION_PAGER_SELECT,
				ts.ui.ACTION_SAFE_LINK
			]);
			if (this.dom.tag() === 'table') {
				throw new SyntaxError(
					'Contrary to common belief, the ts.ui.Table ' +
					'component must not be attached to a TABLE.'
				);
			}
		},

		/**
		 * Load the script. Input the model.
		 */
		onenter: function() {
			ts.ui.Spirit.prototype.onenter.call(this);
			this.script.load(ts.ui.TableSpirit.edbml);
			this.script.input(this._model);
		},

		/**
		 * Release any observers when disposed.
		 * TODO: This automatically in Spiritual :/
		 */
		ondestruct: function() {
			ts.ui.Spirit.prototype.ondestruct.call(this);
			this._model.dispose();
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			ts.ui.Spirit.prototype.onevent.call(this, e);
			var elm = e.target;
			switch (e.type) {
				case 'click':
					this._onclick(elm);
					break;
				case 'scroll':
					if (!this._noscrolling) { // WebKit scroll-collapse workaround :/
						this._hackscrolling();
					} else if (this._scrollfixing) {
						this.queryplugin.getrows().querySelector('table').style.left = 0;
					}
					break;
			}
		},

		/**
		 * We know that this broadcast will trigger the reflex crawler,
		 * so we will quickly perfome some calculations before the
		 * crawler arrives to trigger the `onflex` method (see below).
		 * @param {gui.Broadcast} b
		 */
		onbroadcast: function(b) {
			ts.ui.Spirit.prototype.onbroadcast.call(this, b);
			if (b.type === gui.BROADCAST_RESIZE_END) {
				if (this._ismaximized()) {
					this._onbeforeresize(this._model);
				}
			}
		},

		/**
		 * Window was (most likely) resized. Note that devs should
		 * call `table.reflex()` and not 'table.onflex()` if the
		 * layout has changed to impact maximized Tables because
		 * that's how the API is supposed to work (so everything
		 * that starts with `on` should never be manually invoked).
		 */
		onflex: function() {
			ts.ui.Spirit.prototype.onflex.call(this);
			if (this._crashproof()) {
				if (this._ismaximized()) {
					this._onafterresize(this._target);
					this._maxpages();
				} else {
					this._layouteverything();
					this._maxpages();
				}
			}
		},

		/**
		 * Account for the statusbar breaking up into multiple
		 * levels in small table, basically copy the classname
		 * from the statusbar for the CSS to work with.
		 * @see {ts.ui.ToolBarSpirit#_specialcnames}
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			ts.ui.Spirit.prototype.onaction.call(this, a);
			switch (a.type) {
				case ts.ui.ACTION_STATUSBAR_LEVEL:
					this.guilayout.gotoLevel(a.data);
					this._onafterresize(); // after resize, `onresize` might now be called twice :/
					a.consume();
					break;
				case ts.ui.ACTION_PAGER_SELECT:
					this._flag = 'paging';
					this._resetscrolling();
					a.consume();
					break;
				case ts.ui.ACTION_SAFE_LINK:
					if (Type.isFunction(this.onlink)) {
						this.onlink.call(this, a.data);
					}
					a.consume();
					break;
				case ts.ui.ACTION_CLICK:
					this._onextra(this.onbutton, a.target);
					a.consume();
					break;
				case ts.ui.ACTION_SWITCH:
					this._onextra(this.onswitch, a.target, a.data);
					a.consume();
					break;
			}
		},

		/**
		 * Button or Switch or something was triggered.
		 * @param {ts.ui.Spirit} spirit
		 * @param {function|null} action
		 */
		_onextra: function(action, spirit /* ...rest */) {
			var name, value, elm = spirit.element;
			if (Type.isFunction(action)) {
				var args = gui.Array.from(arguments).slice(2);
				var posi = this.queryplugin.getpos(elm);
				if ((name = elm.getAttribute('name'))) {
					if ((value = elm.getAttribute('value'))) {
						value = Type.cast(value);
						if (Type.isString(value)) {
							value = ConfigPlugin.jsonvaluate(value);
						}
					}
					action.apply(this,
						[name, value || undefined].concat(args).concat([posi.y, posi.x])
					);
				}
			}
		},

		/**
		 *
		 */
		onbutton: function(name, value) {
			console.log(name, value);
		},

		/**
		 *
		 */
		onswitch: function(name, value, checked) {
			console.log(name, value, checked);
		},

		/**
		 * Handle tick to evaluate the `onselect` callback.
		 * @param {gui.Tick} t
		 */
		ontick: function(t) {
			ts.ui.Spirit.prototype.ontick.call(this, t);
			if (t.type === this._TICKSELECT) {
				if (this.onselect) {
					this.onselect.call(this, this._rowsadd, this._rowsoff);
					this._rowsadd = [];
					this._rowsoff = [];
				}
			}
		},

		/**
		 * Handle (model) changes. When rows are updated using array methods, we'll
		 * update the pager (after some time, in case more updates are comming in).
		 * @param {Array<edb.Change>} changes
		 */
		onchange: function(changes) {
			ts.ui.Spirit.prototype.onchange.call(this, changes);
			if (this._model.maxrows && !this._rowsmutated) {
				var type = edb.ArrayChange.TYPE_SPLICE;
				var rows = this._model.rows;
				changes.forEach(function(c) {
					if (c.object === rows && c.type === type) {
						this._rowsmutated = true;
					}
				}, this);
			}
		},

		// Building ................................................................

		/**
		 * @param @optional {Array<string, object>} data
		 * @returns {ts.ui.TableSpirit|ts.ui.TableColCollection}
		 */
		cols: confirmed('(array)')(
			chained(function(input) {
				var cols = this._model.cols;
				if (arguments.length) {
					input = input.map(colify);
					this._model.cols = input;
				} else {
					return cols;
				}
			})
		),

		/**
		 * Set the rows. Note that the rows are not "live" models,
		 * so you should not try to use this method as a getter
		 * unless you know exactly what you are doing.
		 * @param @optional {Array<Array<string, object>>} json
		 * @returns {ts.ui.TableSpirit|ts.ui.TableRowCollection}
		 */
		rows: confirmed('(array)')(
			chained(function(json) {
				var model = this._model;
				if (arguments.length) {
					model.removeObserver(this);
					model.rows = deepclone(json);
					model.addObserver(this);
					this._resetpager();
				} else {
					return model.rows;
				}
			})
		),

		/**
		 * Get or set row at index.
		 * @param {number} rowindex
		 * @param @optional {object|array} json
		 * @returns {object|ts.ui.TableSpirit}
		 */
		row: confirmed('number', '(object|array)')(
			chained(function(rowindex, json) {
				var model = this._model;
				var asobject = true;
				if (arguments.length > 1) {
					model.setrow(rowindex, json);
				} else {
					return model.getrow(rowindex, asobject);
				}
			})
		),

		/**
		 * Get or set cell at indexes.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @param @optional {object|string|number|*} json
		 * @returns {object|ts.ui.TableSpirit}
		 */
		cell: confirmed('number', 'number', '(*)')(
			chained(function(rowindex, cellindex, newcell) {
				var model = this._model;
				var asobject = true;
				if (arguments.length > 2) {
					model.setcell(rowindex, cellindex, newcell);
					// TODO(jmo@): reverse area sync may be needed :/
				} else {
					return model.getcell(rowindex, cellindex, asobject);
				}
			})
		),

		/**
		 * Mark cell invalid.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @param {string} message
		 * @returns {object|ts.ui.TableSpirit}
		 */
		invalid: confirmed('number', 'number', '(string)')(
			chained(function(rowindex, cellindex, message) {
				this._model.setvalidity(false, rowindex, cellindex, message);
				if (this._model.editable) { // attach the classname max pronto
					this.editorplugin.failfast(rowindex, cellindex);
				}
			})
		),

		/**
		 * Mark cell valid.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @returns {object|ts.ui.TableSpirit}
		 */
		valid: confirmed('number', 'number')(
			chained(function(rowindex, cellindex) {
				this._model.setvalidity(true, rowindex, cellindex);
			})
		),

		// Layout ..................................................................

		/**
		 * Maximize the layout to fill positioned container.
		 * Optionally add resize callback for managing pager.
		 * @param @optional {function} onresize
		 * @returns {ts.ui.TableSpirit}
		 */
		maximize: confirmed('(function)')(
			chained(function(onresize) {
				var ended = gui.BROADCAST_RESIZE_END;
				this.css.add('ts-maximized');
				this.onresize = onresize || this.onresize;
				this.broadcast.add(ended);
				var maxrows = this.max();
				this._createpager();
				if (onresize) {
					onresize(maxrows);
				}
			})
		),

		// Paging ..................................................................

		/**
		 * Set maximum number of rows to show (per page).
		 * If the table is maximized, call with no args to:
		 * 1) autofit the amount of rows to the height and...
		 * 2) return this number (of rows that would fit)
		 * The number can be used to limit an API request.
		 * @param @optional {number} n
		 * @returns {number|ts.ui.TableSpirit}
		 */
		max: confirmed('(number)')(
			chained(function(n) {
				var cname = 'ts-hasrows ts-maxrows';
				var ismax = this._ismaximized();
				var model = this._model;
				if (arguments.length) {
					if (ismax) {
						maxerror();
					} else {
						model.maxrows = n;
						this._createpager();
						this._renderqueue.push(function() {
							this.css.shift(n, cname);
						});
					}
				} else {
					if (ismax) {
						return this._automax();
					} else {
						return model.maxrows;
					}
				}
			})
		),

		/**
		 * Works like {ts.ui.TableSpirit#max}, but fixes the height
		 * of the Table so that it doesn't jump when the data arrives.
		 * You can pass a `0` (zero) to reset a previously set size.
		 * @param @optional {number} n
		 * @param @internal {boolean} fixed
		 * @returns {number|ts.ui.TableSpirit}
		 */
		size: confirmed('(number)')(
			chained(function(n) {
				this.$fixedsize = n;
				this.max(n);
			})
		),

		/**
		 * Get or set the (toolbar) pager.
		 * @param @optional {JSONObject|ts.ui.PagerModel} json
		 * @returns {ts.ui.TableSpirit|ts.ui.PagerModel}
		 */
		pager: chained(function(json) {
			var model = this._model;
			var toolb = model.toolbar;
			var pager = toolb.pager;
			if (arguments.length) {
				this._createpager(json);
				this._ownpager = false;
			} else {
				return pager;
			}
		}),

		/**
		 * Set the style of the table.
		 * @param {type:"ts-table-list"} object
		 * @returns {ts.ui.TableSpirit}
		 */
		style: chained(function(config) {
			if (config && config.type) {
				this.css.add(config.type);
			}
		}),

		// Buttons .................................................................

		/**
		 * Expose the toolbar buttons collection for that extra,
		 * added functionality. This is not officially documented.
		 * @param @optional {Array<object|ts.ui.ButtonModel>} json
		 * @returns {ts.ui.ButtonCollection}
		 */
		buttons: chained(function(json) {
			var model = this._model;
			var toolb = model.toolbar;
			if (arguments.length) {
				toolb.buttons.clear();
				json.forEach(function(o) {
					toolb.buttons.push(o);
				});
			} else {
				return toolb.buttons;
			}
		}),

		// Configure ...............................................................

		/**
		 * Show the config button. Call the callback when you click it.
		 * @param @optional {function} onconf
		 * @returns {ts.ui.TableSpirit}
		 */
		configurable: confirmed('(function)')(
			chained(function(onconf) {
				var table = this;
				var model = this._model;
				var toolb = model.toolbar;
				this.onconf = onconf || this.onconf;
				model.configurable = true;
				if (!toolb.buttons.get('config')) {
					toolb.buttons.push({
						id: 'config',
						icon: 'ts-icon-settings',
						onclick: function() {
							if (table.onconf) {
								table.onconf.call(this, table);
							}
						}
					});
				}
				model.$dirty(); // TODO: why needed (for the test)?
			})
		),

		/**
		 * Hide the config button.
		 * TODO: Fix the EDBML bug :/
		 */
		unconfigurable: chained(function(onconfig) {
			var model = this._model;
			var toolb = model.toolbar;
			model.configurable = false;
			toolb.buttons.clear();
			this.onconf = null;
			model.$dirty(); // BUG: `configurable` not picked up!!!!!!
		}),

		// Selecting ...............................................................

		/**
		 * Make (all rows) selectable.
		 * @param @optional {function} onselect
		 * @param @optional {function} onselectall
		 * @param @optional {function} onunselectall
		 * @returns {ts.ui.TableSpirit}
		 */
		selectable: confirmed('(function)', '(function)', '(function)')(
			chained(function(onselect, onselectall, onunselectall) {
				this.tick.add((this._TICKSELECT = this.$instanceid + ':onselect'));
				this._model.selectable = true;
				this.onselect = onselect || this.onselect;
				this.onselectall = onselectall || this.onselectall;
				this.onunselectall = onunselectall || this.onunselectall;
				this._renderqueue.push(function() {
					this.css.add(CLASS_SELECTABLE);
				});
			})
		),

		/**
		 * Make (all rows) unselectable.
		 * @returns {ts.ui.TableSpirit}
		 */
		unselectable: chained(function() {
			this._model.selectable = false;
			this.onselect = null;
			this.onselectall = null;
			this.onunselectall = null;
			this._renderqueue.push(function() {
				this.css.remove(CLASS_SELECTABLE);
			});
		}),

		/**
		 * Get all selected indexes OR confirm selected indexes.
		 * @param @optional {number|Array<number>}
		 * @returns {Array<number>|boolean}
		 */
		selected: function(/* ...indexes */) {
			var model = this._model;
			if (arguments.length) {
				return makearray(arguments).every(function(index) {
					return model.rowselected(index);
				});
			} else {
				return model.selectedrows();
			}
		},

		/**
		 * Select row at index(es).
		 * @param @optional {number|Array<number>}
		 */
		select: confirmed('(number|array)')(
			chained(function(/* ...indexes */) {
				this._select(true, this._rowsadd, arguments);
			})
		),

		/**
		 * Unselect row at index(es).
		 * @param @optional {number|Array<number>}
		 */
		unselect: confirmed('(number|array)')(
			chained(function(/* ...indexes */) {
				this._select(false, this._rowsoff, arguments);
			})
		),

		/**
		 * Toggle row selection at index(es).
		 * @param @optional {number|Array<number>}
		 */
		toggle: confirmed('(number|array)')(
			chained(function(/* ...indexes */) {
				var given = arguments;
				var model = this._model;
				var indxs = given.length ? given : model.rows.map(indexes);
				makearray(indxs).forEach(function(i) {
					if (model.rowselected(i)) {
						this.unselect(i);
					} else {
						this.select(i);
					}
				}, this);
			})
		),

		// Searching ...............................................................

		/**
		 * TODO: Assign a default search model to all columns. Alternatively,
		 * this method could construct a global search field in the statusbar?
		 */
		searchable: chained(function() {
			console.error('Not implemented just yet');
		}),

		/**
		 * TODO: This.
		 */
		unsearchable: chained(function() {
			console.error('Not implemented just yet');
		}),

		// Numbered ................................................................

		/**
		 * Make (all rows) numbered.
		 * @returns {ts.ui.TableSpirit}
		 */

		numbered: confirmed('(function)')(
			chained(function() {
				this._model.numbered = true;
			})
		),

		/**
		 * Make no rows numbered, then.
		 * @returns {ts.ui.TableSpirit}
		 */
		unnumbered: confirmed('(function)')(
			chained(function() {
				this._model.numbered = false;
			})
		),

		// Clicking ................................................................

		/**
		 * Make (all cells) clickable.
		 * @param @optional {function} onclick Optionally configure `onclick`
		 * @returns {ts.ui.TableSpirit}
		 */
		clickable: confirmed('(function)')(
			chained(function(onclick) {
				this.css.add(CLASS_CLICKABLE);
				this._clickable = true;
				if (onclick) {
					this.onclick = onclick;
				}
			})
		),

		/**
		 * Make (all cells) not clickable no more.
		 * @returns {ts.ui.TableSpirit}
		 */
		unclickable: chained(function() {
			this.css.remove(CLASS_CLICKABLE);
			this._clickable = false;
		}),

		/**
		 * Make (all columns) sortable.
		 * @param @optional {function} onsort Optionally configure `onsort`
		 * @returns {ts.ui.TableSpirit}
		 */
		sortable: confirmed('(function)')(
			chained(function(onsort) {
				this._model.sortable = true;
				if (onsort) {
					this.onsort = onsort;
				}
			})
		),

		/**
		 * Make the table not sortable.
		 * @returns {ts.ui.TableSpirit}
		 */
		unsortable: chained(function() {
			this._model.sortable = false;
		}),

		/**
		 * Built-in sort mechanism.
		 * @param {number} colindex
		 * @param @optional {boolan} ascending
		 * @returns {ts.ui.TableSpirit}
		 */
		sort: chained(function(colindex, ascending) {
			var model = this._model;
			var cols = model.cols;
			var col = cols[colindex];
			if (this._model.sortable) {
				if (col) {
					if (Type.isBoolean(ascending)) {
						col.ascending = ascending;
					}
					model.sort(col);
					this.tick.next(function ifnotmanuallyclicked() {
						col.selected = true;
					});
				} else {
					throw new Error(
						'Could not sort column at ' +
						colindex + '. Does it exist?'
					);
				}
			} else {
				throw new Error('Table must be sortable()');
			}
		}),

		/**
		 * Built-in search mechanism. If the rows have not been
		 * compiled into observable models, we'll force repaint.
		 * @param {number} colindex
		 * @param {string} value
		 * @returns {ts.ui.TableSpirit}
		 */
		search: chained(function(colindex, value) {
			var model = this._model;
			model.search(colindex, value);
			this._resetpager();
			this._resetscrolling();
			if (!model.compiled) {
				model.$dirty();
			}
		}),

		/**
		 * EDBML rendering done.
		 * @param {TODO!} summary
		 */
		onrender: function(summary) {
			ts.ui.Spirit.prototype.onrender.call(this, summary);
			this._layouteverything();
			if (summary.first) { // lock keyboard navigation to rows (when editing)
				if (!this.attention.trapping) {
					this.attention.trap(this.queryplugin.getrows());
				}
			}
			// this should really be `onbeforerender` (when we have that)
			if (this._rowsmutated) {
				this._rowsmutated = false;
				var first = this._model.firstVisibleRow();
				var index = first ? first.$index : 0;
				this._bestpage(index);
			}
		},

		// Editing .................................................................

		/**
		 * Make all cells editable with an optional callback.
		 * TODO(jmo@): Make sure that we `vflex` when this is done at any time!
		 * @param @optional {function} onedit
		 * @returns {ts.ui.TableSpirit}
		 */
		editable: confirmed('(function)')(
			chained(function(onedit) {
				var model = this._model;
				model.editable = true;
				this.editorplugin.init(true);
				if (onedit) {
					this.onedit = onedit;
				}
			})
		),

		/**
		 * Make everything not editable.
		 * @returns {ts.ui.TableSpirit}
		 */
		uneditable: chained(function() {
			this.editorplugin.init(false);
			this._model.editable = false;
			this.onedit = null;
		}),

		/**
		 * Focus editable cell.
		 * TODO: Fail if not editable.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 * @returns {ts.ui.TableSpirit}
		 */
		focus: chained(function(rowindex, cellindex) {
			if (this._model.editable) {
				this.editorplugin.focus(rowindex, cellindex);
			} else {
				throw new Error('Cannot focus non-editable Table');
			}
		}),

		// Status ..................................................................

		/**
		 * Show a message in the statusbar.
		 * TODO: Once we have (complex) translations in place, consider showing a
		 * default statusmessage (at least on desktop) "showing 1-23 of 2300 items".
		 * @param @optional {string} message
		 * @returns {string|ts.ui.TableSpirit}
		 */
		status: chained(function(message) {
			var toolbar = this._model.toolbar;
			if (arguments.length) {
				this._statusmessage = message;
				if (!this._errormessage) {
					toolbar.title = message;
				}
			} else {
				return toolbar.title;
			}
		}),

		// Linking .................................................................

		/**
		 * The table supports markdown out of the box, but you'll need to call
		 * this in order to support the link syntax; just so that you are aware
		 * that you expose a surface for phishing attacks.
		 * @param @optional {function} onlink
		 * @returns {ts.ui.TableSpirit}
		 */
		linkable: confirmed('(function)')(
			chained(function(onlink) {
				this._model.linkable = true;
				if (arguments.length) {
					this.onlink = onlink;
				}
			})
		),

		/**
		 * Make the table not support links no more.
		 * @returns {ts.ui.TableSpirit}
		 */
		unlinkable: chained(function() {
			this._model.linkable = false;
		}),

		// Privileged ..............................................................

		/**
		 * If not zero, the Table height will be fixed to
		 * show this many standard rows where "standard"
		 * rows are assumed to be single line (no wraps).
		 * @type {number}
		 */
		$fixedsize: 0,

		/**
		 * Override the statusbar message to show a validation error or something.
		 * @param {string|null} message
		 */
		$errormessage: function(message) {
			var toolbar = this._model.toolbar;
			if (message) {
				toolbar.title = this._errormessage = message;
			} else {
				if (this._errormessage) {
					toolbar.title = this._statusmessage || '';
					this._errormessage = null;
				}
			}
		},

		// Private .................................................................

		/**
		 * Private tick.
		 * @type {string}
		 */
		_TICKSELECT: null,

		/**
		 * Table model.
		 * @type {ts.ui.TableModel}
		 */
		_model: null,

		/**
		 * Ad hoc action queue: Push functions to this
		 * list and they will be evaluated at `onrender`.
		 * This to make sure that we repaint only once.
		 * @type {Array<function>}
		 */
		_renderqueue: null,

		/**
		 * Row scrolling measured.
		 * @type {Position}
		 */
		_scroll: null,

		/**
		 * Don't measure scrolling while this is true.
		 * @type {boolean}
		 */
		_noscrolling: false,

		/**
		 * @type {number}
		 */
		_target: -1,

		/**
		 * We crated the current pager for ourselves?
		 * Otherwise someone else handles pagination.
		 * Set to `false` once the custom is assigned.
		 * @type {boolean}
		 */
		_ownpager: true,

		/**
		 * Hotfixing a problem where Chrome and Safari
		 * resets the scroll position of rows whenever
		 * the HTML is updated by the EDBML engine.
		 * TODO: Is this a general problem or what?
		 * @type {boolean}
		 */
		_scrollfixing: Client.isWebKit,

		/**
		 * Tracking all newly selected rowindexes
		 * (no models, so no observers for free).
		 * @type {Array<number>}
		 */
		_rowsadd: null,

		/**
		 * Tracking newly unselected rowindexes.
		 * @type {Array<number>}
		 */
		_rowsoff: null,

		/**
		 * This can be anything, but usually
		 * it's either `paging` or `sorting`.
		 * @type {string}
		 */
		_flag: null,

		/**
		 * Tracking the statusbar message.
		 * @type {string}
		 */
		_statusmessage: null,

		/**
		 * Tracking the error message.
		 * @type {string}
		 */
		_errormessage: null,

		/**
		 * Spirit of the spinner.
		 * @type {ts.ui.SpinnerSpirit}
		 */
		_spinner: null,

		/**
		 * Spinnig blocking DIV.
		 * @type {HTMLDivElement}
		 */
		_cover: null,

		/**
		 * Do some DHTML whenever the EDBML has updated
		 * and also after the window has been resized.
		 * TODO: Precompute if or not all this is needed!
		 * TODO: If the table is display:none while this
		 * happens, figure out some kind of desperate thing.
		 */
		_layouteverything: function() {
			var model = this._model;
			if (this._crashproof()) {
				this.layoutplugin.layout(this, model);
				this._clip(this.queryplugin.getguts(true));
				this.layoutplugin.flex(this, model);
			}
			this._flush();
			this._cnames(
				model,
				model.cols,
				model.rows,
				model.toolbar
			);
		},

		/**
		 * We know that if the rows are `display:none` or something,
		 * the layout calculations will freeze the browser so bad.
		 * @returns {boolean}
		 */
		_crashproof: function() {
			var rows = this.queryplugin.getrows();
			return !rows || (!!rows.offsetHeight);
		},

		/**
		 * Is maxed layout?
		 * @returns {boolean}
		 */
		_ismaximized: function() {
			return this.css.contains('ts-maximized');
		},

		/**
		 * TODO: No models no more!
		 */
		_clearrows: function(model) {
			var rows = model.rows;
			if (model.compiled) {
				this._observerows(false);
				model.compiled = false;
				rows.clear();
			}
			return rows;
		},

		/**
		 * Update selection.
		 * @param {boolean} select
		 * @param {Array<number>} collect
		 * @param {Arguments} args
		 */
		_select: function(select, collect, args) {
			var model = this._model;
			var alles = !args.length;
			var indxs = alles ? model.rows.map(indexes) : args;
			var changed = makearray(indxs).filter(function(i) {
				return select ? model.selectrow(i) : model.unselectrow(i);
			});
			if (changed.length) {
				if (this.onselect) {
					collect.push.apply(collect, changed);
					this.tick.dispatch(this._TICKSELECT);
				}
			}
		},

		/**
		 * Select everything. This might toogle two billion booleans
		 * and convert two billion arrays into objects (when rows are
		 * declared with compact syntax), so we'll render in two steps:
		 * First update what you see on the screen, then update for real.
		 * (not needed on select because the page is now already selected).
		 */
		_selectall: function(on) {
			if (on === false) {
				this._unselectfast();
				this.tick.time(function unfreeze() {
					this.unselect();
				});
			} else {
				this.select();
			}
		},

		/**
		 * Update page selection using raw DHTML for instant feedback before the
		 * model gets updated for real. This way, we also make sure that `onselect`
		 * is not called more than once (first for the page, then for the rest),
		 * because otherwise we would probably just call `_selectpage(false)`.
		 */
		_unselectfast: function(on) {
			var path = '.ts-table-checkbox button';
			var guts = this.queryplugin.getguts(true);
			var menu = this.queryplugin.getmenu(true);
			var buts = guts.dom.qall(path);
			var butt = menu.dom.qall(path);
			buts.concat(butt).map(function(but) {
				return but.querySelector('i');
			}).forEach(function(icon) {
				icon.className = ICON_OFF;
			});
		},

		/**
		 * Select visible rows (only).
		 * @param @optional {boolean} on
		 */
		_selectpage: function(on) {
			var page = this._model.visibleRows();
			var idxs = page.map(function(row) {
				return row.$index;
			});
			if (on === false) {
				this.unselect(idxs);
			} else {
				this.select(idxs);
			}
		},

		/**
		 * Create default pager and handle page selection.
		 * Optionally, the pager may be specified by users.
		 * In that case, make sure we never overwrite it.
		 * @param @optional {object|ts.ui.PagerModel} json
		 */
		_createpager: function(json) {
			var model = this._model;
			var toolbar = model.toolbar;
			var oldpager = toolbar.pager;
			var newpager = null;
			if (arguments.length) {
				newpager = this._createcustompager(json);
			} else if (this._ownpager) {
				newpager = this._createownpager(model, this);
			}
			if (newpager) {
				toolbar.pager = newpager;
				this._maxpages();
				if (oldpager) {
					oldpager.dispose();
				}
			}
		},

		/**
		 * Crate custom pager.
		 * @param {object|ts.ui.PagerModel} json
		 * @returns {ts.ui.PagerModel}
		 */
		_createcustompager: function(json) {
			return PagerModel.from(json);
		},

		/**
		 * Create my own pager.
		 * @param {ts.ui.TableModel} model
		 * @param {ts.ui.TableSpirit} spirit
		 * @returns {ts.ui.PagerModel}
		 */
		_createownpager: function(model, spirit) {
			return PagerModel.from({
				page: 0,
				pages: model.pageCount(),
				onselect: function(index) {
					spirit._pageselected(index);
				}
			});
		},

		/**
		 * Simply take control of the `max` property on the
		 * pager even if the user has assigned a custom one:
		 * Show three steps when small, otherwise five steps.
		 */
		_maxpages: function() {
			var pager = this._model.toolbar.pager;
			if (pager) {
				var width = this.box.width;
				pager.max = width < 600 ? 3 : 5;
			}
		},

		/**
		 * Reset the pager (if it's our own pager).
		 */
		_resetpager: function() {
			var model = this._model;
			var pager = this.pager();
			if (this._ownpager && model.maxrows) {
				pager.pages = model.pageCount();
				pager.page = 0;
			}
		},

		/**
		 * Setup to reset vertical scrolling after repaint.
		 * This is relevant when either paging or sorting.
		 */
		_resetscrolling: function() {
			this._renderqueue.push(function resetscrolling() {
				var rows = this.queryplugin.getrows();
				if (rows) {
					rows.scrollTop = 0;
				}
			});
		},

		/**
		 * Perhaps pagination was recalculated because of
		 * window resize, perhaps not, this will handle it.
		 * param {number} index
		 */
		_pageselected: function(index) {
			this._model.page = index;
			if (this._resizing) {
				this._resizing = false;
			} else {
				this._target = -1;
			}
			if (this.script.suspended) {
				this.script.unsuspend();
				this.script.run();
			}
		},

		/**
		 * Set the pager to show the row of given index.
		 * The row might be located anywhere on that page.
		 * @param {number} index
		 */
		_bestpage: function(index) {
			var model = this._model;
			var pager = this.pager();
			if (pager) {
				pager.pages = model.pageCount();
				pager.page = model.getPage(index);
			}
		},

		/**
		 * Something was clicked.
		 * @param {Element} elm
		 */
		_onclick: function(elm) {
			var model = this._model;
			if (model.menuopen) {
				this._specialclick(elm);
			} else {
				this._regularclick(elm);
			}
		},

		/**
		 * Something was clicked while the selection menu is open.
		 * @param {Element} elm
		 */
		_specialclick: function(elm) {
			var menu = this.queryplugin.getmenu();
			if (this._contains(menu, elm)) {
				this._onmenuclick(elm);
			} else {
				this._openmenu(false);
			}
		},

		/**
		 * Something was clicked and selection menu is closed.
		 * @param {Element} elm
		 */
		_regularclick: function(elm) {
			var model = this._model;
			var edits = this._editable(model);
			if (model.sortable || model.selectable) {
				var cols = this.queryplugin.getcols();
				if (this._contains(cols, elm)) {
					this._oncolsclick(elm, model);
				}
			}
			if ((this._clickable && this.onclick) || edits) {
				var rows = this.queryplugin.getrows();
				if (this._contains(rows, elm)) {
					this._onrowsclick(elm, edits);
				}
			}
			if (model.selectable) {
				if (CSSPlugin.contains(elm, CLASS_SELECTBUTTON)) {
					this._ongutsclick(elm);
				} else if (this._contains(this.queryplugin.getmenu(), elm)) {
					this._onmenuclick(elm);
				}
			}
		},

		/**
		 * Something is editable?
		 * @param {ts.ui.TableModel} model
		 * @returns {boolean}
		 */
		_editable: function(model) {
			return model.editable && model.cols.some(function(col) {
				return col.editable !== false;
			});
		},

		/**
		 * Compute the target row: When the window resizes, we like to show
		 * the first visible row again after pagination reflow. Now, if the
		 * window resizes yet again, we like to stick to this original row.
		 * @param {ts.ui.TableModel} model
		 */
		_onbeforeresize: function(model) {
			if (this._ownpager && this._target === -1) {
				var first = model.firstVisibleRow();
				var index = first ? first.$index : 0;
				this._target = index > 0 ? index : -1;
			}
		},

		/**
		 * DHTML updates after window resize.
		 * Compute new best page in the pager.
		 * @param {number} index Target rowindex
		 */
		_onafterresize: function(index) {
			this._layouteverything();
			this._hackscrolling();
			var max = this.max();
			if (this._ownpager) {
				if (index > -1) {
					this._resizing = true;
					this.script.suspend();
					this._bestpage(index);
				}
			}
			if (this.onresize) {
				this.onresize.call(this, max);
			}
		},

		/**
		 * Claimed parent contains child?
		 * @param {Element} parent
		 * @param {Element} child
		 * @returns {boolean}
		 */
		_contains: function(parent, child) {
			return parent && DOMPlugin.contains(parent, child);
		},

		/**
		 * Element classList contains classname?
		 * @param {Element} elm
		 * @param {string} classname
		 */
		_hasclass: function(elm, classname) {
			return elm && CSSPlugin.contains(elm, classname);
		},

		/**
		 * Fix columns to rows position. Snapshot the position so that we can
		 * restore it after EDBML updates, which might sometimes ruin it all.
		 * @param {number} x
		 * @param {number} y
		 * @param {ts.ui.Spirit} cols
		 * @param {ts.ui.Spirit} guts
		 */
		_onscroll: function(x, y, cols, guts) {
			this._scroll.x = x;
			this._scroll.y = y;
			if (cols) {
				cols.sprite.x = (0 - x);
			}
			if (guts) {
				guts.sprite.y = (0 - y);
			}
		},

		/**
		 * Patching a dysfunction in WebKit where scroll position
		 * gets reset after HTML is updated by the EDBML engine.
		 * TODO(jmo@): Move this to the {ts.ui.TableLayoutPlugin}
		 */
		_hackscrolling: function() {
			var plug = this.queryplugin;
			var rows = plug.getrows();
			var cols = plug.getcols(true);
			var guts = plug.getguts(true);
			this._clip(guts);
			if (rows && cols) {
				this._onscroll(rows.scrollLeft, rows.scrollTop, cols, guts);
			}
		},

		/**
		 * The gutter is floated on top of the rows and synchronized
		 * to the scrolling of the rows (this so that the gutter can
		 * stay fixed upon horizontal scrolling). Unfortunately, the
		 * CSS can't handle a situation where the gutter appears on
		 * top of the bottom toolbar. Since Firefox doesn't support
		 * nice clip-path just yet, we'll fix it with some DHTML.
		 * Note that this can only possibly perform on mobiles
		 * because the scrollbar size is zero (so nothing happens).
		 * TODO(jmo@): Move this into a (future) SelectionPlugin.
		 * @param {ts.ui.Spirit} guts
		 */
		_clip: function(guts) {
			var bsize = Client.scrollBarSize;
			if (guts && bsize) {
				var avail = this.queryplugin.getbody().offsetHeight;
				var scrol = this.queryplugin.getrows().scrollTop;
				guts.css.maxHeight = avail + scrol - bsize;
			}
		},

		/**
		 * Cols clicked. Call `onsort` with column index and ascending flag.
		 * If the same button is clicked twice, reverse ascending/descending.
		 * Note: the `selected` property is maintained by {ts.ui.TableModel}.
		 * @param {Element} elm
		 * @param {ts.ui.TableModel} model
		 */
		_oncolsclick: function(elm, model) {
			if ((elm = ButtonSpirit.getButton(elm, this))) {
				var length = model.rows.length;
				if (model.sortable) {
					if (this._hasclass(elm, 'ts-button-sort')) {
						var i = this.queryplugin.getindex(elm);
						var c = model.cols[i];
						if (c.selected) {
							c.ascending = !c.ascending;
						}
						if (this.onsort) {
							perfwarning(length > 3000);
							this.onsort(i, c.ascending);
						}
						this._selectcol(c);
						this._flag = 'sorting';
						this._resetscrolling();
					}
				}
			}
		},

		/**
		 * Select the column (unselect other columns).
		 * @param {ts.ui.TableColModel} col
		 */
		_selectcol: function(col) {
			this._model.cols.forEach(function(c) {
				c.selected = c === col;
			});
		},

		/**
		 * Rows clicked. If defined, call `onclick` with rowindex and cellindex.
		 * TODO: Definitely move this method elsewhere...
		 * @param {Element} elem
		 * @param {boolean} editable
		 */
		_onrowsclick: function(elem, editable) {
			var area, pos = this.queryplugin.getpos(elem);
			if (pos) { // abort when non-floating gutter is clicked
				if (this.onclick) {
					this.onclick(pos.y, pos.x);
				}
				if (editable) {
					while (elem.localName !== 'td') {
						elem = elem.parentNode;
					}
					if ((area = elem.querySelector('.' + CLASS_TEXTAREA))) {
						area.focus();
					}
				}
			}
		},

		/**
		 * Gutter clicked. Update (single) row selection.
		 * @param {Element} elm
		 * @param {HTMLDivElement} guts
		 */
		_ongutsclick: function(elm) {
			elm = ButtonSpirit.getButton(elm);
			this.toggle(this.queryplugin.getindex(elm));
		},

		/**
		 * The top-left checkbox-button was clicked. Either open the
		 * selection menu or clear all selections in the whole world.
		 * @param {HTMLAsideElement} menu
		 * @param {Element} elm
		 */
		_onmenuclick: function(elm) {
			if ((elm = ButtonSpirit.getButton(elm))) {
				switch (this.queryplugin.getaction(elm)) {
					case 'selection-menu':
						if (this._maybeclearall()) {
							if (this.onunselectall) {
								this.onunselectall.call(this);
							}
						} else {
							this._openmenu(true);
							this._selectpage();
						}
						break;
					case 'selection-menu-close':
						this._openmenu(false);
						break;
					case 'select-page':
						this._openmenu(false);
						break;
					case 'select-all':
						this._openmenu(false);
						this._renderqueue.push(function menuclosed() {
							this._selectall();
							if (this.onselectall) {
								this.onselectall();
							}
						});
						break;
				}
			}
		},

		/**
		 * The menu works in a peculiar way: If there are any selected
		 * rows on the current page, clicking the menu will clear all
		 * selections in the table. If there are no selections on the
		 * page, the whole page will be selected and the menu opens.
		 * This will determine the outcome.
		 * @returns {boolean} True on clear all
		 */
		_maybeclearall: function(hasselections) {
			if (this._model.isVisibleRowSelected()) {
				this.event.remove('click', document);
				this._openmenu(false);
				this._selectall(false);
				this._model.$dirty();
				return true;
			}
			return false;
		},

		/**
		 * Open or close the selection menu. We'll ask the Pager whether
		 * or not there are multiple pages because the dev might render
		 * one page at a time while in the database there are millions;
		 * and in that case, he will have created a Pager to reflect it.
		 * @param {boolean} open
		 */
		_openmenu: function(open) {
			var model = this._model;
			var toolb = model.toolbar;
			var pager = toolb.pager;
			var pages = pager && pager.pages > 1;
			if (pages && open !== model.menuopen) {
				this._model.menuopen = open;
				this.tick.time(function() {
					this.event.shift(open, 'click', document);
				});
			}
		},

		/**
		 * DHTML updates will mess with the scrolling.
		 * This suspends scroll measurements while the
		 * DHTML is updating (so we can restore scroll).
		 * TODO: This as standard in {edb.ScriptPlugin},
		 * for now we call the method directly from EDBML.
		 * @see {ts.ui.TableSpirit.edbml}
		 */
		_onbeforerender: function() {
			var rows = this.queryplugin.getrows();
			if (rows) {
				this._noscrolling = true;
			}
		},

		/**
		 * Autotatically adjust maxrows to fit
		 * in the Tables embedding container.
		 * @returns {number}
		 */
		_automax: function() {
			var max = this._calcmax();
			this._model.maxrows = max;
			return max;
		},

		/**
		 * Calculate maxrows to fit in container.
		 * Some overflow (scrollbar) is expected.
		 * @returns {number}
		 */
		_calcmax: function() {
			var tablebody = this.queryplugin.getbody();
			var availsize = tablebody.offsetHeight;
			var rowheight = UNIT_DOUBLE;
			var rowslimit = Math.ceil(availsize / rowheight);
			return rowslimit;
		},

		/**
		 * The Table should show a "floating gutter" that stys fixed
		 * on horizontal scrolling (to make row selection easier)?
		 * IE9 just doesn't have the guts to pull this off nicely.
		 * @returns {boolean}
		 */
		_floatgutter: function() {
			return (
				!Client.isExplorer9 &&
				this._model.selectable &&
				this.css.contains('ts-scroll-x')
			);
		},

		/**
		 * Flush the action queue. This apparently
		 * needs a tick for the screen to repaint.
		 */
		_flush: function() {
			this.tick.next(function onrepaint() {
				var list = this._renderqueue;
				while (list.length) {
					list.shift().call(this);
				}
			});
		},

		/**
		 * Update some classnames. Nothing fancy.
		 * @type {ts.ui.TableModel} model
		 * @type {ts.ui.TableColCollection} cols
		 * @param {ts.ui.TableRowCollection} rows
		 * @param {ts.ui.ToolBarModel} toolbar
		 */
		_cnames: function(model, cols, rows, toolbar) {
			var show = !cols.length || cols.some(visible);
			this.css.shift(rows.length && show, 'ts-hasrows');
			this.css.shift(cols.length && show, 'ts-hascols');
			this.css.shift(model.configurable || toolbar.pager, 'ts-hastool');
		},

		/**
		 * If you set the attribute ts.busy is true, you will see the spinner in the table
		 * param {object} opts
		 */
		_initspin: function(opts) {
			if (!this._spinner) {
				this._spinner = ts.ui.SpinnerSpirit.summon();
			}
			var rect = this.element.getBoundingClientRect();
			if (rect.height >= TABLE_MIN_HEIGHT) {
				opts.top = '116px';
			} else {
				opts.length = 22 * rect.height / TABLE_MIN_HEIGHT; // shrink the spinner
				opts.radius = 22 * rect.height / TABLE_MIN_HEIGHT;
				opts.width = 6 * rect.height / TABLE_MIN_HEIGHT;
			}
			if (opts.message) {
				this._createCover(rect);
				this._spinner.spin(this.dom.q('.ts-table-body'), opts);
			} else if (this._cover) {
				this._spinner.stop();
				this._cover.remove();
				this._cover = null;
			}
		},

		/**
		 * @todo If any other elements need a cover, the code should move to ts.ui.CoverSpirit.js
		 * param {object} rect, element.getBoundingClientRect()
		 */
		_createCover: function(rect) {
			if (this._cover) {
				return;
			}
			var cover = document.createElement('div');
			cover.className += 'ts-cover ts-tablecover';
			this.element.appendChild(cover);
			this._cover = cover;
		}
	});
}(
	gui.Type,
	gui.Client,
	gui.Array,
	gui.DOMPlugin,
	gui.CSSPlugin,
	gui.ConfigPlugin,
	gui.Position,
	gui.Combo.chained,
	gui.Arguments.confirmed,
	ts.ui.TableRowModel,
	ts.ui.ButtonSpirit,
	ts.ui.PagerModel
));



/**
 * DOM query studio. Lookup elements and spirits inside the Table. Also
 * parse element attributes and pinpoint elements position in the model.
 * @extends {ts.ui.Plugin}
 * @using {gui.Type} Type
 */
ts.ui.TableQueryPlugin = (function(Type) {
	return ts.ui.Plugin.extend({

		/**
		 * Get the rows element or spirit.
		 * @param {boolean} getspirit
		 * @returns {Element|ts.ui.Spirit}
		 */
		getrows: function(getspirit) {
			return this._get('.ts-table-rows', getspirit);
		},

		/**
		 * Get the cols element or spirit.
		 * @param {boolean} getspirit
		 * @returns {Element|ts.ui.Spirit}
		 */
		getcols: function(getspirit) {
			return this._get('.ts-table-cols', getspirit);
		},

		/**
		 * Get the gutter element (that's the checkboxes).
		 * @param {boolean} getspirit
		 * @returns {Element|ts.ui.Spirit}
		 */
		getguts: function(getspirit) {
			return this._get('.ts-table-gutter', getspirit);
		},

		/**
		 * Get the global selecbutton/selectmenu element.
		 * @param {boolean} getspirit
		 * @returns {Element|ts.ui.Spirit}
		 */
		getmenu: function(getspirit) {
			return this._get('.ts-table-menu', getspirit);
		},

		/**
		 * Get the `DIV` called body.
		 * @returns {HTMLDivElement}
		 */
		getbody: function() {
			return this._get('.ts-table-body');
		},

		/**
		 * Get table cell (element) at position (cellindex and rowindex).
		 * @returns {HTMLTableCellElement}
		 */
		getcell: function(pos) {
			var rowindex = pos.y;
			var celindex = pos.x;
			var model = this.spirit._model;
			var id = model.$cellid(rowindex, celindex);
			return this.spirit.dom.q('#' + id);
		},

		/**
		 * Figure out what rowindex and cellindex (in the model) a given
		 * DOM element relates to (this can be any element in the rows).
		 * TODO: This information can now be extracted from the cell ID!!!
		 * @param {DOMElement} elm
		 * @returns {gui.Position} Where `y` is the rowindex and `x` is the cell.
		 *					or `null` if element is not associated to position in the model
		 */
		getpos: function(elm) {
			var pos = new gui.Position();
			var rows = this.getrows();
			while (elm && elm !== rows) {
				switch (elm.localName) {
					case 'tr':
						pos.y = this.getindex(elm);
						break;
					case 'td':
						pos.x = this.getindex(elm);
						break;
				}
				elm = elm.parentNode;
			}
			if (pos.y !== null && pos.x !== null) {
				return pos;
			} else {
				return null;
			}
		},

		/**
		 * Get `data-index` value from element (as a number).
		 * @param {Element} elm
		 * @returns {number}
		 */
		getindex: function(elm) {
			var i = elm.getAttribute('data-index');
			return i !== null ? Type.cast(i) : i;
		},

		/**
		 * Get `data-action` value from element (as a string).
		 * @param {Element} elm
		 * @returns {string}
		 */
		getaction: function(elm) {
			return elm.getAttribute('data-action');
		},

		// Private .................................................................

		/**
		 * Get element or spirit.
		 * @param {boolean} getspirit
		 * @returns {Element|ts.ui.Spirit}
		 */
		_get: function(selector, getspirit) {
			var elem = this.spirit.dom.q(selector);
			return getspirit ? (elem ? ts.ui.get(elem) : null) : elem;
		}

	});
}(gui.Type));



/**
 * Table inline editing.
 * TODO: Prevent the table from changing page while invalid (or alternatively
 * cache textarea invalid values so that those can be restored on page shift).
 * @extends {ts.ui.Plugin}
 * @using {gui.CSSPluign} CSSPlugin
 * @using {gui.DOMPlugin} DOMPlugin
 * @using {gui.Position} Position
 * @using {gui.Client} Client
 * @using {gui.Key} key
 */
ts.ui.TableEditPlugin = (function(CSSPlugin, DOMPlugin, Position, Client, Key) {
	var CLASS_CONTAINER = 'ts-table-cell';
	var CLASS_TEXTAREA = 'ts-table-input';
	var CLASS_EDITMODE = 'ts-table-editmode';
	var CLASS_NAVIMODE = 'ts-table-navimode';
	var CLASS_OUTLINER = 'ts-table-line';
	var CLASS_INVALID = 'ts-table-invalid';

	/**
	 * Query by classname.
	 * @param {Element} elm
	 * @param {string} classname
	 * @returns {Element}
	 */
	function query(elm, classname) {
		return elm.querySelector('.' + classname);
	}

	/**
	 * Element has classname?
	 * @param {Element} elm
	 * @param {string} classname
	 * @returns {boolean}
	 */
	function hasclass(elm, classname) {
		return CSSPlugin.contains(elm, classname);
	}

	return ts.ui.Plugin.extend({

		/**
		 * Prepare (and unprepare) for editing going on
		 * @param {boolean} on
		 */
		init: function(on) {
			var spirit = this.spirit, element = spirit.element;
			spirit.event.shift(on, 'focus blur', element, this, true);
			spirit.action.shift(on, ts.ui.ACTION_CHANGED, this);
			spirit.life.shift(on, gui.LIFE_RENDER, this);
		},

		/**
		 * Add "invalid" classname now, don't wait for model to trigger EDBML repaint.
		 * This fixes a visual glitch where a multiline textarea would collapse and
		 * then expand again non-immediately (the table layout would jump around).
		 * @param {number} rowindexe
		 * @param {number} cellindex
		 */
		failfast: function(rowindex, cellindex) {
			var td = this._getcellat(rowindex, cellindex);
			if (td) {
				CSSPlugin.add(td, CLASS_INVALID);
			}
		},

		/**
		 * Focus cell at index.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 */
		focus: function(rowindex, cellindex) {
			this._focuscell(this._getcellat(rowindex, cellindex), true);
		},

		/**
		 * Blur cell at index.
		 * @param {number} rowindex
		 * @param {number} cellindex
		 */
		blur: function(rowindex, cellindex) {
			this._focuscell(false, this._getcellat(rowindex, cellindex), true);
		},

		/**
		 * Handle event.
		 * @param {Event} e
		 */
		onevent: function(e) {
			var target = e.target;
			var spirit = this.spirit;
			switch (e.type) {
				case 'focus':
				case 'blur':
					if (hasclass(target, CLASS_TEXTAREA)) {
						this._areaupdate(target, e.type === 'focus');
					} else if (this._navimode) {
						this._maybereset(spirit, target);
					}
					break;
				case 'keypress':
				case 'keydown':
					if (this._noscroll) {
						switch (e.keyCode) {
							case 38:
							case 40:
								e.preventDefault();
								e.stopPropagation();
								break;
						}
					}
					break;
			}
		},

		/**
		 * Handle action.
		 * @param {gui.Action} a
		 */
		onaction: function(a) {
			if (a.type === ts.ui.ACTION_CHANGED) {
				if (ts.ui.TextAreaSpirit.is(a.target)) {
					var area = a.target.element;
					var cont = area.parentNode;
					var next = a.data.newheight;
					if (document.activeElement === area) {
						this._sync(true, area, cont, next);
					}
				}
			}
		},

		/**
		 * Handle key (cross browser fixed).
		 * TODO(jmo@): When in navimode, BACK should not trigger `history.back()``
		 * @param {gui.Key} key
		 */
		onkey: function(key) {
			var spirit = this.spirit;
			if (key.down) {
				switch (key.type) {
					case 'Enter':
						if (!Key.shiftDown) {
							if ((this._navimode = !this._navimode)) {
								this._gonavimode(spirit);
							} else {
								this._goeditmode(spirit);
							}
						}
						break;
					case 'Esc':
						if (this._editmode) {
							this._escape(this._cell);
							this._editmode = false;
							this._navimode = true;
							this._gonavimode(spirit);
						}
						break;
					default:
						this._movecell(key.type.toLowerCase());
						break;
				}
			}
		},

		/**
		 * Called when an EDBML update happened.
		 * @param {gui.Life} life
		 */
		onlife: function(life) {
			if (life.type === gui.LIFE_RENDER) {
				this._syncinvalid();
				if (this._cell) { // catch scenario: ENTER on edited cell
					this._resolveinvalid(this._cell);
				}
			}
		},

		// Private .................................................................

		/**
		 * While keyboard navigating (via arrow keys), this is the focused cell.
		 * TODO: Use a string ID instead (because element references not stable).
		 * @type {HTMLTableCellElement}
		 */
		_cell: null,

		/**
		 * True while editing.
		 * @type {boolean}
		 */
		_editmode: false,

		/**
		 * Is in navigation mode (arrow keys move the focus outline)?
		 * @type {boolean}
		 */
		_navimode: false,

		/**
		 * Snapshot value of an edited cell (as a string)
		 * so that later, we can figure out if it changed.
		 * @type {string}
		 */
		_snapshot: null,

		/**
		 * Marks the current position (rowindex and cellindex).
		 * @type {gui.Position}
		 */
		_position: null,

		/**
		 * Attempt to supress page scrolling on UP/DOWN keys?
		 * TODO: Move this functionality to higher order util.
		 * @type {boolean}
		 */
		_noscroll: false,

		/**
		 * Get TD element at position (in the model).
		 * @param {number} rowindex
		 * @param {number} rowindex
		 * @returns {HTMLTableCellElement}
		 */
		_getcellat: function(rowindex, cellindex) {
			var pos = new Position(cellindex, rowindex);
			var cel = this.spirit.queryplugin.getcell(pos);
			return cel;
		},

		/**
		 * Textarea focused or blurred: Start and stop edit session.
		 * @param {HTMLTextAreaElement} area
		 * @param {boolean} focused
		 */
		_areaupdate: function(area, focused) {
			var cont = area.parentNode;
			var cell = cont.parentNode;
			this._sync(focused, area, cont);
			CSSPlugin.shift(cell, focused, CLASS_EDITMODE);
			this.spirit.css.shift(focused, CLASS_EDITMODE);
			if (focused) {
				this._areafocus(this.spirit, area, cell);
			} else {
				this._areablur(area);
			}
		},

		/**
		 * Textarea focused. Start edit session.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {HTMLTextAreaElement} area
		 * @param {HTMLTableCellElement} cell
		 */
		_areafocus: function(spirit, area, cell) {
			this._resetall(spirit);
			this._editmode = true;
			this._resolveinvalid(cell);
			spirit.key.add('Enter Esc', this);
			this._snapshot = area.value.trim();
			this._cell = cell;
		},

		/**
		 * Textarea blurred. Stop edit session.
		 * @param {HTMLTextAreaElement} area
		 */
		_areablur: function(area) {
			this._editmode = false;
			this._evalchange(area, area.value.trim(), this._snapshot);
			this._snapshot = null;
			this._syncinvalid();
		},

		/**
		 * While in navimode, move the focus outline with those keys.
		 * @param {string} dir
		 * @param {boolean} skip TODO(jmo@): Hold shift to skip non-editable cells?
		 */
		_movecell: function(dir, skip) {
			var plug = this.spirit.queryplugin;
			var icel = DOMPlugin.ordinal(this._cell);
			var irow = DOMPlugin.ordinal(this._cell.parentNode);
			var rows = plug.getrows(true).dom.qall('tr');
			this._focuscell(this._nextcell(dir, rows, irow, icel));
		},

		/**
		 * @param {string} dir
		 * @param {Array<HTMLTableRowElement>} rows
		 * @param {number} irow
		 * @param {number} icel
		 */
		_nextcell: function(dir, rows, irow, icel) {
			var row = rows[irow];
			var cels = row.cells;
			var cell = cels[icel];
			var selects = this.spirit._model.selectable;
			var initrow = rows[0];
			var lastrow = rows[rows.length - 1];
			var initcel = cels[selects ? 1 : 0];
			var lastcel = cels[cels.length - 1];
			switch (dir) {
				case 'up':
					return (row === initrow ? lastrow : rows[--irow]).cells[icel];
				case 'down':
					return (row === lastrow ? initrow : rows[++irow]).cells[icel];
				case 'left':
					return cell === initcel ? lastcel : cels[--icel];
				case 'right':
					return cell === lastcel ? initcel : cels[++icel];
			}
		},

		/**
		 * Focus cell outline or texarea (or blur the current cell).
		 * @param {HTMLTableCellElement|null} cell
		 * @param @optional {boolean} edit Focus the textarea?
		 */
		_focuscell: function(cell, edit) {
			var current = this._cell;
			var target = edit ? CLASS_TEXTAREA : CLASS_OUTLINER;
			if ((this._cell = cell)) {
				this._resolveinvalid(cell);
				gui.Tick.time(function() {
					query(cell, target).focus();
				});
			} else if (current) {
				query(current, target).blur();
			}
		},

		/**
		 * Enter navigation mode: Arrow keys move the focus.
		 * @param {ts.ui.TableSpirit} spirit
		 */
		_gonavimode: function(spirit) {
			spirit.css.add(CLASS_NAVIMODE);
			spirit.key.add('Up Down Left Right', this);
			this._scrollsuppress(true);
			this._focuscell(this._cell);
		},

		/**
		 * Enter edit mode coming from navigation mode.
		 * @param {ts.ui.TableSpirit} spirit
		 */
		_goeditmode: function(spirit) {
			var cell = this._cell;
			var area = query(cell, CLASS_TEXTAREA);
			if (area) { // otherwise not editable
				this._resetall(spirit);
				area.focus();
			}
		},

		/**
		 * If something changed, perhaps it's time to invoke the callback.
		 * TODO: Perhaps just set this up with an `onchange` listener :/
		 * @param {HTMLTextAreaElement} area
		 * @param {string} newval
		 * @param {string} oldval
		 */
		_evalchange: function(area, newval, oldval) {
			var spirit = this.spirit;
			var onedit = spirit.onedit;
			if (onedit && (newval !== oldval)) {
				var pos = spirit.queryplugin.getpos(area);
				onedit.call(spirit, pos.y, pos.x, newval, oldval);
			}
		},

		/**
		 * When enabled (so in keyboard navigation mode),
		 * arrow UP/DOWN will not scroll the whole page.
		 * TODO(jmo@): Perhaps move this to general util?
		 * @param {boolean} enabled
		 */
		_scrollsuppress: function(enabled) {
			var events = 'keypress keydown'; // browser specific :/
			this.spirit.event.shift(
				(this._noscroll = enabled), events, document, this
			);
		},

		/**
		 * Synchronize (and reset) the size of textarea and container.
		 * TODO: The `clip` update should probably be fixed differently
		 * TODO: Move this stuff to the {ts.ui.TableLayoutPlugin}
		 * TODO: If no cols in Table, don't substract the `-1` value :/
		 * @param {boolean} sync (reset when false)
		 * @param {HTMLTextAreaElement} area
		 * @param {HTMLDivElement} cont
		 * @param @optional {number} height
		 */
		_sync: function(sync, area, cont, height) {
			height = (height || area.offsetHeight) - 1;
			height = (Math.round(height / 22) * 22) - 1;
			if (sync) {
				cont.style.minHeight = height + 'px';
				this._shrink(area, height);
			} else {
				cont.style.minHeight = '';
				this._shrink(area, 0);
			}
		},

		/**
		 * Make the textarea appear smaller than it really is so that it doesn't
		 * appear to overlap the bottom cell border. Unfortunately, IE11 and up
		 * has a bug where this affects the *actual* height of the textarea :/
		 * TODO(jmo@): We still need to perform this cosmetic tweak for newer IE!
		 * @param {HTMLTextAreaElement} area
		 * @param {number|boolean} height
		 */
		_shrink: function(area, height) {
			if (!Client.isExplorer11 && !Client.isEdge) {
				if (height) {
					area.style.clip = 'rect(auto,auto,' + height + 'px,auto)';
				} else {
					area.style.clip = '';
				}
			}
		},

		/**
		 * Sync all invalid cells to the height of the textarea.
		 * TODO(jmo@): To look right in navimode, all cells in
		 * to row should be synced (and unsynced when validated).
		 * This might involve {ts.ui.TableLayoutPlugin#_hflex}.
		 */
		_syncinvalid: function() {
			this.spirit.dom.qall('.' + CLASS_INVALID).forEach(function(td) {
				var cont = query(td, CLASS_CONTAINER);
				var area = query(td, CLASS_TEXTAREA);
				this._sync(true, area, cont);
			}, this);
		},

		/**
		 * While keyboard navigating, reset all if
		 * something outside the Table is clicked.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {HTMLElement} elm
		 */
		_maybereset: function(spirit, elm) {
			if (hasclass(elm, CLASS_OUTLINER)) {
				gui.Tick.next(function allow_new_focus() {
					var rows = spirit.queryplugin.getrows();
					var curr = document.activeElement;
					if (!DOMPlugin.contains(rows, curr) || !curr) {
						this._resetall(spirit);
					}
				}, this);
			}
		},

		/**
		 * Remove traces of editmode and navimode.
		 * @param {ts.ui.TableSpirit} spirit
		 */
		_resetall: function(spirit) {
			spirit.key.remove('Up Down Left Right Enter Esc', this);
			spirit.css.remove([CLASS_NAVIMODE, CLASS_EDITMODE]);
			this._scrollsuppress(false);
			this._navimode = false;
			this._editmode = false;
		},

		/**
		 * Update Table statusbar to show potential error message.
		 * @param {HTMLTableCellElement} cell
		 * @retrurns {boolean} True when invalid
		 */
		_resolveinvalid: function(cell) {
			var spirit = this.spirit;
			var model = spirit._model;
			if ((cell = this._getcellmodel(spirit, model, cell))) {
				if (!cell.valid && cell.message) {
					spirit.$errormessage(cell.message);
					return true;
				} else {
					spirit.$errormessage(null);
				}
			}
			return false;
		},

		/**
		 * Lookup (readonly) cell model for cell element.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 * @param {HTMLTableCellElement} cell
		 * @returns {object}
		 */
		_getcellmodel: function(spirit, model, cell) {
			var pos = spirit.queryplugin.getpos(cell);
			var cel = model.getcell(pos.y, pos.x);
			return cel;
		},

		/**
		 * ESCAPE key was pressed. Restore original value.
		 * TODO: This should require less hacks :/
		 * @param {HTMLTableCellElement} cell
		 */
		_escape: function(cell) {
			var area = query(cell, CLASS_TEXTAREA);
			if (this._snapshot !== null) {
				area.value = this._snapshot;
			} else {
				console.error('Out of synch');
			}
		}

	});
}(gui.CSSPlugin, gui.DOMPlugin, gui.Position, gui.Client, gui.Key));



/**
 * Table layout and flexiness.
 * @extends {ts.ui.Plugin}
 * @using {gui.Client} Client
 * @using {gui.Tick} Tick
 */
ts.ui.TableLayoutPlugin = (function using(Client, Tick) {
	var UNIT = 22;
	var UNIT_DOUBLE = UNIT * 2;
	var COL_CELLS = '.ts-table-cols th:not(.ts-table-addition)';
	var ROW_CELLS = '.ts-table-rows tr:first-child td:not(.ts-table-addition)';

	/**
	 * @param {Element} elm
	 * @returns {number}
	 */
	function getheight(elm) {
		return elm.getBoundingClientRect().height;
	}

	/**
	 * TODO(jmo@): Only fix the height of editable cells!
	 * @param {HTMLTableCellElement} td
	 * @param {number} height
	 */
	function setheight(td, height) {
		var div = td.querySelector('.ts-table-cell');
		if (div) {
			div.style.height = height + 'px';
		}
	}

	/**
	 * Cells in this column may span multiple lines? Because
	 * otherwise the `style.height` setters are not needed.
	 * @param {ts.ui.TableColModel} col
	 * @returns {boolean}
	 */
	function ismultiline(col) {
		return col.wrap && col.visible;
	}

	return ts.ui.Plugin.extend({

		/**
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 */
		layout: function(spirit, model) {
			var plug = spirit.queryplugin;
			var cols = plug.getcols();
			var rows = plug.getrows();
			var guts = plug.getguts();
			this._layout1(spirit, model, cols, rows, guts);
			this._layout2(spirit, model.cols);
		},

		/**
		 * Flex all the things.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 */
		flex: function(spirit, model) {
			this._hflex(spirit, model);
			if (model.cols.some(ismultiline)) {
				this._vfix(spirit, model);
			}
		},

		// Private .................................................................

		/**
		 * Restore scroll positions after EDBML update (might have) ruined it.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 * @param {HTMLDivElement} cols
		 * @param {HTMLDivElement} rows
		 * @param {HTMLDivElement} guts
		 */
		_layout1: function(spirit, model, cols, rows, guts) {
			spirit.event.add('scroll', rows); // TODO: WHAT ABOUT THIS?
			var fixed = model.maxrows && spirit.$fixedsize;
			rows.style.height = fixed ? (UNIT_DOUBLE * model.maxrows) + 'px' : '';
			if (model.isWrapping()) {
				cols.style.paddingRight = Client.scrollBarSize + 'px';
			}
			Tick.nextFrame(function() {
				this._layoutasync(spirit, model, rows, guts, spirit._flag);
				spirit._hackscrolling();
				spirit._flag = null;
			}, this);
		},

		/**
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableColCollection} cols
		 */
		_layout2: function(spirit, cols) {
			spirit.css.shift(cols.some(function(col) {
				return col.wrap;
			}), 'ts-wrapping');
		},

		/**
		 * Table updates reset the scroll position asynchronously
		 * so that this operation needs to be performed later on.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 * @param {HTMLDivElement} rows
		 * @param {HTMLDivElement} guts
		 * @param {string} flag
		 */
		_layoutasync: function(spirit, model, rows, guts, flag) {
			var x = spirit._scroll.x;
			var y = spirit._scroll.y;
			if (rows) {
				switch (flag) {
					case 'paging':
					case 'sorting':
						y = 0;
						break;
				}
				rows.scrollLeft = x;
				rows.scrollTop = y;
			}
			Tick.time(function() {
				spirit._noscrolling = false;
			});
		},

		// Horizontal flex .........................................................

		/**
		 * Release it, measure it, flex it, then fix it again.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 */
		_hflex: function(spirit, model) {
			spirit.css.width = 'auto';
			var cols = model.visibleCols();
			var ths = spirit.dom.qall(COL_CELLS);
			var tds = spirit.dom.qall(ROW_CELLS);
			var width = spirit.box.width;
			this._hflex1(spirit, model, width, cols, ths, tds);
			spirit.css.width = width;
			this._hflex3(spirit, model, width, cols, ths, tds);
		},

		/**
		 * Flex step one.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 * @param {number} width
		 * @param {Array<ts.ui.TableColModel>} cols
		 * @param {Array<HTMLTableCellElement>} ths
		 * @param {Array<HTMLTableCellElement>} tds
		 */
		_hflex1: function(spirit, model, width, cols, ths, tds) {
			var total = this._hflextotal(cols);
			var adjust = this._hflexadjust(model);
			var correct = (width - adjust) / total;
			var sum = this._hflex2(cols, ths, tds, correct);
			spirit.css.shift(sum + adjust > width, 'ts-scroll-x');
		},

		/**
		 * Flex step two.
		 * @param {Array<ts.ui.TableColModel>} cols
		 * @param {Array<HTMLTableCellElement>} cells
		 * @param {number} xxxxx
		 */
		_hflex2: function(cols, ths, tds, xxxxx) {
			return cols.reduce(function(sum, col, i) {
				var td, th, flex = col.flex;
				var span = flex * xxxxx;
				var mins = col.minwidth;
				if (mins && span < mins) {
					span = mins;
				}
				if ((th = ths[i])) {
					th.style.width = span + 'px';
				}
				if ((td = tds[i])) {
					td.style.width = span + 'px';
				}
				return sum + span;
			}, 0);
		},

		/**
		 * First we flex and then we minwidth. We should probably do it
		 * the other way around, because the flex should account for the
		 * minwidth, but it's easier now to simply flex *again* with
		 * a new width (accounting for how much "too big" the table
		 * has now become). The variable `STRANGE_NUMBER` seems to make
		 * it work as expected, but not really sure why this is needed.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 * @param {number} width
		 * @param {Array<ts.ui.TableColModel>} cols
		 * @param {Array<HTMLTableCellElement>} ths
		 * @param {Array<HTMLTableCellElement>} tds
		 */
		_hflex3: function(spirit, model, width, cols, ths, tds) {
			if (model.rows.length) {
				var rows = spirit.queryplugin.getrows();
				var result = rows.scrollWidth;
				var STRANGE_NUMBER = 63; // strange number!
				if (result > width) {
					width = width - (result - width) - STRANGE_NUMBER;
					this._hflex1(spirit, model, width, cols, ths, tds);
				}
			}
		},

		/**
		 * Compute summed flex values.
		 * @param {Array<ts.ui.TableColModel} cols
		 * @returns {number}
		 */
		_hflextotal: function(cols) {
			return cols.reduce(function(sum, col) {
				return sum + col.flex;
			}, 0);
		},

		/**
		 * Compute width calc adjustment.
		 * @param {ts.ui.TableModel} model
		 * @returns {number}
		 */
		_hflexadjust: function(model) {
			var adjust = model.selectable ? UNIT_DOUBLE : 0;
			if (model.isWrapping() && model.maxrows) {
				adjust += Client.scrollBarSize;
			}
			return adjust;
		},

		// Vertical fix ............................................................

		/**
		 * Weirdly match the height of DIVS (inside cells) to the height of
		 * the containing row (tallest cell) because that's the only way we
		 * could figure out how to get the layout working with all the
		 * table-bugs in various browsers.
		 * @param {ts.ui.TableSpirit} spirit
		 * @param {ts.ui.TableModel} model
		 */
		_vfix: function(spirit, model) {
			var floats = spirit._floatgutter();
			var edits = model.editable;
			var plug = spirit.queryplugin;
			if (floats || edits) {
				this._vfix2(
					plug.getrows(true),
					plug.getguts(true),
					floats, edits
				);
			}
		},

		/**
		 * Classname will make all the cells `auto` height while
		 * we measure the natural dimensions of the table members.
		 * @param {HTMLDivElement} rows
		 * @param {HTMLDivElement} guts
		 * @param {boolean} floats
		 * @param {boolean} edits
		 */
		_vfix2: function(rows, guts, floats, edits) {
			var klass = 'ts-table-vfix';
			rows.css.add(klass);
			this._vfix3(rows, guts, floats, edits);
			rows.css.remove(klass);
		},

		/**
		 * Match cell height of "floating gutter" to the main (nonfloating) cells.
		 * Also, while editing, match height of all cells to the tallest cell so
		 * that the `textarea` can span the entire cell vertically. It has to work
		 * like that because you cannot dynamically set `focus` on touch devices.
		 * TODO: Fix the browser specific CSS in the CSS :/
		 * @param {HTMLDivElement} rows
		 * @param {HTMLDivElement} guts
		 * @param {boolean} floats
		 * @param {boolean} edits
		 */
		_vfix3: function(rows, guts, floats, edits) {
			rows = rows.dom.qall('tr');
			guts = floats ? guts.dom.qall('tr') : null;
			rows.map(function readheight(row, index) {
				var border = index ? 1 : (Client.isGecko ? 1 : 0);
				var height = getheight(row) - border;
				return height;
			}).forEach(function writeheight(height, index) {
				var row = rows[index];
				if (floats) {
					setheight(guts[index], height);
				}
				if (edits) {
					Array.forEach(row.cells, function(td) {
						setheight(td, height);
					});
				}
			});
		}

	});
}(gui.Client, gui.Tick));



/**
 * Tables GUI module.
 */
gui.module('tables-gui@tradeshift.com', {

	/**
	 * Channeling spirits to CSS selectors.
	 */
	channel: [
		['[data-ts=Table]', ts.ui.TableSpirit]
	],

	/**
	 * Setup some special plugins for the Table
	 * (to split the code up in smaller pieces).
	 */
	oncontextinitialize: function() {
		ts.ui.TableSpirit
			.plugin('editorplugin', ts.ui.TableEditPlugin)
			.plugin('layoutplugin', ts.ui.TableLayoutPlugin)
			.plugin('queryplugin', ts.ui.TableQueryPlugin);
	}

});

/*
 * Note: Just because this happens to be the last loaded bundle
 * Note: During "idle time", the browser was parsing other resources
 *			 (CSS and JS) and/or waiting for the DOMContentLoadeed event.
 * TODO: These kinds of "saga" measurements into seperate script files!
 */
gui.$stop('- parse runtime');
gui.$mark('- idle time ...');



}(self));
// src/runtime/edbml/functions/ts.ui.aside.edbml
edbml.declare("ts.ui.aside.edbml").as(function $edbml(aside
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set,
    $val = edbml.safeattr;
  var title = aside ? aside.title || '' : '';
  var $1 = $set(function(){
    return aside;
  }, this);
  out.html += '<aside data-ts="Aside" data-ts.title="' + $val(title) + '" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);">' +
              '<div data-ts="Panel"></div>' +
              '</aside>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.button.edbml
edbml.declare("ts.ui.button.edbml").as(function $edbml(button, isButtonMenu
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  $att['id'] = 'button' + button.$instanceid;
  $att['title'] = button.info || null;
  $att['class'] = button.type || '';
  $att['name'] = button.name || '';
  $att['value'] = button.value || '';
  $att['autofocus'] = button.autofocus ? 'autofocus' : null;
  $att['tabindex'] = button.tabindex === 0 || isButtonMenu ? null : button.tabindex;
  $att['disabled'] = button.disabled ? 'disabled' : null;
  $att['data-ts.type'] = button.action || null;
  $att['data-ts.data'] = button.data || null;
  $att['data-ts.busy'] = button.busystatus || null;
  var $1 = $set(function(){
    button.click();
  }, this);
  out.html += '<button data-ts="Button" ' + $att.$('name') + ' ' + $att.$('value') + ' ' + $att.$('title') + ' ' + $att.$('class') + ' ' + $att.$('id') + ' ' + $att.$('tabindex') + ' ' + $att.$('autofocus') + ' ' + $att.$('disabled') + ' ' + $att.$('data-ts.busy') + ' ' + $att.$('data-ts.type') + ' ' + $att.$('data-ts.data') + ' onclick="edbml.$run(this, \'' + $1 + '\');">';
  if (button.label) {
    out.html += '<span>' + $txt(button.label) + '</span>';
  } else if (isButtonMenu && button.info) {
    out.html += '<span>' + $txt(button.info) + '</span>';
  } else if (button.icon) {
    out.html += '<i class="' + $val(button.icon) + '"></i>';
  }
  out.html += '</button>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.buttons.edbml
edbml.declare("ts.ui.buttons.edbml").as(function $edbml(buttons
/**/){
  'use strict';
  var out = $edbml.$out;
  out.html += '<span class="ts-join">' +
              buttons.map(function(button){
    return button.render();
  }).join('');
  out.html += '</span>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.buttonsmenu.edbml
edbml.declare("ts.ui.buttonsmenu.edbml").as(function $edbml(menu
/**/){
  'use strict';
  var out = $edbml.$out,
    $val = edbml.safeattr;
  var id = menu.$instanceid;
  var buttons = menu.items;
  var isButtonMenu = true;
  if (buttons.length) {
    out.html += '<menu data-ts="Buttons" id="' + $val(id) + '-buttons">';
    buttons.forEach(function(button, index){
      out.html += '<li id="' + $val(id) + '-' + $val(index) + '">' +
                  button.render(isButtonMenu) +
                  '</li>';
    });
    out.html += '</menu>';
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.companycard.edbml
edbml.declare("ts.ui.companycard.edbml").as(function $edbml(card, contentonly, classconfig
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  var data = card.data;
  var mock = card.mock;
  var    // preloader...
    conn = card.$computeConnection();
  var bizz = card.$computeIndustry();
  var size = card.$computeSize();
  function renderContent() {
    $att['class'] = mock ? 'ts-mockup' : null;
    out.html += '<div ' + $att.$('class') + '>' +
                '<div class="ts-companycard-main">' +
                '<h3 class="ts-companycard-name">' +
                '<span>' + $txt(data.name || '') + '' +
                '</h3>' +
                '<ul class="ts-companycard-details">';
    if (data.location) {
      out.html += '<li class="ts-companycard-location">' +
                  '<i class="ts-icon ts-icon-location"></i>' +
                  '<span>' + $txt(data.location) + '</span>' +
                  '</li>';
    }
    if (bizz) {
      out.html += '<li class="ts-companycard-industry">' +
                  '<i class="ts-icon ts-icon-industry"></i>' +
                  '<span>' + $txt(bizz) + '</span>' +
                  '</li>';
    }
    if (size) {
      out.html += '<li class="ts-companycard-users">' +
                  '<i class="ts-icon ts-icon-users"></i>' +
                  '<span>' + $txt(size) + '</span>' +
                  '</li>';
    }
    out.html += '</ul>' +
                '</div>' +
                '<div class="ts-card-connection">';
    if (conn) {
      out.html += '<i class="ts-card-connection-icon ' + $val(conn.icon) + '"></i>' +
                  '<span class="ts-card-connectiont-ext">' + $txt(conn.text) + '</span>';
    }
    out.html += '</div>' +
                '<div class="ts-companycard-branding">';
    if (data.logo) {
      out.html += '<img class="ts-companycard-logo" src="' + $val(data.logo) + '" width="88" alt=""/>';
    }
    out.html += '</div>' +
                '</div>';
  }
  if (contentonly) {
    renderContent();
  } else {
    $att['class'] = card.type || null;
    var $1 = $set(function(){
      return card;
    }, this);
    out.html += '<div data-ts="CompanyCard" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);" ' + $att.$('class') + '></div>';
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.datepicker.edbml
edbml.declare("ts.ui.datepicker.edbml").as(function $edbml(picker
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set;
  var $1 = $set(function(){
    return picker;
  }, this);
  out.html += '<div data-ts="Calendar" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);"></div>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.form.edbml
edbml.declare("ts.ui.form.edbml").as(function $edbml(form
/**/){
  'use strict';
  var out = $edbml.$out;
  out.html += '<form data-ts="Form">';
  if (form) {
    if (form.items.getLength()) {
      out.html += form.items.render();
    }
    if (form.buttons.getLength()) {
      out.html += form.buttons.render();
    }
  }
  out.html += '</form>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.icononly.edbml
edbml.declare("ts.ui.icononly.edbml").as(function $edbml(icon
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att;
  $att['class'] = icon.type;
  if (icon.color && !$att['class'].includes('ts-color-')) {
    var color = ts.ui.COLORS[icon.color];
    if (color) {
      $att['class'] += ' ' + color;
    } else {
      throw new Error('The color "' + '" does is not defined');
    }
  }
  out.html += '<i ' + $att.$('class') + '></i>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.image.edbml
edbml.declare("ts.ui.image.edbml").as(function $edbml(image
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr;
  $att['src'] = image.background ? ts.ui.ImageModel.BLANK : image.src;
  $att['style'] = image.background ? 'background-image:url("' + image.src + '")' : null;
  $att['alt'] = image.alt || null;
  out.html += '<img class="ts-image" ' + $att.$('src') + ' ' + $att.$('alt') + ' ' + $att.$('style') + ' id="' + $val(image.$instanceid) + '" width="' + $val(image.width) + '" height="' + $val(image.height) + '"/>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.input.edbml
edbml.declare("ts.ui.input.edbml").as(function $edbml(input
/**/){
  'use strict';
  var out = $edbml.$out,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  var id = input.$instanceid;
  out.html += '<fieldset id="ts-group-' + $val(id) + '">' +
              '<label data-ts="Label" id="ts-label-' + $val(id) + '">' +
              '<span>' + $txt(input.label) + '</span>' +
              ts.ui.inputonly.edbml(input) +
              '</label>' +
              '</fieldset>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.inputonly.edbml
edbml.declare("ts.ui.inputonly.edbml").as(function $edbml(input
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  $att['class'] = input.validity.valid ? null : 'ts-error';
  $att['id'] = 'ts-field-' + input.$instanceid;
  $att['readonly'] = input.readonly ? 'readonly' : null;
  $att['disabled'] = input.disabled ? 'disabled' : null;
  $att['autofocus'] = input.autofocus ? 'autofocus' : null;
  $att['required'] = input.required ? 'required' : null;
  $att['placeholder'] = input.placeholder || null;
  if (ts.ui.TextAreaModel.is(input)) {
    var $1 = $set(function(){
      return input;
    }, this);
    out.html += '<textarea data-ts="TextArea" ' + $att.$('id') + ' rows="' + $val(input.rows) + '" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);" data-ts.entershift="' + $val(input.entershift) + '" ' + $att.$('readonly') + ' ' + $att.$('disabled') + ' ' + $att.$('autofocus') + ' ' + $att.$('required') + ' ' + $att.$('placeholder') + ' data-ts.idletime="' + $val(input.idletime) + '">' + $txt(input.value) + '</textarea>';
  } else {
    var $2 = $set(function(){
      return input;
    }, this);
    out.html += '<input data-ts="Input" ' + $att.$('id') + ' value="' + $val(input.value) + '" data-ts._model="edbml.$get(&quot;' + $2 + '&quot;);" ' + $att.$('readonly') + ' ' + $att.$('disabled') + ' ' + $att.$('autofocus') + ' ' + $att.$('required') + ' ' + $att.$('placeholder') + ' data-ts.idletime="' + $val(input.idletime) + '"/>';
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.menu.edbml
edbml.declare("ts.ui.menu.edbml").as(function $edbml(menu
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  menu.random;
  var id = menu.$instanceid;
  var index = menu.selectedIndex;
  var indxs = menu.selectedIndexes;
  var shown = menu.maxItemsShown;
  var items = prepareItems(menu.items);
  var minis = minimumItems(items, shown);
  renderSearch(false);
  if ( // search will probably move to Aside toolbar!
    items.length) {
    var isoptimizing = shown > -1;
    $att['style'] = getinlinestyle(isoptimizing);
    var $1 = $set(function(){
      return menu;
    }, this);
    out.html += '<menu data-ts="Menu" id="' + $val(id) + '-menu" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);" ' + $att.$('style') + ' tempname>';
    minis.forEach(renderItem);
    out.html += '</menu>';
    renderDoneButton(menu);
  }
  function prepareItems(items$2) {
    return items$2.map(function(item, i){
      item.index = i;
      return item;
    }).filter(function(item, i){
      return item.visible !== false;
    });
  }
  function minimumItems(items$2, shown$2) {
    var start,
      stops,
      length = items$2.length;
    if (shown$2 > -1) {
      start = index > shown$2 - 1 ? index : 0;
      stops = shown$2 + start;
      stops = stops > length - 1 ? length : stops;
      start = stops - index < shown$2 ? stops - shown$2 : start;
      return items$2.slice(start, stops);
    }
    return items$2;
  }
  function renderItem(item) {
    var selected = isSelected(item);
    $att['disabled'] = item.disabled ? 'disabled' : null;
    $att['class'] = selected ? 'ts-checked' : null;
    out.html += '<li id="' + $val(id) + '-' + $val(item.index) + '" ' + $att.$('class') + '>' +
                '<button ' + $att.$('disabled') + '>';
    if (item.icon && !item.reverse) {
      out.html += '<i class="' + $val(item.icon) + '"></i>';
    }
    if (item.label) {
      out.html += '<span>' + $txt(item.label) + '</span>';
    }
    if (item.icon && item.reverse) {
      out.html += '<i class="' + $val(item.icon) + '"></i>';
    }
    if (selected) {
      out.html += '<i class="ts-icon-checked"></i>';
    }
    out.html += '</button>' +
                '</li>';
  }
  function isSelected(item) {
    switch(    menu.select){
    case 'one':
    return item.index === index;
    case 'many':
    return indxs.indexOf(item.index) > -1;
}
  }
  function renderSearch(enabled) {
    if (enabled) {
      out.html += '<form data-ts="Form" id="' + $val(id) + '-form">' +
                  menu._searchmodel.render() +
                  '</form>';
    }
  }
  function getinlinestyle(optimized) {
    if (optimized) {
      var yspan = 44;
      var total = items.length;
      var start = minis[0].index;
      menu.scrollContainingPanel(start * yspan);
      return declarations(total, start, yspan);
    }
    return null;
  }
  function declarations(total, start, yspan) {
    return [
  'padding-top:' + start * yspan + 'px;',
  'height:' + total * yspan + 'px;'
].join('');
  }
  function renderDoneButton(menu$2) {
    if (menu$2.select === 'many') {
      out.html += '<menu data-ts="Buttons">' +
                  '<li>';
      $att['disabled'] = menu$2.donebuttonenabled ? null : 'disabled';
      var $2 = $set(function(){
        menu$2.done();
      }, this);
      out.html += '<button ' + $att.$('disabled') + ' id="' + $val(id) + '-button" class="ts-primary" onclick="edbml.$run(this, \'' + $2 + '\');">' +
                  '<span>' + $txt(menu$2.donebuttonlabel) + '</span>' +
                  '</button>' +
                  '</li>' +
                  '</menu>';
    }
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.pager.edbml
edbml.declare("ts.ui.pager.edbml").as(function $edbml(pager
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set,
    $val = edbml.safeattr;
  var $1 = $set(function(){
    return pager;
  }, this);
  out.html += '<div data-ts="Pager" id="' + $val(pager.$instanceid) + '" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);"></div>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.search.edbml
edbml.declare("ts.ui.search.edbml").as(function $edbml(search
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set;
  $att['class'] = search.inset ? 'ts-inset' : null;
  var $1 = $set(function(){
    return search;
  }, this);
  out.html += '<span data-ts="Search" ' + $att.$('class') + ' data-ts.model="edbml.$get(&quot;' + $1 + '&quot;);"></span>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.select.edbml
edbml.declare("ts.ui.select.edbml").as(function $edbml(select
/**/){
  'use strict';
  var out = $edbml.$out,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  out.html += '<select id="' + $val(select.$instanceid) + '">';
  select.options.forEach(function(option){
    out.html += '<option value="' + $val(option.value) + '">' + $txt(option.text) + '</option>';
  });
  out.html += '</select>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.statusbar.edbml
edbml.declare("ts.ui.statusbar.edbml").as(function $edbml(statusbar
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set;
  var $1 = $set(function(){
    return statusbar;
  }, this);
  out.html += '<footer data-ts="StatusBar" data-ts.model="edbml.$get(&quot;' + $1 + '&quot;);"></header>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.svgicons.edbml
edbml.declare("ts.ui.svgicons.edbml").as(function $edbml(icon, size
/**/){
  'use strict';
  var out = $edbml.$out,
    $val = edbml.safeattr;
  size = size || 22;
  out.html += '<svg class="ts-svg-' + $val(icon) + '" xmlns="http://www.w3.org/2000/svg" width="' + $val(size) + '" height="' + $val(size) + '" lineHeight="' + $val(size) + '" viewBox="0 0 24 24">';
  switch(icon){
  case 'fast-forward':
  out.html += '<path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/>';
  break;
  case 'fast-rewind':
  out.html += '<path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>';
  break;
  case 'skip-next':
  out.html += '<path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>';
  break;
  case 'skip-previous':
  out.html += '<path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>';
  break;
  case 'checked':
  case 'accept':
  case 'done':
  case 'approve':
  case 'appactive':
  out.html += '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/>';
  break;
  case 'logo-t1':
  out.html += '<path d="M1.148 9.035v-1.98q0-0.246 0.281-0.246h8.074q0.27 0 0.27 0.246v11.883q0 0.258-0.27 0.258h-2.883q-0.129 0-0.205-0.070t-0.076-0.188v-9.645h-4.91q-0.281 0-0.281-0.258z"></path>';
  break;
  case 'logo-t2':
  out.html += '<path d="M1.148 18.938v-11.883q0-0.246 0.281-0.246h8.063q0.281 0 0.281 0.246v1.98q0 0.258-0.281 0.258h-4.898v9.645q0 0.117-0.076 0.188t-0.205 0.070h-2.883q-0.129 0-0.205-0.070t-0.076-0.188z"></path>';
  break;
  case 'logo-shift':
  out.html += '<path d="M0.762 10.723q0-1.922 1.23-3.012t3.691-1.090q1.664 0 4.008 0.586 0.469 0.141 0.375 0.516l-0.34 1.582q-0.094 0.387-0.375 0.305-2.355-0.504-3.434-0.504h-0.129q-1.688 0.059-1.688 1.254 0 0.281 0.111 0.492t0.275 0.334 0.475 0.217 0.568 0.141 0.691 0.117q0.211 0.035 0.316 0.047 0.492 0.082 0.814 0.146t0.773 0.205 0.75 0.311 0.627 0.469 0.516 0.668 0.316 0.908 0.129 1.195q0 0.832-0.258 1.482t-0.697 1.072-1.061 0.697-1.307 0.393-1.482 0.117q-1.055 0-2.139-0.146t-1.594-0.27-0.756-0.205q-0.293-0.105-0.293-0.41v-0.082l0.246-1.453q0.047-0.305 0.293-0.305 0.047 0 0.211 0.023 0.035 0.012 0.352 0.088t0.627 0.146 0.732 0.152 0.867 0.129 0.832 0.047q0.996 0 1.5-0.275t0.504-0.99q0-0.188-0.029-0.34t-0.123-0.27-0.158-0.205-0.246-0.164-0.275-0.123-0.346-0.1-0.357-0.070-0.416-0.070-0.428-0.076q-0.609-0.105-1.043-0.217t-1.020-0.381-0.949-0.633-0.627-0.996-0.264-1.453zM12.070 18.949v-11.895q0-0.246 0.27-0.246h2.777q0.281 0 0.281 0.246v4.781h4.148v-4.781q0-0.246 0.258-0.246h2.789q0.281 0 0.281 0.246v11.895q0 0.246-0.281 0.246h-2.789q-0.281 0-0.281-0.246v-4.758h-4.125v4.758q0 0.246-0.258 0.246h-2.789q-0.281 0-0.281-0.246zM25.254 18.949v-11.895q0-0.246 0.258-0.246h2.789q0.281 0 0.281 0.246v11.895q0 0.246-0.27 0.246h-2.777q-0.281 0-0.281-0.246zM30.961 18.938v-11.871q0-0.117 0.082-0.188t0.211-0.070h7.934q0.281 0 0.281 0.246v1.992q0 0.105-0.082 0.176t-0.199 0.070h-4.91v2.543h4.137q0.281 0 0.281 0.246v1.852q0 0.246-0.281 0.246h-4.137v4.758q0 0.117-0.082 0.188t-0.211 0.070h-2.73q-0.129 0-0.211-0.070t-0.082-0.188zM41.039 18.949v-11.895q0-0.246 0.281-0.246h8.074q0.281 0 0.281 0.246v1.992q0 0.105-0.082 0.176t-0.199 0.070h-4.91v9.656q0 0.246-0.281 0.246h-2.883q-0.281 0-0.281-0.246z"></path>';
  break;
  case 'logo-trade':
  out.html += '<path d="M0.621 9.035v-1.98q0-0.246 0.281-0.246h8.063q0.281 0 0.281 0.246v11.883q0 0.246-0.281 0.246h-2.871q-0.281 0-0.281-0.246v-9.645h-4.91q-0.281 0-0.281-0.258zM11.637 18.938v-11.871q0-0.117 0.082-0.193t0.211-0.076h5.625q2.414 0 3.48 0.926t1.066 2.672q0 0.551-0.105 0.979t-0.369 0.838-0.779 0.686-1.266 0.404l-0.082 0.012q-0.188 0.012-0.188 0.188 0 0.199 0.164 0.199 0.129 0 0.258 0.088t0.188 0.182l0.070 0.094 2.637 3.574 3.305-10.641q0.059-0.199 0.281-0.199h4.898q0.223 0 0.281 0.199l3.68 11.93 0.023 0.047q0 0.094-0.076 0.152t-0.193 0.059h-2.859q-0.117 0-0.223-0.088t-0.129-0.205l-0.492-1.828h-4.969l-0.492 1.863q-0.059 0.258-0.316 0.258h-4.992q-0.293 0-0.387-0.164l-3-4.254h-2.016v4.172q0 0.246-0.258 0.246h-2.777q-0.281 0-0.281-0.246zM14.965 12.715h1.91q0.949 0 1.395-0.357t0.445-1.33q0-0.961-0.398-1.336t-1.301-0.398h-2.051v3.422zM26.766 14.766h3.75l-1.465-5.473h-0.832zM35.813 18.926v-11.859q0-0.117 0.076-0.193t0.193-0.076h5.484q1.336 0 2.32 0.299t1.6 0.814 0.984 1.313 0.51 1.664 0.141 1.992q0 1.207-0.141 2.121t-0.516 1.729-0.99 1.336-1.6 0.82-2.309 0.299h-5.484q-0.117 0-0.193-0.070t-0.076-0.188zM39.141 17.004h2.086q1.488 0 1.986-0.785t0.498-3.035q0-1.535-0.258-2.391t-0.732-1.178-1.283-0.322h-2.297v7.711zM48.586 18.926v-11.859q0-0.117 0.088-0.193t0.217-0.076h8.332q0.27 0 0.27 0.246v2.004q0 0.246-0.27 0.246h-5.309v2.543h5.051q0.281 0 0.281 0.223v1.875q0 0.246-0.281 0.246h-5.051v2.672h5.32q0.258 0 0.258 0.246v1.84q0 0.258-0.258 0.258h-8.344q-0.129 0-0.217-0.076t-0.088-0.193z"></path>';
  break;
  case 'back':
  out.html += '<path d="M21 11H6.83l3.58-3.59L9 6l-6 6 6 6 1.41-1.41L6.83 13H21z"/>';
  break;
  case 'discovery':
  out.html += '<path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"/>';
  break;
  case 'insertfrominventory':
  out.html += '<path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 14H6v-2h2v2zm0-3H6V9h2v2zm0-3H6V6h2v2zm7 6h-5v-2h5v2zm3-3h-8V9h8v2zm0-3h-8V6h8v2z"/>';
  break;
  case 'preview':
  out.html += '<path d="M11.5 9C10.12 9 9 10.12 9 11.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5S12.88 9 11.5 9zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-3.21 14.21l-2.91-2.91c-.69.44-1.51.7-2.39.7C9.01 16 7 13.99 7 11.5S9.01 7 11.5 7 16 9.01 16 11.5c0 .88-.26 1.69-.7 2.39l2.91 2.9-1.42 1.42z"/>';
  break;
  case 'split':
  out.html += '<path d="M19.707,10.707L23.414,7l-3.707-3.707l-1.414,1.414L19.586,6H17c-3.905,0-4.943,1.489-5.858,2.803 C10.32,9.982,9.611,11,6,11H0v2h6c3.611,0,4.32,1.018,5.142,2.197C12.057,16.511,13.095,18,17,18h2.586l-1.293,1.293l1.414,1.414 L23.414,17l-3.707-3.707l-1.414,1.414L19.586,16H17c-2.861,0-3.43-0.816-4.217-1.946c-0.479-0.687-1.016-1.458-2.029-2.054 c1.014-0.596,1.551-1.367,2.029-2.054C13.57,8.816,14.139,8,17,8h2.586l-1.293,1.293L19.707,10.707z"/>';
  break;
  case 'activity':
  out.html += '<g>' +
              '<polygon points="12.067,21.959 7.012,8.815 4.693,14.999 0,14.999 0,12.999 3.307,12.999 6.988,3.183 11.933,16.039 14.815,7.393 17.618,12.999 24,12.999 24,14.999 16.382,14.999 15.185,12.605 \t\t"/>' +
              '</g>';
  break;
  case 'broadcastmessage':
  out.html += '<path d="M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5S9.5 10.62 9.5 12c0 1.02.62 1.9 1.5 2.29v3.3L7.59 21 9 22.41l3-3 3 3L16.41 21 13 17.59v-3.3zM12 1C5.93 1 1 5.93 1 12h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z"/>';
  break;
  case 'dispute':
  out.html += '<path d="M23.885,12.558l0.01-0.005L20.618,6H22V4h-9V2h-2v2H2v2h1.382l-3.276,6.553l0.01,0.005 C0.047,12.692,0,12.839,0,13c0,2.757,2.243,5,5,5s5-2.243,5-5c0-0.161-0.047-0.308-0.115-0.442l0.01-0.005L6.618,6H11v14H8v2h8v-2 h-3V6h4.382l-3.276,6.553l0.01,0.005C14.047,12.692,14,12.839,14,13c0,2.757,2.243,5,5,5s5-2.243,5-5 C24,12.839,23.953,12.692,23.885,12.558z M5,7.236L7.382,12H2.618L5,7.236z M5,16c-1.304,0-2.416-0.836-2.828-2h5.656 C7.416,15.164,6.304,16,5,16z M21.382,12h-4.764L19,7.236L21.382,12z M19,16c-1.304,0-2.416-0.836-2.828-2h5.656 C21.416,15.164,20.304,16,19,16z"/>';
  break;
  case 'location':
  out.html += '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>';
  break;
  case 'previously-requested':
  out.html += '<path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>';
  break;
  case 'statuschange':
  out.html += '<path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>';
  break;
  case 'add':
  case 'appactivate':
  out.html += '<path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>';
  break;
  case 'cancel':
  case 'reject':
  out.html += '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"/>';
  break;
  case 'document':
  out.html += '<path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/>';
  break;
  case 'locked':
  out.html += '<path d="M17,11V7c0-2.757-2.244-5-5-5C9.242,2,7,4.243,7,7v4c-1.103,0-2,0.896-2,2v7c0,1.103,0.897,2,2,2h10 c1.103,0,2-0.897,2-2v-7C19,11.896,18.103,11,17,11z M12,18c-0.828,0-1.5-0.672-1.5-1.5S11.172,15,12,15s1.5,0.672,1.5,1.5 S12.828,18,12,18z M15,11H9V7c0-1.654,1.346-3,3-3s3,1.346,3,3V11z"/>';
  break;
  case 'proceed':
  out.html += '<path d="M12 8V4l8 8-8 8v-4H4V8z"/>';
  break;
  case 'support':
  out.html += '<path d="M18.002,0.005c-3.309,0-6,2.693-6,6c0,3.309,2.691,6,6,6c3.308,0,6-2.691,6-6 C24.002,2.698,21.31,0.005,18.002,0.005z M19.002,10.006h-2v-4h2V10.006z M19.002,4.006c0,0.553-0.447,1-1,1c-0.553,0-1-0.447-1-1 c0-0.553,0.447-1,1-1C18.555,3.006,19.002,3.453,19.002,4.006z"/>' +
              '<path d="M6.3,12.198c1.003-0.485,1.702-1.505,1.702-2.692c0-1.654-1.346-3-3-3s-3,1.346-3,3 c0,1.188,0.699,2.207,1.702,2.692c-2.126,0.576-3.702,2.503-3.702,4.808v2c0,0.553,0.447,1,1,1h1v3c0,0.553,0.447,1,1,1h4 c0.553,0,1-0.447,1-1v-3h1c0.553,0,1-0.447,1-1v-2C10.002,14.701,8.426,12.774,6.3,12.198z"/>' +
              '<path d="M15.756,18.429c0.752-0.546,1.246-1.425,1.246-2.423c0-1.654-1.346-3-3-3s-3,1.346-3,3 c0,0.998,0.494,1.877,1.246,2.423c-1.324,0.652-2.246,2.004-2.246,3.577v1c0,0.553,0.447,1,1,1h6c0.553,0,1-0.447,1-1v-1 C18.002,20.433,17.081,19.081,15.756,18.429z"/>';
  break;
  case 'add-to-archive':
  out.html += '<path d="M13,18H6V2h10v11h2V1c0-0.552-0.447-1-1-1H1C0.447,0,0,0.449,0,1v18c0,0.552,0.447,1,1,1h12V18z M4,18H2V2h2V18z"/>' +
              '<polygon points="23,18 20,18 20,15 18,15 18,18 15,18 15,20 18,20 18,23 20,23 20,20 23,20 \t\t"/>';
  break;
  case 'cart':
  case 'purchases':
  out.html += '<path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"/>';
  break;
  case 'timer':
  out.html += '<path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>' +
              '<path d="M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"/>';
  break;
  case 'addfield':
  out.html += '<path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>';
  break;
  case 'categories':
  out.html += '<path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/>';
  break;
  case 'download':
  out.html += '<path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>';
  break;
  case 'radio':
  out.html += '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>';
  break;
  case 'todo':
  out.html += '<path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/>';
  break;
  case 'addfilter':
  out.html += '<path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/>';
  break;
  case 'checkbox':
  out.html += '<path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>';
  break;
  case 'drafts':
  out.html += '<path d="M12,16.001c-2.205,0-4-1.794-4-4s1.795-4,4-4s4,1.794,4,4S14.205,16.001,12,16.001z M12,10.001 c-1.104,0-2,0.898-2,2c0,1.103,0.896,2,2,2s2-0.897,2-2C14,10.899,13.104,10.001,12,10.001z"/>' +
              '<path d="M12.165,23.046l-0.209-1.989l0.995-0.105c0.625-0.066,1.243-0.197,1.838-0.391l0.951-0.309 l0.619,1.901l-0.951,0.31c-0.728,0.237-1.484,0.397-2.248,0.478L12.165,23.046z M9.564,22.778L8.613,22.47 c-0.729-0.236-1.436-0.55-2.102-0.934l-0.867-0.499l0.998-1.733l0.867,0.499c0.545,0.314,1.123,0.571,1.719,0.764l0.951,0.307 L9.564,22.778z M18.622,20.842l-1.339-1.486l0.742-0.669c0.467-0.42,0.891-0.891,1.26-1.398l0.588-0.81l1.617,1.177 l-0.588,0.809c-0.451,0.62-0.969,1.194-1.537,1.708L18.622,20.842z M3.701,19.291l-0.59-0.808 c-0.453-0.621-0.842-1.29-1.154-1.988l-0.409-0.912l1.825-0.818l0.408,0.914c0.256,0.571,0.574,1.118,0.945,1.625l0.59,0.807 L3.701,19.291z M22.556,15.265l-1.957-0.414l0.206-0.978C20.935,13.262,21,12.631,21,12.001v-1l2-0.041v1.012 c0,0.798-0.08,1.566-0.238,2.314L22.556,15.265z M1,13.022v-1.001c0-0.78,0.078-1.541,0.232-2.282L1.438,8.76l1.957,0.409 l-0.203,0.979C3.064,10.754,3,11.378,3,12.001v1L1,13.022z M20.621,9.22L20.21,8.309c-0.257-0.57-0.575-1.116-0.947-1.624 l-0.591-0.807l1.613-1.183l0.591,0.807c0.454,0.62,0.845,1.289,1.158,1.985l0.41,0.912L20.621,9.22z M4.117,7.54L2.498,6.367 l0.586-0.81c0.45-0.621,0.967-1.196,1.534-1.71l0.741-0.671l1.343,1.483L5.961,5.329C5.496,5.75,5.072,6.222,4.705,6.73 L4.117,7.54z M17.34,4.688L16.473,4.19c-0.543-0.313-1.121-0.567-1.719-0.76l-0.952-0.306l0.611-1.904l0.952,0.306 c0.73,0.235,1.438,0.548,2.104,0.93l0.867,0.498L17.34,4.688z M8.243,3.759l-0.623-1.9l0.95-0.312 c0.728-0.239,1.484-0.401,2.248-0.483l0.994-0.106l0.213,1.989l-0.994,0.107c-0.625,0.067-1.244,0.199-1.838,0.394L8.243,3.759z"/>';
  break;
  case 'logout':
  out.html += '<path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"/>';
  break;
  case 'radioon':
  out.html += '<path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>';
  break;
  case 'alldocuments':
  out.html += '<path d="M17.414,0H10C8.897,0,8,0.898,8,2v14c0,1.103,0.897,2,2,2h10c1.103,0,2-0.897,2-2V4.586L17.414,0z M20.001,16H10V2h6v4h4L20.001,16z"/>' +
              '<path d="M7,3H5v16c0,1.103,0.897,2,2,2h12v-2H7V3z"/>' +
              '<path d="M4,6H2v16c0,1.103,0.897,2,2,2h12v-2H4V6z"/>';
  break;
  case 'checkboxon':
  out.html += '<path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>';
  break;
  case 'edit':
  out.html += '<path d="M20.822,3.179C20.062,2.419,19.051,2,17.976,2S15.89,2.418,15.13,3.179l-9.983,9.982 c-0.391,0.391-0.391,1.024,0,1.414l0.104,0.104l-1.733,0.347c-0.417,0.084-0.734,0.42-0.794,0.84l-0.712,4.991 c-0.045,0.311,0.06,0.625,0.282,0.847c0.223,0.223,0.537,0.329,0.849,0.283l4.991-0.713c0.42-0.059,0.756-0.377,0.84-0.793 l0.347-1.733l0.104,0.104c0.391,0.392,1.023,0.392,1.414,0l9.983-9.982C21.581,8.11,22,7.1,22,6.024s-0.419-2.086-1.179-2.847 L20.822,3.179z M16.538,4.599l0.005-0.006c0.765-0.764,2.1-0.765,2.864,0c0.764,0.764,0.764,2.099,0,2.864l-0.006,0.005 L16.538,4.599z M7.151,19.397L4.179,19.82l0.424-2.971l2.348-0.469l0.669,0.669L7.151,19.397z M10.132,16.733l-2.863-2.864 l7.855-7.856l2.863,2.864L10.132,16.733z"/>';
  break;
  case 'menuswitch':
  out.html += '<path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>';
  break;
  case 'rating':
  case 'followed':
  out.html += '<path d="M21.924,8.618C21.77,8.245,21.404,8.001,21,8.001h-5.382l-2.724-5.447c-0.339-0.677-1.45-0.677-1.789,0 L8.382,8.001H3c-0.404,0-0.77,0.244-0.924,0.617c-0.154,0.373-0.069,0.805,0.217,1.09l4.584,4.584l-1.838,6.435 c-0.115,0.403,0.033,0.835,0.371,1.082c0.34,0.248,0.797,0.257,1.144,0.024L12,18.203l5.445,3.63 c0.168,0.112,0.361,0.168,0.555,0.168c0.207,0,0.414-0.064,0.59-0.192c0.338-0.247,0.486-0.679,0.371-1.082l-1.838-6.435 l4.584-4.584C21.993,9.423,22.078,8.991,21.924,8.618z"/>';
  break;
  case 'triangledown':
  case 'triangleleft':
  case 'triangleright':
  case 'showpicker':
  out.html += '<path d="M7 10l5 5 5-5z"/>';
  break;
  case 'triangleup':
  out.html += '<path d="M7 14l5-5 5 5z"/>';
  break;
  case 'error':
  case 'warning':
  out.html += '<path d="M21.895,20.553l-9-18c-0.339-0.677-1.45-0.677-1.789,0l-9,18c-0.154,0.31-0.139,0.677,0.044,0.974 C2.332,21.821,2.653,22,3,22h18c0.347,0,0.668-0.18,0.851-0.474C22.033,21.23,22.049,20.864,21.895,20.553z M11,10h2v6h-2V10z M12,19.25c-0.69,0-1.25-0.559-1.25-1.25c0-0.69,0.56-1.25,1.25-1.25s1.25,0.56,1.25,1.25C13.25,18.691,12.69,19.25,12,19.25z"/>';
  break;
  case 'merge':
  out.html += '<path d="M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z"/>';
  break;
  case 'checked-alt':
  out.html += '<path d="M12.042,2c-5.523,0-10,4.477-10,10s4.477,10,10,10s10-4.477,10-10S17.564,2,12.042,2z M11.292,17.75 l-5-3.75l1.5-2l3,2.25l5.25-7l2,1.5L11.292,17.75z"/>';
  break;
  case 'favorites':
  case 'heart':
  out.html += '<path d="M16,4.001c-1.594,0-3.07,0.837-4,2.08c-0.93-1.243-2.406-2.08-4-2.08c-2.757,0-5,2.243-5,5 c0,5.491,8.124,10.632,8.471,10.848c0.162,0.101,0.346,0.152,0.529,0.152s0.367-0.051,0.529-0.152 C12.876,19.633,21,14.492,21,9.001C21,6.244,18.757,4.001,16,4.001z"/>';
  break;
  case 'more':
  out.html += '<path d="M12,2.001c-5.514,0-10,4.486-10,10s4.486,10,10,10s10-4.486,10-10S17.514,2.001,12,2.001z M17,13.001h-4v4 h-2v-4H7v-2h4v-4h2v4h4V13.001z"/>';
  break;
  case 'remove':
  out.html += '<path d="M12,2.001c-5.514,0-10,4.486-10,10s4.486,10,10,10s10-4.486,10-10S17.514,2.001,12,2.001z M16.707,15.294 l-1.414,1.414L12,13.415l-3.293,3.293l-1.414-1.414l3.293-3.293L7.293,8.708l1.414-1.414L12,10.587l3.293-3.293l1.414,1.414 l-3.293,3.293L16.707,15.294z"/>';
  break;
  case 'close':
  out.html += '<g>' +
              '<polygon points="21.456,5.414 18.627,2.586 12.042,9.172 5.456,2.586 2.627,5.414 9.213,12 2.627,18.586 5.456,21.414 12.042,14.828 18.627,21.414 21.456,18.586 14.87,12 \t"/>' +
              '</g>';
  break;
  case 'fileaccess':
  out.html += '<path d="M9,12c0-1,1-1,1-1h8.736C19.53,9.865,20,8.487,20,7c0-3.859-3.141-7-7-7c-2.51,0-4.74,1.31-5.978,3.357 C7.987,3.815,9.018,4.62,9.992,6.004L9.175,6.58C7.678,4.454,6.393,4,5,4C2.243,4,0,6.243,0,9c0,2.757,2.243,5,5,5h4 C9,12.981,9,12.228,9,12z"/>' +
              '<path d="M23,15h-5.586l-1.707-1.707C15.519,13.106,15.266,13,15,13h-3c-0.553,0-1,0.447-1,1v9c0,0.553,0.447,1,1,1 h11c0.553,0,1-0.447,1-1v-7C24,15.447,23.553,15,23,15z"/>';
  break;
  case 'myapps':
  out.html += '<path d="M20,19.999h-4v2h4c1.103,0,2-0.897,2-2v-4h-2V19.999z"/>' +
              '<path d="M20,1.999h-4v2h4v4h2v-4C22,2.896,21.103,1.999,20,1.999z"/>' +
              '<path d="M2,3.999v4h2v-4h4v-2H4C2.897,1.999,2,2.896,2,3.999z"/>' +
              '<path d="M4,15.999H2v4c0,1.103,0.897,2,2,2h4v-2H4V15.999z"/>' +
              '<rect x="10" y="15.999" width="4" height="4"/>' +
              '<rect x="10" y="9.999" width="4" height="4"/>' +
              '<rect x="4" y="9.999" width="4" height="4"/>' +
              '<rect x="16" y="9.999" width="4" height="4"/>' +
              '<rect x="10" y="3.999" width="4" height="4"/>';
  break;
  case 'reset':
  out.html += '<g>' +
              '<polygon points="11,8 11,14 15,14 15,12 13,12 13,8 \t\t"/>' +
              '<path d="M12,2C9.285,2,6.779,3.089,4.938,4.938L3,3v6h6L6.351,6.351C7.824,4.871,9.828,4,12,4 c4.411,0,8,3.589,8,8s-3.589,8-8,8v2c5.514,0,10-4.485,10-10S17.514,2,12,2z"/>' +
              '</g>';
  break;
  case 'unfollowed':
  out.html += '<path d="M18,22.001c-0.193,0-0.387-0.056-0.555-0.168L12,18.203l-5.445,3.63 c-0.348,0.232-0.805,0.224-1.145-0.024c-0.338-0.247-0.486-0.679-0.371-1.082l1.838-6.435L2.293,9.708 c-0.286-0.285-0.371-0.716-0.217-1.09C2.23,8.245,2.596,8.001,3,8.001h5.382l2.724-5.447c0.339-0.677,1.45-0.677,1.789,0 l2.724,5.447H21c0.404,0,0.77,0.244,0.924,0.617c0.154,0.374,0.069,0.805-0.217,1.09l-4.584,4.584l1.838,6.435 c0.115,0.403-0.033,0.835-0.371,1.082C18.414,21.937,18.207,22.001,18,22.001z M12,16.001c0.193,0,0.387,0.057,0.555,0.168 l3.736,2.491l-1.252-4.384c-0.101-0.35-0.003-0.726,0.254-0.982l3.293-3.293H15c-0.379,0-0.725-0.214-0.895-0.553L12,5.237 L9.895,9.448C9.725,9.787,9.379,10.001,9,10.001H5.414l3.293,3.293c0.257,0.257,0.354,0.633,0.254,0.982L7.709,18.66l3.736-2.491 C11.613,16.058,11.807,16.001,12,16.001z"/>';
  break;
  case 'apps':
  out.html += '<path d="M6,2.001H4c-1.103,0-2,0.898-2,2v2c0,1.102,0.897,2,2,2h2c1.103,0,2-0.898,2-2v-2 C8,2.899,7.103,2.001,6,2.001z"/>' +
              '<path d="M6,9.001H4c-1.103,0-2,0.898-2,2v2c0,1.102,0.897,2,2,2h2c1.103,0,2-0.898,2-2v-2 C8,9.899,7.103,9.001,6,9.001z"/>' +
              '<path d="M6,16.001H4c-1.103,0-2,0.898-2,2v2c0,1.103,0.897,2,2,2h2c1.103,0,2-0.897,2-2v-2 C8,16.899,7.103,16.001,6,16.001z"/>' +
              '<path d="M13,2.001h-2c-1.104,0-2,0.898-2,2v2c0,1.102,0.896,2,2,2h2c1.104,0,2-0.898,2-2v-2 C15,2.899,14.104,2.001,13,2.001z"/>' +
              '<path d="M13,9.001h-2c-1.104,0-2,0.898-2,2v2c0,1.102,0.896,2,2,2h2c1.104,0,2-0.898,2-2v-2 C15,9.899,14.104,9.001,13,9.001z"/>' +
              '<path d="M13,16.001h-2c-1.104,0-2,0.898-2,2v2c0,1.103,0.896,2,2,2h2c1.104,0,2-0.897,2-2v-2 C15,16.899,14.104,16.001,13,16.001z"/>' +
              '<path d="M20,2.001h-2c-1.104,0-2,0.898-2,2v2c0,1.102,0.896,2,2,2h2c1.104,0,2-0.898,2-2v-2 C22,2.899,21.104,2.001,20,2.001z"/>' +
              '<path d="M20,9.001h-2c-1.104,0-2,0.898-2,2v2c0,1.102,0.896,2,2,2h2c1.104,0,2-0.898,2-2v-2 C22,9.899,21.104,9.001,20,9.001z"/>' +
              '<path d="M20,16.001h-2c-1.104,0-2,0.898-2,2v2c0,1.103,0.896,2,2,2h2c1.104,0,2-0.897,2-2v-2 C22,16.899,21.104,16.001,20,16.001z"/>';
  break;
  case 'code':
  out.html += '<g>' +
              '<polygon points="21,10 15.465,10 18.232,5.206 14.769,3.206 12,8 9.232,3.206 5.769,5.206 8.538,10 3,10 3,14 8.537,14 5.769,18.795 9.232,20.795 12.001,15.998 14.769,20.793 18.232,18.793 15.465,14 21,14 \t"/>' +
              '</g>';
  break;
  case 'fileattach':
  out.html += '<path d="M11,23c-2.897,0-5-2.313-5-5.5V9c0-3.991,2.794-7,6.5-7S19,5.009,19,9v7h-2V9 c0-2.897-1.893-5-4.5-5S8,6.103,8,9v8.5c0,1.743,0.928,3.5,3,3.5s3-1.757,3-3.5V10c0-0.602-0.146-2-1.5-2S11,9.398,11,10v7H9v-7 c0-2.393,1.407-4,3.5-4S16,7.607,16,10v7.5C16,20.687,13.897,23,11,23z"/>';
  break;
  case 'network':
  out.html += '<path d="M17,7c-3.055,0-4.539,2.375-5.848,4.471C9.779,13.666,8.814,15,7,15c-1.387,0-3-1.311-3-3 s1.613-3,3-3c1.037,0,1.795,0.448,2.512,1.231l1.139-1.706C9.721,7.631,8.569,7,7,7c-2.664,0-5,2.336-5,5s2.336,5,5,5 c3.055,0,4.539-2.375,5.848-4.471C14.221,10.334,15.186,9,17,9c1.387,0,3,1.311,3,3c0,2.074-0.926,3-3,3 c-0.988,0-1.723-0.406-2.409-1.121l-1.216,1.622C14.3,16.382,15.445,17,17,17c3.178,0,5-1.822,5-5C22,9.336,19.664,7,17,7z"/>';
  break;
  case 'sales':
  out.html += '<g>' +
              '<circle cx="17" cy="18" r="2"/>' +
              '<path d="M8.965,15.173C8.976,15.115,9,15.061,9,15V8c0-0.552-0.447-1-1-1H6c-2.205,0-4,1.794-4,4v6 c0,0.552,0.447,1,1,1h2c0-1.656,1.344-3,3-3C8.34,15,8.66,15.069,8.965,15.173z M7,12H4v-2h3V12z"/>' +
              '<circle cx="8" cy="18" r="2"/>' +
              '<path d="M20,4h-8c-1.104,0-2,0.897-2,2v9.779c0.609,0.549,1,1.336,1,2.221h3c0-1.656,1.344-3,3-3 c1.656,0,3,1.344,3,3h1c0.553,0,1-0.448,1-1V6C22,4.897,21.104,4,20,4z"/>' +
              '</g>';
  break;
  case 'unlocked':
  out.html += '<path d="M17,11H9V7c0-1.654,1.346-3,3-3s3,1.346,3,3v1h2V7c0-2.757-2.243-5-5-5S7,4.243,7,7v4c-1.103,0-2,0.896-2,2 v7c0,1.103,0.897,2,2,2h10c1.104,0,2-0.897,2-2v-7C19,11.896,18.104,11,17,11z M12,18c-0.828,0-1.5-0.672-1.5-1.5S11.172,15,12,15 s1.5,0.672,1.5,1.5S12.828,18,12,18z"/>';
  break;
  case 'archive':
  case 'split-alt':
  out.html += '<path d="M20,2.001H4c-0.553,0-1,0.448-1,1v18c0,0.552,0.447,1,1,1h16c0.553,0,1-0.448,1-1v-18 C21,2.449,20.553,2.001,20,2.001z M5,4.001h2v16H5V4.001z M19,20.001H9v-16h10V20.001z"/>';
  break;
  case 'comment':
  out.html += '<path d="M19.998,2h-16c-1.104,0-2,0.895-2,2v12c0,1.104,0.896,2,2,2h1v4l4-4h10.999c1.105,0,2-0.896,2-2V4 C21.998,2.895,21.103,2,19.998,2z M7.998,11h-2V9h2V11z M12.998,11h-2V9h2V11z M17.998,11h-2V9h2V11z"/>';
  break;
  case 'next':
  case 'arrowright':
  out.html += '<g>' +
              '<polygon points="16.707,7.293 15.293,8.707 17.586,11 2,11 2,13 17.586,13 15.293,15.293 16.707,16.707 21.414,12 \t"/>' +
              '</g>';
  break;
  case 'save':
  out.html += '<g>' +
              '<polygon points="16.707,13.709 15.293,12.295 13,14.588 13,2.002 11,2.002 11,14.588 8.707,12.295 7.293,13.709 12,18.416 \t\t"/>' +
              '<path d="M18,8.002h-1v2h1v10H6v-10h1v-2H6c-1.104,0-2,0.896-2,2v10c0,1.102,0.896,2,2,2h12 c1.104,0,2-0.898,2-2v-10C20,8.898,19.104,8.002,18,8.002z"/>' +
              '</g>';
  break;
  case 'users':
  case 'companysize':
  out.html += '<g>' +
              '<path d="M9.359,15.5c0,1.381-1.12,2.5-2.5,2.5c-1.381,0-2.5-1.119-2.5-2.5s1.119-2.5,2.5-2.5 C8.239,13,9.359,14.119,9.359,15.5"/>' +
              '<path d="M11.718,22c-0.446-1.722-1.997-3-3.858-3h-2c-1.862,0-3.413,1.278-3.859,3H11.718z"/>' +
              '<path d="M19.643,15.5c0,1.381-1.12,2.5-2.5,2.5c-1.381,0-2.5-1.119-2.5-2.5s1.119-2.5,2.5-2.5 C18.522,13,19.643,14.119,19.643,15.5"/>' +
              '<path d="M22.001,22c-0.446-1.722-1.997-3-3.858-3h-2c-1.862,0-3.413,1.278-3.859,3H22.001z"/>' +
              '<path d="M14.501,4.5c0,1.381-1.12,2.5-2.5,2.5c-1.381,0-2.5-1.119-2.5-2.5S10.62,2,12.001,2 C13.381,2,14.501,3.119,14.501,4.5"/>' +
              '<path d="M16.859,11c-0.446-1.722-1.997-3-3.858-3h-2c-1.862,0-3.413,1.278-3.859,3H16.859z"/>' +
              '</g>';
  break;
  case 'arrowdown':
  out.html += '<g>' +
              '<polygon points="15.293,15.293 13,17.586 13,2 11,2 11,17.586 8.707,15.293 7.293,16.707 12,21.414 16.707,16.707 \t"/>' +
              '</g>';
  break;
  case 'arrowleft':
  out.html += '<g>' +
              '<polygon points="22,11 6.414,11 8.707,8.707 7.293,7.293 2.586,12 7.293,16.707 8.707,15.293 6.414,13 22,13 \t"/>' +
              '</g>';
  break;
  case 'arrowup':
  out.html += '<g>' +
              '<polygon points="16.707,7.293 12,2.586 7.293,7.293 8.707,8.707 11,6.414 11,22 13,22 13,6.414 15.293,8.707 \t"/>' +
              '</g>';
  break;
  case 'companyevent':
  out.html += '<g>' +
              '<path d="M21,3h-3V1h-2v6h2V5h3v15H3V5h2V3H3C1.896,3,1,3.895,1,5v15c0,1.104,0.896,2,2,2h18 c1.104,0,2-0.896,2-2V5C23,3.895,22.104,3,21,3z"/>' +
              '<polygon points="8,5 15,5 15,3 8,3 8,1 6,1 6,7 8,7 \t\t"/>' +
              '<rect x="5" y="9" width="4" height="4"/>' +
              '<rect x="10" y="9" width="4" height="4"/>' +
              '<rect x="15" y="9" width="4" height="4"/>' +
              '<rect x="5" y="14" width="4" height="4"/>' +
              '<rect x="10" y="14" width="4" height="4"/>' +
              '</g>';
  break;
  case 'forums':
  case 'info':
  out.html += '<path d="M12,2C6.486,2,2,6.487,2,12c0,5.515,4.486,10,10,10s10-4.485,10-10C22,6.487,17.514,2,12,2z M12,6.751 c0.69,0,1.25,0.56,1.25,1.25c0,0.691-0.56,1.25-1.25,1.25S10.75,8.691,10.75,8C10.75,7.31,11.31,6.751,12,6.751z M15,17H9v-2h2v-3 h-1v-2h2c0.553,0,1,0.448,1,1v4h2V17z"/>';
  break;
  case 'other':
  out.html += '<g>' +
              '<circle cx="5" cy="12" r="2"/>' +
              '<circle cx="12" cy="12" r="2"/>' +
              '<circle cx="19" cy="12" r="2"/>' +
              '</g>';
  break;
  case 'search':
  out.html += '<path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>';
  break;
  case 'usersettings':
  out.html += '<g>' +
              '<path d="M8.002,8.006c-2.205,0-4,1.795-4,4c0,2.205,1.795,4,4,4c2.205,0,4-1.795,4-4 C12.002,9.801,10.208,8.006,8.002,8.006z"/>' +
              '<path d="M8.002,17.006c-4.711,0-8,2.467-8,6v1h16v-1C16.002,19.473,12.713,17.006,8.002,17.006z"/>' +
              '<path d="M24.004,7.006v-2h-1.102c-0.13-0.638-0.385-1.229-0.732-1.754l0.783-0.784L21.54,1.054l-0.784,0.784 c-0.524-0.347-1.114-0.602-1.751-0.731V0.006h-2v1.101c-0.638,0.129-1.229,0.384-1.754,0.732l-0.783-0.783L13.053,2.47 l0.783,0.783c-0.348,0.524-0.601,1.116-0.731,1.753h-1.103v2h1.103c0.13,0.638,0.384,1.228,0.732,1.754l-0.784,0.784l1.416,1.413 l0.782-0.784c0.524,0.348,1.116,0.602,1.753,0.732v1.101h2v-1.102c0.638-0.13,1.229-0.385,1.754-0.732l0.783,0.783l1.414-1.415 l-0.784-0.782c0.347-0.524,0.601-1.115,0.731-1.752H24.004z M18.002,8.006c-1.105,0-2-0.897-2-2c0-1.104,0.895-2,2-2 c1.104,0,2,0.896,2,2C20.002,7.109,19.106,8.006,18.002,8.006z"/>' +
              '</g>';
  break;
  case 'companyprofile':
  out.html += '<g>' +
              '<path d="M22.447,8.724l-4-2c-0.31-0.155-0.678-0.139-0.973,0.044C17.18,6.95,17,7.272,17,7.619V11.2l3,1.8v10h2 c0.552,0,1-0.447,1-1V9.619C23,9.239,22.786,8.893,22.447,8.724z"/>' +
              '<path d="M6.585,5.576C6.324,5.388,5.989,5.338,5.684,5.438l-4,1.334C1.275,6.908,1,7.291,1,7.721V22 c0,0.553,0.448,1,1,1h4c0.552,0,1-0.447,1-1V6.387C7,6.066,6.846,5.764,6.585,5.576z M5,20H3v-2h2V20z M5,16H3v-2h2V16z M5,12H3 v-2h2V12z"/>' +
              '<path d="M17.447,13.724c-0.403-0.202-2.046-1.101-2.447-1.101V2.721c0-0.43-0.275-0.812-0.684-0.948l-4-1.334 c-0.305-0.101-0.64-0.05-0.901,0.138C9.154,0.764,9,1.066,9,1.387V3h4v2H9v2h4v2H9v2h4v2H9v9c0,0.553,0.448,1,1,1h2v-1.5 c0-0.828,0.672-1.5,1.5-1.5s1.5,0.672,1.5,1.5V23h3v-8.381C18,14.239,17.786,13.893,17.447,13.724z M16,17h-5v-2h5V17z"/>' +
              '</g>';
  break;
  case 'halt':
  out.html += '<path d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>';
  break;
  case 'ownership':
  out.html += '<path d="M20,8h-3.101C16.435,5.721,14.415,4,12,4S7.565,5.721,7.101,8H4c-1.105,0-2,0.896-2,2v10 c0,1.104,0.895,2,2,2h16c1.104,0,2-0.896,2-2V10C22,8.896,21.104,8,20,8z M12,6c1.304,0,2.416,0.836,2.829,2H9.171 C9.584,6.836,10.696,6,12,6z M8,20H6V10h2V20z M18,20h-2V10h2V20z"/>';
  break;
  case 'send':
  out.html += '<path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>';
  break;
  case 'view':
  out.html += '<path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>';
  break;
  case 'pay':
  out.html += '<path d="M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z"/>';
  break;
  case 'settings':
  out.html += '<path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/>';
  break;
  case 'createdocument':
  out.html += '<g>' +
              '<path d="M18,14.349V4.586L13.414,0H2C0.897,0,0,0.898,0,2v18c0,1.103,0.897,2,2,2h12.349 C14.127,21.374,14,20.703,14,20C14,17.389,15.671,15.173,18,14.349z M9,15H3v-2h6V15z M12,11H3V9h9V11z M12,6V1l5,5H12z"/>' +
              '<polygon points="21,19 21,16 19,16 19,19 16,19 16,21 19,21 19,24 21,24 21,21 24,21 24,19 \t\t"/>' +
              '</g>';
  break;
  case 'industry':
  out.html += '<path d="M21.707,13.293l-11-11C10.519,2.105,10.266,2,10,2H3C2.447,2,2,2.447,2,3v7 c0,0.266,0.105,0.519,0.293,0.707l11,11C13.488,21.902,13.744,22,14,22s0.512-0.098,0.707-0.293l7-7 C22.098,14.316,22.098,13.684,21.707,13.293z M7,9C5.894,9,5,8.104,5,7c0-1.106,0.894-2,2-2c1.104,0,2,0.894,2,2 C9,8.104,8.104,9,7,9z"/>';
  break;
  case 'pin':
  case 'preferred':
  out.html += '<g>' +
              '<polygon points="22,12 12.101,2.101 10.686,3.514 12.101,4.929 12.101,4.929 7.151,9.878 7.151,9.88 5.736,8.465 4.322,9.88 8.565,14.122 2.908,19.778 4.322,21.192 9.979,15.536 14.222,19.778 15.636,18.364 14.222,16.95 14.222,16.95 19.171,12 19.172,12 20.586,13.414 \t"/>' +
              '</g>';
  break;
  case 'share':
  out.html += '<path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>';
  break;
  case 'written-request':
  out.html += '<g>' +
              '<path d="M11.607,18c-1.654,0-3,1.346-3,3s1.346,3,3,3s3-1.346,3-3S13.262,18,11.607,18z M11.607,22 c-0.551,0-1-0.448-1-1c0-0.551,0.449-1,1-1s1,0.449,1,1C12.607,21.552,12.158,22,11.607,22z"/>' +
              '<path d="M11,5.029C6.955,5.18,3.17,6.809,0.293,9.688l1.414,1.414c2.5-2.5,5.782-3.923,9.293-4.072V5.029z"/>' +
              '<path d="M23.707,3.294l-3-3c-0.391-0.392-1.023-0.392-1.414,0l-7,7c-0.129,0.128-0.219,0.288-0.264,0.464 l-1,4c-0.084,0.341,0.016,0.701,0.264,0.949C11.482,12.898,11.738,13,12,13c0.08,0,0.162-0.009,0.242-0.029l4-1 c0.176-0.044,0.337-0.135,0.465-0.264l7-7C24.098,4.316,24.098,3.684,23.707,3.294z M15.488,10.098l-2.113,0.528l0.527-2.114 L17,5.414L18.586,7L15.488,10.098z M20,5.586L18.414,4L20,2.414L21.586,4L20,5.586z"/>' +
              '<path d="M10,9.127c-2.517,0.338-4.947,1.458-6.878,3.387l1.414,1.414c1.54-1.539,3.462-2.461,5.464-2.783 V9.127z"/>' +
              '<path d="M10,13.162c-1.523,0.311-2.925,1.057-4.049,2.182l1.414,1.414c0.743-0.743,1.648-1.263,2.635-1.535 V13.162z"/>' +
              '</g>';
  break;
  case 'associated':
  out.html += '<g>' +
              '<path d="M16.414,1H9C7.897,1,7,1.898,7,3v14c0,1.103,0.897,2,2,2h10c1.103,0,2-0.897,2-2V5.586L16.414,1z M19.001,17H9V3h6v4h4L19.001,17z"/>' +
              '<path d="M5,5H3v16c0,1.103,0.897,2,2,2h12v-2H5V5z"/>' +
              '</g>';
  break;
  case 'delete':
  out.html += '<path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"/>';
  break;
  case 'share':
  out.html += '<path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>';
  break;
  case 'share':
  out.html += '<path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>';
  break;
  case 'share':
  out.html += '<path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>';
  break;
}
  out.html += '</svg>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.svgname.edbml
edbml.declare("ts.ui.svgname.edbml").as(function $edbml(text, col1, col2, size, stylesheet_url, stylesheet_txt
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  text = text || '?';
  col1 = col1 || 'pink';
  col2 = col2 || 'lime';
  var fontsize = size / 2.6;
  out.html += '<svg xmlns="http://www.w3.org/2000/svg" width="' + $val(size) + 'px" height="' + $val(size) + 'px" viewBox="0 0 ' + $val(size) + ' ' + $val(size) + '" style="background-color:' + $val(col1) + ';" text-rendering="optimizeLegibility">';
  if (stylesheet_url) {
    out.html += '<defs>';
    stylesheet(!gui.Client.agent);
    out.html += '</defs>';
  }
  out.html += '<text x="50%" y="' + $val(ypos(gui.Client)) + '" text-anchor="middle" alignment-baseline="middle" font-size="' + $val(fontsize) + '" font-family="' + $val(stylesheet_url ? 'Open Sans' : 'Arial') + '" font-weight="300" fill="' + $val(col2) + '">' + $txt(text) + '</text>' +
              '</svg>';
  function stylesheet(imports) {
    out.html += '<style type="text/css">';
    if (imports) {
      out.html += '@import "' + stylesheet_url + '";';
    } else {
      out.html += stylesheet_txt;
    }
    out.html += '</style>';
  }
  function ypos(Client) {
    switch(    Client.agent){
    case 'gecko':
    return '65%';
    case 'explorer':
    return '66%';
    case 'webkit':
    return '54%';
    default:
    return '50%';
}
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.switch.edbml
edbml.declare("ts.ui.switch.edbml").as(function $edbml(model
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $val = edbml.safeattr;
  $att['id'] = 'switch' + model.$instanceid;
  $att['name'] = model.name || null;
  $att['value'] = model.value || null;
  out.html += '<fieldset class="ts-form">' +
              '<label>' +
              '<span></span>';
  var $1 = $set(function(value, checked){
    model.checked = checked;
  }, this);
  out.html += '<input type="checkbox" ' + $att.$('id') + ' ' + $att.$('name') + ' ' + $att.$('value') + ' checked="' + $val(model.checked) + '" onchange="edbml.$run(this, \'' + $1 + '\');"/>' +
              '</label>' +
              '</fieldset>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.switchonly.edbml
edbml.declare("ts.ui.switchonly.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $val = edbml.safeattr;
  out.html += '<div data-ts="Spirit" class="ts-switcher ' + $val(ts.ui.CLASS_ENGINE) + '">' +
              '<i class="ts-icon-cancel"></i>' +
              '<i class="ts-icon-checked"></i>' +
              '</div>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.tablecheck.edbml
edbml.declare("ts.ui.tablecheck.edbml").as(function $edbml(table, row, fixed
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr;
  out.html += '<td class="ts-table-addition ts-table-checkbox">';
  $att['id'] = table.$instanceid + (fixed ? '-fixed-' : '-floating-') + row.$index;
  $att['class'] = row.selected ? 'ts-icon-checkboxon' : 'ts-icon-checkbox';
  out.html += '<div class="ts-table-cell">' +
              '<button class="ts-table-checkbox-button" ' + $att.$('id') + ' data-index="' + $val(row.$index) + '" tabindex="-1">' +
              '<i ' + $att.$('class') + '></i>' +
              '</button>' +
              '</div>' +
              '</td>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.tablecols.edbml
edbml.declare("ts.ui.tablecols.edbml").as(function $edbml(table, cols
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  if (cols.length) {
    out.html += '<tr>';
    if (table.numbered) {
      out.html += '<td class="ts-table-addition ts-table-numbered">' +
                  '<div>#</div>' +
                  '</td>';
    }
    if (table.selectable) {
      out.html += '<td class="ts-table-addition ts-table-checkbox"></td>';
    }
    cols.forEach(renderCol);
    out.html += '</tr>';
  }
  function renderCol(col) {
    $att['class'] = getCellClass(col);
    out.html += '<th ' + $att.$('class') + '>' +
                '<fieldset id="fieldset-' + $val(col.$instanceid) + '">';
    renderOptions(col);
    renderHeader(col);
    out.html += '</fieldset>' +
                '</th>';
  }
  function renderOptions(col) {
    if (col.search && !col.search.hidden) {
      out.html += col.search.render();
    } else if (col.button && !col.button.hidden) {
      out.html += col.button.render();
    }
  }
  function renderHeader(col) {
    $att['class'] = col.ascending ? 'ts-icon-triangledown' : 'ts-icon-triangleup';
    out.html += '<button class="ts-button-sort" id="label-' + $val(col.$instanceid) + '" data-index="' + $val(col.$index) + '">' +
                '<span>' + $txt(col.label) + '</span>' +
                '<i ' + $att.$('class') + '></i>' +
                '</button>';
  }
  function getCellClass(col) {
    return col.type + (col.selected ? ' ts-selected' : '');
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.tablegutter.edbml
edbml.declare("ts.ui.tablegutter.edbml").as(function $edbml(table, rows
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    renderCheck = ts.ui.tablecheck.edbml.lock(out),
    renderHilt = ts.ui.tablehilt.edbml.lock(out);
  rows.forEach(function(row){
    var selectable = row.selectable !== false;
    $att['class'] = table.selectable && selectable && row.selected ? 'ts-table-row-selected ts-bg-yellow' : '';
    out.html += '<tr ' + $att.$('class') + '>';
    if (selectable) {
      renderCheck(table, row);
    } else {
      renderHilt(table, row);
    }
    out.html += '</tr>';
  });
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.tablehilt.edbml
edbml.declare("ts.ui.tablehilt.edbml").as(function $edbml(table, row, icon
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr;
//todo(leo) we will support icon later
  out.html += '<td class="ts-table-addition ts-table-hilt">';
  $att['id'] = table.$instanceid + icon + row.$index;
  $att['class'] = icon ? 'icon' : '';
  out.html += '<div class="ts-table-cell">' +
              '<button ' + $att.$('id') + ' data-index="' + $val(row.$index) + '" tabindex="-1">';
  if (icon) {
    out.html += '<i ' + $att.$('class') + '></i>';
  }
  out.html += '</button>' +
              '</div>' +
              '</td>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.tablemenu.edbml
edbml.declare("ts.ui.tablemenu.edbml").as(function $edbml(table
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr;
  var id = table.$instanceid;
  $att['class'] = 'ts-table-menu ts-engine-' + gui.Client.agent;
  $att['class'] += table.menuopen ? ' ts-open ts-bg-yellow' : '';
  out.html += '<aside ' + $att.$('class') + ' id="' + $val(id) + '-menu" data-ts="Spirit">' +
              '<table>' +
              '<thead>' +
              '<tr>' +
              '<th class="ts-table-checkbox">' +
              '<button data-action="selection-menu" id="' + $val(id) + '-menu-button">';
  var check = table.isVisibleRowSelected();
  $att['class'] = check ? 'ts-icon-checkboxon' : 'ts-icon-checkbox';
  out.html += '<i ' + $att.$('class') + '></i>' +
              '</button>' +
              '</th>';
  if (table.menuopen) {
    out.html += '<th class="ts-table-choices">' +
                '<button data-action="select-page" class="ts-button ts-tertiary">' +
                '<span>This Page</span>' +
                '</button>' +
                '<button data-action="select-all" class="ts-button ts-tertiary">' +
                '<span>All Pages</span>' +
                '</button>' +
                '</th>' +
                '<th class="ts-table-choices-close">' +
                '<button data-action="selection-menu-close" class="ts-button ts-tertiary">' +
                '<i class="ts-icon-close"></i>' +
                '</button>' +
                '</th>' +
                '</tr>';
  }
  out.html += '</thead>' +
              '</table>' +
              '</aside>' +
              '</scipt>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.tablerows.edbml
edbml.declare("ts.ui.tablerows.edbml").as(function $edbml(table, rows, cols
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr,
    renderCheck = ts.ui.tablecheck.edbml.lock(out),
    renderHilt = ts.ui.tablehilt.edbml.lock(out);
  var colcount = cols.length;
  var Markdown = ts.ui.Markdown;
  var whitelist = [
  'strong',
  'em',
  'strike',
  'code',
  'ul'
];
  if (table.linkable) {
    whitelist.push('a');
  }
  if (cols.length || !table.cols.length) {
    rows.forEach(renderRow);
  }
  function renderRow(row) {
    var selectable = row.selectable === false ? false : true;
    $att['class'] = row.TEMPFIX ? 'TEMPFIX' : '';
    $att['class'] += table.selectable && selectable && row.selected ? 'ts-table-row-selected ts-bg-yellow' : '';
    $att['class'] += table.selectable && !selectable ? 'ts-table-row-unselectable' : '';
    $att['class'] += row.new ? 'ts-table-new-row' : '';
    out.html += '<tr data-index="' + $val(row.$index) + '" ' + $att.$('class') + '>';
    if (table.numbered) {
      renderNumber(row);
    }
    if (table.selectable) {
      if (selectable) {
        var simulated = true;
        renderCheck(table, row, simulated);
      } else {
        renderHilt(table, row);
      }
    }
    row.cells.forEach(function(cell, i){
      if (!colcount || i < colcount) {
        var col = cols[cell.$index];
        if (!col || col.visible) {
          renderCell(col, row, cell);
        }
      }
    });
    out.html += '</tr>';
  }
  function renderNumber(row) {
    out.html += '<td class="ts-table-addition ts-table-numbered" data-index="' + $val(row.$index) + '">' +
                '<div class="ts-table-cell">' +
                Markdown.parse(row.$index + 1) +
                '</div>' +
                '</td>';
  }
  function renderCell(col, row, cell) {
    var editable = iseditable(col, row, cell);
    $att['class'] = getCellClass(col, row, cell, editable);
    $att['id'] = table.$cellid(row.$index, cell.$index);
    out.html += '<td ' + $att.$('id') + ' ' + $att.$('class') + ' ' + $att.$('note') + ' data-index="' + $val(cell.$index) + '">' +
                '<div class="ts-table-cell">';
    if (table.editable) {
      out.html += '<div class="ts-table-line" tabindex="0"></div>';
    }
    if (editable) {
      renderEditor(cell.value);
    }
    if (ts.ui.Model.is(cell)) {
      out.html += cell.render();
    } else {
      out.html += Markdown.parse(cell.text, whitelist);
    }
    out.html += '</div>' +
                '</td>';
  }
  function renderEditor(value) {
    out.html += '<textarea rows="1" data-ts="TextArea" class="ts-table-input" type="submit">' +
                value +
                '</textarea>';
  }
  function getCellClass(col, row, cell, editable) {
    var css = [row.type];
    if (cell.item) {
    // will render a button or switch or something
      css.push('ts-has-extra');
      css.push('ts-has-' + cell.item.toLowerCase());
      if (col) {
        css.push(col.type);
      }
    } else {
      css.push(cell.type);
      css.push(editable ? 'ts-editable' : '');
      css.push(cell.valid ? '' : 'ts-table-invalid');
      if (col) {
        css = css.concat([
  col.type,
  col.wrap ? 'ts-wrap' : ''
]);
      }
    }
    if (col) {
      css.push(col.selected ? 'ts-selected' : '');
    }
    return css.join(' ').trim();
  }
  function iseditable(col, row, cell) {
    if (table.editable) {
      if (cell.editable) {
        return true;
      } else {
        return (!col || col.editable !== false) && row.editable !== false;
      }
    }
    return false;
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.toolbar.edbml
edbml.declare("ts.ui.toolbar.edbml").as(function $edbml(toolbar
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set;
  var $1 = $set(function(){
    return toolbar;
  }, this);
  out.html += '<header data-ts="ToolBar" data-ts.model="edbml.$get(&quot;' + $1 + '&quot;);"></header>';
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.toolbartabs.edbml
edbml.declare("ts.ui.toolbartabs.edbml").as(function $edbml(spirit, tabs, id, mobilos
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  (function specialTabs(topbar){
    $att['ts'] = topbar ? 'ts.ui.TopBarTabsSpirit' : null;
    $att['class'] = 'ts-toolbar-tabs' + (topbar ? ' ts-topbar-tabs' : '');
    out.html += '<ul ' + $att.$('ts') + ' ' + $att.$('class') + ' id="' + $val(id) + '-tabs">';
    tabs.forEach(rendertab);
    if (tabs.newtabbutton) {
      rendernew(tabs.newtabbutton);
    }
    if (!(topbar && mobilos)) {
      rendermore();
    }
    out.html += '</ul>';
  }(ts.ui.TopBarSpirit.is(spirit)));
  function rendertab(tab) {
    $att['href'] = tab.href || null;
    $att['class'] = 'ts-tab';
    $att['class'] += tab.selected ? ' ts-selected' : '';
    $att['class'] += tab.counter > 0 ? ' ts-counter' : '';
    $att['class'] += tab.selected && tab.closeable ? ' ts-tab-close' : '';
    out.html += '<li data-ts="Spirit" ' + $att.$('class') + ' id="' + $val(tab.$instanceid) + '">';
    var $1 = $set(function(){
      tab.select();
    }, this);
    out.html += '<a data-ts="Button" ' + $att.$('href') + ' onclick="edbml.$run(this, \'' + $1 + '\');" tabindex="-1">';
    if (tab.icon) {
      out.html += '<i class="ts-tab-icon ' + $val(tab.icon) + '"></i>';
    }
    out.html += '<span class="ts-tab-label">' + $txt(tab.label) + '</span>';
    if (tab.selected && tab.closeable) {
      var $2 = $set(function(){
        close(tab);
      }, this);
      out.html += '<span class="ts-close-bg" onclick="edbml.$run(this, \'' + $2 + '\');">' +
                  '<i class="ts-icon-close"></i>' +
                  '</span>';
    }
    if (tab.counter > 0) {
      out.html += '<em>' + $txt(tab.counter) + '</em>';
    }
    out.html += '</a>' +
                '</li>';
  }
  function close(tab) {
    var abort = false;
    if (tab.selected) {
      if (tab.onclose) {
        abort = tab.onclose() === false;
      }
      if (!abort) {
        var index = tabs.indexOf(tab);
        gui.Array.remove(tabs, index);
      }
    }
  }
  function rendermore() {
    $att['id'] = id + '-tabs-more';
    $att['class'] = 'ts-tab ts-tab-button ts-tab-more';
    $att['title'] = ts.ui.TopBar.localize('more');
    out.html += '<li data-ts="Spirit" ' + $att.$('class') + ' ' + $att.$('id') + '>';
    var $3 = $set(function(){
      showmore();
    }, this);
    out.html += '<a data-ts="Button" ' + $att.$('title') + ' onclick="edbml.$run(this, \'' + $3 + '\');" tabindex="-1">' +
                '<i class="ts-icon-other"></i>' +
                '<span class="ts-tab-label">\xA0</span>' +
                '</a>' +
                '</li>';
  }
  function rendernew(newtabbutton) {
    $att['id'] = newtabbutton.$instanceid;
    $att['class'] = 'ts-tab ts-tab-button ts-add-tab';
    out.html += '<li data-ts="Spirit" ' + $att.$('class') + ' ' + $att.$('id') + '>';
    var $4 = $set(function(){
      newtabbutton.click();
    }, this);
    out.html += '<a data-ts="Button" tabindex="-1" onclick="edbml.$run(this, \'' + $4 + '\');">' +
                '<i class="ts-icon-add"></i>' +
                '<span class="ts-tab-label">\xA0</span>' +
                '</a>' +
                '</li>';
  }
  function showmore() {
    spirit.puttabs(tabs.slice().reverse());
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.usercard.edbml
edbml.declare("ts.ui.usercard.edbml").as(function $edbml(user, contentonly, classconfig
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  var data = user.data || {};
  var type = data.type || '';
  var name = data.name;
  var title = data.title;
  var companyUrl = data.companyUrl;
  var company = data.company;
  var role = data.role;
  var show = name;
  var image = data.image;
  var email = data.email;
  if (isType('ts-current-user')) {
    show = ts.ui.UserCard.localize('currentUserDisplayName');
  }
  if (contentonly) {
    renderContent();
  } else {
    renderSpirit();
  }
  function renderContent() {
    out.html += '<div class="ts-usercard-main">';
    renderBasic();
    if (isType('ts-details')) {
      renderDetails();
    }
    out.html += '</div>';
  }
  function renderSpirit() {
    $att['class'] = user.type || null;
    var $1 = $set(function(){
      return user;
    }, this);
    out.html += '<div data-ts="UserCard" data-ts._model="edbml.$get(&quot;' + $1 + '&quot;);" ' + $att.$('class') + '></div>';
  }
  function renderBasic() {
    if (isType('ts-compact ts-reverse')) {
      renderName();
      renderImage();
    } else {
      renderImage();
      renderName();
    }
  }
  function renderImage() {
    out.html += '<p class="ts-usercard-image">';
    $att['src'] = image || null;
    $att['alt'] = name || null;
    $att['width'] = $att['height'] = isType('ts-details') ? 110 : 44;
    out.html += '<img data-ts="UserImage" ' + $att.$('src') + ' ' + $att.$('alt') + ' ' + $att.$('width') + ' ' + $att.$('height') + '/>' +
                '</p>';
  }
  function renderName() {
    out.html += '<p class="ts-usercard-name">' +
                '<span>' + $txt(show || '') + '</span>' +
                '</p>';
  }
  function renderDetails() {
    out.html += '<ul class="ts-usercard-details">';
    if (title) {
      out.html += '<li class="ts-usercard-title">' + $txt(title) + '</li>';
    }
    if (role) {
      out.html += '<li class="ts-usercard-role">' + $txt(role) + '</li>';
    }
    if (company) {
      out.html += '<li class="ts-usercard-company">';
      if (companyUrl) {
        out.html += '<a href="' + $val(companyUrl) + '" target=\'_blank\'>' + $txt(company) + '</a>';
      } else {
        out.html += '<span>' + $txt(company) + '</span>';
      }
      out.html += '</li>';
    }
    if (email) {
      out.html += '<li class="ts-usercard-email">' +
                  '<a href="mailto:' + $val(email) + '">' + $txt(email) + '</a>' +
                  '</li>';
    }
    out.html += '</ul>';
  }
  function isType(string) {
    return string.split(' ').every(function(single){
      return classconfig.includes(single);
    });
  }
  return out.write();
});

// src/runtime/edbml/functions/ts.ui.userimage.edbml
edbml.declare("ts.ui.userimage.edbml").as(function $edbml(image
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att;
  $att['src'] = image.src || null;
  $att['alt'] = image.name || null;
  $att['width'] = image.size || null;
  $att['height'] = image.size || null;
  out.html += '<img data-ts="UserImage" ' + $att.$('src') + ' ' + $att.$('alt') + ' ' + $att.$('width') + ' ' + $att.$('height') + '/>';
  return out.write();
});

// src/runtime/edbml/scripts/ts.ui.AsideSpirit.edbml
edbml.declare("ts.ui.AsideSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $val = edbml.safeattr,
    aside = $edbml.$input(ts.ui.AsideModel);
  out.html += '<header data-ts="ToolBar" id="' + $val(this.$instanceid) + '-header" class="ts-header" data-ts.title="' + $val(aside.title) + '"></header>' +
              '<div data-ts="Panel" id="' + $val(this.$instanceid) + '-panel">' +
              aside.items.render() +
              '</div>';
  return out.write();
}).withInstructions([{
    input : {
      name : "aside",
      type : "ts.ui.AsideModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.AutocompleteDropdownSpirit.edbml
edbml.declare("ts.ui.AutocompleteDropdownSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set,
    $val = edbml.safeattr,
    autocomplete = $edbml.$input(ts.ui.AutocompleteDropdownModel);
  var spirit = this;
  var guid = autocomplete.$instanceid;
  var filter = autocomplete.filter;
  var count = autocomplete.filteredAutocompleteList.length;
  var hiddenClass = spirit._isActive ? '' : 'ts-hidden';
  if (count) {
    out.html += '<menu id="' + $val(guid) + '-list" class="ts-autocomplete-list ' + $val(hiddenClass) + '">';
    if (count > 1) {
      out.html += '<li class="ts-autocomplete-results">' +
                  spirit._locale.matchString(count) +
                  '</li>';
    }
    (autocomplete.filteredAutocompleteList || []).forEach(function(item){
      var json = JSON.stringify(item);
      var $1 = $set(function(){
        spirit._onselect(item);
      }, this);
      out.html += '<li onclick="edbml.$run(this, \'' + $1 + '\');" data-item="' + $val(json) + '">' +
                  printLabel(item, filter) +
                  '</li>';
    });
    out.html += '</menu>';
  }
  function printLabel(item, filter$2) {
    var label = item.value;
    var labelIndex = label.toLowerCase().indexOf(filter$2.toLowerCase());
    var output = '';
    output += label.substr(0, labelIndex);
    out.html += '<b>';
    output += label.substr(labelIndex, filter$2.length);
    out.html += '</b>';
    output += label.substr(labelIndex + filter$2.length);
    return output;
  }
  return out.write();
}).withInstructions([{
    input : {
      name : "autocomplete",
      type : "ts.ui.AutocompleteDropdownModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.CalendarSpirit.edbml
edbml.declare("ts.ui.CalendarSpirit.edbml").as(function $edbml(labels, month, year, view, prevYear, nextYear, prevMonth, nextMonth, minDay, maxDay
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $txt = edbml.safetext,
    $val = edbml.safeattr;
  out.html += '<table>' +
              '<thead>' +
              '<tr class="ts-calendar-transports">';
  renderbuttons(prevMonth, month, nextMonth);
  out.html += '<th/>';
  renderbuttons(prevYear, year, nextYear);
  out.html += '</tr>' +
              '<tr class="ts-calendar-labels">';
  labels.forEach(function(label){
    out.html += '<th>' + $txt(label) + '</th>';
  });
  out.html += '</tr>' +
              '</thead>' +
              '<tbody class="ts-calendar-days">';
  view.forEach(function(row){
    out.html += '<tr>';
    row.forEach(rendercell);
    out.html += '</tr>';
  });
  out.html += '</tbody>' +
              '</table>';
  function renderbuttons(prev, label, next) {
    renderbutton(prev, 'ts-icon-triangleleft');
    out.html += '<th><label>' + $txt(label) + '</label></th>';
    renderbutton(next, 'ts-icon-triangleright');
  }
  function renderbutton(name, icon) {
    $att['class'] = name ? null : 'ts-calendar-nogo';
    $att['name'] = name || null;
    out.html += '<th ' + $att.$('class') + '>' +
                '<button ' + $att.$('name') + '>' +
                '<i class="' + $val(icon) + '"></i>' +
                '</button>' +
                '</th>';
  }
  function rendercell(cell) {
    var other = cell.prev || cell.next;
    var allow = allowcell(cell, other);
    $att['name'] = allow ? 'accept' : 'reject';
    $att['value'] = allow ? cell.stringify() : null;
    $att['class'] = classname({
      'ts-calendar-other' : other,
      'ts-calendar-today' : cell.today,
      'ts-selected' : cell.selected,
      'ts-calendar-nogo' : !allow
    });
    out.html += '<td ' + $att.$('class') + '>' +
                '<button ' + $att.$('name') + ' ' + $att.$('value') + '>' +
                '<span>' + $txt(cell.day) + '</span>' +
                '</button>' +
                '</td>';
  }
  function classname(classes) {
    return Object.keys(classes).filter(function(c){
      return classes[c];
    }).join(' ') || null;
  }
  function allowcell(cell, other) {
    var all = Number.MAX_VALUE;
    return minDay !== all && maxDay !== 1 - all && !lower(cell.day, minDay, !other, !prevMonth, cell.prev) && !upper(cell.day, maxDay, !other, !nextMonth, cell.next);
  }
  function lower(day, min, main, stops, before) {
    return min && (main && day < min) || stops && before;
  }
  function upper(day, max, main, stops, after) {
    return max && (main && day > max) || stops && after;
  }
  return out.write();
});

// src/runtime/edbml/scripts/ts.ui.DialogSpirit.edbml
edbml.declare("ts.ui.DialogSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr,
    dialog = $edbml.$input(ts.ui.DialogModel);
  var mobile = ts.ui.isMobilePoint();
  var buttons = dialog.buttons;
  if (dialog.icon) {
    renderIcon(dialog.icon);
  }
  if (dialog.items.getLength()) {
    renderItems(dialog.items);
  }
  if (buttons.getLength()) {
    renderButtons(mobile ? buttons.descending() : buttons);
  }
  function renderIcon(icon) {
    out.html += '<div class="ts-dialog-head">' +
                '<i class="ts-dialog-icon ' + $val(icon) + '"></i>' +
                '</div>';
  }
  function renderItems(items) {
    out.html += '<div class="ts-dialog-body">' +
                items.map(function(item){
      switch(      item.item){
      case 'text':
      var markdowntags = dialog.tags;
      return item.render(markdowntags);
      default:
      return item.render();
}
    });
    out.html += '</div>';
  }
  function renderButtons(buttons$2) {
    out.html += '<div class="ts-dialog-buttons">';
    $att['class'] = 'ts-buttons';
    if (!mobile) {
      switch(      buttons$2.length){
      case 2:
      $att['class'] += ' ts-t-t';
      break;
}
    }
    out.html += '<menu data-ts="Buttons" ' + $att.$('class') + '>';
    buttons$2.forEach(function(button){
      out.html += '<li>' +
                  button.render() +
                  '</li>';
    });
    out.html += '</menu>' +
                '</div>';
  }
  return out.write();
}).withInstructions([{
    input : {
      name : "dialog",
      type : "ts.ui.DialogModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.FormSpirit.edbml
edbml.declare("ts.ui.FormSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    form = $edbml.$input(ts.ui.FormModel);
  out.html += form.items.render() +
              form.buttons.render();
  return out.write();
}).withInstructions([{
    input : {
      name : "form",
      type : "ts.ui.FormModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.NoteSpirit.edbml
edbml.declare("ts.ui.NoteSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $set = edbml.$set,
    $val = edbml.safeattr,
    note = $edbml.$input(ts.ui.NoteModel);
  if (note.icon) {
    out.html += '<i class="' + $val(note.icon) + '"></i>';
  }
  if (note.text) {
    out.html += ts.ui.Markdown.parse(note.text);
  }
  if (note.buttons && note.buttons.length) {
    out.html += '<div class="ts-note-buttons ts-micro">' +
                note.buttons.render() +
                '</div>';
  } else if (note.onclose) {
    var $1 = $set(function(){
      this.close();
    }, this);
    out.html += '<button class="ts-note-close" onclick="edbml.$run(this, \'' + $1 + '\');">' +
                '<i class="ts-icon-close"></i>' +
                '</button>';
  }
  return out.write();
}).withInstructions([{
    input : {
      name : "note",
      type : "ts.ui.NoteModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.ObjectSpirit.edbml
edbml.declare("ts.ui.ObjectSpirit.edbml").as(function $edbml(object
/**/){
  'use strict';
  var out = $edbml.$out;
  var classconfig = this.css.name();
  var contentonly = true;
  if (object) {
    out.html += object.render(contentonly, classconfig);
  } else {
  }
  return out.write();
});

// src/runtime/edbml/scripts/ts.ui.PagerSpirit.edbml
edbml.declare("ts.ui.PagerSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $txt = edbml.safetext,
    $val = edbml.safeattr,
    renderIcon = ts.ui.svgicons.edbml.lock(out),
    model = $edbml.$input(ts.ui.PagerModel);
  var id = this.$instanceid;
  var most = model.max || model.defaultmax;
  var init = model.init;
  var last = init + most;
  var size = model.pages;
  var page = model.page;
  var many = size > most;
  var more = page < size - 1;
  var xxxx = 0;
  var less = page > 0;
  out.html += '<menu>';
  if (size) {
    renderItems(init);
  }
  out.html += '</menu>';
  function renderItems(i) {
    if (many) {
      renderJump(less, 'first', 'skip-previous');
    }
    renderJump(less, 'prev', 'fast-rewind');
    while (i < last && i < size) {
      var indicateless = init > 0 && i === init;
      renderStep(i++, indicateless, i === last && i < size, xxxx++);
    }
    renderJump(more, 'next', 'fast-forward');
    if (many) {
      renderJump(more, 'last', 'skip-next');
    }
  }
  function renderJump(enabled, value, icon) {
    out.html += '<li>';
    $att['disabled'] = !enabled ? 'disabled' : null;
    $att['class'] = 'ts-pager-jump ts-pager-' + value;
    $att['class'] += ' ts-engine-' + gui.Client.agent;
    out.html += '<button ' + $att.$('class') + ' ' + $att.$('disabled') + ' data-jump="' + $val(value) + '" id="' + $val(id) + '-' + $val(value) + '">' +
                '<i>';
    renderIcon(icon);
    out.html += '</i>' +
                '</button>' +
                '</li>';
  }
  function renderStep(i, indicateless, indicatemore, index) {
    out.html += '<li>';
    $att['class'] = 'ts-pager-step';
    $att['class'] += model.page === i ? ' ts-selected' : '';
    $att['class'] += indicateless ? ' ts-less' : '';
    $att['class'] += indicatemore ? ' ts-more' : '';
    out.html += '<button ' + $att.$('class') + ' data-page="' + $val(i) + '" id="' + $val(id) + '-' + $val(index) + '">' +
                '<span>' + $txt(i + 1) + '</span>' +
                '</button>' +
                '</li>';
  }
  return out.write();
}).withInstructions([{
    input : {
      name : "model",
      type : "ts.ui.PagerModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.SearchSpirit.edbml
edbml.declare("ts.ui.SearchSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $val = edbml.safeattr,
    search = $edbml.$input(ts.ui.SearchModel);
  var id = search.$instanceid;
  $att['placeholder'] = gui.Client.isExplorer ? null : search.info || null;
  $att['title'] = (search.focused || search.flex ? null : search.info) || null;
  $att['class'] = 'ts-button-clear' + (search.value ? '' : ' ts-hidden');
  var $1 = $set(function(){
    return search;
  }, this);
  out.html += '<input data-ts="Input" data-ts.model="edbml.$get(&quot;' + $1 + '&quot;);" id="' + $val(id) + '-input" ' + $att.$('title') + ' ' + $att.$('placeholder') + '/>' +
              '<button data-ts="Button" ' + $att.$('class') + ' tabindex="-1" id="' + $val(id) + '-clear">' +
              '<i class="ts-icon-close"></i>' +
              '</button>';
  return out.write();
}).withInstructions([{
    input : {
      name : "search",
      type : "ts.ui.SearchModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.TableGutterSpirit.edbml
edbml.declare("ts.ui.TableGutterSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    renderGutter = ts.ui.tablegutter.edbml.lock(out),
    table = $edbml.$input(ts.ui.TableModel);
  $att['style'] = null;
  out.html += '<table ' + $att.$('style') + '>' +
              '<tbody>';
  renderGutter(table, table.visibleRows());
  out.html += '</tbody>' +
              '</table>';
  return out.write();
}).withInstructions([{
    input : {
      name : "table",
      type : "ts.ui.TableModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.TableSpirit.edbml
edbml.declare("ts.ui.TableSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $val = edbml.safeattr,
    renderCols = ts.ui.tablecols.edbml.lock(out),
    renderRows = ts.ui.tablerows.edbml.lock(out),
    renderMenu = ts.ui.tablemenu.edbml.lock(out),
    renderGutter = ts.ui.tablegutter.edbml.lock(out),
    table = $edbml.$input(ts.ui.TableModel);
  var guid = table.$instanceid;
  var cols = table.visibleCols();
  var rows = table.visibleRows();
  var css1 = table.selectable ? 'ts-selectable' : '';
  var css2 = table.isWrapping() ? 'ts-wrapping' : '';
  var hack = table.tempdirtyflag;
  var    // TODO: dirtyflags!
    tbar = table.toolbar;
  this._onbeforerender();
// TODO: this as default in {edb.ScriptPlugin}
  out.html += '<header data-ts="Spirit" id="' + $val(guid) + '-cols" class="ts-table-cols ' + $val(css1) + ' ' + $val(css2) + '">' +
              '<table>' +
              '<thead>';
  renderCols(table, cols);
  out.html += '</thead>' +
              '</table>' +
              '</header>' +
              '<div id="' + $val(guid) + '-body" class="ts-table-body">';
  $att['style'] = this._scrollfixing ? 'left:-' + this._scroll.x + 'px;' : null;
  out.html += '<main data-ts="Spirit" id="' + $val(guid) + '-rows" class="ts-table-rows ' + $val(css1) + ' ' + $val(css2) + '">' +
              '<table ' + $att.$('style') + '>' +
              '<tbody>';
  renderRows(table, rows, cols);
  out.html += '</tbody>' +
              '</table>' +
              '</main>';
  if (table.selectable) {
    out.html += '<aside data-ts="Spirit" id="' + $val(guid) + '-gutter" class="ts-table-gutter">' +
                '<table>' +
                '<tbody>';
    renderGutter(table, rows);
    out.html += '</tbody>' +
                '</table>' +
                '</aside>';
  }
  out.html += '</div>';
  if (table.selectable && cols.length) {
    renderMenu(table);
  }
  if (showfooter(this.$fixedsize, table.maxrows)) {
    out.html += '<footer id="' + $val(guid) + '-foot" class="ts-table-foot">' +
                tbar.render() +
                '</footer>';
  }
  function showfooter(size, max) {
    if (table.configurable || tbar.title !== null) {
      return true;
    } else if (tbar.pager) {
      return size || max && tbar.pager.pages > 1;
    }
    return false;
  }
  return out.write();
}).withInstructions([{
    input : {
      name : "table",
      type : "ts.ui.TableModel"
    }
  }]);

// src/runtime/edbml/scripts/ts.ui.ToolBarSpirit.edbml
edbml.declare("ts.ui.ToolBarSpirit.edbml").as(function $edbml(
/**/){
  'use strict';
  var out = $edbml.$out,
    $att = $edbml.$att,
    $set = edbml.$set,
    $txt = edbml.safetext,
    $val = edbml.safeattr,
    renderTabs = ts.ui.toolbartabs.edbml.lock(out),
    toolbar = $edbml.$input(ts.ui.ToolBarModel),
    layout = $edbml.$input(ts.ui.LayoutModel);
  var spirit = this;
  var id = toolbar.$instanceid;
  var mobilos = layout.isMobilePoint();
  var topbar = ts.ui.TopBarModel.is(toolbar);
  var statusbar = ts.ui.StatusBarModel.is(toolbar);
  var mytitle = toolbar.title || (topbar ? toolbar.defaultTitle : '');
  var hasrealtitle = !!toolbar.title;
  renderLeft(id, mytitle, toolbar.search, toolbar.tabs, toolbar.navigation);
  renderCenter(id, toolbar.pager);
  renderRight(id, toolbar.$allbuttons());
  renderSpinner(topbar && mobilos);
  function renderLeft(id$2, title, search, tabs, navigation) {
    var hasnavi = !!(topbar && navigation && navigation.getLength());
    var hastabs = !!tabs.getLength();
    if (mobilos || search || hastabs || hasnavi || (topbar ? hasrealtitle : title)) {
      if (mobilos && hastabs) {
        renderTabs(spirit, tabs, id$2, mobilos);
      }
      out.html += '<menu id="' + $val(id$2) + '-items" class="ts-toolbar-menu ts-left">';
      if (topbar) {
        renderNav(navigation);
      }
      if (!mobilos && hastabs && !hasnavi) {
        renderTabs(spirit, tabs, id$2, mobilos);
      } else {
        if (search) {
          $att['class'] = klass('ts-toolbar-search', search);
          out.html += '<li id="' + $val(id$2) + '-search" ' + $att.$('class') + '>' +
                      search.render() +
                      '</li>';
        }
        if (title && (!search || !using(search))) {
          $att['class'] = klass('ts-toolbar-title');
          out.html += '<li id="' + $val(id$2) + '-title" ' + $att.$('class') + '>';
          if (statusbar) {
            out.html += '<label>';
            var whitelist = [
  'strong',
  'em',
  'strike',
  'code'
];
            if (toolbar.linkable) whitelist.push('a');
            out.html += ts.ui.Markdown.parse(title, whitelist) +
                        '</label>';
          } else {
            out.html += '<label>' + $txt(title) + '</label>';
          }
          out.html += '</li>';
        }
      }
      out.html += '</menu>';
    }
  }
  function renderCenter(id$2, pager) {
    if (showPager()) {
      out.html += '<menu id="' + $val(id$2) + '-extras" class="ts-toolbar-menu ts-center">';
      $att['class'] = klass('ts-toolbar-pager', pager);
      out.html += '<li id="' + $val(id$2) + '-pager" ' + $att.$('class') + '>' +
                  pager.render() +
                  '</li>' +
                  '</menu>';
    }
  }
  function showPager() {
    var pager = toolbar.pager;
    return !!(statusbar && pager && pager.pages);
  }
  function renderRight(id$2, buttons) {
    if (buttons.length || toolbar.closebutton) {
      out.html += '<menu id="' + $val(id$2) + '-buttons" class="ts-toolbar-menu ts-right">';
      if (!toolbar.compact) {
        toolbar.$allbuttons().forEach(renderbutton);
      } else if (mobilos && buttons.length > 1) {
        renderasidebutton(function onclick(){
          spirit.putaside(toolbar.$allbuttons());
        });
      } else {
        renderbuttons(toolbar.$specialbuttons(), toolbar.$normalbuttons());
      }
      if (toolbar.closebutton) {
        renderbutton(toolbar.closebutton);
      }
      out.html += '</menu>';
    }
  }
  function renderbuttons(specials, normals) {
    if (showPager()) {
      collapsebuttons(specials, normals);
    }
    if (normals.length === 1) {
      specials = normals.concat(specials);
    } else if (shouldrenderaside(normals)) {
      renderasidebutton(function onclick(){
        spirit.putaside(normals);
      });
    }
    specials.forEach(renderbutton);
  }
  function collapsebuttons(specials, normals) {
    while (specials.length) {
      normals.push(specials.shift());
    }
  }
  function shouldrenderaside(buttons) {
    return buttons.length > 1 && !buttons.every(function(button){
      return button.disabled;
    });
  }
  function renderbutton(button) {
    var id$2 = button.$instanceid;
    $att['class'] = klass('ts-item', button);
    out.html += '<li ' + $att.$('class') + ' id="' + $val(id$2) + '-item">' +
                button.render() +
                '</li>';
  }
  function renderasidebutton(action) {
    $att['class'] = 'ts-toolbar-item ts-item';
    out.html += '<li ' + $att.$('class') + ' id="' + $val(id) + '-aside">';
    var $1 = $set(function(){
      action();
    }, this);
    out.html += '<button data-ts="Button" class="ts-tertiary" onclick="edbml.$run(this, \'' + $1 + '\');" tabindex="-1">' +
                '<i class="ts-icon-other"></i>' +
                '</button>' +
                '</li>';
  }
  function klass(cname, model) {
    var flex = model && model.flex;
    return [
  'ts-toolbar-item',
  cname || '',
  flex ? 'ts-flex' : ''
].join(' ');
  }
  function using(search) {
    return search && (search.focused || search.value || search.flex);
  }
  function renderSpinner(on) {
    $att['id'] = id + '-spinner';
    $att['class'] = 'ts-topbarspinner';
    if (on) {
      out.html += '<div data-ts="Spinner" ' + $att.$('id') + ' ' + $att.$('class') + ' data-ts.spinning="true"></div>';
    }
  }
  function renderNav(navbuttons) {
    if (navbuttons.getLength() || mobilos) {
      menubutton(navbuttons).forEach(renderbutton);
    }
  }
  function menubutton(navbuttons) {
    var buttons = mobilos ? [toolbar.menubutton] : [];
    return buttons.concat(gui.Array.from(navbuttons));
  }
  return out.write();
}).withInstructions([{
    input : {
      name : "toolbar",
      type : "ts.ui.ToolBarModel"
    }
  }, {
    input : {
      name : "layout",
      type : "ts.ui.LayoutModel"
    }
  }]);